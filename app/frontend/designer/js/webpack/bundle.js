(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app/frontend/designer/js/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app/frontend/designer/images/cursors/cursor_circle.png":
/*!****************************************************************!*\
  !*** ./app/frontend/designer/images/cursors/cursor_circle.png ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/492f40d01cb4aa7e66fbae9f01abda49.png";

/***/ }),

/***/ "./app/frontend/designer/images/cursors/cursor_line.png":
/*!**************************************************************!*\
  !*** ./app/frontend/designer/images/cursors/cursor_line.png ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/2545e9daa1296aeaf03c8ea0aaab4afe.png";

/***/ }),

/***/ "./app/frontend/designer/images/cursors/cursor_port.png":
/*!**************************************************************!*\
  !*** ./app/frontend/designer/images/cursors/cursor_port.png ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/657c4c890bc69affe796a29f4d9d0dcf.png";

/***/ }),

/***/ "./app/frontend/designer/images/cursors/cursor_rectangle.png":
/*!*******************************************************************!*\
  !*** ./app/frontend/designer/images/cursors/cursor_rectangle.png ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/485860c000764fd82149fc94aa6673cd.png";

/***/ }),

/***/ "./app/frontend/designer/images/cursors/cursor_text.png":
/*!**************************************************************!*\
  !*** ./app/frontend/designer/images/cursors/cursor_text.png ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/2e59ba615169ea5c7506a8094f9e1301.png";

/***/ }),

/***/ "./app/frontend/designer/images/layer_circle.svg":
/*!*******************************************************!*\
  !*** ./app/frontend/designer/images/layer_circle.svg ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/03dd73054fb8e850a1d7b3cf989d110e.svg";

/***/ }),

/***/ "./app/frontend/designer/images/layer_line.svg":
/*!*****************************************************!*\
  !*** ./app/frontend/designer/images/layer_line.svg ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/548ef4f9e994071644291e2fe872748c.svg";

/***/ }),

/***/ "./app/frontend/designer/images/layer_port.svg":
/*!*****************************************************!*\
  !*** ./app/frontend/designer/images/layer_port.svg ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/d8793b0b2697aeab906405c2133b2077.svg";

/***/ }),

/***/ "./app/frontend/designer/images/layer_rect.svg":
/*!*****************************************************!*\
  !*** ./app/frontend/designer/images/layer_rect.svg ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/255ca93908929c739da78f8d94add6bb.svg";

/***/ }),

/***/ "./app/frontend/designer/images/layer_text.svg":
/*!*****************************************************!*\
  !*** ./app/frontend/designer/images/layer_text.svg ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/ccdfb2c619d129bdfadb0fb4439a9aab.svg";

/***/ }),

/***/ "./app/frontend/designer/js/Application.js":
/*!*************************************************!*\
  !*** ./app/frontend/designer/js/Application.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _View = __webpack_require__(/*! ./View */ "./app/frontend/designer/js/View.js");

var _View2 = _interopRequireDefault(_View);

var _Toolbar = __webpack_require__(/*! ./Toolbar */ "./app/frontend/designer/js/Toolbar.js");

var _Toolbar2 = _interopRequireDefault(_Toolbar);

var _Layer = __webpack_require__(/*! ./Layer */ "./app/frontend/designer/js/Layer.js");

var _Layer2 = _interopRequireDefault(_Layer);

var _FilterPane = __webpack_require__(/*! ./FilterPane */ "./app/frontend/designer/js/FilterPane.js");

var _FilterPane2 = _interopRequireDefault(_FilterPane);

var _BackendStorage = __webpack_require__(/*! ./io/BackendStorage */ "./app/frontend/designer/js/io/BackendStorage.js");

var _BackendStorage2 = _interopRequireDefault(_BackendStorage);

var _SelectionToolPolicy = __webpack_require__(/*! ./policy/SelectionToolPolicy */ "./app/frontend/designer/js/policy/SelectionToolPolicy.js");

var _SelectionToolPolicy2 = _interopRequireDefault(_SelectionToolPolicy);

var _FileOpen = __webpack_require__(/*! ./dialog/FileOpen */ "./app/frontend/designer/js/dialog/FileOpen.js");

var _FileOpen2 = _interopRequireDefault(_FileOpen);

var _FileSave = __webpack_require__(/*! ./dialog/FileSave */ "./app/frontend/designer/js/dialog/FileSave.js");

var _FileSave2 = _interopRequireDefault(_FileSave);

var _FileSaveAs = __webpack_require__(/*! ./dialog/FileSaveAs */ "./app/frontend/designer/js/dialog/FileSaveAs.js");

var _FileSaveAs2 = _interopRequireDefault(_FileSaveAs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *
 * The **GraphicalEditor** is responsible for layout and dialog handling.
 *
 * @author Jupiter Bakakeu
 */

var Application = function () {
  /**
   * @constructor
   *
   * @param {String} canvasId the id of the DOM element to use as paint container
   */
  function Application() {
    var _this = this;

    _classCallCheck(this, Application);

    this.documentConfigurationTempl = {
      baseClass: "draw2d.SetFigure",
      code: $("#shape-edit-template").text().trim()
    };

    this.localStorage = [];
    try {
      if ('localStorage' in window && window.localStorage !== null) {
        this.localStorage = localStorage;
      }
    } catch (e) {}

    $("body").delegate(".mousetrap-pause", "focus", function () {
      Mousetrap.pause();
    }).delegate(".mousetrap-pause", "blur", function () {
      Mousetrap.unpause();
    });

    // automatic add the configuration to the very first shape
    // in the document as userData
    //
    this.documentConfiguration = $.extend({}, this.documentConfigurationTempl);

    this.storage = new _BackendStorage2.default();
    this.view = new _View2.default(this, "canvas");
    this.toolbar = new _Toolbar2.default(this, ".toolbar", this.view);
    this.layer = new _Layer2.default(this, "layer_elements", this.view);
    this.filter = new _FilterPane2.default(this, "#filter .filter_actions", this.view);

    this.view.installEditPolicy(new _SelectionToolPolicy2.default());

    // check if the user has added a "file" parameter. In this case we load the shape from
    // the draw2d.shape github repository
    //
    var file = this.getParam("file");
    if (file) {
      this._load(file);
    } else {
      this.fileNew();
    }

    // listen on the history object to load files
    //
    window.addEventListener('popstate', function (event) {
      if (event.state && event.state.id === 'editor') {
        // Render new content for the hompage
        _this._load(event.state.file);
      }
    });
  }

  _createClass(Application, [{
    key: "_load",
    value: function _load(file) {
      var _this2 = this;

      this.storage.loadFile(file).then(function (content) {
        _this2.view.clear();
        _this2.view.centerDocument();
        var reader = new draw2d.io.json.Reader();
        reader.unmarshal(_this2.view, content);
        _this2.getConfiguration();
        _this2.storage.fileName = file;
        _this2.view.getCommandStack().markSaveLocation();
        _this2.view.centerDocument();
        return content;
      });
    }
  }, {
    key: "getParam",
    value: function getParam(name) {
      name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
      var regexS = "[\\?&]" + name + "=([^&#]*)";
      var regex = new RegExp(regexS);
      var results = regex.exec(window.location.href);
      // the param isn't part of the normal URL pattern...
      //
      if (results === null) {
        // maybe it is part in the hash.
        //
        regexS = "[\\#]" + name + "=([^&#]*)";
        regex = new RegExp(regexS);
        results = regex.exec(window.location.hash);
        if (results === null) {
          return null;
        }
      }
      return results[1];
    }
  }, {
    key: "fileNew",
    value: function fileNew(shapeTemplate) {
      this.view.clear();
      this.storage.currentFile = null;
      this.documentConfiguration = $.extend({}, this.documentConfigurationTempl);

      if (shapeTemplate) {
        new draw2d.io.json.Reader().unmarshal(this.view, shapeTemplate);
        this.view.getCommandStack().markSaveLocation();
        this.view.centerDocument();
      }
    }
  }, {
    key: "fileOpen",
    value: function fileOpen() {
      new _FileOpen2.default().show(this.storage, this.view);
    }
  }, {
    key: "fileSave",
    value: function fileSave() {
      this.setConfiguration();
      if (this.storage.currentFile === null) {
        new _FileSaveAs2.default().show(this.storage, this.view);
      } else {
        new _FileSave2.default().show(this.storage, this.view);
      }
    }
  }, {
    key: "getConfiguration",
    value: function getConfiguration(key) {
      var figures = this.view.getExtFigures();
      if (figures.getSize() > 0) {
        this.documentConfiguration = $.extend({}, this.documentConfiguration, figures.first().getUserData());
      }

      if (key) {
        return this.documentConfiguration[key];
      }
      return this.documentConfiguration;
    }
  }, {
    key: "setConfiguration",
    value: function setConfiguration(conf) {
      this.documentConfiguration = $.extend({}, this.documentConfiguration, conf);
      var figures = this.view.getExtFigures();
      if (figures.getSize() > 0) {
        figures.first().setUserData(this.documentConfiguration);
      }
    }
  }]);

  return Application;
}();

exports.default = Application;
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/Configuration.js":
/*!***************************************************!*\
  !*** ./app/frontend/designer/js/Configuration.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  fileSuffix: ".shape",
  serverless: false,
  backend: {
    file: {
      list: "/backend/shape/list",
      get: function get(file) {
        return "../backend/shape/get?filePath=" + file;
      },
      save: "/backend/shape/save"
    }
  }
};
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/FilterPane.js":
/*!************************************************!*\
  !*** ./app/frontend/designer/js/FilterPane.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FilterPane = function () {
  function FilterPane(app, elementId, view) {
    _classCallCheck(this, FilterPane);

    this.DEFAULT_LABEL = "Properties";
    this.html = $(elementId);
    this.view = view;
    this.currentFigure = null;

    // Register a Selection listener for the state handling
    // of the Delete Button
    //
    view.on("select", this.onSelectionChanged.bind(this));
  }

  /**
   * @method
   * Called if the selection in the canvas has been changed. You must register this
   * class on the canvas to receive this event.
   *
   * @param {draw2d.Canvas} canvas the emitter of the event. In this case it is the canvas.
   * @param {draw2d.Figure} figure
   */


  _createClass(FilterPane, [{
    key: "onSelectionChanged",
    value: function onSelectionChanged(canvas) {
      var _this2 = this;

      var event = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { figure: null };

      var figure = event.figure;

      this.html.html('');
      $('#add_filter_button').addClass('disabled');

      if (this.currentFigure !== null && typeof this.currentFigure.isExtFigure !== "undefined") {
        this.currentFigure.filters.each(function (i, filter) {
          filter.removePane();
        });
      }
      $("#add_filter_action_menu").html("");

      if (figure !== null && typeof figure.isExtFigure !== "undefined") {
        figure.filters.each(function (i, filter) {
          filter.insertPane(figure, _this2.html);
        });
        $('#add_filter_button').removeClass('disabled');

        $.each(figure.getPotentialFilters(), function (i, e) {
          $("#add_filter_action_menu").append("<li><a href='#' data-filter='" + e.impl + "' >" + e.label + "</a></li>");
        });

        var _this = this;
        $("#add_filter_action_menu a").on("click", function () {
          var $this = $(this);
          var filterName = $this.data("filter");
          var filter = eval("new " + filterName + "()");
          _this.currentFigure.addFilter(filter);
          _this.onSelectionChanged(_this.view, { figure: _this.currentFigure });
        });
      }

      this.currentFigure = figure;
    }
  }]);

  return FilterPane;
}();

exports.default = FilterPane;
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/Hardware.js":
/*!**********************************************!*\
  !*** ./app/frontend/designer/js/Hardware.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// just a simple mock object for the brainbox
// Hardware binding
//
exports.default = {

  raspi: {
    set: function set(pin, value) {},
    get: function get(pin) {
      return false;
    },
    on: function on(event, callback) {},
    connected: false
  },

  arduino: {
    set: function set(pin, value) {},
    get: function get(pin) {
      return false;
    },
    on: function on(event, callback) {},
    connected: false
  }
};
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/LabelInplaceEditor.js":
/*!********************************************************!*\
  !*** ./app/frontend/designer/js/LabelInplaceEditor.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = draw2d.ui.LabelInplaceEditor.extend({

  NAME: "LabelInplaceEditor",

  /**
   * @constructor
   *
   */
  init: function init(attr, setter, getter) {
    this._super({
      onStart: function onStart() {
        Mousetrap.pause();
      },
      onCancel: function onCancel() {
        Mousetrap.unpause();
      },
      onCommit: function onCommit() {
        Mousetrap.unpause();
      }
    }, setter, getter);
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/Layer.js":
/*!*******************************************!*\
  !*** ./app/frontend/designer/js/Layer.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Layer = function () {
  function Layer(app, elementId, view) {
    _classCallCheck(this, Layer);

    this.html = $("#" + elementId);
    this.view = view;

    // register this class as event listener for the canvas
    // CommandStack. This is required to update the state of
    // the Undo/Redo Buttons.
    //
    view.getCommandStack().addEventListener(this);

    // Register a Selection listener for the state hnadling
    // of the Delete Button
    //
    view.on("select", this.onSelectionChanged.bind(this));
  }

  /**
   * @method
   * Called if the selection in the cnavas has been changed. You must register this
   * class on the canvas to receive this event.
   *
   * @param {draw2d.Figure} emitter
   */


  _createClass(Layer, [{
    key: "onSelectionChanged",
    value: function onSelectionChanged(emitter, event) {
      this._updateSelection();
    }

    /**
     * @method
     * Sent when an event occurs on the command stack. draw2d.command.CommandStackEvent.getDetail()
     * can be used to identify the type of event which has occurred.
     *
     * @template
     *
     * @param {draw2d.command.CommandStackEvent} event
     **/

  }, {
    key: "stackChanged",
    value: function stackChanged(event) {
      var _this = this;

      this.html.html('');
      var figures = this.view.getExtFigures();
      figures.each(function (i, figure) {
        _this.html.append('<div class="layerElement ' + _this.figureToCSS(figure) + '" data-figure="' + figure.id + '"  data-visibility="' + figure.isVisible() + '" id="layerElement_' + figure.id + '" >' + figure.getUserData().name + '<span data-figure="' + figure.id + '"  data-toggle="tooltip" title="Toggle Visibility of the Layer"  class="layer_visibility pull-right"><img class="icon svg" src="' + (figure.isVisible() ? './images/layer_visible.svg' : './images/layer_hidden.svg') + '"/></span>' + '<span data-figure="' + figure.id + '"  data-toggle="tooltip" title="Edit Name of Layer" class="layer_edit pull-right" ><img class="icon svg" src="./images/layer_edit.svg"/></span>' + '</div>');
      }, true);

      inlineSVG.init();

      $('*[data-toggle="tooltip"]').tooltip({
        placement: "bottom",
        container: "body",
        delay: { show: 1000, hide: 100 },
        html: true
      });

      this.html.sortable({
        axis: "y",
        update: function update() {
          $(".layerElement").toArray().reverse().forEach(function (e) {
            _this.view.getExtFigure($(e).data("figure")).toFront();
          });
        }
      });

      $(".layerElement .layer_edit").on("click", $.proxy(function (event) {
        var figure = this.view.getExtFigure($(event.currentTarget).data("figure"));
        Mousetrap.pause();
        bootbox.prompt({
          title: "Layer Name",
          className: "layer-name-prompt",
          value: figure.getUserData().name,
          callback: $.proxy(function (result) {
            Mousetrap.unpause();
            if (result !== null) {
              figure.getUserData().name = result;
              this.stackChanged(null);
            }
          }, this)
        });

        // autoselect text for fast edit
        setTimeout(function () {
          $(".bootbox-input").focus().select();
        }, 200);
      }, this));

      $(".layerElement .layer_visibility").on("click", $.proxy(function (event) {
        var figure = this.view.getExtFigure($(event.currentTarget).data("figure"));
        figure.setVisible(!figure.isVisible());
        this.view.setCurrentSelection(null);
        $(event.currentTarget).html('<img class="icon svg" src="' + (figure.isVisible() ? './images/layer_visible.svg' : './images/layer_hidden.svg') + '"/>');
        inlineSVG.init();

        // set the "data" with attr and not with "data()". Otherwise the css selector won't work
        //
        $(event.currentTarget).parent().attr({ "data-visibility": figure.isVisible() });

        this.ripple(figure);
        return false;
      }, this));

      $(".layerElement").on("click", $.proxy(function (event) {
        var figure = this.view.getExtFigure($(event.currentTarget).data("figure"));
        if (figure.isVisible()) {
          this.view.setCurrentSelection(figure);
          this.ripple(figure);
        }
      }, this));

      this._updateSelection();
    }
  }, {
    key: "_updateSelection",
    value: function _updateSelection() {
      $(".layerElement").removeClass("layerSelectedElement");
      var selection = this.view.getSelection();
      selection.each(function (i, e) {
        $("#layerElement_" + e.id).addClass("layerSelectedElement");
      });
    }
  }, {
    key: "ripple",
    value: function ripple(figure) {
      var rect = figure.getBoundingBox();
      var p = rect.getCenter();
      var circle = this.view.paper.circle(p.x, p.y, Math.max(3, rect.w / 4), Math.max(3, rect.h / 4)).attr({
        fill: null,
        stroke: "#d0d0ff"
      });
      var anim = Raphael.animation({
        transform: "s6",
        opacity: 0.0,
        "stroke-width": 5
      }, 500, "linear", function () {
        circle.remove();
      });
      circle.animate(anim);
    }
  }, {
    key: "figureToCSS",
    value: function figureToCSS(figure) {
      return figure.NAME.split(".").slice(-1)[0];
    }
  }]);

  return Layer;
}();

exports.default = Layer;
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/Toolbar.js":
/*!*********************************************!*\
  !*** ./app/frontend/designer/js/Toolbar.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _RectangleToolPolicy = __webpack_require__(/*! ./policy/RectangleToolPolicy */ "./app/frontend/designer/js/policy/RectangleToolPolicy.js");

var _RectangleToolPolicy2 = _interopRequireDefault(_RectangleToolPolicy);

var _CircleToolPolicy = __webpack_require__(/*! ./policy/CircleToolPolicy */ "./app/frontend/designer/js/policy/CircleToolPolicy.js");

var _CircleToolPolicy2 = _interopRequireDefault(_CircleToolPolicy);

var _LineToolPolicy = __webpack_require__(/*! ./policy/LineToolPolicy */ "./app/frontend/designer/js/policy/LineToolPolicy.js");

var _LineToolPolicy2 = _interopRequireDefault(_LineToolPolicy);

var _TextToolPolicy = __webpack_require__(/*! ./policy/TextToolPolicy */ "./app/frontend/designer/js/policy/TextToolPolicy.js");

var _TextToolPolicy2 = _interopRequireDefault(_TextToolPolicy);

var _PortToolPolicy = __webpack_require__(/*! ./policy/PortToolPolicy */ "./app/frontend/designer/js/policy/PortToolPolicy.js");

var _PortToolPolicy2 = _interopRequireDefault(_PortToolPolicy);

var _SelectionToolPolicy = __webpack_require__(/*! ./policy/SelectionToolPolicy */ "./app/frontend/designer/js/policy/SelectionToolPolicy.js");

var _SelectionToolPolicy2 = _interopRequireDefault(_SelectionToolPolicy);

var _GeoUnionToolPolicy = __webpack_require__(/*! ./policy/GeoUnionToolPolicy */ "./app/frontend/designer/js/policy/GeoUnionToolPolicy.js");

var _GeoUnionToolPolicy2 = _interopRequireDefault(_GeoUnionToolPolicy);

var _GeoIntersectionToolPolicy = __webpack_require__(/*! ./policy/GeoIntersectionToolPolicy */ "./app/frontend/designer/js/policy/GeoIntersectionToolPolicy.js");

var _GeoIntersectionToolPolicy2 = _interopRequireDefault(_GeoIntersectionToolPolicy);

var _GeoDifferenceToolPolicy = __webpack_require__(/*! ./policy/GeoDifferenceToolPolicy */ "./app/frontend/designer/js/policy/GeoDifferenceToolPolicy.js");

var _GeoDifferenceToolPolicy2 = _interopRequireDefault(_GeoDifferenceToolPolicy);

var _FigureCodeEdit = __webpack_require__(/*! ./dialog/FigureCodeEdit */ "./app/frontend/designer/js/dialog/FigureCodeEdit.js");

var _FigureCodeEdit2 = _interopRequireDefault(_FigureCodeEdit);

var _FigureMarkdownEdit = __webpack_require__(/*! ./dialog/FigureMarkdownEdit */ "./app/frontend/designer/js/dialog/FigureMarkdownEdit.js");

var _FigureMarkdownEdit2 = _interopRequireDefault(_FigureMarkdownEdit);

var _FigureTest = __webpack_require__(/*! ./dialog/FigureTest */ "./app/frontend/designer/js/dialog/FigureTest.js");

var _FigureTest2 = _interopRequireDefault(_FigureTest);

var _Configuration = __webpack_require__(/*! ./Configuration */ "./app/frontend/designer/js/Configuration.js");

var _Configuration2 = _interopRequireDefault(_Configuration);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Toolbar = function () {
  function Toolbar(app, elementId, view) {
    var _this = this;

    _classCallCheck(this, Toolbar);

    this.html = $(elementId);
    this.view = view;
    this.app = app;

    // register this class as event listener for the canvas
    // CommandStack. This is required to update the state of
    // the Undo/Redo Buttons.
    //
    view.getCommandStack().addEventListener(this);

    // Register a Selection listener for the state handling
    // of the Delete Button
    //
    view.on("select", this.onSelectionChanged.bind(this));
    view.on("unselect", this.onSelectionChanged.bind(this));

    this.fileName = null;
    var buttonGroup = null;

    if (_Configuration2.default.serverless === false) {
      buttonGroup = $("<div id='fileOperationGroup' class='group'></div>");
      this.html.append(buttonGroup);

      this.openButton = $('<div class="image-button" id="fileOpen" data-toggle="tooltip" title="Load File <span class=\'highlight\'> [ Ctrl+O ]</span>" ><img src="./images/toolbar_download.svg"/><div>Open</div></div>');
      buttonGroup.append(this.openButton);
      this.openButton.on("click", function () {
        _this.openButton.tooltip("hide");
        app.fileOpen();
      });
      Mousetrap.bindGlobal("ctrl+o", function () {
        _this.openButton.click();
        return false;
      });

      this.saveButton = $('<div class="image-button"  id="fileSave" data-toggle="tooltip" title="Save File <span class=\'highlight\'> [ Ctrl+S ]</span>"  ><img src="./images/toolbar_upload.svg"/><div>Save</div></div>');
      buttonGroup.append(this.saveButton);
      this.saveButton.on("click", function () {
        _this.saveButton.tooltip("hide");
        app.fileSave();
      });
      Mousetrap.bindGlobal("ctrl+s", function (event) {
        _this.saveButton.click();
        return false;
      });
    }

    // Inject the UNDO Button and the callbacks
    //
    buttonGroup = $('<div class="group"></div>');
    this.html.append(buttonGroup);
    this.undoButton = $('<div class="image-button" id="editUndo" data-toggle="tooltip" title="Undo <span class=\'highlight\'> [ Ctrl+Z ]</span>"  ><img class="icon disabled"  src="./images/toolbar_undo.svg"/><div>Undo</div></div>');
    buttonGroup.append(this.undoButton);
    this.html.delegate("#editUndo:not(.disabled)", "click", function () {
      _this.view.getCommandStack().undo();
    });
    Mousetrap.bindGlobal("ctrl+z", function () {
      _this.undoButton.click();
      return false;
    });

    // Inject the REDO Button and the callback
    //
    this.redoButton = $('<div class="image-button" id="editRedo" data-toggle="tooltip" title="Redo <span class=\'highlight\'> [ Ctrl+Y ]</span>"  ><img  class="icon disabled" src="./images/toolbar_redo.svg"/><div>Redo</div></div>');
    buttonGroup.append(this.redoButton);
    this.html.delegate("#editRedo:not(.disabled)", "click", function () {
      _this.view.getCommandStack().redo();
    });
    Mousetrap.bindGlobal("ctrl+y", function () {
      _this.redoButton.click();
      return false;
    });

    // Inject the DELETE Button
    //
    this.deleteButton = $('<div class="image-button" id="editDelete" data-toggle="tooltip" title="Delete <span class=\'highlight\'> [ Del ]</span>"  ><img class="icon disabled" src="./images/toolbar_delete.svg"/><div>Delete</div></div>');
    buttonGroup.append(this.deleteButton);
    this.html.delegate("#editDelete:not(.disabled)", "click", function () {
      view.getCommandStack().startTransaction(draw2d.Configuration.i18n.command.deleteShape);
      view.getSelection().each(function (index, figure) {
        var cmd = figure.createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.DELETE));
        if (cmd !== null) {
          view.getCommandStack().execute(cmd);
        }
      });
      // execute all single commands at once.
      view.getCommandStack().commitTransaction();
    });
    Mousetrap.bindGlobal(["del", "backspace"], function () {
      _this.deleteButton.click();
      return false;
    });

    buttonGroup = $('<div class="group"></div>');
    this.html.append(buttonGroup);

    this.selectButton = $('<div class="image-button" id="editSelect" data-toggle="tooltip" title="Select mode <span class=\'highlight\'> [ spacebar ]</span>" ><img src="./images/toolbar_select.svg"/><div>Select</div></div>');
    buttonGroup.append(this.selectButton);
    this.selectButton.on("click", function () {
      _this.view.installEditPolicy(new _SelectionToolPolicy2.default());
    });
    Mousetrap.bindGlobal("space", function () {
      _this.selectButton.click();
      return false;
    });

    this.shapeButton = $('<label id="tool_shape" class="dropdown" >' + '    <div class="image-button" data-toggle="dropdown"  id="tool_shape_image" ><img  src="./images/toolbar_insert.svg"><div>Add</div></div>' + '    <ul class="dropdown-menu" role="menu" >' + '       <li class="tool_shape_entry policyRectangleToolPolicy" ><a href="#"><img  src="./images/toolbar_rectangle.svg"><span class="tool_label">Rectangle</span><span class="tool_shortcut">R</span></a></li>' + '       <li class="tool_shape_entry policyCircleToolPolicy"    ><a href="#"><img  src="./images/toolbar_circle.svg"><span class="tool_label">Circle</span><span class="tool_shortcut">C</span></a></li>' + '       <li class="tool_shape_entry policyLineToolPolicy"      ><a href="#"><img  src="./images/toolbar_line.svg"><span class="tool_label">Line</span><span class="tool_shortcut">L</span></a></li>' + '       <li class="tool_shape_entry policyTextToolPolicy"      ><a href="#"><img  src="./images/toolbar_text.svg"><span class="tool_label">Text</span><span class="tool_shortcut">T</span></a></li>' + '       <li class="tool_shape_entry policyPortToolPolicy"      ><a href="#"><img  src="./images/toolbar_rectangle.svg"><span class="tool_label">Port</span><span class="tool_shortcut">P</span></a></li>' + '    </ul>' + '</label>');
    buttonGroup.append(this.shapeButton);

    $(".policyRectangleToolPolicy").on("click", function () {
      var p = new _RectangleToolPolicy2.default();
      p.executed = function () {
        _this.selectButton.click();
      };
      _this.view.installEditPolicy(p);
    });
    $(".policyCircleToolPolicy").on("click", function () {
      var p = new _CircleToolPolicy2.default();
      p.executed = function () {
        _this.selectButton.click();
      };
      _this.view.installEditPolicy(p);
    });
    $(".policyLineToolPolicy").on("click", function () {
      var p = new _LineToolPolicy2.default();
      p.executed = function () {
        _this.selectButton.click();
      };
      _this.view.installEditPolicy(p);
    });
    $(".policyTextToolPolicy").on("click", function () {
      var p = new _TextToolPolicy2.default();
      p.executed = function () {
        _this.selectButton.click();
      };
      _this.view.installEditPolicy(p);
    });
    $(".policyPortToolPolicy").on("click", function () {
      var p = new _PortToolPolicy2.default();
      p.executed = function () {
        _this.selectButton.click();
      };
      _this.view.installEditPolicy(p);
    });

    Mousetrap.bindGlobal(["R", "r"], function () {
      $('.policyRectangleToolPolicy').click();
      return false;
    });
    Mousetrap.bindGlobal(["C", "c"], function () {
      $('.policyCircleToolPolicy').click();
      return false;
    });
    Mousetrap.bindGlobal(["T", "t"], function () {
      $('.policyTextToolPolicy').click();
      return false;
    });
    Mousetrap.bindGlobal(["P", "p"], function () {
      $('.policyPortToolPolicy').click();
      return false;
    });
    Mousetrap.bindGlobal(["L", "l"], function () {
      $('.policyLineToolPolicy').click();
      return false;
    });

    this.unionButton = $('<div class="image-button disabled" id="toolUnion" data-toggle="tooltip" title="Polygon Union <span class=\'highlight\'> [ U ]</span>" ><img src="./images/toolbar_geo_union.svg"/><div>Union</div></div>');
    buttonGroup.append(this.unionButton);
    this.html.delegate("#toolUnion:not(.disabled)", "click", function () {
      var selection = _this.view.getSelection().getAll();
      var p = new _GeoUnionToolPolicy2.default();
      p.executed = function () {
        _this.selectButton.click();
      };
      _this.view.installEditPolicy(p);
      p.execute(_this.view, selection);
    });
    Mousetrap.bindGlobal(["U", "u"], function () {
      _this.unionButton.click();
      return false;
    });

    this.differenceButton = $('<div class="image-button disabled" id="toolDifference" data-toggle="tooltip"  title="Polygon Difference <span class=\'highlight\'> [ D ]</span>" ><img src="./images/toolbar_geo_subtract.svg"/><div>Subtract</div></div>');
    buttonGroup.append(this.differenceButton);
    this.html.delegate("#toolDifference:not(.disabled)", "click", function () {
      _this.view.installEditPolicy(new _GeoDifferenceToolPolicy2.default());
    });
    Mousetrap.bindGlobal(["D", "d"], function () {
      _this.differenceButton.click();
      return false;
    });

    this.intersectionButton = $('<div class="image-button disabled" id="toolIntersection" data-toggle="tooltip" title="Polygon Intersection <span class=\'highlight\'> [ I ]</span>" ><img src="./images/toolbar_geo_intersect.svg"/><div>Intersect</div></div>');
    buttonGroup.append(this.intersectionButton);
    this.html.delegate("#toolIntersection:not(.disabled)", "click", function () {
      _this.view.installEditPolicy(new _GeoIntersectionToolPolicy2.default());
    });
    Mousetrap.bindGlobal(["I", "i"], function () {
      _this.intersectionButton.click();
      return false;
    });

    buttonGroup = $('<div class="group" style="float:right"></div>');
    this.html.append(buttonGroup);
    this.testButton = $('<div class="image-button" data-toggle="tooltip" title="Test your shape"><img src="./images/toolbar_element_test.svg"/><div>Test</div></div>');
    buttonGroup.append(this.testButton);
    this.testButton.on("click", function () {
      // if any error happens during the shape code create/execute -> goto the the JS editor
      try {
        new _FigureTest2.default().show();
      } catch (exc) {
        console.log(exc);
        new _FigureCodeEdit2.default().show();
      }
    });

    this.codeButton = $('<div class="image-button" data-toggle="tooltip" title="Edit JavaScript code</span>"><img src="./images/toolbar_element_js.svg"/><div>Code</div></div>');
    buttonGroup.append(this.codeButton);
    this.codeButton.on("click", function () {
      new _FigureCodeEdit2.default().show();
    });

    this.markdownButton = $('<div class="image-button" data-toggle="tooltip" title="Write documentation for your shape</span>"><img src="./images/toolbar_element_doc.svg"/><div>Doku</div></div>');
    buttonGroup.append(this.markdownButton);
    this.markdownButton.on("click", function () {
      new _FigureMarkdownEdit2.default().show();
    });

    // enable the tooltip for all buttons
    //
    $('*[data-toggle="tooltip"]').tooltip({
      placement: "bottom",
      container: "body",
      delay: { show: 1000, hide: 10 },
      html: true
    });
  }

  /**
   * @method
   * Called if the selection in the cnavas has been changed. You must register this
   * class on the canvas to receive this event.
   *
   * @param {draw2d.Figure} figure
   */


  _createClass(Toolbar, [{
    key: "onSelectionChanged",
    value: function onSelectionChanged(emitter, event) {
      if (event.figure === null) {
        $("#editDelete").addClass("disabled");
      } else {
        $("#editDelete").removeClass("disabled");
      }

      // available in BoundBox selection event
      if (event.selection) {
        if (event.selection.getSize() >= 2) {
          $("#toolUnion").removeClass("disabled");
          $("#toolDifference").removeClass("disabled");
          $("#toolIntersection").removeClass("disabled");
        } else {
          $("#toolUnion").addClass("disabled");
          $("#toolDifference").addClass("disabled");
          $("#toolIntersection").addClass("disabled");
        }
      }
    }

    /**
     * @method
     * Sent when an event occurs on the command stack. draw2d.command.CommandStackEvent.getDetail()
     * can be used to identify the type of event which has occurred.
     *
     * @template
     *
     * @param {draw2d.command.CommandStackEvent} event
     **/

  }, {
    key: "stackChanged",
    value: function stackChanged(event) {
      $("#editUndo").addClass("disabled");
      $("#editRedo").addClass("disabled");

      if (event.getStack().canUndo()) {
        $("#editUndo").removeClass("disabled");
      }

      if (event.getStack().canRedo()) {
        $("#editRedo").removeClass("disabled");
      }
    }
  }]);

  return Toolbar;
}();

exports.default = Toolbar;
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/View.js":
/*!******************************************!*\
  !*** ./app/frontend/designer/js/View.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = draw2d.Canvas.extend({

  init: function init(app, id) {
    var _this = this;

    this._super(id, 16000, 16000);
    this.clippboardFigure = null;
    this.app = app;
    this.grid = new draw2d.policy.canvas.ShowGridEditPolicy(20);

    this.setScrollArea("#" + id);

    this.installEditPolicy(this.grid);
    this.installEditPolicy(new draw2d.policy.canvas.FadeoutDecorationPolicy());
    this.installEditPolicy(new draw2d.policy.canvas.SnapToGeometryEditPolicy());
    this.installEditPolicy(new draw2d.policy.canvas.SnapToCenterEditPolicy());
    this.installEditPolicy(new draw2d.policy.canvas.SnapToInBetweenEditPolicy());

    Mousetrap.bindGlobal(['left'], function () {
      var diff = _this.getZoom() < 0.5 ? 0.5 : 1;
      _this.getSelection().each(function (i, f) {
        f.translate(-diff, 0);
      });
      return false;
    });
    Mousetrap.bindGlobal(['up'], function () {
      var diff = _this.getZoom() < 0.5 ? 0.5 : 1;
      _this.getSelection().each(function (i, f) {
        f.translate(0, -diff);
      });
      return false;
    });
    Mousetrap.bindGlobal(['right'], function () {
      var diff = _this.getZoom() < 0.5 ? 0.5 : 1;
      _this.getSelection().each(function (i, f) {
        f.translate(diff, 0);
      });
      return false;
    });
    Mousetrap.bindGlobal(['down'], function () {
      var diff = _this.getZoom() < 0.5 ? 0.5 : 1;
      _this.getSelection().each(function (i, f) {
        f.translate(0, diff);
      });
      return false;
    });

    Mousetrap.bindGlobal(['ctrl+c', 'command+c'], function () {
      var primarySelection = _this.getSelection().getPrimary();
      if (primarySelection !== null) {
        _this.clippboardFigure = primarySelection.clone();
        _this.clippboardFigure.translate(5, 5);
      }
      return false;
    });

    Mousetrap.bindGlobal(['ctrl+v', 'command+v'], function () {
      if (_this.clippboardFigure !== null) {
        var cloneToAdd = _this.clippboardFigure.clone();
        var command = new draw2d.command.CommandAdd(_this, cloneToAdd, cloneToAdd.getPosition());
        _this.getCommandStack().execute(command);
        _this.setCurrentSelection(cloneToAdd);
      }
      return false;
    });

    var zoom = new draw2d.policy.canvas.WheelZoomPolicy();
    this.installEditPolicy(zoom);

    var setZoom = function setZoom(newZoom) {
      var bb = _this.getBoundingBox().getCenter();
      var c = $("#canvas");
      _this.setZoom(newZoom);
      c.scrollTop(bb.y / newZoom - c.height() / 2);
      c.scrollLeft(bb.x / newZoom - c.width() / 2);
    };

    // Inject the ZoomIn Button and the callbacks
    //
    $("#canvas_zoom_in").on("click", function () {
      setZoom(_this.getZoom() * 1.2);
    });

    // Inject the OneToOne Button
    //
    $("#canvas_zoom_normal").on("click", function () {
      setZoom(1.0);
    });

    // Inject the ZoomOut Button and the callback
    //
    $("#canvas_zoom_out").on("click", function () {
      setZoom(_this.getZoom() * 0.8);
    });

    $('#canvas_config_grid').on('change', function () {
      if ($('#canvas_config_grid').prop('checked')) {
        _this.installEditPolicy(_this.grid);
      } else {
        _this.uninstallEditPolicy(_this.grid);
      }
    });

    $("#canvas_config_items").on("click", function (e) {
      e.stopPropagation();
    });

    this.reset();
  },

  setCursor: function setCursor(cursor) {
    if (cursor !== null) {
      this.html.css("cursor", "url(" + cursor + ") 0 0, default");
    } else {
      this.html.css("cursor", "default");
    }
  },

  /**
   * @method
   * Reset the view/canvas and starts with a clean and new document with default decorations
   *
   *
   */
  reset: function reset() {
    this.clear();
  },

  setZoom: function setZoom(newZoom) {
    $("#canvas_zoom_normal").text(parseInt(1.0 / newZoom * 100) + "%");
    this._super(newZoom);
  },

  getExtFigure: function getExtFigure(id) {
    var figure = null;
    this.getExtFigures().each(function (i, e) {
      if (e.id === id) {
        figure = e;
        return false;
      }
    });
    return figure;
  },

  getExtFigures: function getExtFigures() {
    var figures = this.getFigures().clone();

    // the export rectangles are not part of the document itself. In this case we
    // filter them out
    //
    figures.grep(function (figure) {
      return typeof figure.isExtFigure !== "undefined";
    });

    var lines = this.getLines().clone();
    lines.grep(function (line) {
      return typeof line.isExtFigure !== "undefined";
    });

    figures.addAll(lines);

    return figures;
  },

  getBoundingBox: function getBoundingBox() {
    var xCoords = [];
    var yCoords = [];
    this.getExtFigures().each(function (i, f) {
      if (f instanceof shape_designer.figure.ExtPort) {
        return;
      }
      var b = f.getBoundingBox();
      xCoords.push(b.x, b.x + b.w);
      yCoords.push(b.y, b.y + b.h);
    });
    var minX = Math.min.apply(Math, xCoords);
    var minY = Math.min.apply(Math, yCoords);
    var width = Math.max(10, Math.max.apply(Math, xCoords) - minX);
    var height = Math.max(10, Math.max.apply(Math, yCoords) - minY);

    return new draw2d.geo.Rectangle(minX, minY, width, height);
  },

  hideDecoration: function hideDecoration() {
    this.uninstallEditPolicy(this.grid);
    this.getFigures().each(function (index, figure) {
      figure.unselect();
    });
  },

  showDecoration: function showDecoration() {
    this.installEditPolicy(this.grid);
  },

  /**
   * @method
   * Return the width of the canvas
   *
   * @return {Number}
   **/
  getWidth: function getWidth() {
    return this.html.find("svg").width();
  },

  /**
   * @method
   * Return the height of the canvas.
   *
   * @return {Number}
   **/
  getHeight: function getHeight() {
    return this.html.find("svg").height();
  },

  centerView: function centerView() {
    var bb = this.getBoundingBox().getCenter();
    var c = $("#canvas");
    c.scrollTop(bb.y / this.getZoom() - c.height() / 2);
    c.scrollLeft(bb.x / this.getZoom() - c.width() / 2);
  },

  centerDocument: function centerDocument() {
    this.setZoom(1.0);
    // get the bounding box of the document and translate the complete document
    // into the center of the canvas. Scroll to the top left corner after them
    //
    var bb = this.getBoundingBox();

    var dx = this.getWidth() / 2 - (bb.x + bb.w / 2);
    var dy = this.getHeight() / 2 - (bb.y + bb.h / 2);

    this.getFigures().each(function (i, f) {
      f.translate(dx, dy);
    });
    this.getLines().each(function (i, f) {
      f.translate(dx, dy);
    });
    this.centerView();
  }

});
module.exports = exports['default'];

/***/ }),

/***/ "./app/frontend/designer/js/dialog/FigureCodeEdit.js":
/*!***********************************************************!*\
  !*** ./app/frontend/designer/js/dialog/FigureCodeEdit.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _FigureTest = __webpack_require__(/*! ./FigureTest */ "./app/frontend/designer/js/dialog/FigureTest.js");

var _FigureTest2 = _interopRequireDefault(_FigureTest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FigureCodeEdit = function () {
  function FigureCodeEdit() {
    _classCallCheck(this, FigureCodeEdit);
  }

  _createClass(FigureCodeEdit, [{
    key: "show",
    value: function show() {
      Mousetrap.pause();
      var code = shape_designer.app.getConfiguration("code");
      var splash = $('<pre id="code_overlay">' + code + '</pre>' + '<img title="Run"   id="test_run"   class="icon" src="./images/dialog_run.svg"/>' + '<img title="Close" id="code_close" class="icon" src="./images/dialog_close.svg"/>');
      splash.hide();
      $("body").append(splash);
      splash.fadeIn();

      var before = function before(obj, method, wrapper) {
        var orig = obj[method];
        obj[method] = function () {
          var args = Array.prototype.slice.call(arguments);
          return wrapper.call(this, function () {
            return orig.apply(obj, args);
          }, args);
        };

        return obj[method];
      };

      var intersects = function intersects(range) {
        return editor.getSelectionRange().intersects(range);
      };

      var preventReadonly = function preventReadonly(next, args) {
        if (intersects(range)) return;
        next();
      };

      var lines = code.split("\n");
      var last = lines.length - 1;
      var first = lines.findIndex(function (element, index, array) {
        return element.startsWith("testShape");
      });

      var editor = ace.edit("code_overlay"),
          session = editor.getSession(),
          Range = ace.require("ace/range").Range,
          range = new Range(0, 0, first, lines[first].length),
          range2 = new Range(last, 0, last, lines[last].length);

      session.addMarker(range, "readonly-highlight");
      session.addMarker(range2, "readonly-highlight");
      session.setMode("ace/mode/javascript");
      session.setUseWrapMode(true);
      editor.moveCursorTo(first + 1, 0);
      editor.focus();

      editor.keyBinding.addKeyboardHandler({
        handleKeyboard: function handleKeyboard(data, hash, keyString, keyCode, event) {
          if (hash === -1 || keyCode <= 40 && keyCode >= 37) return false;

          if (intersects(range) || intersects(range2)) {
            return { command: "null", passEvent: false };
          }
        }
      });

      before(editor, 'onPaste', preventReadonly);
      before(editor, 'onCut', preventReadonly);

      range.start = session.doc.createAnchor(range.start);
      range.end = session.doc.createAnchor(range.end);
      range.end.$insertRight = true;

      range2.start = session.doc.createAnchor(range2.start);
      range2.end = session.doc.createAnchor(range2.end);
      range2.end.$insertRight = true;

      $("#code_close").on("click", function () {
        var code = editor.getValue();
        shape_designer.app.setConfiguration({ code: code });
        Mousetrap.unpause();
        splash.fadeOut(function () {
          splash.remove();
        });
      });

      $("#test_run").on("click", function () {
        var code = editor.getValue();
        shape_designer.app.setConfiguration({ code: code });
        new _FigureTest2.default().show();
      });
    }
  }]);

  return FigureCodeEdit;
}();

exports.default = FigureCodeEdit;
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/dialog/FigureMarkdownEdit.js":
/*!***************************************************************!*\
  !*** ./app/frontend/designer/js/dialog/FigureMarkdownEdit.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _remarkable = __webpack_require__(/*! remarkable */ "./node_modules/remarkable/index.js");

var _remarkable2 = _interopRequireDefault(_remarkable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FigureMarkdownEdit = function () {
  function FigureMarkdownEdit() {
    _classCallCheck(this, FigureMarkdownEdit);

    this.mdHtml = null;
    this.scrollMap = null;

    this.lineHeight = 1.45;
    this.defaults = {
      html: true, // Enable HTML tags in source
      xhtmlOut: false, // Use '/' to close single tags (<br />)
      breaks: false, // Convert '\n' in paragraphs into <br>
      langPrefix: 'language-', // CSS language prefix for fenced blocks
      linkify: true, // autoconvert URL-like texts to links
      linkTarget: '_blank', // set target to open link in
      typographer: true // Enable smartypants and other sweet transforms
    };
  }

  /**
   */


  _createClass(FigureMarkdownEdit, [{
    key: 'show',
    value: function show() {
      Mousetrap.pause();
      var _this = this;
      this.mdHtml = new _remarkable2.default('full', this.defaults);

      var markdown = shape_designer.app.getConfiguration("markdown");
      markdown = markdown ? markdown : "# Header \n## Subheader \nbe nice and write a help file for your new \ncreated ***DigitalTrainingStudion*** shape. \n\n  - point 1\n  - point 2\n  - point 3";
      var splash = $('<div id="FigureMarkdownEdit" class="overlay-scale">' + '<pre class="source full-height">' + markdown + '</pre>' + '<div class="preview full-height" >' + '' + '</div>' + ' <div class="header">' + '<span class="left">Documentation Editor (<a target="_blank" href="https://en.wikipedia.org/wiki/Markdown">markdown syntax </a>)</span>' + '<span class="right">HTML Preview</span></div>' + ' <img title="Close" id="test_close" class="icon" src="./images/dialog_close.svg"/>' + '<div>');

      // fadeTo MUSS leider sein. Man kann mit raphael keine paper.text elemente einfügen
      // wenn das canvas nicht sichtbar ist. In diesen Fall mach ich das Canvas "leicht" sichtbar und raphael ist
      // zufrieden.
      $("body").append(splash);

      var removeDialog = function removeDialog() {
        Mousetrap.unpause();
        shape_designer.app.setConfiguration({ markdown: _this.editor.getValue() });
        splash.removeClass("open");
        setTimeout(function () {
          splash.remove();
        }, 400);
      };

      $("#test_close").on("click", removeDialog);
      setTimeout(function () {
        splash.addClass("open");
      }, 100);

      // Inject line numbers for sync scroll.
      //
      this.mdHtml.renderer.rules.paragraph_open = function (tokens, idx) {
        var line;
        if (tokens[idx].lines && tokens[idx].level === 0) {
          line = tokens[idx].lines[0];
          return '<p class="line" data-line="' + line + '">';
        }
        return '<p>';
      };

      this.mdHtml.renderer.rules.heading_open = function (tokens, idx) {
        var line;
        if (tokens[idx].lines && tokens[idx].level === 0) {
          line = tokens[idx].lines[0];
          return '<h' + tokens[idx].hLevel + ' class="line" data-line="' + line + '">';
        }
        return '<h' + tokens[idx].hLevel + '>';
      };

      this.$preview = $("#FigureMarkdownEdit .preview");
      this.$source = $('#FigureMarkdownEdit .source');

      var editor = ace.edit(this.$source[0]),
          session = editor.getSession();
      this.editor = editor;
      editor.moveCursorTo(5, 0);
      editor.focus();

      session.setMode("ace/mode/markdown");

      session.on('changeScrollTop', _this._debounce($.proxy(_this.syncScroll, _this), 50, false));

      editor.keyBinding.addKeyboardHandler({ handleKeyboard: _this._debounce($.proxy(_this.updateResult, _this), 300, false) });

      this.updateResult();
    }
  }, {
    key: 'updateResult',
    value: function updateResult() {
      var source = this.editor.getValue();
      this.$preview.html(this.mdHtml.render(source));
      // reset lines mapping cache on content update
      this.scrollMap = null;
    }

    // Build offsets for each line (lines can be wrapped)
    // That's a bit dirty to process each line everytime, but ok for demo.
    // Optimizations are required only for big texts.

  }, {
    key: 'buildScrollMap',
    value: function buildScrollMap() {
      var _this = this;

      var i, offset, nonEmptyList, pos, a, b, lineHeightMap, linesCount, acc, sourceLikeDiv, _scrollMap;

      sourceLikeDiv = $('<div />').css({
        position: 'absolute',
        visibility: 'hidden',
        height: 'auto',
        width: $("#FigureMarkdownEdit .left")[0].clientWidth,
        'font-size': '10pt',
        'font-family': 'tahoma',
        'line-height': this.lineHeight,
        'white-space': 'nowrap'
      }).appendTo('body');

      offset = this.$preview.scrollTop() - this.$preview.offset().top - 40;
      _scrollMap = [];
      nonEmptyList = [];
      lineHeightMap = [];

      acc = 0;
      this.editor.getValue().split('\n').forEach(function (str) {
        var h, lh;

        lineHeightMap.push(acc);

        if (str.length === 0) {
          acc++;
          return;
        }

        sourceLikeDiv.text(str);
        h = parseFloat(sourceLikeDiv.css('height'));
        lh = parseFloat(_this.lineHeight);
        acc += Math.round(h / lh);
      });
      sourceLikeDiv.remove();
      lineHeightMap.push(acc);
      linesCount = acc;

      for (i = 0; i < linesCount; i++) {
        _scrollMap.push(-1);
      }

      nonEmptyList.push(0);
      _scrollMap[0] = 0;

      $('.line').each(function (n, el) {
        var $el = $(el),
            t = $el.data('line');
        if (t === '') {
          return;
        }
        t = lineHeightMap[t];
        if (t !== 0) {
          nonEmptyList.push(t);
        }
        _scrollMap[t] = Math.round($el.offset().top + offset);
      });

      nonEmptyList.push(linesCount);
      _scrollMap[linesCount] = this.$preview[0].scrollHeight;

      pos = 0;
      for (i = 1; i < linesCount; i++) {
        if (_scrollMap[i] !== -1) {
          pos++;
          continue;
        }

        a = nonEmptyList[pos];
        b = nonEmptyList[pos + 1];
        _scrollMap[i] = Math.round((_scrollMap[b] * (i - a) + _scrollMap[a] * (b - i)) / (b - a));
      }

      return _scrollMap;
    }
  }, {
    key: 'syncScroll',
    value: function syncScroll(scroll) {
      var lineNo, posTo;
      lineNo = Math.floor(scroll / this.lineHeight);
      if (!this.scrollMap) {
        this.scrollMap = this.buildScrollMap();
      }
      posTo = this.scrollMap[lineNo];
      this.$preview.stop(true).animate({
        scrollTop: posTo
      }, 400, 'linear');
    }

    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.

  }, {
    key: '_debounce',
    value: function _debounce(func, wait, immediate) {
      var timeout;
      return function () {
        var context = this,
            args = arguments;
        var later = function later() {
          timeout = null;
          if (!immediate) func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
      };
    }
  }]);

  return FigureMarkdownEdit;
}();

exports.default = FigureMarkdownEdit;
module.exports = exports['default'];

/***/ }),

/***/ "./app/frontend/designer/js/dialog/FigureTest.js":
/*!*******************************************************!*\
  !*** ./app/frontend/designer/js/dialog/FigureTest.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _FigureWriter = __webpack_require__(/*! ./../io/FigureWriter */ "./app/frontend/designer/js/io/FigureWriter.js");

var _FigureWriter2 = _interopRequireDefault(_FigureWriter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FigureTest = function () {
  function FigureTest() {
    _classCallCheck(this, FigureTest);

    this.simulationContext = {};
  }

  _createClass(FigureTest, [{
    key: "show",
    value: function show() {
      var _this = this;
      this.animationFrameFunc = this._calculate.bind(this);

      this.simulationContext = {};

      var writer = new _FigureWriter2.default();
      var testShape = null;
      writer.marshal(shape_designer.app.view, "testShape", function (js) {
        try {
          js = $("#decoratedport-template").text().trim() + js;
          testShape = eval(js);
        } catch (exc) {
          alert("Error in shape code. \nRemove error and try it again:\n\n>>    " + exc);
          throw exc;
        }
        var splash = $('<div class="overlay-scale">' + '<div id="test_canvas">' + '</div>' + ' <div               id="test_info" >Test page for your designed and coded draw2d shape.</div>' + ' <img title="Close" id="test_close" class="icon" src="./images/dialog_close.svg"/>' + '<div>');

        // fadeTo MUSS leider sein. Man kann mit raphael keine paper.text elemente einfügen
        // wenn das canvas nicht sichtbar ist. In diesen Fall mach ich das Canvas "leicht" sichtbar und raphael ist
        // zufrieden.
        $("body").append(splash);

        var canvas = new draw2d.Canvas("test_canvas");
        _this.canvas = canvas;
        canvas.installEditPolicy(new draw2d.policy.canvas.ShowDotEditPolicy(20, 1, "#FF4981"));
        var router = new draw2d.layout.connection.InteractiveManhattanConnectionRouter();
        canvas.installEditPolicy(new draw2d.policy.connection.ComposedConnectionCreatePolicy([
        // create a connection via Drag&Drop of ports
        //
        new draw2d.policy.connection.DragConnectionCreatePolicy({
          createConnection: function createConnection() {
            return new draw2d.Connection({
              radius: 3,
              stroke: 2,
              color: "#129CE4",
              outlineStroke: 1,
              outlineColor: "#ffffff",
              router: router
            });
          }
        }),
        // or via click and point
        //
        new draw2d.policy.connection.OrthogonalConnectionCreatePolicy({
          createConnection: function createConnection() {
            return new draw2d.Connection({
              radius: 3,
              stroke: 2,
              color: "#129CE4",
              outlineStroke: 1,
              outlineColor: "#ffffff",
              router: router
            });
          }
        })]));
        var test = new testShape();
        canvas.add(test, 400, 160);

        // create and add two nodes which contains Ports (In and OUT)
        //
        var start = new draw2d.shape.node.Start();
        var toggle1 = new shape_designer.figure.TestSwitch();
        var toggle2 = new shape_designer.figure.TestSwitch();
        var end = new draw2d.shape.node.End();

        // ...add it to the canvas
        canvas.add(toggle1, 50, 150);
        canvas.add(toggle2, 50, 200);
        canvas.add(start, 50, 250);
        canvas.add(end, 630, 250);

        canvas.setCurrentSelection(test);
        var removeDialog = function removeDialog() {
          _this.simulate = false;
          splash.removeClass("open");
          setTimeout(function () {
            splash.remove();
            test.onStop(_this.simulationContext);
          }, 400);
        };

        $("#test_close").on("click", removeDialog);
        splash.addClass("open");

        test.onStart(_this.simulationContext);

        _this.simulate = true;
        requestAnimationFrame(_this.animationFrameFunc);
      });
    }
  }, {
    key: "_calculate",
    value: function _calculate() {
      // call the "calculate" method if given to calculate the output-port values
      //
      var _this = this;
      var figures = this.canvas.getFigures().clone().grep(function (f) {
        return f.calculate;
      });
      figures.each(function (i, figure) {
        figure.calculate(_this.simulationContext);
      });

      // transport the value from oututPort to inputPort
      //
      this.canvas.getLines().each(function (i, line) {
        var outPort = line.getSource();
        var inPort = line.getTarget();
        inPort.setValue(outPort.getValue());
        line.setColor(outPort.getValue() ? "#ff5252" : "#0000ff");
      });

      if (this.simulate === true) {
        requestAnimationFrame(this.animationFrameFunc);
      }
    }
  }]);

  return FigureTest;
}();

exports.default = FigureTest;
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/dialog/FileOpen.js":
/*!*****************************************************!*\
  !*** ./app/frontend/designer/js/dialog/FileOpen.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Configuration = __webpack_require__(/*! ../Configuration */ "./app/frontend/designer/js/Configuration.js");

var _Configuration2 = _interopRequireDefault(_Configuration);

var _hogan = __webpack_require__(/*! hogan.js */ "./node_modules/hogan.js/lib/hogan.js");

var _hogan2 = _interopRequireDefault(_hogan);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FileOpen = function () {

  /**
   * @constructor
   *
   */
  function FileOpen() {
    _classCallCheck(this, FileOpen);
  }

  /**
   * @method
   *
   * Open the file picker and load the selected file.<br>
   *
   * @param {Function} successCallback callback method if the user select a file and the content is loaded
   * @param {Function} errorCallback method to call if any error happens
   *
   * @since 4.0.0
   */


  _createClass(FileOpen, [{
    key: "show",
    value: function show(storage, view) {
      $('#fileOpenDialog').modal('show');
      this.fetchPathContent(storage, storage.currentDir, view);
    }
  }, {
    key: "fetchPathContent",
    value: function fetchPathContent(storage, newPath, view) {
      var _this = this;

      storage.getFiles(newPath).then(function (files) {
        files = files.filter(function (file) {
          return file.name.endsWith(_Configuration2.default.fileSuffix);
        });
        var compiled = _hogan2.default.compile("\n               {{^rootDir}}     \n               <a href=\"#\" class=\"list-group-item githubPath\" data-type=\"dir\" data-path=\"{{parentPath}}\" >\n                   <span class=\"glyphicon glyphicon-menu-left\"></span>\n                   ..\n               </a>\n               {{/rootDir}}\n               {{#files}}\n                 <a href=\"#\" data-draw2d=\"{{draw2d}}\" class=\"list-group-item githubPath text-nowrap\" data-type=\"{{type}}\" data-path=\"{{currentDir}}{{name}}\" data-id=\"{{id}}\">\n                    <span class=\"glyphicon {{icon}}\"></span>\n                    {{{name}}}\n                 </a>\n               {{/files}}\n          ");

        var parentPath = storage.dirname(newPath);
        var output = compiled.render({
          parentPath: parentPath,
          currentDir: storage.currentDir,
          files: files,
          rootDir: newPath === null,
          draw2d: function draw2d() {
            return this.name.endsWith(_Configuration2.default.fileSuffix);
          },
          icon: function icon() {
            if (this.name.endsWith(_Configuration2.default.fileSuffix)) {
              return "fa fa-object-group";
            }
            return this.type === "dir" ? "fa fa-folder-o" : "fa fa-file-o";
          }
        });

        $("#fileOpenDialog .list-group").html($(output));
        $("#fileOpenDialog .list-group").scrollTop(0);

        $(".githubPath[data-type='dir']").on("click", function (event) {
          _this.fetchPathContent(storage, $(event.currentTarget).data("path"), view);
        });

        $('.githubPath*[data-draw2d="true"][data-type="file"]').on("click", function (event) {
          var path = $(event.currentTarget).data("path");
          storage.loadFile(path).then(function (content) {
            $('#fileOpenDialog').modal('hide');
            storage.currentFile = path;
            view.clear();
            new draw2d.io.json.Reader().unmarshal(view, content);
            view.app.getConfiguration();
            view.getCommandStack().markSaveLocation();
            view.centerDocument();
            return content;
          });
          event.preventDefault();
        });
      });
    }
  }]);

  return FileOpen;
}();

exports.default = FileOpen;
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/dialog/FileSave.js":
/*!*****************************************************!*\
  !*** ./app/frontend/designer/js/dialog/FileSave.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Configuration = __webpack_require__(/*! ./../Configuration */ "./app/frontend/designer/js/Configuration.js");

var _Configuration2 = _interopRequireDefault(_Configuration);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FileSave = function () {

  /**
   * @constructor
   *
   */
  function FileSave() {
    _classCallCheck(this, FileSave);
  }

  /**
   * @method
   *
   * Open the file picker and load the selected file.<br>
   *
   * @param {Function} successCallback callback method if the user select a file and the content is loaded
   * @param {Function} errorCallback method to call if any error happens
   *
   * @since 4.0.0
   */


  _createClass(FileSave, [{
    key: "show",
    value: function show(storage, canvas) {

      new draw2d.io.png.Writer().marshal(canvas, function (imageDataUrl) {
        $("#fileSaveDialog .filePreview").attr("src", imageDataUrl);
        $("#fileSaveDialog .githubFileName").val(storage.currentFile ? storage.currentFile : "NewDocument" + _Configuration2.default.fileSuffix);

        $('#fileSaveDialog').on('shown.bs.modal', function (event) {
          $(event.currentTarget).find('input:first').focus();
        });
        $("#fileSaveDialog").modal("show");
        Mousetrap.pause();

        // Button: Commit to GitHub
        //
        $("#fileSaveDialog .okButton").off('click').on("click", function () {
          Mousetrap.unpause();
          var writer = new draw2d.io.json.Writer();
          writer.marshal(canvas, function (json) {
            var newName = $("#fileSaveDialog .githubFileName").val();
            storage.saveFile(json, imageDataUrl, newName).then(function () {
              storage.currentFile = newName;
              $('#fileSaveDialog').modal('hide');
            });
          });
        });
      }, canvas.getBoundingBox().scale(20, 20));
    }
  }]);

  return FileSave;
}();

exports.default = FileSave;
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/dialog/FileSaveAs.js":
/*!*******************************************************!*\
  !*** ./app/frontend/designer/js/dialog/FileSaveAs.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Configuration = __webpack_require__(/*! ./../Configuration */ "./app/frontend/designer/js/Configuration.js");

var _Configuration2 = _interopRequireDefault(_Configuration);

var _hogan = __webpack_require__(/*! hogan.js */ "./node_modules/hogan.js/lib/hogan.js");

var _hogan2 = _interopRequireDefault(_hogan);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FileSaveAs = function () {

  /**
   * @constructor
   *
   */
  function FileSaveAs() {
    _classCallCheck(this, FileSaveAs);
  }

  /**
   * @method
   *
   * Open the file picker and load the selected file.
   *
   * @since 4.0.0
   */


  _createClass(FileSaveAs, [{
    key: "show",
    value: function show(storage, canvas) {
      var _this = this;

      if (storage.currentFile === null) {
        storage.currentFile = "DocumentName" + _Configuration2.default.fileSuffix;
      }

      new draw2d.io.png.Writer().marshal(canvas, function (imageDataUrl) {
        // else reopen the already selected directory
        $("#githubFileSaveAsDialog .okButton").prop("disabled", false);
        _this.fetchPathContent(storage, storage.currentDir);

        $("#githubFileSaveAsDialog .filePreview").attr("src", imageDataUrl);
        $("#githubFileSaveAsDialog .githubFileName").val(storage.currentFile);

        $('#githubFileSaveAsDialog').off('shown.bs.modal').on('shown.bs.modal', function (event) {
          $(event.currentTarget).find('input:first').focus();
        });
        $("#githubFileSaveAsDialog").modal("show");
        Mousetrap.pause();

        // Button: Commit to GitHub
        //
        $("#githubFileSaveAsDialog .okButton").off('click').on("click", function () {
          Mousetrap.unpause();
          var writer = new draw2d.io.json.Writer();
          writer.marshal(canvas, function (json) {
            var title = $("#githubFileSaveAsDialog .githubFileName").val();
            storage.saveFile(json, imageDataUrl, title).then(function () {
              storage.currentFile = name;
              $('#githubFileSaveAsDialog').modal('hide');
            });
          });
        });
      }, canvas.getBoundingBox().scale(20, 20));
    }
  }, {
    key: "fetchPathContent",
    value: function fetchPathContent(storage, newPath) {
      var _this2 = this;

      storage.getFiles(newPath).then(function (files) {
        storage.currentFile = newPath;
        var compiled = _hogan2.default.compile('         <a href="#" class="list-group-item githubPath" data-type="{{parentType}}" data-path="{{parentPath}}" >' + '             <span class="glyphicon glyphicon-menu-left"></span>' + '             ..' + '         </a>' + '         {{#files}}' + '           <a href="#" data-draw2d="{{draw2d}}" class="list-group-item githubPath text-nowrap" data-type="{{type}}" data-path="{{currentDir}}{{name}}" data-title="{{name}}" data-id="{{id}}" data-sha="{{sha}}">' + '              <span class="glyphicon {{icon}}"></span>' + '              {{{name}}}' + '           </a>' + '         {{/files}}');

        var parentPath = storage.dirname(newPath);
        var output = compiled.render({
          parentPath: parentPath,
          currentDir: storage.currentDir,
          files: files,
          draw2d: function draw2d() {
            return this.name.endsWith(_Configuration2.default.fileSuffix);
          },
          icon: function icon() {
            if (this.name.endsWith(_Configuration2.default.fileSuffix)) {
              return "fa fa-object-group";
            }
            return this.type === "dir" ? "fa fa-folder-o" : "fa fa-file-o";
          }
        });
        $("#githubFileSaveAsDialog .list-group").html($(output));
        $("#githubFileSaveAsDialog .list-group").scrollTop(0);

        //we are in a folder. Create of a file is possible now
        //
        $("#githubFileSaveAsDialog .okButton").prop("disabled", false);

        $(".githubPath[data-type='dir']").on("click", function (event) {
          _this2.fetchPathContent(storage, $(event.currentTarget).data("path"));
        });

        $('.githubPath*[data-draw2d="true"][data-type="file"]').on("click", function (event) {
          var path = $(event.currentTarget).data("path");
          var title = path.split(/[\\/]/).pop(); // basename
          $("#githubFileSaveAsDialog .githubFileName").val(title);
        });
      });
    }
  }]);

  return FileSaveAs;
}();

exports.default = FileSaveAs;
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/figure/CircuitFigure.js":
/*!**********************************************************!*\
  !*** ./app/frontend/designer/js/figure/CircuitFigure.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = draw2d.SetFigure.extend({

  NAME: "CircuitFigure",

  init: function init(attr, setter, getter) {
    var _this = this;

    this.tooltip = null;
    this.tooltipTimer = -1;

    this._super($.extend({ stroke: 0, bgColor: null, width: 30, height: 32 }, attr), setter, getter);

    this.persistPorts = false;
    this.zoomCallback = $.proxy(this.positionTooltip, this);

    this.on("dragstart", function () {
      _this.hideTooltip(true);
    });

    this.on("mouseenter", function () {
      _this.tooltipTimer = window.setTimeout(function () {
        _this.tooltipTimer = -1;
        _this.showTooltip();
      }, 500);
    });

    this.on("mouseleave", function () {
      _this.hideTooltip();
    });

    this.on("move", function () {
      _this.positionTooltip();
    });
  },

  setCanvas: function setCanvas(canvas) {
    if (this.canvas !== null) this.canvas.off(this.zoomCallback);
    this._super(canvas);
    if (this.canvas !== null) this.canvas.on("zoom", this.zoomCallback);
  },

  hideTooltip: function hideTooltip(fast) {
    if (this.tooltipTimer !== -1) {
      window.clearTimeout(this.tooltipTimer);
      this.tooltipTimer = -1;
    } else if (this.tooltip !== null) {
      if (fast) {
        this.tooltip.remove();
      } else {
        this.tooltip.fadeOut(500, function () {
          $(this).remove();
        });
      }
      this.tooltip = null;
    }
  },

  showTooltip: function showTooltip() {
    this.tooltip = $('<div class="draw2d_tooltip">' + this.NAME + '</div>').appendTo('body').hide().fadeIn(1000);
    this.positionTooltip();
  },

  positionTooltip: function positionTooltip() {
    if (this.tooltip === null) {
      return;
    }

    var width = this.tooltip.outerWidth(true);
    var pos = this.canvas.fromCanvasToDocumentCoordinate(this.getAbsoluteX() + this.getWidth() / 2 - width / 2 + 8, this.getAbsoluteY() + this.getHeight() + 10);

    this.tooltip.css({ 'top': pos.y, 'left': pos.x });
  },

  applyAlpha: function applyAlpha() {},

  layerGet: function layerGet(name, attributes) {
    if (this.svgNodes === null) return null;
    var found = null;
    this.svgNodes.forEach(function (shape) {
      if (found === null && shape.data("name") === name) {
        found = shape;
      }
    });
    return found;
  },

  layerAttr: function layerAttr(name, attributes) {
    if (this.svgNodes === null) return;

    this.svgNodes.forEach(function (shape) {
      if (shape.data("name") === name) {
        shape.attr(attributes);
      }
    });
  },

  layerShow: function layerShow(name, flag, duration) {
    if (this.svgNodes === null) return;

    if (duration) {
      this.svgNodes.forEach(function (node) {
        if (node.data("name") === name) {
          if (flag) {
            node.attr({ opacity: 0 }).show().animate({ opacity: 1 }, duration);
          } else {
            node.animate({ opacity: 0 }, duration, function () {
              this.hide();
            });
          }
        }
      });
    } else {
      this.svgNodes.forEach(function (node) {
        if (node.data("name") === name) {
          if (flag) {
            node.show();
          } else {
            node.hide();
          }
        }
      });
    }
  },

  calculate: function calculate(context) {},

  onStart: function onStart(context) {},

  onStop: function onStop(context) {},

  getParameterSettings: function getParameterSettings() {
    return [];
  },

  getRequiredHardware: function getRequiredHardware() {
    return {
      raspi: false,
      arduino: false
    };
  },

  onDrop: function onDrop(dropTarget, x, y, shiftKey, ctrlKey) {
    // Activate a "smart insert" If the user drop this figure on connection
    //
    /*
    if (dropTarget instanceof draw2d.Connection) {
      let additionalConnection = dropTarget.getCanvas().createConnection()
      let oldSource = dropTarget.getSource()
      let oldTarget = dropTarget.getTarget()
      if (oldSource instanceof draw2d.InputPort) {
        oldSource = dropTarget.getTarget()
        oldTarget = dropTarget.getSource()
      }
        let stack = this.getCanvas().getCommandStack()
      let cmd = new draw2d.command.CommandReconnect(dropTarget)
      cmd.setNewPorts(oldSource, this.getInputPort(0))
      stack.execute(cmd)
        cmd = new draw2d.command.CommandConnect(oldTarget, this.getOutputPort(0))
      cmd.setConnection(additionalConnection)
      stack.execute(cmd)
    }
    */
  },

  /**
   * @method
   * Return an objects with all important attributes for XML or JSON serialization
   *
   * @returns {Object}
   */
  getPersistentAttributes: function getPersistentAttributes() {
    var memento = this._super();

    // add all decorations to the memento
    //
    memento.labels = [];
    this.children.each(function (i, e) {
      var labelJSON = e.figure.getPersistentAttributes();
      labelJSON.locator = e.locator.NAME;
      memento.labels.push(labelJSON);
    });

    return memento;
  },

  /**
   * @method
   * Read all attributes from the serialized properties and transfer them into the shape.
   *
   * @param {Object} memento
   * @returns
   */
  setPersistentAttributes: function setPersistentAttributes(memento) {
    this._super(memento);

    // remove all decorations created in the constructor of this element
    //
    this.resetChildren();

    // and add all children of the JSON document.
    //
    $.each(memento.labels, $.proxy(function (i, json) {
      // create the figure stored in the JSON
      var figure = eval("new " + json.type + "()");

      // apply all attributes
      figure.attr(json);

      // instantiate the locator
      var locator = eval("new " + json.locator + "()");

      // add the new figure as child to this figure
      this.add(figure, locator);
    }, this));
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/figure/DecoratedInputPort.js":
/*!***************************************************************!*\
  !*** ./app/frontend/designer/js/figure/DecoratedInputPort.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = shape_designer.figure.DecoratedInputPort = draw2d.InputPort.extend({

  init: function init(attr, setter, getter) {
    this.hasChanged = true;

    this._super(attr, setter, getter);

    this.decoration = new shape_designer.figure.MarkerFigure();

    this.add(this.decoration, new draw2d.layout.locator.LeftLocator({ margin: 8 }));

    // a port can have a value. Useful for workflow engines or circuit diagrams
    this.setValue(true);
  },

  useDefaultValue: function useDefaultValue() {
    this.decoration.setStick(true);
  },

  setValue: function setValue(value) {
    this.hasChanged = this.value !== value;
    this._super(value);
  },

  hasChangedValue: function hasChangedValue() {
    return this.hasChanged;
  },

  hasRisingEdge: function hasRisingEdge() {
    return this.hasChangedValue() && this.getValue();
  },

  hasFallingEdge: function hasFallingEdge() {
    return this.hasChangedValue() && !this.getValue();
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/figure/ExtLabel.js":
/*!*****************************************************!*\
  !*** ./app/frontend/designer/js/figure/ExtLabel.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = shape_designer.figure.ExtLabel = draw2d.shape.basic.Label.extend({

  NAME: "shape_designer.figure.ExtLabel",

  init: function init() {
    this.blur = 0;
    this.isExtFigure = true;

    this._super();

    this.setUserData({ name: "Label" });

    this.filters = new draw2d.util.ArrayList();
    this.filters.add(new shape_designer.filter.PositionFilter());
    this.filters.add(new shape_designer.filter.FontSizeFilter());
    this.filters.add(new shape_designer.filter.FontColorFilter());

    this.installEditor(new LabelInplaceEditor());
  },

  getPotentialFilters: function getPotentialFilters() {
    return [{ label: "Opacity", impl: "shape_designer.filter.OpacityFilter" }, { label: "Blur", impl: "shape_designer.filter.BlurFilter" }, { label: "Outline", impl: "shape_designer.filter.OutlineStrokeFilter" }, { label: "Gradient", impl: "shape_designer.filter.TextLinearGradientFilter" }, { label: "Font Size", impl: "shape_designer.filter.FontSizeFilter" }, { label: "Font Color", impl: "shape_designer.filter.FontColorFilter" }];
  },

  setBlur: function setBlur(value) {
    this.blur = value;
    this.repaint();
  },

  getBlur: function getBlur() {
    return this.blur;
  },

  removeFilter: function removeFilter(filter) {
    this.filters.remove(filter);

    return this;
  },

  addFilter: function addFilter(filter) {
    var alreadyIn = false;

    this.filters.each($.proxy(function (i, e) {
      alreadyIn = alreadyIn || e.NAME === filter.NAME;
    }, this));
    if (alreadyIn === true) {
      return; // silently
    }

    this.filters.add(filter);
    filter.onInstall(this);
    this.repaint();

    return this;
  },

  /*
    setPosition: function(x, y) {
      if (x instanceof draw2d.geo.Point) {
        return this._super(
          parseFloat(x.x.toFixed(1)),
          parseFloat(x.y.toFixed(1)))
      }
  
      return this._super(
        parseFloat(x.toFixed(1)),
        parseFloat(y.toFixed(1)))
    },
  */

  /**
  * @method
  * Trigger the repaint of the element.
  *
  */
  repaint: function repaint(attributes) {
    if (this.shape === null) {
      return;
    }

    if (typeof attributes === "undefined") {
      attributes = {};
    }

    // style the label
    var lattr = {};
    lattr.text = this.text;
    lattr["font-weight"] = this.bold === true ? "bold" : "normal";
    lattr["text-anchor"] = "start";
    lattr["font-size"] = this.fontSize;
    if (this.fontFamily !== null) {
      lattr["font-family"] = this.fontFamily;
    }
    lattr.fill = this.fontColor.hash();
    // since 4.2.1
    lattr.stroke = this.outlineColor.hash();
    lattr["stroke-width"] = this.outlineStroke;

    this.filters.each($.proxy(function (i, filter) {
      filter.apply(this, attributes, lattr);
    }, this));

    this.svgNodes.attr(lattr);
    // set of the x/y must be done AFTER the font-size and bold has been set.
    // Reason: the getHeight method needs the font-size for calculation because
    //         it redirects the calculation to the SVG element.
    this.svgNodes.attr({ x: this.padding.left, y: this.getHeight() / 2 });

    // jump over the normal Label implementation
    draw2d.SetFigure.prototype.repaint.call(this, attributes);
  },

  getPersistentAttributes: function getPersistentAttributes() {
    var memento = this._super();

    memento.filters = [];
    this.filters.each($.proxy(function (i, e) {
      var filterMemento = e.getPersistentAttributes(this);
      memento.filters.push(filterMemento);
    }, this));

    return memento;
  },

  setPersistentAttributes: function setPersistentAttributes(memento) {
    this._super(memento);

    if (typeof memento.filters !== "undefined") {
      this.filters = new draw2d.util.ArrayList();
      $.each(memento.filters, $.proxy(function (i, e) {
        var filter = eval("new " + e.name + "()");
        filter.setPersistentAttributes(this, e);
        this.filters.add(filter);
      }, this));
    }
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/figure/ExtLine.js":
/*!****************************************************!*\
  !*** ./app/frontend/designer/js/figure/ExtLine.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = shape_designer.figure.ExtLine = draw2d.shape.basic.PolyLine.extend({

  NAME: "shape_designer.figure.ExtLine",

  init: function init() {
    this._super();

    this.blur = 0;
    this.isExtFigure = true;

    this.setUserData({ name: "Line" });

    this.filters = new draw2d.util.ArrayList();
    this.filters.add(new shape_designer.filter.StrokeFilter());

    this.setRouter(new draw2d.layout.connection.VertexRouter());
    this.installEditPolicy(new draw2d.policy.line.VertexSelectionFeedbackPolicy());
  },

  setBlur: function setBlur(value) {
    this.blur = parseInt(value);
    this.repaint();
  },

  getBlur: function getBlur() {
    return this.blur;
  },

  getPotentialFilters: function getPotentialFilters() {
    return [{ label: "Opacity", impl: "shape_designer.filter.OpacityFilter" }, { label: "Blur", impl: "shape_designer.filter.BlurFilter" }, { label: "Outline", impl: "shape_designer.filter.OutlineStrokeFilter" }, { label: "Corner Radius", impl: "shape_designer.filter.RadiusFilter" }, { label: "Stroke", impl: "shape_designer.filter.StrokeFilter" }];
  },

  removeFilter: function removeFilter(filter) {
    this.filters.remove(filter);

    return this;
  },

  addFilter: function addFilter(filter) {
    var alreadyIn = false;

    this.filters.each($.proxy(function (i, e) {
      alreadyIn = alreadyIn || e.NAME === filter.NAME;
    }, this));
    if (alreadyIn === true) {
      return; // silently
    }

    this.filters.add(filter);
    filter.onInstall(this);
    this.repaint();

    return this;
  },

  /**
   * @method
   * Trigger the repaint of the element.
   *
   */
  repaint: function repaint(attributes) {
    if (this.shape === null) {
      return;
    }

    if (typeof attributes === "undefined") {
      attributes = {};
    }

    this.filters.each($.proxy(function (i, filter) {
      filter.apply(this, attributes);
    }, this));

    //        this.shape.blur(this.blur);
    this._super(attributes);
  },

  getPersistentAttributes: function getPersistentAttributes() {
    var memento = this._super();

    memento.filters = [];
    this.filters.each($.proxy(function (i, e) {
      var filterMemento = e.getPersistentAttributes(this);
      memento.filters.push(filterMemento);
    }, this));

    return memento;
  },

  setPersistentAttributes: function setPersistentAttributes(memento) {
    this._super(memento);

    if (typeof memento.filters !== "undefined") {
      this.filters = new draw2d.util.ArrayList();
      $.each(memento.filters, $.proxy(function (i, e) {
        var filter = eval("new " + e.name + "()");
        filter.setPersistentAttributes(this, e);
        this.filters.add(filter);
      }, this));
    }
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/figure/ExtPolygon.js":
/*!*******************************************************!*\
  !*** ./app/frontend/designer/js/figure/ExtPolygon.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _PositionFilter = __webpack_require__(/*! ../filter/PositionFilter */ "./app/frontend/designer/js/filter/PositionFilter.js");

var _PositionFilter2 = _interopRequireDefault(_PositionFilter);

var _SizeFilter = __webpack_require__(/*! ../filter/SizeFilter */ "./app/frontend/designer/js/filter/SizeFilter.js");

var _SizeFilter2 = _interopRequireDefault(_SizeFilter);

var _StrokeFilter = __webpack_require__(/*! ../filter/StrokeFilter */ "./app/frontend/designer/js/filter/StrokeFilter.js");

var _StrokeFilter2 = _interopRequireDefault(_StrokeFilter);

var _FillColorFilter = __webpack_require__(/*! ../filter/FillColorFilter */ "./app/frontend/designer/js/filter/FillColorFilter.js");

var _FillColorFilter2 = _interopRequireDefault(_FillColorFilter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* jshint evil:true */
// required for serialie/deserialize of JSON
exports.default = shape_designer.figure.ExtPolygon = draw2d.shape.basic.Polygon.extend({

  NAME: "shape_designer.figure.ExtPolygon",

  init: function init(attr, setter, getter) {
    this.blur = 0;

    this.isExtFigure = true;

    this._super(attr, setter, getter);

    this.setUserData({ name: "Polygon" });

    this.filters = new draw2d.util.ArrayList();
    this.filters.add(new _PositionFilter2.default());
    this.filters.add(new _SizeFilter2.default());
    this.filters.add(new _StrokeFilter2.default());
    this.filters.add(new _FillColorFilter2.default());

    this.installEditPolicy(new draw2d.policy.figure.RectangleSelectionFeedbackPolicy());
  },

  setBlur: function setBlur(value) {
    this.blur = parseInt(value);
    this.repaint();
  },

  getBlur: function getBlur() {
    return this.blur;
  },

  getPotentialFilters: function getPotentialFilters() {
    return [{ label: "Stroke", impl: "shape_designer.filter.StrokeFilter" }, { label: "Opacity", impl: "shape_designer.filter.OpacityFilter" }, { label: "Blur", impl: "shape_designer.filter.BlurFilter" }, { label: "Corner Radius", impl: "shape_designer.filter.RadiusFilter" }, { label: "Linear Gradient", impl: "shape_designer.filter.LinearGradientFilter" }, { label: "Fill Color", impl: "shape_designer.filter.FillColorFilter" }];
  },

  removeFilter: function removeFilter(filter) {
    this.filters.remove(filter);
  },

  addFilter: function addFilter(filter) {
    var alreadyIn = false;

    this.filters.each($.proxy(function (i, e) {
      alreadyIn = alreadyIn || e.NAME === filter.NAME;
    }, this));

    if (alreadyIn === true) {
      return; // silently
    }

    this.filters.add(filter);
    filter.onInstall(this);
    this.repaint();
  },

  onDoubleClick: function onDoubleClick() {
    this.installEditPolicy(new draw2d.policy.figure.VertexSelectionFeedbackPolicy());
  },

  /**
   * @method
   * Unselect the figure and propagete this event to all edit policies.
   *
   * @final
   * @private
   **/
  unselect: function unselect() {
    this._super();

    this.installEditPolicy(new draw2d.policy.figure.RectangleSelectionFeedbackPolicy());
    return this;
  },

  /**
   * @method
   * Trigger the repaint of the element.
   *
   */
  repaint: function repaint(attributes) {
    if (this.shape === null) {
      return;
    }

    if (this.svgPathString === null) {
      this.calculatePath();
    }

    if (typeof attributes === "undefined") {
      attributes = {};
    }

    attributes.path = this.svgPathString;

    this.filters.each($.proxy(function (i, filter) {
      filter.apply(this, attributes);
    }, this));

    //this.shape.blur(this.blur===0?-1:this.blur);
    /*
            if(this.filter)
            this.filter = this.canvas.paper.createFilter();
            filter.addShiftToColor("red");
            filter.addBlur(7);
            this.shape.filter(filter);
    */
    this._super(attributes);
  },

  getPersistentAttributes: function getPersistentAttributes() {
    var memento = this._super();

    memento.blur = this.blur;
    memento.filters = [];
    this.filters.each($.proxy(function (i, e) {
      var filterMemento = e.getPersistentAttributes(this);
      memento.filters.push(filterMemento);
    }, this));

    return memento;
  },

  setPersistentAttributes: function setPersistentAttributes(memento) {
    this._super(memento);

    if (typeof memento.blur !== "undefined") this.setBlur(memento.blur);

    if (typeof memento.filters !== "undefined") {
      this.filters = new draw2d.util.ArrayList();
      var sizeFilterAdded = false;
      $.each(memento.filters, $.proxy(function (i, e) {

        var filter = eval("new " + e.name + "()");
        if (filter instanceof shape_designer.filter.SizeFilter) {
          sizeFilterAdded = true;
        }
        filter.setPersistentAttributes(this, e);
        this.filters.add(filter);
      }, this));
      if (!sizeFilterAdded) {
        this.filters.insertElementAt(new shape_designer.filter.SizeFilter(), 1);
      }
    }
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/figure/ExtPort.js":
/*!****************************************************!*\
  !*** ./app/frontend/designer/js/figure/ExtPort.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = shape_designer.figure.ExtPort = draw2d.shape.basic.Circle.extend({

  NAME: "shape_designer.figure.ExtPort",

  init: function init() {
    this.isExtFigure = true;
    this.decoration = null;
    this._super({
      bgColor: "#37B1DE",
      diameter: 10
    });

    this.setUserData({
      name: "Port",
      type: "Hybrid",
      direction: null,
      fanout: 20
    });

    this.filters = new draw2d.util.ArrayList();
    this.filters.add(new shape_designer.filter.PositionFilter());
    this.filters.add(new shape_designer.filter.FanoutFilter());
    this.filters.add(new shape_designer.filter.PortDirectionFilter());
    this.filters.add(new shape_designer.filter.PortTypeFilter());

    this.installEditPolicy(new draw2d.policy.figure.AntSelectionFeedbackPolicy());
  },

  setInputType: function setInputType(type) {
    this.getUserData().type = type;
  },

  getInputType: function getInputType() {
    return this.getUserData().type;
  },

  setMaxFanOut: function setMaxFanOut(count) {
    this.getUserData().fanout = parseInt(count);
  },

  getMaxFanOut: function getMaxFanOut() {
    return this.getUserData().fanout ? this.getUserData().fanout : 20;
  },

  setConnectionDirection: function setConnectionDirection(direction) {
    this.getUserData().direction = direction;
    this.updateDecoration();
  },

  getConnectionDirection: function getConnectionDirection() {
    return this.getUserData().direction;
  },

  updateDecoration: function updateDecoration() {
    if (this.decoration !== null) {
      this.remove(this.decoration);
      this.decoration = null;
    }
    var figure = null;
    var locator = null;
    switch (this.getConnectionDirection()) {
      case 0:
        figure = new draw2d.shape.icon.ArrowUp({ width: 8, height: 8, opacity: 0.5 });
        locator = new draw2d.layout.locator.TopLocator();
        break;
      case 1:
        figure = new draw2d.shape.icon.ArrowRight({ width: 8, height: 8, opacity: 0.5 });
        locator = new draw2d.layout.locator.RightLocator();
        break;
      case 2:
        figure = new draw2d.shape.icon.ArrowDown({ width: 8, height: 8, opacity: 0.5 });
        locator = new draw2d.layout.locator.BottomLocator();
        break;
      case 3:
        figure = new draw2d.shape.icon.ArrowLeft({ width: 8, height: 8, opacity: 0.5 });
        locator = new draw2d.layout.locator.LeftLocator();
        break;
    }
    if (figure !== null) {
      this.add(figure, locator);
      this.decoration = figure;
    }
  },

  getPotentialFilters: function getPotentialFilters() {
    return [{ label: "Port Type", impl: "shape_designer.filter.PortTypeFilter" }, { label: "Port Direction", impl: "shape_designer.filter.PortDirectionFilter" }, { label: "Color", impl: "shape_designer.filter.FillColorFilter" }];
  },

  removeFilter: function removeFilter(filter) {
    this.filters.remove(filter);
  },

  addFilter: function addFilter(filter) {
    var alreadyIn = false;

    this.filters.each($.proxy(function (i, e) {
      alreadyIn = alreadyIn || e.NAME === filter.NAME;
    }, this));
    if (alreadyIn === true) {
      return; // silently
    }

    this.filters.add(filter);
    filter.onInstall(this);
    this.repaint();
  },

  /**
   * @method
   * Trigger the repaint of the element.
   *
   */
  repaint: function repaint(attributes) {
    if (this.shape === null) {
      return;
    }

    if (typeof attributes === "undefined") {
      attributes = {};
    }

    this.filters.each($.proxy(function (i, filter) {
      filter.apply(this, attributes);
    }, this));

    this._super(attributes);
  },

  getPersistentAttributes: function getPersistentAttributes() {
    var memento = this._super();

    memento.filters = [];
    this.filters.each($.proxy(function (i, e) {
      var filterMemento = e.getPersistentAttributes(this);
      memento.filters.push(filterMemento);
    }, this));

    return memento;
  },

  setPersistentAttributes: function setPersistentAttributes(memento) {
    this._super(memento);

    if (typeof memento.filters !== "undefined") {
      this.filters = new draw2d.util.ArrayList();
      var fanoutFilterAdded = false;
      $.each(memento.filters, $.proxy(function (i, e) {
        var filter = eval("new " + e.name + "()");
        if (filter instanceof shape_designer.filter.FanoutFilter) {
          fanoutFilterAdded = true;
        }
        filter.setPersistentAttributes(this, e);
        this.filters.add(filter);
      }, this));
      if (!fanoutFilterAdded) {
        this.filters.insertElementAt(new shape_designer.filter.FanoutFilter(), 1);
      }
    }
    this.updateDecoration();
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/figure/MarkerFigure.js":
/*!*********************************************************!*\
  !*** ./app/frontend/designer/js/figure/MarkerFigure.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * The markerFigure is the left hand side annotation for a DecoratedPort.
 *
 * It contains two children
 *
 * StateAFigure: if the mouse hover and the figure isn't permanent visible
 * StateBFigure: either the mouse is over or the user pressed the checkbox to stick the figure on the port
 *
 * This kind of decoration is usefull for defualt values on workflwos enginges or circuit diagrams
 *
 */

exports.default = shape_designer.figure.MarkerFigure = draw2d.shape.layout.VerticalLayout.extend({

  NAME: "MarkerFigure",

  init: function init(attr, setter, getter) {
    var _this = this;

    this.isMouseOver = false; // indicator if the mouse is over the element
    this.stick = false; // indicator if the stateBFigure should always be visible
    this.defaultValue = true; // current selected default value for the decoration

    this._super($.extend({
      stroke: 0
    }, attr), setter, getter);

    // figure if the decoration is not permanent visible (sticky note)
    this.add(this.stateA = new shape_designer.figure.MarkerStateAFigure({ text: "X" }));
    // figure if the decoration permanent visible
    this.add(this.stateB = new shape_designer.figure.MarkerStateBFigure({ text: "X" }));

    this.on("mouseenter", function (emitter, event) {
      _this.onMouseOver(true);
    });

    this.on("mouseleave", function (emitter, event) {
      _this.onMouseOver(false);
    });

    this.on("click", function (emitter, event) {
      if (_this.isVisible() === false) {
        return; //silently
      }

      if (_this.stateB.getStickTickFigure().getBoundingBox().hitTest(event.x, event.y) === true) {
        _this.setStick(!_this.getStick());
      } else if (_this.stateB.getLabelFigure().getBoundingBox().hitTest(event.x, event.y) === true) {
        $.contextMenu({
          selector: 'body',
          trigger: "left",
          events: {
            hide: function hide() {
              $.contextMenu('destroy');
            }
          },
          callback: $.proxy(function (key, options) {
            // propagate the default value to the port
            //
            switch (key) {
              case "high":
                _this.setDefaultValue(true);
                break;
              case "low":
                _this.setDefaultValue(false);
                break;
              default:
                break;
            }
          }, this),
          x: event.x,
          y: event.y,
          items: {
            "high": { name: "High" },
            "low": { name: "Low" }
          }
        });
      }
    });

    this.setDefaultValue(true);
    this.onMouseOver(false);
  },

  onMouseOver: function onMouseOver(flag) {
    this.isMouseOver = flag;

    if (this.visible === false) {
      return; // silently
    }

    if (this.stick === true) {
      this.stateA.setVisible(false);
      this.stateB.setVisible(true);
    } else {
      this.stateA.setVisible(!this.isMouseOver);
      this.stateB.setVisible(this.isMouseOver);
    }

    return this;
  },

  setVisible: function setVisible(flag) {
    this._super(flag);

    // update the hover/stick state of the figure
    this.onMouseOver(this.isMouseOver);

    return this;
  },

  setStick: function setStick(flag) {
    this.stick = flag;
    this.onMouseOver(this.isMouseOver);

    // the port has only a default value if the decoration is visible
    this.parent.setValue(flag ? this.defaultValue : null);

    this.stateB.setTick(this.getStick());

    return this;
  },

  getStick: function getStick() {
    return this.stick;
  },

  setText: function setText(text) {
    this.stateB.setText(text);

    return this;
  },

  setDefaultValue: function setDefaultValue(value) {
    this.defaultValue = value;
    this.setText(this.defaultValue === true ? "High" : "Low");

    // only propagate the value to the parent if the decoration permanent visible
    //
    if (this.stick === true) {
      this.parent.setValue(this.defaultValue);
    }
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/figure/MarkerStateAFigure.js":
/*!***************************************************************!*\
  !*** ./app/frontend/designer/js/figure/MarkerStateAFigure.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * This is only the mouseover reactive shape. A little bit smaller than the visible shape
 *
 * Or you can display this shape with opacity of 0.2 to indicate that this is a reactive area.
 */

exports.default = shape_designer.figure.MarkerStateAFigure = draw2d.shape.basic.Label.extend({

  NAME: "MarkerStateAFigure",

  /**
   * @param attr
   */
  init: function init(attr, setter, getter) {
    this._super($.extend({
      padding: { left: 5, top: 2, bottom: 2, right: 10 },
      bgColor: null,
      stroke: 1,
      color: null,
      fontColor: null,
      fontSize: 10
    }, attr), setter, getter);

    // we must override the hitTest method to ensure that the parent can receive the mouseenter/mouseleave events.
    // Unfortunately draw2D didn't provide event bubbling like HTML. The first shape in queue consumes the event.
    //
    // now this shape is "dead" for any mouse events and the parent must/can handle this.
    this.hitTest = function () {
      return false;
    };
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/figure/MarkerStateBFigure.js":
/*!***************************************************************!*\
  !*** ./app/frontend/designer/js/figure/MarkerStateBFigure.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = shape_designer.figure.MarkerStateBFigure = draw2d.shape.layout.HorizontalLayout.extend({

  NAME: "MarkerStateBFigure",

  /**
   * @param attr
   */
  init: function init(attr, setter, getter) {
    this._super($.extend({
      bgColor: "#FFFFFF",
      stroke: 1,
      color: "#00bcd4",
      radius: 2,
      padding: { left: 3, top: 3, bottom: 3, right: 8 },
      gap: 5
    }, attr), setter, getter);

    this.stickTick = new draw2d.shape.basic.Circle({
      diameter: 10,
      bgColor: "#f0f0f0",
      stroke: 1,
      resizeable: false
    });
    this.add(this.stickTick);
    this.stickTick.hitTest = function () {
      return false;
    };
    this.stickTick.addCssClass("cursorPointer");

    this.label = new draw2d.shape.basic.Label({
      text: attr.text,
      resizeable: false,
      stroke: 0,
      padding: 0,
      fontSize: 10,
      fontColor: "#303030"
    });
    this.add(this.label);
    // don't catch the mouse events. This is done by the parent container
    this.label.hitTest = function () {
      return false;
    };
    this.label.addCssClass("cursorPointer");

    // we must override the hitTest method to ensure that the parent can receive the mouseenter/mouseleave events.
    // Unfortunately draw2D didn't provide event bubbling like HTML. The first shape in queue consumes the event.
    //
    // now this shape is "dead" for any mouse events and the parent must/can handle this.
    this.hitTest = function () {
      return false;
    };
  },

  setText: function setText(text) {
    this.label.setText(text);
  },

  setTick: function setTick(flag) {
    this.stickTick.attr({ bgColor: flag ? "#00bcd4" : "#f0f0f0" });
  },

  getStickTickFigure: function getStickTickFigure() {
    return this.stickTick;
  },

  getLabelFigure: function getLabelFigure() {
    return this.label;
  },

  /**
   * @method
   *
   *
   * @template
   **/
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    attributes = attributes || {};

    attributes.path = this.calculatePath();

    this._super(attributes);
  },

  /**
   * @method
   *
   * Override the default rendering of the HorizontalLayout, which is a simple
   * rectangle. We want an arrow.
   */
  createShapeElement: function createShapeElement() {
    return this.canvas.paper.path(this.calculatePath());
  },

  /**
   * stupid copy&paste the code from the Polygon shape...unfortunately the LayoutFigure isn't a polygon.
   *
   * @returns {string}
   */
  calculatePath: function calculatePath() {
    var arrowLength = 8;

    this.vertices = new draw2d.util.ArrayList();

    var w = this.width;
    var h = this.height;
    var pos = this.getAbsolutePosition();
    var i = 0;
    var length = 0;
    this.vertices.add(new draw2d.geo.Point(pos.x, pos.y));
    this.vertices.add(new draw2d.geo.Point(pos.x + w - arrowLength, pos.y));

    this.vertices.add(new draw2d.geo.Point(pos.x + w, pos.y + h / 2));

    this.vertices.add(new draw2d.geo.Point(pos.x + w - arrowLength, pos.y + h));
    this.vertices.add(new draw2d.geo.Point(pos.x, pos.y + h));

    var radius = this.getRadius();
    var path = [];
    // hard corners
    //
    if (radius === 0) {
      length = this.vertices.getSize();
      var p = this.vertices.get(0);
      path.push("M", (p.x | 0) + 0.5, " ", (p.y | 0) + 0.5);
      for (i = 1; i < length; i++) {
        p = this.vertices.get(i);
        path.push("L", (p.x | 0) + 0.5, " ", (p.y | 0) + 0.5);
      }
      path.push("Z");
    }
    // soften/round corners
    //
    else {
        length = this.vertices.getSize();
        var start = this.vertices.first();
        var end = this.vertices.last();
        if (start.equals(end)) {
          length = length - 1;
          end = this.vertices.get(length - 1);
        }
        var begin = draw2d.geo.Util.insetPoint(start, end, radius);
        path.push("M", (begin.x | 0) + 0.5, ",", (begin.y | 0) + 0.5);
        for (i = 0; i < length; i++) {
          start = this.vertices.get(i);
          end = this.vertices.get((i + 1) % length);
          var modStart = draw2d.geo.Util.insetPoint(start, end, radius);
          var modEnd = draw2d.geo.Util.insetPoint(end, start, radius);
          path.push("Q", start.x, ",", start.y, " ", (modStart.x | 0) + 0.5, ", ", (modStart.y | 0) + 0.5);
          path.push("L", (modEnd.x | 0) + 0.5, ",", (modEnd.y | 0) + 0.5);
        }
      }
    return path.join("");
  }

});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/figure/PolyCircle.js":
/*!*******************************************************!*\
  !*** ./app/frontend/designer/js/figure/PolyCircle.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = shape_designer.figure.PolyCircle = draw2d.shape.basic.Oval.extend({

  NAME: "shape_designer.figure.PolyCircle",

  init: function init(center, radius) {
    this.blur = 0;
    this.isExtFigure = true;

    // set some good defaults
    if (typeof radius === "undefined") {
      radius = 10;
    }

    this._super({ stroke: 0, bgColor: "95C06A", width: radius * 2, height: radius * 2 });

    // center must be set after the width/height...bug
    if (typeof center !== "undefined") {
      this.setCenter(center);
    }

    this.setUserData({ name: "Circle" });

    this.filters = new draw2d.util.ArrayList();
    this.filters.add(new shape_designer.filter.PositionFilter());
    this.filters.add(new shape_designer.filter.SizeFilter());
    this.filters.add(new shape_designer.filter.FillColorFilter());
  },

  getPotentialFilters: function getPotentialFilters() {
    return [{ label: "Stroke", impl: "shape_designer.filter.StrokeFilter" }, { label: "Opacity", impl: "shape_designer.filter.OpacityFilter" }, { label: "Blur", impl: "shape_designer.filter.BlurFilter" }, { label: "Linear Gradient", impl: "shape_designer.filter.LinearGradientFilter" }, { label: "Fill Color", impl: "shape_designer.filter.FillColorFilter" }];
  },

  removeFilter: function removeFilter(filter) {
    this.filters.remove(filter);
  },

  addFilter: function addFilter(filter) {
    var alreadyIn = false;

    this.filters.each($.proxy(function (i, e) {
      alreadyIn = alreadyIn || e.NAME === filter.NAME;
    }, this));

    if (alreadyIn === true) {
      return; // silently
    }

    this.filters.add(filter);
    filter.onInstall(this);
    this.repaint();
  },

  setBlur: function setBlur(value) {
    this.blur = parseInt(value);
    this.repaint();
  },

  getBlur: function getBlur() {
    return this.blur;
  },

  /**
   * @method
   * Trigger the repaint of the element.
   *
   */
  repaint: function repaint(attributes) {
    if (this.shape === null) {
      return;
    }

    this.filters.each($.proxy(function (i, filter) {
      filter.apply(this, attributes);
    }, this));

    //        this.shape.blur(this.blur);
    this._super(attributes);
  },

  getVertices: function getVertices() {

    var w2 = this.getWidth() / 2;
    var h2 = this.getHeight() / 2;
    var center = this.getCenter();
    var sides = 36;

    var vertices = new draw2d.util.ArrayList();
    for (var i = 0; i < sides; i++) {
      var radian = 2 * Math.PI * i / sides;
      var x = Math.cos(radian) * w2 + center.x;
      var y = Math.sin(radian) * h2 + center.y;
      vertices.add(new draw2d.geo.Point(x, y));
    }
    return vertices;
  },

  getPersistentAttributes: function getPersistentAttributes() {
    var memento = this._super();

    memento.blur = this.blur;
    memento.filters = [];
    this.filters.each($.proxy(function (i, e) {
      var filterMemento = e.getPersistentAttributes(this);
      memento.filters.push(filterMemento);
    }, this));

    return memento;
  },

  setPersistentAttributes: function setPersistentAttributes(memento) {
    this._super(memento);

    if (typeof memento.blur !== "undefined") this.setBlur(memento.blur);

    if (typeof memento.filters !== "undefined") {
      this.filters = new draw2d.util.ArrayList();
      $.each(memento.filters, $.proxy(function (i, e) {
        var filter = eval("new " + e.name + "()");
        filter.setPersistentAttributes(this, e);
        this.filters.add(filter);
      }, this));
    }
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/figure/PolyRect.js":
/*!*****************************************************!*\
  !*** ./app/frontend/designer/js/figure/PolyRect.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ExtPolygon = __webpack_require__(/*! ./ExtPolygon */ "./app/frontend/designer/js/figure/ExtPolygon.js");

var _ExtPolygon2 = _interopRequireDefault(_ExtPolygon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = shape_designer.figure.PolyRect = _ExtPolygon2.default.extend({

  NAME: "shape_designer.figure.PolyRect",

  init: function init(topLeft, bottomRight) {
    this._super();
    if (typeof topLeft === "undefined") {
      this.vertices = new draw2d.util.ArrayList();
      this.addVertex(new draw2d.geo.Point(100, 100));
      this.addVertex(new draw2d.geo.Point(140, 100));
      this.addVertex(new draw2d.geo.Point(140, 140));
      this.addVertex(new draw2d.geo.Point(100, 140));
    } else {
      this.vertices = new draw2d.util.ArrayList();
      this.addVertex(new draw2d.geo.Point(topLeft.x, topLeft.y));
      this.addVertex(new draw2d.geo.Point(bottomRight.x, topLeft.y));
      this.addVertex(new draw2d.geo.Point(bottomRight.x, bottomRight.y));
      this.addVertex(new draw2d.geo.Point(topLeft.x, bottomRight.y));
    }

    this.setUserData({ name: "Rectangle" });
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/figure/TestSwitch.js":
/*!*******************************************************!*\
  !*** ./app/frontend/designer/js/figure/TestSwitch.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = shape_designer.figure.TestSwitch = draw2d.shape.basic.Label.extend({

  NAME: "shape_designer.figure.TestSwitch",

  init: function init(attr, setter, getter) {
    this._super({ text: "Low" }, setter, getter);

    this.createPort("output");

    var _this = this;

    this.value = false;
    this.on("click", function () {
      _this.toggleValue();
      _this.getOutputPort(0).setValue(_this.value);
      _this.getOutputPort(0).getConnections().each(function (i, c) {
        c.getTarget().setValue(_this.value);
      });
    });
  },

  toggleValue: function toggleValue() {
    this.value = !this.value;
    this.attr({ text: this.value ? "High" : "Low" });
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/figure/index.js":
/*!**************************************************!*\
  !*** ./app/frontend/designer/js/figure/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// required to register them for JSON serialize/deserialize
//
exports.default = [__webpack_require__(/*! ./ExtLabel */ "./app/frontend/designer/js/figure/ExtLabel.js"), __webpack_require__(/*! ./DecoratedInputPort */ "./app/frontend/designer/js/figure/DecoratedInputPort.js"), __webpack_require__(/*! ./ExtLine */ "./app/frontend/designer/js/figure/ExtLine.js"), __webpack_require__(/*! ./ExtPolygon */ "./app/frontend/designer/js/figure/ExtPolygon.js"), __webpack_require__(/*! ./ExtPort */ "./app/frontend/designer/js/figure/ExtPort.js"), __webpack_require__(/*! ./MarkerFigure */ "./app/frontend/designer/js/figure/MarkerFigure.js"), __webpack_require__(/*! ./MarkerStateAFigure */ "./app/frontend/designer/js/figure/MarkerStateAFigure.js"), __webpack_require__(/*! ./MarkerStateBFigure */ "./app/frontend/designer/js/figure/MarkerStateBFigure.js"), __webpack_require__(/*! ./PolyCircle */ "./app/frontend/designer/js/figure/PolyCircle.js"), __webpack_require__(/*! ./PolyRect */ "./app/frontend/designer/js/figure/PolyRect.js"), __webpack_require__(/*! ./TestSwitch */ "./app/frontend/designer/js/figure/TestSwitch.js")];
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/filter/BlurFilter.js":
/*!*******************************************************!*\
  !*** ./app/frontend/designer/js/filter/BlurFilter.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Filter2 = __webpack_require__(/*! ./Filter */ "./app/frontend/designer/js/filter/Filter.js");

var _Filter3 = _interopRequireDefault(_Filter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = shape_designer.filter.BlurFilter = function (_Filter) {
  _inherits(BlurFilter, _Filter);

  function BlurFilter() {
    _classCallCheck(this, BlurFilter);

    return _possibleConstructorReturn(this, (BlurFilter.__proto__ || Object.getPrototypeOf(BlurFilter)).call(this, "shape_designer.filter.BlurFilter"));
  }

  _createClass(BlurFilter, [{
    key: "insertPane",
    value: function insertPane(figure, $parent) {
      $parent.append('<div id="' + this.containerId + '" class="panel panel-default">' + ' <div class="panel-heading filter-heading" data-toggle="collapse" data-target="#' + this.cssScope + '_width_panel">' + '     Blur' + '    <span id="button_remove_' + this.cssScope + '"><img class="svg icon pull-right" src="./images/dialog_close.svg"/></span></span>' + '</div>' + ' <div class="panel-body collapse in" id="' + this.cssScope + '_blur_panel">' + '   <div class="form-group">' + '      <div class="input-group" ></div> ' + // required to ensure the correct width of the siblings
      '       <input id="filter_blur" type="text" value="' + figure.getBlur() + '"  name="filter_blur" class="mousetrap-pause form-control" />' + '   </div>' + ' </div>' + '</div>');
      inlineSVG.init({ svgSelector: "#" + this.containerId + " img.svg" });

      $("#filter_blur").TouchSpin({
        min: 0,
        max: 5,
        step: 1
      });

      $("#filter_blur").on("change", $.proxy(function () {
        this.setBlur(parseInt($("#filter_blur").val()));
      }, figure));

      $("#button_remove_" + this.cssScope).on("click", $.proxy(function () {
        figure.removeFilter(this);
        figure.setBlur(0);
        $('#' + this.containerId).animate({
          "height": "0",
          "opacity": 0,
          "margin-bottom": 0
        }, 500, function () {
          $('#' + this.containerId).remove();
        });
      }, this));
    }
  }]);

  return BlurFilter;
}(_Filter3.default);

module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/filter/FanoutFilter.js":
/*!*********************************************************!*\
  !*** ./app/frontend/designer/js/filter/FanoutFilter.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Filter2 = __webpack_require__(/*! ./Filter */ "./app/frontend/designer/js/filter/Filter.js");

var _Filter3 = _interopRequireDefault(_Filter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = shape_designer.filter.FanoutFilter = function (_Filter) {
  _inherits(FanoutFilter, _Filter);

  function FanoutFilter() {
    _classCallCheck(this, FanoutFilter);

    return _possibleConstructorReturn(this, (FanoutFilter.__proto__ || Object.getPrototypeOf(FanoutFilter)).call(this, "shape_designer.filter.FanoutFilter"));
  }

  _createClass(FanoutFilter, [{
    key: "insertPane",
    value: function insertPane(figure, $parent) {
      $parent.append('<div id="' + this.containerId + '" class="panel panel-default">' + ' <div class="panel-heading filter-heading" data-toggle="collapse" data-target="#' + this.cssScope + '_width_panel">' + '     Maximal fan out' + '</div>' + ' <div class="panel-body collapse in" id="' + this.cssScope + '_width_panel">' + '   <div class="form-group">' + '      <div class="input-group" ></div> ' + // required to ensure the correct width of the siblings
      '       <input id="filter_' + this.cssScope + '_fanout" type="text" value="' + figure.getMaxFanOut() + '" name="filter_' + this.cssScope + '_fanout" class="mousetrap-pause form-control" />' + '   </div>' + ' </div>' + '</div>');
      inlineSVG.init({ svgSelector: "#" + this.containerId + " img.svg" });

      $("input[name='filter_" + this.cssScope + "_fanout']").TouchSpin({
        min: 0,
        max: 50,
        step: 1,
        maxboostedstep: 1,
        postfix: 'px'
      });
      $("input[name='filter_" + this.cssScope + "_fanout']").on("change", $.proxy(function () {
        this.setMaxFanOut(parseInt($("input[name='filter_" + this.cssScope + "_fanout']").val()));
      }, figure));
    }
  }, {
    key: "removePane",
    value: function removePane() {}
  }, {
    key: "onInstall",
    value: function onInstall(figure) {}
  }]);

  return FanoutFilter;
}(_Filter3.default);

module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/filter/FillColorFilter.js":
/*!************************************************************!*\
  !*** ./app/frontend/designer/js/filter/FillColorFilter.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Filter2 = __webpack_require__(/*! ./Filter */ "./app/frontend/designer/js/filter/Filter.js");

var _Filter3 = _interopRequireDefault(_Filter2);

var _jscolor = __webpack_require__(/*! ../widget/jscolor/jscolor */ "./app/frontend/designer/js/widget/jscolor/jscolor.js");

var _jscolor2 = _interopRequireDefault(_jscolor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = shape_designer.filter.FillColorFilter = function (_Filter) {
  _inherits(FillColorFilter, _Filter);

  function FillColorFilter() {
    _classCallCheck(this, FillColorFilter);

    var _this = _possibleConstructorReturn(this, (FillColorFilter.__proto__ || Object.getPrototypeOf(FillColorFilter)).call(this, "shape_designer.filter.FillColorFilter"));

    _this.colorPicker = null;
    return _this;
  }

  _createClass(FillColorFilter, [{
    key: "insertPane",
    value: function insertPane(figure, $parent) {

      $parent.append('<div id="' + this.containerId + '" class="panel panel-default">' + ' <div class="panel-heading filter-heading" data-toggle="collapse" data-target="#color_fill_panel">' + '    Color Fill' + '    <span id="button_remove_FillColorFilter"><img class="svg icon pull-right" src="./images/dialog_close.svg"/><span>' + ' </div>' + ' <div class="panel-body collapse in" id="color_fill_panel">' + '   <div class="form-group">' + '      <div class="input-group" ></div> ' + // required to ensure the correct width of the siblings
      '      <div class="input-group">' + '          <span class="input-group-addon">#</span>' + '          <input id="filter_color_fill" type="text" value="" name="filter_color_fill" class="mousetrap-pause form-control color"/>' + '       </div>' + '    </div>' + ' </div>' + '</div>');
      inlineSVG.init({ svgSelector: "#" + this.containerId + " img.svg" });

      var picker = this.colorPicker = new _jscolor2.default.color(document.getElementById('filter_color_fill'), {});
      this.colorPicker.fromString(figure.getBackgroundColor().hash());
      this.colorPicker.onImmediateChange = $.proxy(function () {
        this.setBackgroundColor("#" + picker.toString());
      }, figure);

      $("#button_remove_FillColorFilter").on("click", $.proxy(function () {
        figure.removeFilter(this);
        figure.setBackgroundColor(null);
        $("#" + this.containerId).animate({ "height": "0", "opacity": 0, "margin-bottom": 0 }, 500, function () {
          $('#' + this.containerId).remove();
        });
      }, this));
    }
  }, {
    key: "onInstall",
    value: function onInstall(figure) {
      figure.setBackgroundColor("#f0f3f3");
    }
  }, {
    key: "removePane",
    value: function removePane() {
      if (this.colorPicker !== null) {
        this.colorPicker.hidePicker();
      }
    }
  }]);

  return FillColorFilter;
}(_Filter3.default);

module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/filter/Filter.js":
/*!***************************************************!*\
  !*** ./app/frontend/designer/js/filter/Filter.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Filter = function () {
  function Filter(name) {
    _classCallCheck(this, Filter);

    this.NAME = name;
    this.colorPicker = null;
    this.cssScope = this.NAME.replace(/[.]/g, "_");
    this.containerId = this.cssScope + "_container";
  }

  /**
   * @method
   * Sent when an event occurs on the command stack. draw2d.command.CommandStackEvent.getDetail()
   * can be used to identify the type of event which has occurred.
   *
   * @template
   *
   **/


  _createClass(Filter, [{
    key: "apply",
    value: function apply(figure, attributes) {}
  }, {
    key: "onInstall",
    value: function onInstall(figure) {}
  }, {
    key: "insertPane",
    value: function insertPane(figure, $parent) {}
  }, {
    key: "removePane",
    value: function removePane() {}
  }, {
    key: "getPersistentAttributes",
    value: function getPersistentAttributes(relatedFigure) {
      var memento = {};
      memento.name = this.NAME;

      return memento;
    }
  }, {
    key: "setPersistentAttributes",
    value: function setPersistentAttributes(relatedFigure, memento) {}
  }]);

  return Filter;
}();

exports.default = Filter;
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/filter/FontColorFilter.js":
/*!************************************************************!*\
  !*** ./app/frontend/designer/js/filter/FontColorFilter.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jscolor = __webpack_require__(/*! ../widget/jscolor/jscolor */ "./app/frontend/designer/js/widget/jscolor/jscolor.js");

var _jscolor2 = _interopRequireDefault(_jscolor);

var _Filter2 = __webpack_require__(/*! ./Filter */ "./app/frontend/designer/js/filter/Filter.js");

var _Filter3 = _interopRequireDefault(_Filter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = shape_designer.filter.FontColorFilter = function (_Filter) {
  _inherits(FontColorFilter, _Filter);

  function FontColorFilter() {
    _classCallCheck(this, FontColorFilter);

    var _this = _possibleConstructorReturn(this, (FontColorFilter.__proto__ || Object.getPrototypeOf(FontColorFilter)).call(this, "shape_designer.filter.FontColorFilter"));

    _this.colorPicker = null;
    return _this;
  }

  _createClass(FontColorFilter, [{
    key: "insertPane",
    value: function insertPane(figure, $parent) {
      var _this2 = this;

      $parent.append('<div id="' + this.containerId + '" class="panel panel-default">' + ' <div class="panel-heading filter-heading" data-toggle="collapse" data-target="#color_fill_panel">' + '    Font Color' + '    <span id="button_remove_FillColorFilter"><img class="svg icon pull-right" src="./images/dialog_close.svg"/></span>' + ' </div>' + ' <div class="panel-body collapse in" id="color_fill_panel">' + '   <div class="form-group">' + '      <div class="input-group" ></div> ' + // required to ensure the correct width of the siblings
      '      <div class="input-group">' + '          <span class="input-group-addon">#</span>' + '          <input id="filter_color_fill" type="text" value="" name="filter_color_fill" class="mousetrap-pause form-control color"/>' + '       </div>' + '    </div>' + ' </div>' + '</div>');
      inlineSVG.init({ svgSelector: "#" + this.containerId + " img.svg" });

      var picker = this.colorPicker = new _jscolor2.default.color(document.getElementById('filter_color_fill'), {});
      this.colorPicker.fromString(figure.getFontColor().hash());
      this.colorPicker.onImmediateChange = $.proxy(function () {
        this.setFontColor("#" + picker.toString());
      }, figure);

      $("#button_remove_FillColorFilter").on("click", function () {
        figure.removeFilter(_this2);
        figure.setFontColor(null);
        $("#" + _this2.containerId).animate({ "height": "0", "opacity": 0, "margin-bottom": 0 }, 500, function () {
          $('#' + _this2.containerId).remove();
        });
      });
    }
  }, {
    key: "onInstall",
    value: function onInstall(figure) {
      figure.setFontColor("#000000");
    }
  }, {
    key: "removePane",
    value: function removePane() {
      if (this.colorPicker !== null) {
        this.colorPicker.hidePicker();
      }
    }
  }]);

  return FontColorFilter;
}(_Filter3.default);

module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/filter/FontSizeFilter.js":
/*!***********************************************************!*\
  !*** ./app/frontend/designer/js/filter/FontSizeFilter.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Filter2 = __webpack_require__(/*! ./Filter */ "./app/frontend/designer/js/filter/Filter.js");

var _Filter3 = _interopRequireDefault(_Filter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = shape_designer.filter.FontSizeFilter = function (_Filter) {
  _inherits(FontSizeFilter, _Filter);

  function FontSizeFilter() {
    _classCallCheck(this, FontSizeFilter);

    return _possibleConstructorReturn(this, (FontSizeFilter.__proto__ || Object.getPrototypeOf(FontSizeFilter)).call(this, "shape_designer.filter.FontSizeFilter"));
  }

  _createClass(FontSizeFilter, [{
    key: "insertPane",
    value: function insertPane(figure, $parent) {
      var _this2 = this;

      $parent.append('<div id="' + this.containerId + '" class="panel panel-default">' + ' <div class="panel-heading filter-heading" data-toggle="collapse" data-target="#fontsize_width_panel">' + '     Font Size' + '    <span id="button_remove_FontSizeFilter"><img  class="svg icon pull-right" src="./images/dialog_close.svg"/></span>' + '</div>' + ' <div class="panel-body collapse in" id="fontsize_width_panel">' + '   <div class="form-group">' + '      <div class="input-group" ></div> ' + // required to ensure the correct width of the siblings
      '       <input id="filter_fontsize" type="text" value="' + figure.getFontSize() + '" name="filter_fontsize" class="mousetrap-pause form-control" />' + '   </div>' + ' </div>' + '</div>');
      inlineSVG.init({ svgSelector: "#" + this.containerId + " img.svg" });

      $("#filter_fontsize").TouchSpin({
        min: 4,
        max: 300,
        step: 1,
        boostat: figure.getFontSize(),
        maxboostedstep: 10,
        postfix: 'px'
      });

      $("input[name='filter_fontsize']").on("change", $.proxy(function () {
        this.setFontSize(parseInt($("input[name='filter_fontsize']").val()));
      }, figure));

      $("#button_remove_FontSizeFilter").on("click", function () {
        figure.removeFilter(_this2);
        figure.setFontSize(12);
        $("#" + _this2.containerId).animate({ "height": "0", "opacity": 0, "margin-bottom": 0 }, 500, function () {
          $('#' + _this2.containerId).remove();
        });
      });
    }
  }, {
    key: "removePane",
    value: function removePane() {}
  }, {
    key: "onInstall",
    value: function onInstall(figure) {
      //   figure.setFontSize(1);
    }
  }]);

  return FontSizeFilter;
}(_Filter3.default);

module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/filter/LinearGradientFilter.js":
/*!*****************************************************************!*\
  !*** ./app/frontend/designer/js/filter/LinearGradientFilter.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _jscolor = __webpack_require__(/*! ../widget/jscolor/jscolor */ "./app/frontend/designer/js/widget/jscolor/jscolor.js");

var _jscolor2 = _interopRequireDefault(_jscolor);

var _Filter2 = __webpack_require__(/*! ./Filter */ "./app/frontend/designer/js/filter/Filter.js");

var _Filter3 = _interopRequireDefault(_Filter2);

__webpack_require__(/*! ../widget/ui.anglepicker */ "./app/frontend/designer/js/widget/ui.anglepicker.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = shape_designer.filter.LinearGradientFilter = function (_Filter) {
  _inherits(LinearGradientFilter, _Filter);

  function LinearGradientFilter() {
    _classCallCheck(this, LinearGradientFilter);

    var _this = _possibleConstructorReturn(this, (LinearGradientFilter.__proto__ || Object.getPrototypeOf(LinearGradientFilter)).call(this, "shape_designer.filter.LinearGradientFilter"));

    _this.colorPicker1 = null;
    _this.colorPicker2 = null;

    _this.startColor = "#f0f0f0";
    _this.endColor = "#3f3f3f";
    _this.angle = 0;
    return _this;
  }

  _createClass(LinearGradientFilter, [{
    key: "insertPane",
    value: function insertPane(figure, $parent) {
      var _this2 = this;

      $parent.append('<div id="' + this.containerId + '" class="panel panel-default">' + ' <div class="panel-heading filter-heading" data-toggle="collapse" data-target="#' + this.cssScope + '_panel">' + '     Linear Gradient' + '    <span id="button_remove_' + this.cssScope + '"><img  class="svg icon pull-right" src="./images/dialog_close.svg"/></span>' + '</div>' + ' <div class="panel-body collapse in" id="' + this.cssScope + '_panel">' + '   <div class="form-group">' + '      <div class="input-group" ></div> ' + // required to ensure the correct width of the siblings
      '      <div class="input-group text-center" style="width:100%" >' + '           <div id="' + this.cssScope + '_angle" />' + '      </div> ' + '       <div class="input-group">' + '          <span class="input-group-addon">#</span>' + '          <input id="' + this.cssScope + '_color1" type="text" value="' + this.startColor + '" class="mousetrap-pause form-control color"/>' + '       </div>' + '       <div class="input-group">' + '          <span class="input-group-addon">#</span>' + '          <input id="' + this.cssScope + '_color2" type="text" value="' + this.endColor + '" class="mousetrap-pause form-control color"/>' + '       </div>' + '   </div>' + ' </div>' + '</div>');
      inlineSVG.init({ svgSelector: "#" + this.containerId + " img.svg" });

      $('#' + this.cssScope + '_angle').anglepicker({
        start: function start(e, ui) {},
        change: function change(e, ui) {
          _this2.angle = ui.value;
          figure.repaint();
        },
        stop: function stop(e, ui) {},
        value: this.angle
      });

      var picker1 = this.colorPicker1 = new _jscolor2.default.color($("#" + this.cssScope + '_color1')[0], {});
      this.colorPicker1.fromString(this.startColor);
      this.colorPicker1.onImmediateChange = function () {
        _this2.startColor = "#" + picker1.toString();
        figure.repaint();
      };

      var picker2 = this.colorPicker2 = new _jscolor2.default.color($("#" + this.cssScope + '_color2')[0], {});
      this.colorPicker2.fromString(this.endColor);
      this.colorPicker2.onImmediateChange = function () {
        _this2.endColor = "#" + picker2.toString();
        figure.repaint();
      };

      $("#button_remove_" + this.cssScope).on("click", function () {
        figure.removeFilter(_this2);
        $('#' + _this2.containerId).animate({
          "height": "0",
          "opacity": 0,
          "margin-bottom": 0
        }, 500, function () {
          $('#' + _this2.containerId).remove();
        });
      });
    }
  }, {
    key: "apply",
    value: function apply(figure, attributes) {
      attributes.fill = this.angle + "-" + this.endColor + "-" + this.startColor;
    }
  }, {
    key: "removePane",
    value: function removePane() {
      if (this.colorPicker1 !== null) {
        this.colorPicker1.hidePicker();
      }
      if (this.colorPicker2 !== null) {
        this.colorPicker2.hidePicker();
      }
    }
  }, {
    key: "onInstall",
    value: function onInstall(figure) {
      figure.setStroke(1);
    }
  }, {
    key: "getPersistentAttributes",
    value: function getPersistentAttributes(relatedFigure) {
      var memento = _get(LinearGradientFilter.prototype.__proto__ || Object.getPrototypeOf(LinearGradientFilter.prototype), "getPersistentAttributes", this).call(this, relatedFigure);

      memento.startColor = this.startColor;
      memento.endColor = this.endColor;
      memento.angle = this.angle;

      return memento;
    }
  }, {
    key: "setPersistentAttributes",
    value: function setPersistentAttributes(relatedFigure, memento) {
      _get(LinearGradientFilter.prototype.__proto__ || Object.getPrototypeOf(LinearGradientFilter.prototype), "setPersistentAttributes", this).call(this, relatedFigure, memento);

      this.startColor = memento.startColor;
      this.endColor = memento.endColor;
      this.angle = memento.angle;

      return memento;
    }
  }]);

  return LinearGradientFilter;
}(_Filter3.default);

module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/filter/OpacityFilter.js":
/*!**********************************************************!*\
  !*** ./app/frontend/designer/js/filter/OpacityFilter.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Filter2 = __webpack_require__(/*! ./Filter */ "./app/frontend/designer/js/filter/Filter.js");

var _Filter3 = _interopRequireDefault(_Filter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = shape_designer.filter.OpacityFilter = function (_Filter) {
  _inherits(OpacityFilter, _Filter);

  function OpacityFilter() {
    _classCallCheck(this, OpacityFilter);

    return _possibleConstructorReturn(this, (OpacityFilter.__proto__ || Object.getPrototypeOf(OpacityFilter)).call(this, "shape_designer.filter.OpacityFilter"));
  }

  _createClass(OpacityFilter, [{
    key: "insertPane",
    value: function insertPane(figure, $parent) {
      var _this2 = this;

      $parent.append('<div id="' + this.containerId + '" class="panel panel-default">' + ' <div class="panel-heading filter-heading" data-toggle="collapse" data-target="#opacity_panel">' + '    Opacity' + '    <span id="button_remove_OpacityFilter"><img  class="svg icon pull-right" src="./images/dialog_close.svg"/></span>' + '</div>' + ' <div class="panel-body collapse in" id="opacity_panel">' + '   <div class="form-group">' + '      <div class="input-group" ></div> ' + // required to ensure the correct width of the siblings
      '      <div class="input-group">' + '         <input class="mousetrap-pause form-control" id="filter_opacity" type="text" value="' + parseInt(figure.getAlpha() * 100) + '" />' + '      </div>' + '   </div>' + ' </div>' + '</div>');
      inlineSVG.init({ svgSelector: "#" + this.containerId + " img.svg" });

      $("#filter_opacity").TouchSpin({
        min: 0,
        max: 100,
        step: 5,
        boostat: parseInt(figure.getAlpha() * 100),
        maxboostedstep: 10,
        postfix: '%'
      });
      $("#filter_opacity").on("change", $.proxy(function () {
        this.setAlpha(parseInt($("#filter_opacity").val()) / 100.0);
      }, figure));

      $("#button_remove_OpacityFilter").on("click", function () {
        figure.removeFilter(_this2);
        figure.setAlpha(1);
        $("#" + _this2.containerId).animate({ "height": "0", "opacity": 0, "margin-bottom": 0 }, 500, function () {
          $('#' + _this2.containerId).remove();
        });
      });
    }
  }, {
    key: "removePane",
    value: function removePane() {}
  }]);

  return OpacityFilter;
}(_Filter3.default);

module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/filter/OutlineStrokeFilter.js":
/*!****************************************************************!*\
  !*** ./app/frontend/designer/js/filter/OutlineStrokeFilter.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jscolor = __webpack_require__(/*! ../widget/jscolor/jscolor */ "./app/frontend/designer/js/widget/jscolor/jscolor.js");

var _jscolor2 = _interopRequireDefault(_jscolor);

var _Filter2 = __webpack_require__(/*! ./Filter */ "./app/frontend/designer/js/filter/Filter.js");

var _Filter3 = _interopRequireDefault(_Filter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = shape_designer.filter.OutlineStrokeFilter = function (_Filter) {
  _inherits(OutlineStrokeFilter, _Filter);

  function OutlineStrokeFilter() {
    _classCallCheck(this, OutlineStrokeFilter);

    var _this = _possibleConstructorReturn(this, (OutlineStrokeFilter.__proto__ || Object.getPrototypeOf(OutlineStrokeFilter)).call(this, "shape_designer.filter.OutlineStrokeFilter"));

    _this.colorPicker = null;
    return _this;
  }

  _createClass(OutlineStrokeFilter, [{
    key: "insertPane",
    value: function insertPane(figure, $parent) {
      var _this2 = this;

      $parent.append('<div id="' + this.containerId + '" class="panel panel-default">' + ' <div class="panel-heading filter-heading" data-toggle="collapse" data-target="#outlinestroke_width_panel">' + '     Outline Stroke' + '    <img id="button_remove_OutlineStrokeFilter" class="icon pull-right" src="./images/dialog_close.svg"/>' + '</div>' + ' <div class="panel-body collapse in" id="outlinestroke_width_panel">' + '   <div class="form-group">' + '      <div class="input-group" ></div> ' + // required to ensure the correct width of the siblings
      '       <input id="filter_outlinestroke" type="text" value="' + figure.getOutlineStroke() + '" name="filter_outlinestroke" class="mousetrap-pause form-control" />' + '       <div class="input-group">' + '          <span class="input-group-addon">#</span>' + '          <input id="filter_outlinestroke_color" type="text" value="" name="outlinestroke-color" class="mousetrap-pause form-control color"/>' + '       </div>' + '   </div>' + ' </div>' + '</div>');

      inlineSVG.init({ svgSelector: "#" + this.containerId + " img.svg" });

      $("input[name='filter_outlinestroke']").TouchSpin({
        min: 0,
        max: 50,
        step: 1,
        boostat: figure.getOutlineStroke(),
        maxboostedstep: 10,
        postfix: 'px'
      }).on("change", $.proxy(function () {
        this.setOutlineStroke(parseFloat($("input[name='filter_outlinestroke']").val()));
      }, figure));

      var picker = this.colorPicker = new _jscolor2.default.color(document.getElementById('filter_outlinestroke_color'), {});
      this.colorPicker.fromString(figure.getOutlineColor().hash());
      this.colorPicker.onImmediateChange = $.proxy(function () {
        this.setOutlineColor("#" + picker.toString());
      }, figure);

      $("#button_remove_OutlineStrokeFilter").on("click", function () {
        figure.removeFilter(_this2);
        figure.setOutlineStroke(0);
        $("#" + _this2.containerId).animate({ "height": "0", "opacity": 0, "margin-bottom": 0 }, 500, function () {
          $('#' + _this2.containerId).remove();
        });
      });
    }
  }, {
    key: "removePane",
    value: function removePane() {
      if (this.colorPicker !== null) {
        this.colorPicker.hidePicker();
      }
    }
  }, {
    key: "onInstall",
    value: function onInstall(figure) {
      figure.setOutlineStroke(1);
      figure.setOutlineColor("#ff0000");
    }
  }]);

  return OutlineStrokeFilter;
}(_Filter3.default);

module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/filter/PortDirectionFilter.js":
/*!****************************************************************!*\
  !*** ./app/frontend/designer/js/filter/PortDirectionFilter.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Filter2 = __webpack_require__(/*! ./Filter */ "./app/frontend/designer/js/filter/Filter.js");

var _Filter3 = _interopRequireDefault(_Filter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = shape_designer.filter.PortDirectionFilter = function (_Filter) {
  _inherits(PortDirectionFilter, _Filter);

  function PortDirectionFilter() {
    _classCallCheck(this, PortDirectionFilter);

    return _possibleConstructorReturn(this, (PortDirectionFilter.__proto__ || Object.getPrototypeOf(PortDirectionFilter)).call(this, "shape_designer.filter.PortDirectionFilter"));
  }

  _createClass(PortDirectionFilter, [{
    key: "insertPane",
    value: function insertPane(figure, $parent) {
      var _this = this;
      var dir = figure.getConnectionDirection();
      $parent.append('<div id="' + this.containerId + '" class="panel panel-default">' + ' <div class="panel-heading filter-heading" data-toggle="collapse" data-target="#' + this.cssScope + '_panel">' + '     Connection Direction' + '</div>' + ' <div class="panel-body collapse in" id="' + this.cssScope + '_panel">' + '   <div class="form-group portDirectionOption">' + '      <div class="input-group" ></div> ' + // required to ensure the correct width of the siblings

      '<label>' + '  <input ' + (dir === 0 ? ' checked="checked"' : '') + ' type="radio" value="" name="' + this.cssScope + '_label" name="' + this.cssScope + '_label" data-dir="0" />' + '  <span  title="up" class="glyphicon glyphicon-arrow-up"></span>' + '</label>' + '<br>' + '<label>' + '  <input ' + (dir === 3 ? ' checked="checked"' : '') + 'type="radio" value="" name="' + this.cssScope + '_label" name="' + this.cssScope + '_label" data-dir="3" />' + '  <span  title="left" class="glyphicon glyphicon-arrow-left"></span>' + '</label>' + '<label>' + '  <input ' + (dir === null ? ' checked="checked"' : '') + 'type="radio" value="" name="' + this.cssScope + '_label" name="' + this.cssScope + '_label" data-dir="null" />' + '  <span title="automatic" class="glyphicon glyphicon-screenshot"></span>' + '</label>' + '<label>' + '  <input ' + (dir === 1 ? ' checked="checked"' : '') + 'type="radio" value="" name="' + this.cssScope + '_label" name="' + this.cssScope + '_label" data-dir="1" />' + '  <span title="right"  class="glyphicon glyphicon-arrow-right"></span>' + '</label>' + '<br>' + '<label>' + '  <input ' + (dir === 2 ? ' checked="checked"' : '') + 'type="radio" value="" name="' + this.cssScope + '_label" name="' + this.cssScope + '_label" data-dir="2" />' + '  <span  title="down" class="glyphicon glyphicon-arrow-down"></span>' + '</label>' + '       </div>' + '   </div>' + ' </div>' + '</div>');
      inlineSVG.init({ svgSelector: "#" + this.containerId + " img.svg" });

      $("#" + _this.cssScope + "_panel .portDirectionOption input").on("change", function (event) {
        figure.setConnectionDirection($(event.currentTarget).data("dir"));
      });
    }
  }, {
    key: "removePane",
    value: function removePane() {}
  }, {
    key: "onInstall",
    value: function onInstall(figure) {}
  }, {
    key: "getPersistentAttributes",
    value: function getPersistentAttributes(relatedFigure) {
      var memento = _get(PortDirectionFilter.prototype.__proto__ || Object.getPrototypeOf(PortDirectionFilter.prototype), "getPersistentAttributes", this).call(this, relatedFigure);

      return memento;
    }
  }, {
    key: "setPersistentAttributes",
    value: function setPersistentAttributes(relatedFigure, memento) {
      _get(PortDirectionFilter.prototype.__proto__ || Object.getPrototypeOf(PortDirectionFilter.prototype), "setPersistentAttributes", this).call(this, relatedFigure, memento);

      return memento;
    }
  }]);

  return PortDirectionFilter;
}(_Filter3.default);

module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/filter/PortTypeFilter.js":
/*!***********************************************************!*\
  !*** ./app/frontend/designer/js/filter/PortTypeFilter.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Filter2 = __webpack_require__(/*! ./Filter */ "./app/frontend/designer/js/filter/Filter.js");

var _Filter3 = _interopRequireDefault(_Filter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = shape_designer.filter.PortTypeFilter = function (_Filter) {
  _inherits(PortTypeFilter, _Filter);

  function PortTypeFilter() {
    _classCallCheck(this, PortTypeFilter);

    return _possibleConstructorReturn(this, (PortTypeFilter.__proto__ || Object.getPrototypeOf(PortTypeFilter)).call(this, "shape_designer.filter.PortTypeFilter"));
  }

  _createClass(PortTypeFilter, [{
    key: "insertPane",
    value: function insertPane(figure, $parent) {
      var _this = this;
      var type = figure.getInputType();
      $parent.append('<div id="' + this.containerId + '" class="panel panel-default">' + ' <div class="panel-heading filter-heading" data-toggle="collapse" data-target="#' + this.cssScope + '_panel">' + '     Port Type' + '</div>' + ' <div class="panel-body collapse in" id="' + this.cssScope + '_panel">' + '   <div class="form-group portTypeOption">' + '<label>' + '  <input ' + (type == 'Input' ? ' checked="checked"' : '') + 'type="radio" value="" name="' + this.cssScope + '_label" name="' + this.cssScope + '_label" data-type="Input" />' + '  <span  title="down" class="icon ion-log-in">input</span>' + '</label>' + '<br>' + '<label>' + '  <input ' + (type == 'Output' ? ' checked="checked"' : '') + 'type="radio" value="" name="' + this.cssScope + '_label" name="' + this.cssScope + '_label" data-type="Output" />' + '  <span  title="down" class="icon ion-log-out">output</span>' + '</label>' + '<br>' + '<label>' + '  <input ' + (type == 'Hybrid' ? ' checked="checked"' : '') + 'type="radio" value="" name="' + this.cssScope + '_label" name="' + this.cssScope + '_label" data-type="Hybrid" />' + '  <span  title="down" class="icon ion-ios-circle-outline">unspecified</span>' + '</label>' + '       </div>' + '   </div>' + ' </div>' + '</div>');
      inlineSVG.init({ svgSelector: "#" + this.containerId + " img.svg" });

      $("#" + _this.cssScope + "_panel .portTypeOption input").on("change", function (event) {
        figure.setInputType($(event.currentTarget).data("type"));
      });
    }
  }, {
    key: "removePane",
    value: function removePane() {}
  }, {
    key: "onInstall",
    value: function onInstall(figure) {}
  }, {
    key: "getPersistentAttributes",
    value: function getPersistentAttributes(relatedFigure) {
      var memento = _get(PortTypeFilter.prototype.__proto__ || Object.getPrototypeOf(PortTypeFilter.prototype), "getPersistentAttributes", this).call(this, relatedFigure);

      return memento;
    }
  }, {
    key: "setPersistentAttributes",
    value: function setPersistentAttributes(relatedFigure, memento) {
      _get(PortTypeFilter.prototype.__proto__ || Object.getPrototypeOf(PortTypeFilter.prototype), "setPersistentAttributes", this).call(this, relatedFigure, memento);

      return memento;
    }
  }]);

  return PortTypeFilter;
}(_Filter3.default);

module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/filter/PositionFilter.js":
/*!***********************************************************!*\
  !*** ./app/frontend/designer/js/filter/PositionFilter.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Filter2 = __webpack_require__(/*! ./Filter */ "./app/frontend/designer/js/filter/Filter.js");

var _Filter3 = _interopRequireDefault(_Filter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = shape_designer.filter.PositionFilter = function (_Filter) {
  _inherits(PositionFilter, _Filter);

  function PositionFilter() {
    _classCallCheck(this, PositionFilter);

    return _possibleConstructorReturn(this, (PositionFilter.__proto__ || Object.getPrototypeOf(PositionFilter)).call(this, "shape_designer.filter.PositionFilter"));
  }

  _createClass(PositionFilter, [{
    key: "insertPane",
    value: function insertPane(figure, $parent) {
      var _this2 = this;

      $parent.append('<div id="' + this.containerId + '" class="panel panel-default">' + ' <div class="panel-heading filter-heading" data-toggle="collapse" data-target="#position_width_panel">' + '     Position' + '</div>' + ' <div class="panel-body  collapse in" id="position_width_panel">' + '   <div class="form-group">' + '      <div class="input-group" ></div> ' + // required to ensure the correct width of the siblings
      '       <input id="filter_position_x" type="text" value="' + parseFloat(figure.getPosition().x) + '" name="filter_position_x" class="mousetrap-pause form-control" />' + '       <input id="filter_position_y" type="text" value="' + parseFloat(figure.getPosition().y) + '" name="filter_position_y" class="mousetrap-pause form-control" />' + '   </div>' + ' </div>' + '</div>');
      inlineSVG.init({ svgSelector: "#" + this.containerId + " img.svg" });

      $("#filter_position_x").TouchSpin({
        min: 0,
        max: 10000,
        step: 1,
        maxboostedstep: 10,
        postfix: 'X'
      });

      $("#filter_position_y").TouchSpin({
        min: 0,
        max: 10000,
        step: 1,
        maxboostedstep: 10,
        postfix: 'Y'
      });

      $("input[name='filter_position_x']").on("change", function () {
        try {
          _this2.block = true;
          var pos = figure.getPosition();
          figure.setPosition(parseFloat($("input[name='filter_position_x']").val()), pos.y);
        } finally {
          _this2.block = false;
        }
      });

      $("input[name='filter_position_y']").on("change", function () {
        try {
          _this2.block = true;
          var pos = figure.getPosition();
          figure.setPosition(pos.x, parseFloat($("input[name='filter_position_y']").val()));
        } finally {
          _this2.block = false;
        }
      });
    }
  }, {
    key: "apply",
    value: function apply(figure, attributes) {
      if (this.block === true) {
        return;
      }
      var pos = figure.getPosition();
      $("input[name='filter_position_y']").val(pos.y);
      $("input[name='filter_position_x']").val(pos.x);
    }
  }, {
    key: "removePane",
    value: function removePane() {}
  }, {
    key: "onInstall",
    value: function onInstall(figure) {}
  }]);

  return PositionFilter;
}(_Filter3.default);

module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/filter/RadiusFilter.js":
/*!*********************************************************!*\
  !*** ./app/frontend/designer/js/filter/RadiusFilter.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Filter2 = __webpack_require__(/*! ./Filter */ "./app/frontend/designer/js/filter/Filter.js");

var _Filter3 = _interopRequireDefault(_Filter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = shape_designer.filter.RadiusFilter = function (_Filter) {
  _inherits(RadiusFilter, _Filter);

  function RadiusFilter() {
    _classCallCheck(this, RadiusFilter);

    return _possibleConstructorReturn(this, (RadiusFilter.__proto__ || Object.getPrototypeOf(RadiusFilter)).call(this, "shape_designer.filter.RadiusFilter"));
  }

  _createClass(RadiusFilter, [{
    key: "insertPane",
    value: function insertPane(figure, $parent) {
      var _this2 = this;

      $parent.append('<div id="' + this.containerId + '" class="panel panel-default">' + ' <div class="panel-heading filter-heading" data-toggle="collapse" data-target="#radius_panel">' + '    Corner Radius' + '    <span id="button_remove_RadiusFilter"><img class="svg icon pull-right" src="./images/dialog_close.svg"/></span>' + '</div>' + ' <div class="panel-body collapse in" id="radius_panel">' + '   <div class="form-group">' + '      <div class="input-group" ></div> ' + // required to ensure the correct width of the siblings
      '      <div class="input-group">' + '         <input class="mousetrap-pause form-control" id="filter_radius" type="text" value="' + figure.getRadius() + '" />' + '      </div>' + '   </div>' + ' </div>' + '</div>');
      inlineSVG.init({ svgSelector: "#" + this.containerId + " img.svg" });

      $("#filter_radius").TouchSpin({
        min: 0,
        max: 200,
        step: 1,
        maxboostedstep: 10,
        postfix: 'px'
      });
      $("#filter_radius").on("change", $.proxy(function () {
        this.setRadius(parseInt($("#filter_radius").val()));
      }, figure));

      $("#button_remove_RadiusFilter").on("click", function () {
        figure.removeFilter(_this2);
        figure.setRadius(0);
        $("#" + _this2.containerId).animate({ "height": "0", "opacity": 0, "margin-bottom": 0 }, 500, function () {
          $('#' + _this2.containerId).remove();
        });
      });
    }
  }, {
    key: "removePane",
    value: function removePane() {}
  }]);

  return RadiusFilter;
}(_Filter3.default);

module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/filter/SizeFilter.js":
/*!*******************************************************!*\
  !*** ./app/frontend/designer/js/filter/SizeFilter.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Filter2 = __webpack_require__(/*! ./Filter */ "./app/frontend/designer/js/filter/Filter.js");

var _Filter3 = _interopRequireDefault(_Filter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = shape_designer.filter.SizeFilter = function (_Filter) {
  _inherits(SizeFilter, _Filter);

  function SizeFilter() {
    _classCallCheck(this, SizeFilter);

    return _possibleConstructorReturn(this, (SizeFilter.__proto__ || Object.getPrototypeOf(SizeFilter)).call(this, "shape_designer.filter.SizeFilter"));
  }

  _createClass(SizeFilter, [{
    key: "insertPane",
    value: function insertPane(figure, $parent) {
      var _this2 = this;

      $parent.append('<div id="' + this.containerId + '" class="panel panel-default">' + ' <div class="panel-heading filter-heading" data-toggle="collapse" data-target="#size_width_panel">' + '     Size' + ' </div>' + ' <div class="panel-body  collapse in" id="size_width_panel">' + '   <div class="form-group">' + '       <div class="input-group" ></div> ' + // required to ensure the correct width of the siblings
      '       <input id="filter_width"  type="text" value="' + figure.getWidth() + '"  name="filter_width"  class="mousetrap-pause form-control" />' + '       <input id="filter_height" type="text" value="' + figure.getHeight() + '" name="filter_height" class="mousetrap-pause form-control" />' + '   </div>' + ' </div>' + '</div>');
      inlineSVG.init({ svgSelector: "#" + this.containerId + " img.svg" });

      $("#filter_width").TouchSpin({
        min: 0,
        max: 600,
        step: 1,
        maxboostedstep: 10,
        postfix: 'width'
      });

      $("#filter_height").TouchSpin({
        min: 0,
        max: 600,
        step: 1,
        maxboostedstep: 10,
        postfix: 'height'
      });

      $("input[name='filter_width']").on("change", function () {
        try {
          _this2.block = true;
          figure.setWidth(parseInt($("input[name='filter_width']").val()));
        } finally {
          _this2.block = false;
        }
      });

      $("input[name='filter_height']").on("change", function () {
        try {
          _this2.block = true;
          figure.setHeight(parseInt($("input[name='filter_height']").val()));
        } finally {
          _this2.block = false;
        }
      });
    }
  }, {
    key: "apply",
    value: function apply(figure, attributes) {
      if (this.block === true) {
        return;
      }

      $("input[name='filter_width']").val(figure.getWidth());
      $("input[name='filter_height']").val(figure.getHeight());
    }
  }, {
    key: "removePane",
    value: function removePane() {}
  }, {
    key: "onInstall",
    value: function onInstall(figure) {}
  }]);

  return SizeFilter;
}(_Filter3.default);

module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/filter/StrokeFilter.js":
/*!*********************************************************!*\
  !*** ./app/frontend/designer/js/filter/StrokeFilter.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jscolor = __webpack_require__(/*! ../widget/jscolor/jscolor */ "./app/frontend/designer/js/widget/jscolor/jscolor.js");

var _jscolor2 = _interopRequireDefault(_jscolor);

var _Filter2 = __webpack_require__(/*! ./Filter */ "./app/frontend/designer/js/filter/Filter.js");

var _Filter3 = _interopRequireDefault(_Filter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = shape_designer.filter.StrokeFilter = function (_Filter) {
  _inherits(StrokeFilter, _Filter);

  function StrokeFilter() {
    _classCallCheck(this, StrokeFilter);

    return _possibleConstructorReturn(this, (StrokeFilter.__proto__ || Object.getPrototypeOf(StrokeFilter)).call(this, "shape_designer.filter.StrokeFilter"));
  }

  _createClass(StrokeFilter, [{
    key: "insertPane",
    value: function insertPane(figure, $parent) {
      var _this2 = this;

      $parent.append('<div id="' + this.containerId + '" class="panel panel-default">' + ' <div class="panel-heading filter-heading" data-toggle="collapse" data-target="#' + this.cssScope + '_width_panel">' + '     Stroke' + '    <span id="button_remove_' + this.cssScope + '"><img  class="svg icon pull-right" src="./images/dialog_close.svg"/></span>' + '</div>' + ' <div class="panel-body collapse in" id="' + this.cssScope + '_width_panel">' + '   <div class="form-group">' + '      <div class="input-group" ></div> ' + // required to ensure the correct width of the siblings
      '       <input id="filter_' + this.cssScope + '_width" type="text" value="' + figure.getStroke() + '" name="filter_' + this.cssScope + '_width" class="mousetrap-pause form-control" />' + '       <div class="input-group">' + '          <span class="input-group-addon">#</span>' + '          <input id="filter_' + this.cssScope + '_color" type="text" value="" name="stroke_' + this.cssScope + '_color" class="mousetrap-pause form-control color"/>' + '       </div>' + '   </div>' + ' </div>' + '</div>');
      inlineSVG.init({ svgSelector: "#" + this.containerId + " img.svg" });

      $("input[name='filter_" + this.cssScope + "_width']").TouchSpin({
        min: 0,
        max: 50,
        step: 1,
        maxboostedstep: 1,
        postfix: 'px'
      });
      $("input[name='filter_" + this.cssScope + "_width']").on("change", $.proxy(function () {
        this.setStroke(parseInt($("input[name='filter_" + this.cssScope + "_width']").val()));
      }, figure));

      var picker = this.colorPicker = new _jscolor2.default.color(document.getElementById('filter_' + this.cssScope + '_color'), {});
      this.colorPicker.fromString(figure.getColor().hash());
      this.colorPicker.onImmediateChange = $.proxy(function () {
        this.setColor("#" + picker.toString());
      }, figure);

      $("#button_remove_" + this.cssScope).on("click", function () {
        figure.removeFilter(_this2);
        figure.setStroke(0);
        $("#" + _this2.containerId).animate({ "height": "0", "opacity": 0, "margin-bottom": 0 }, 500, function () {
          $('#' + _this2.containerId).remove();
        });
      });
    }
  }, {
    key: "removePane",
    value: function removePane() {
      if (this.colorPicker !== null) {
        this.colorPicker.hidePicker();
      }
    }
  }, {
    key: "onInstall",
    value: function onInstall(figure) {
      figure.setStroke(1);
    }
  }]);

  return StrokeFilter;
}(_Filter3.default);

module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/filter/TextLinearGradientFilter.js":
/*!*********************************************************************!*\
  !*** ./app/frontend/designer/js/filter/TextLinearGradientFilter.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _jscolor = __webpack_require__(/*! ../widget/jscolor/jscolor */ "./app/frontend/designer/js/widget/jscolor/jscolor.js");

var _jscolor2 = _interopRequireDefault(_jscolor);

var _Filter2 = __webpack_require__(/*! ./Filter */ "./app/frontend/designer/js/filter/Filter.js");

var _Filter3 = _interopRequireDefault(_Filter2);

__webpack_require__(/*! ../widget/ui.anglepicker */ "./app/frontend/designer/js/widget/ui.anglepicker.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

exports.default = shape_designer.filter.TextLinearGradientFilter = function (_Filter) {
  _inherits(TextLinearGradientFilter, _Filter);

  function TextLinearGradientFilter() {
    _classCallCheck(this, TextLinearGradientFilter);

    var _this = _possibleConstructorReturn(this, (TextLinearGradientFilter.__proto__ || Object.getPrototypeOf(TextLinearGradientFilter)).call(this, "shape_designer.filter.TextLinearGradientFilter"));

    _this.colorPicker1 = null;
    _this.colorPicker2 = null;
    _this.startColor = "#f0f0f0";
    _this.endColor = "#3f3f3f";
    _this.angle = 0;
    return _this;
  }

  _createClass(TextLinearGradientFilter, [{
    key: "insertPane",
    value: function insertPane(figure, $parent) {
      var _this2 = this;

      $parent.append('<div id="' + this.containerId + '" class="panel panel-default">' + ' <div class="panel-heading filter-heading" data-toggle="collapse" data-target="#' + this.cssScope + '_panel">' + '     Linear Gradient' + '    <span id="button_remove_' + this.cssScope + '"><img  class="svg icon pull-right" src="./images/dialog_close.svg"/></span>' + '</div>' + ' <div class="panel-body collapse in" id="' + this.cssScope + '_panel">' + '   <div class="form-group">' + '      <div class="input-group" ></div> ' + // required to ensure the correct width of the siblings
      '      <div class="input-group text-center" style="width:100%" >' + '           <div id="' + this.cssScope + '_angle" />' + '      </div> ' + '       <div class="input-group">' + '          <span class="input-group-addon">#</span>' + '          <input id="' + this.cssScope + '_color1" type="text" value="' + this.startColor + '" class="mousetrap-pause form-control color"/>' + '       </div>' + '       <div class="input-group">' + '          <span class="input-group-addon">#</span>' + '          <input id="' + this.cssScope + '_color2" type="text" value="' + this.endColor + '" class="mousetrap-pause form-control color"/>' + '       </div>' + '   </div>' + ' </div>' + '</div>');
      inlineSVG.init({ svgSelector: "#" + this.containerId + " img.svg" });

      $('#' + this.cssScope + '_angle').anglepicker({
        start: function start(e, ui) {},
        change: function change(e, ui) {
          _this2.angle = ui.value;
          figure.repaint();
        },
        stop: function stop(e, ui) {},
        value: this.angle
      });

      var picker1 = this.colorPicker1 = new _jscolor2.default.color($("#" + this.cssScope + '_color1')[0], {});
      this.colorPicker1.fromString(this.startColor);
      this.colorPicker1.onImmediateChange = function () {
        _this2.startColor = "#" + picker1.toString();
        figure.repaint();
      };

      var picker2 = this.colorPicker2 = new _jscolor2.default.color($("#" + this.cssScope + '_color2')[0], {});
      this.colorPicker2.fromString(this.endColor);
      this.colorPicker2.onImmediateChange = function () {
        _this2.endColor = "#" + picker2.toString();
        figure.repaint();
      };

      $("#button_remove_" + this.cssScope).on("click", function () {
        figure.removeFilter(_this2);
        $('#' + _this2.containerId).animate({
          "height": "0",
          "opacity": 0,
          "margin-bottom": 0
        }, 500, function () {
          $('#' + _this2.containerId).remove();
        });
      });
    }
  }, {
    key: "apply",
    value: function apply(figure, attributes, lattr) {
      lattr.fill = this.angle + "-" + this.endColor + "-" + this.startColor;
    }
  }, {
    key: "removePane",
    value: function removePane() {
      if (this.colorPicker1 !== null) {
        this.colorPicker1.hidePicker();
      }
      if (this.colorPicker2 !== null) {
        this.colorPicker2.hidePicker();
      }
    }
  }, {
    key: "onInstall",
    value: function onInstall(figure) {}
  }, {
    key: "getPersistentAttributes",
    value: function getPersistentAttributes(relatedFigure) {
      var memento = _get(TextLinearGradientFilter.prototype.__proto__ || Object.getPrototypeOf(TextLinearGradientFilter.prototype), "getPersistentAttributes", this).call(this, relatedFigure);

      memento.startColor = this.startColor;
      memento.endColor = this.endColor;
      memento.angle = this.angle;

      return memento;
    }
  }, {
    key: "setPersistentAttributes",
    value: function setPersistentAttributes(relatedFigure, memento) {
      _get(TextLinearGradientFilter.prototype.__proto__ || Object.getPrototypeOf(TextLinearGradientFilter.prototype), "setPersistentAttributes", this).call(this, relatedFigure, memento);

      this.startColor = memento.startColor;
      this.endColor = memento.endColor;
      this.angle = memento.angle;

      return memento;
    }
  }]);

  return TextLinearGradientFilter;
}(_Filter3.default);

module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/filter/index.js":
/*!**************************************************!*\
  !*** ./app/frontend/designer/js/filter/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// required to register them for JSON serialize/deserialize
//
exports.default = [__webpack_require__(/*! ./BlurFilter */ "./app/frontend/designer/js/filter/BlurFilter.js"), __webpack_require__(/*! ./FanoutFilter */ "./app/frontend/designer/js/filter/FanoutFilter.js"), __webpack_require__(/*! ./FillColorFilter */ "./app/frontend/designer/js/filter/FillColorFilter.js"), __webpack_require__(/*! ./Filter */ "./app/frontend/designer/js/filter/Filter.js"), __webpack_require__(/*! ./FontColorFilter */ "./app/frontend/designer/js/filter/FontColorFilter.js"), __webpack_require__(/*! ./FontSizeFilter */ "./app/frontend/designer/js/filter/FontSizeFilter.js"), __webpack_require__(/*! ./LinearGradientFilter */ "./app/frontend/designer/js/filter/LinearGradientFilter.js"), __webpack_require__(/*! ./OpacityFilter */ "./app/frontend/designer/js/filter/OpacityFilter.js"), __webpack_require__(/*! ./OutlineStrokeFilter */ "./app/frontend/designer/js/filter/OutlineStrokeFilter.js"), __webpack_require__(/*! ./PortDirectionFilter */ "./app/frontend/designer/js/filter/PortDirectionFilter.js"), __webpack_require__(/*! ./PortTypeFilter */ "./app/frontend/designer/js/filter/PortTypeFilter.js"), __webpack_require__(/*! ./PositionFilter */ "./app/frontend/designer/js/filter/PositionFilter.js"), __webpack_require__(/*! ./RadiusFilter */ "./app/frontend/designer/js/filter/RadiusFilter.js"), __webpack_require__(/*! ./SizeFilter */ "./app/frontend/designer/js/filter/SizeFilter.js"), __webpack_require__(/*! ./StrokeFilter */ "./app/frontend/designer/js/filter/StrokeFilter.js"), __webpack_require__(/*! ./TextLinearGradientFilter */ "./app/frontend/designer/js/filter/TextLinearGradientFilter.js")];
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/global.js":
/*!********************************************!*\
  !*** ./app/frontend/designer/js/global.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _DecoratedInputPort = __webpack_require__(/*! ./figure/DecoratedInputPort */ "./app/frontend/designer/js/figure/DecoratedInputPort.js");

var _DecoratedInputPort2 = _interopRequireDefault(_DecoratedInputPort);

var _CircuitFigure = __webpack_require__(/*! ./figure/CircuitFigure */ "./app/frontend/designer/js/figure/CircuitFigure.js");

var _CircuitFigure2 = _interopRequireDefault(_CircuitFigure);

var _mousetrap = __webpack_require__(/*! mousetrap */ "./node_modules/mousetrap/mousetrap.js");

var _mousetrap2 = _interopRequireDefault(_mousetrap);

__webpack_require__(/*! ./util/mousetrap-global */ "./app/frontend/designer/js/util/mousetrap-global.js");

__webpack_require__(/*! ./util/mousetrap-pause */ "./app/frontend/designer/js/util/mousetrap-pause.js");

var _Hardware = __webpack_require__(/*! ./Hardware */ "./app/frontend/designer/js/Hardware.js");

var _Hardware2 = _interopRequireDefault(_Hardware);

var _inlineSVG = __webpack_require__(/*! ../lib/inlineSVG */ "./app/frontend/designer/lib/inlineSVG.js");

var _inlineSVG2 = _interopRequireDefault(_inlineSVG);

var _LabelInplaceEditor = __webpack_require__(/*! ./LabelInplaceEditor */ "./app/frontend/designer/js/LabelInplaceEditor.js");

var _LabelInplaceEditor2 = _interopRequireDefault(_LabelInplaceEditor);

var _BackendSkills = __webpack_require__(/*! ./io/BackendSkills */ "./app/frontend/designer/js/io/BackendSkills.js");

var _BackendSkills2 = _interopRequireDefault(_BackendSkills);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  hardware: _Hardware2.default,
  DecoratedInputPort: _DecoratedInputPort2.default,
  LabelInplaceEditor: _LabelInplaceEditor2.default,
  Mousetrap: _mousetrap2.default,
  CircuitFigure: _CircuitFigure2.default,
  inlineSVG: _inlineSVG2.default,
  skillproxy: _BackendSkills2.default
};
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/index.js":
/*!*******************************************!*\
  !*** ./app/frontend/designer/js/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../less/index.less */ "./app/frontend/designer/less/index.less");

__webpack_require__(/*! font-awesome/css/font-awesome.css */ "./node_modules/font-awesome/css/font-awesome.css");

var _global = __webpack_require__(/*! ./global */ "./app/frontend/designer/js/global.js");

var _global2 = _interopRequireDefault(_global);

var _Configuration = __webpack_require__(/*! ./Configuration */ "./app/frontend/designer/js/Configuration.js");

var _Configuration2 = _interopRequireDefault(_Configuration);

__webpack_require__(/*! ./figure/index */ "./app/frontend/designer/js/figure/index.js");

__webpack_require__(/*! ./filter/index */ "./app/frontend/designer/js/filter/index.js");

var _Application = __webpack_require__(/*! ./Application */ "./app/frontend/designer/js/Application.js");

var _Application2 = _interopRequireDefault(_Application);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//require('webpack-jquery-ui/css');  //ommit, if you don't want to load basic css theme

// Resolve name collision between jQuery UI and Twitter Bootstrap
/*** Handle jQuery plugin naming conflict between jQuery UI and Bootstrap ***/
$.widget.bridge('uibutton', $.ui.button);
$.widget.bridge('uitooltip', $.ui.tooltip);

// required to be compatible with jquery.layout and jquery.handsontable
//
jQuery.uaMatch = function (ua) {
  ua = ua.toLowerCase();
  var match = /(chrome)[ \/]([\w.]+)/.exec(ua) || /(webkit)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
  return {
    browser: match[1] || "",
    version: match[2] || "0"
  };
};
if (!jQuery.browser) {
  var matched = jQuery.uaMatch(navigator.userAgent);
  var browser = {};
  if (matched.browser) {
    browser[matched.browser] = true;
    browser.version = matched.version;
  }
  // Chrome is Webkit, but Webkit is also Safari.
  if (browser.chrome) {
    browser.webkit = true;
  } else if (browser.webkit) {
    browser.safari = true;
  }
  jQuery.browser = browser;
}

$(window).load(function () {

  // export all required classes for deserialize JSON with "eval"
  // "eval" code didn't sees imported class or code
  //
  for (var k in _global2.default) {
    window[k] = _global2.default[k];
  }socket = io({
    path: '/socket.io'
  });

  // Hack: add socket to the global context
  window['socket'] = socket;

  // remove the fileOpen/Save stuff if we run in a "serverless" mode. e.g. on gh-pages
  // (fake event from the socket.io mock )
  //
  socket.on("serverless", function () {
    _Configuration2.default.serverless = true;
    _Configuration2.default.backend.file.get = function (file) {
      return "./shapes/" + file;
    };
  });

  socket.on("connect", function () {
    app = shape_designer.app = new _Application2.default();
  });
});

/***/ }),

/***/ "./app/frontend/designer/js/io/BackendSkills.js":
/*!******************************************************!*\
  !*** ./app/frontend/designer/js/io/BackendSkills.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Configuration = __webpack_require__(/*! ./../Configuration */ "./app/frontend/designer/js/Configuration.js");

var _Configuration2 = _interopRequireDefault(_Configuration);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var sanitize = __webpack_require__(/*! sanitize-filename */ "./node_modules/sanitize-filename/index.js");

var BackendSkills = function () {

  /**
   * @constructor
   *
   */
  function BackendSkills() {
    _classCallCheck(this, BackendSkills);

    this.skillList = [];
    Object.preventExtensions(this);
  }

  _createClass(BackendSkills, [{
    key: "getSkillStateConfig",
    value: function getSkillStateConfig() {
      return {
        "nodeKeyProperty": "id",
        "nodeDataArray": [{ "id": "running", "text": "Running", "isGroup": true, "group": "cleared", "isHighlighted": true, "nid": 75 }, { "id": "stopped", "text": "Stopped", "trans": 0, "group": "cleared", "isHighlighted": true, "loc": "150 650", "nid": 53 }, { "id": "cleared", "text": "cleared", "isGroup": true, "isHighlighted": true, "nid": 71 }, { "id": "aborted", "text": "aborted", "trans": 0, "loc": "600 850", "nid": 62 }, { "id": "aborting", "text": "aborting", "trans": 1, "loc": " 370 850", "nid": 61 }, { "id": "clearing", "text": "clearing", "trans": 1, "group": "cleared", "loc": "600 700", "nid": 55 }, { "id": "stopping", "text": "stopping", "trans": 1, "group": "cleared", "loc": "370 650", "nid": 54 }, { "id": "resetting", "text": "resetting", "trans": 1, "group": "running", "isGroup": true, "loc": "150 500", "nid": 27 }, { "id": "check_resource", "text": "Check Res.", "trans": 1, "group": "resetting", "isHighlighted": true, "loc": "0 450", "nid": 1026 }, { "id": "initialize_resource", "text": "Init. Res.", "trans": 1, "group": "resetting", "loc": "300 450", "nid": 1025 }, { "id": "skill_initialized", "text": "Skill Res. Init.", "trans": 1, "group": "resetting", "loc": "150 400", "nid": 1027 }, { "id": "idle", "text": "idle", "trans": 0, "group": "running", "isGroup": true, "loc": "150 250", "nid": 28 }, { "id": "init_skill", "text": "Init. Skill", "trans": 0, "group": "idle", "isHighlighted": true, "loc": "150 270", "nid": 1018 }, { "id": "skill_ready", "text": "Skill Ready", "trans": 0, "group": "idle", "loc": "150 200", "nid": 1017 }, { "id": "execute", "text": "execute", "trans": 0, "group": "running", "isGroup": true, "loc": "400 200", "nid": 36 }, { "id": "execute_skill", "text": "Execute Skill", "trans": 0, "group": "execute", "loc": "400 170", "nid": 1013 }, { "id": "wait_next_step", "text": "Wait next Step", "trans": 0, "group": "execute", "loc": "400 270", "nid": 1014 }, { "id": "completing", "text": "completing", "trans": 1, "group": "running", "loc": "600 200", "nid": 37 }, { "id": "completed", "text": "completed", "trans": 0, "group": "running", "loc": "800 200", "nid": 38 }, { "id": "hold", "text": "hold", "trans": 0, "group": "running", "isGroup": true, "isHighlighted": true, "loc": "350 0", "nid": 136 }, { "id": "holding", "text": "holding", "trans": 1, "group": "hold", "loc": "200 0", "nid": 1020 }, { "id": "held", "text": "held", "trans": 0, "group": "hold", "loc": "400 0", "nid": 1021 }, { "id": "unholding", "text": "unholding", "trans": 1, "group": "hold", "loc": "600 0", "nid": 1022 }],
        "linkDataArray": [{ "from": "cleared", "to": "aborting", "curviness": 0, "text": "Abort" }, { "from": "aborting", "to": "aborted", "curviness": 0, "text": "SC" }, { "from": "aborted", "to": "clearing", "curviness": 0, "text": "Clear" }, { "from": "clearing", "to": "stopped", "curviness": 50, "text": "SC" }, { "from": "stopped", "to": "resetting", "curviness": 0, "text": "Reset" }, { "from": "skill_initialized", "to": "idle", "curviness": 0, "text": "SC" }, { "from": "check_resource", "to": "skill_initialized", "curviness": 20, "text": "OK" }, { "from": "check_resource", "to": "initialize_resource", "curviness": 0, "text": "n.OK" }, { "from": "initialize_resource", "to": "check_resource", "curviness": 50, "text": "SC" }, { "from": "skill_ready", "to": "execute_skill", "curviness": 0, "text": "StartSkill" }, { "from": "init_skill", "to": "skill_ready", "curviness": 0, "text": "SC" }, { "from": "execute_skill", "to": "completing", "curviness": 0, "text": "SC" }, { "from": "completing", "to": "completed", "curviness": 0, "text": "SC" }, { "from": "completed", "to": "init_skill", "curviness": 180, "text": "Reset" }, { "from": "execute", "to": "hold", "curviness": 0, "text": "hold" }, { "from": "holding", "to": "held", "curviness": 0, "text": "SC" }, { "from": "held", "to": "unholding", "curviness": 0, "text": "UnHold" }, { "from": "unholding", "to": "execute_skill", "curviness": 0, "text": "SC" }, { "from": "running", "to": "stopping", "curviness": 0, "text": "Stop" }, { "from": "stopping", "to": "stopped", "curviness": 0, "text": "SC" }, { "from": "execute_skill", "to": "wait_next_step", "curviness": 0, "text": "SC" }, { "from": "wait_next_step", "to": "execute_skill", "curviness": 50, "text": "NEXT" }]
      };
    }
  }, {
    key: "connectSkill",
    value: function connectSkill(ip, port) {
      var self = this;
      self.skillList = [];
      return $.ajax({
        url: _Configuration2.default.backend.skill.connect,
        xhrFields: {
          withCredentials: true
        },
        data: {
          ip: ip,
          port: port
        }
      }).then(function (resp) {
        if (resp.err) {
          return { err: resp.err };
        } else {
          self.skillList = resp.results;
          return { err: resp.err, skills: self.skillList };
        }
        return { err: "Unknown response." };
      });
    }
  }, {
    key: "browseSkills",
    value: function browseSkills(ip, port) {
      var self = this;
      self.skillList = [];
      return $.ajax({
        url: _Configuration2.default.backend.skill.browse,
        xhrFields: {
          withCredentials: true
        },
        data: {
          ip: ip,
          port: port
        }
      }).then(function (resp) {
        if (resp.err) {
          return { err: resp.err };
        } else {
          self.skillList = resp.results;
          return { err: resp.err, skills: self.skillList };
        }
        return { err: "Unknown response." };
      });
    }
  }, {
    key: "saveSkill",
    value: function saveSkill(skillObject, _machineName) {
      return $.ajax({
        url: _Configuration2.default.backend.skill.save,
        method: "POST",
        async: false,
        xhrFields: {
          withCredentials: true
        },
        data: {
          filePath: "" + _machineName + "_" + skillObject.ip + "_" + skillObject.port + "_" + skillObject.skill.name + ".shape",
          skill: skillObject
        }
      });
    }
  }, {
    key: "deleteSkill",
    value: function deleteSkill(skill) {
      // TODO: Jupiter Delete Skill remotely
      // return $.ajax({
      //     url: conf.backend.skill.del,
      //     method: "POST",
      //     xhrFields: {
      //       withCredentials: true
      //     },
      //     data: {
      //       filePath: fileName
      //     }
      //   }
      // );
    }
  }, {
    key: "getSkillDescription",
    value: function getSkillDescription(skill_name) {
      var self = this;
      return $.ajax({
        url: _Configuration2.default.backend.skill.getDescription,
        xhrFields: {
          withCredentials: true
        },
        data: {
          skill_name: skill_name
        }
      }).then(function (resp) {
        if (resp.err) {
          return { err: resp.err };
        } else {
          return { err: resp.err, skill_descp: JSON.parse(resp.skill_descp) };
        }
        return { err: "Unknown response." };
      });
    }
  }, {
    key: "startSkill",
    value: function startSkill(_ip, _port, _skill_name, _parameters) {
      var self = this;
      self.skillList = [];
      return $.ajax({
        url: _Configuration2.default.backend.skill.call,
        xhrFields: {
          withCredentials: true
        },
        data: {
          ip: _ip,
          port: _port,
          skillName: _skill_name,
          method: 'Start',
          parameters: _parameters
        }
      }).then(function (resp) {
        if (resp.err) {
          return { err: resp.err };
        } else {
          return { err: resp.err, results: resp.results };
        }
        return { err: "Unknown response." };
      });
    }
  }, {
    key: "getResultsOfSkillCall",
    value: function getResultsOfSkillCall(_ip, _port, _skill_name, _parameters) {
      var self = this;
      self.skillList = [];
      return $.ajax({
        url: _Configuration2.default.backend.skill.call,
        xhrFields: {
          withCredentials: true
        },
        data: {
          ip: _ip,
          port: _port,
          skillName: _skill_name,
          method: 'GetResults',
          parameters: _parameters
        }
      }).then(function (resp) {
        if (resp.err) {
          return { err: resp.err };
        } else {
          return { err: resp.err, results: resp.results };
        }
        return { err: "Unknown response." };
      });
    }
  }, {
    key: "allSkills",
    get: function get() {
      return this.skillList;
    }
  }]);

  return BackendSkills;
}();

var skillproxy = new BackendSkills();
exports.default = skillproxy;
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/io/BackendStorage.js":
/*!*******************************************************!*\
  !*** ./app/frontend/designer/js/io/BackendStorage.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Configuration = __webpack_require__(/*! ../Configuration */ "./app/frontend/designer/js/Configuration.js");

var _Configuration2 = _interopRequireDefault(_Configuration);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BackendStorage = function () {

  /**
   * @constructor
   *
   */
  function BackendStorage() {
    _classCallCheck(this, BackendStorage);

    this.fileName = "";
    Object.preventExtensions(this);
  }

  _createClass(BackendStorage, [{
    key: 'getFiles',
    value: function getFiles(path) {
      return $.ajax({
        url: _Configuration2.default.backend.file.list,
        xhrFields: {
          withCredentials: true
        },
        data: {
          path: path
        }
      }).then(function (response) {
        // happens in "serverless" mode on the gh-pages/docs installation
        //
        if (typeof response === "string") response = JSON.parse(response);

        var files = response.files;
        // sort the result
        // Directories are always on top
        //
        files.sort(function (a, b) {
          if (a.type === b.type) {
            if (a.name.toLowerCase() < b.name.toLowerCase()) return -1;
            if (a.name.toLowerCase() > b.name.toLowerCase()) return 1;
            return 0;
          }
          if (a.type === "dir") {
            return -1;
          }
          return 1;
        });
        return files;
      });
    }
  }, {
    key: 'saveFile',
    value: function saveFile(json, imageDataUrl, fileName) {
      return $.ajax({
        url: _Configuration2.default.backend.file.save,
        method: "POST",
        xhrFields: {
          withCredentials: true
        },
        data: {
          filePath: fileName,
          content: JSON.stringify({ draw2d: json, image: imageDataUrl }, undefined, 2)
        }
      });
    }

    /**
     * Load the file content of the given path
     *
     * @param fileName
     * @returns {*}
     */

  }, {
    key: 'loadFile',
    value: function loadFile(fileName) {
      return $.ajax({
        url: _Configuration2.default.backend.file.get(fileName),
        xhrFields: {
          withCredentials: true
        }
      }).fail(function (error) {
        console.log(arguments);
      }).then(function (response) {
        // happens in "serverless" mode on the gh-pages/docs installation
        //
        if (typeof response === "string") response = JSON.parse(response);

        if (response.draw2d) return response.draw2d;
        return response;
      });
    }
  }, {
    key: 'dirname',
    value: function dirname(path) {
      if (path === undefined || path === null || path.length === 0) return null;

      var segments = path.split("/");
      if (segments.length <= 1) return null;

      segments = segments.filter(function (n) {
        return n != "";
      });
      path = segments.slice(0, -1).join("/");
      return path === "" ? null : path + "/";
    }
  }, {
    key: 'basename',
    value: function basename(path) {
      if (path === null || path === "" || path === undefined) {
        return null;
      }
      return path.split(/[\\/]/).pop();
    }
  }, {
    key: 'currentDir',
    get: function get() {
      return this.dirname(this.dirname());
    }
  }, {
    key: 'currentFile',
    get: function get() {
      return this.basename(this.fileName);
    },
    set: function set(name) {
      this.fileName = name;

      var url = window.location.href.split('?')[0] + '?file=' + name;
      history.pushState({ id: 'editor', file: name }, 'Brainbox Designer ' + name, url);
    }
  }]);

  return BackendStorage;
}();

exports.default = BackendStorage;
module.exports = exports['default'];

/***/ }),

/***/ "./app/frontend/designer/js/io/FigureWriter.js":
/*!*****************************************************!*\
  !*** ./app/frontend/designer/js/io/FigureWriter.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _hogan = __webpack_require__(/*! hogan.js */ "./node_modules/hogan.js/lib/hogan.js");

var _hogan2 = _interopRequireDefault(_hogan);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = shape_designer.FigureWriter = draw2d.io.Writer.extend({

  init: function init() {
    this._super();
  },

  /**
   * @method
   * Export the content to the implemented data format. Inherit class implements
   * content specific writer.
   * <br>
   * <br>
   *
   * Method signature has been changed from version 2.10.1 to version 3.0.0.<br>
   * The parameter <b>resultCallback</b> is required and new. The method calls
   * the callback instead of return the result.
   *
   * @param {draw2d.Canvas} canvas
   * @parma {String} className
   * @param {Function} resultCallback the method to call on success. The first argument is the result object, the second the base64 representation of the file content
   */
  marshal: function marshal(canvas, className, resultCallback) {
    var baseClass = shape_designer.app.getConfiguration("baseClass");
    var customCode = shape_designer.app.getConfiguration("code");
    customCode = customCode.replace(/testShape/g, className);

    var figures = canvas.getExtFigures();
    var b = canvas.getBoundingBox();

    var x = b.x;
    var y = b.y;

    var ports = [];
    var shapes = [];

    shapes.push({
      constructor: 'this.canvas.paper.path("M0,0 L' + b.w + ',0 L' + b.w + ',' + b.h + ' L0,' + b.h + '")',
      attr: '{"stroke":"none","stroke-width":0,"fill":"none"}',
      name: "BoundingBox"
    });

    figures.each(function (i, figure) {
      figure.uninstallEditPolicy("draw2d.policy.figure.RegionEditPolicy");
      var attr = {};
      figure.svgPathString = null;
      figure.translate(-x, -y);
      // paint the element and fill the "attr" object with the current
      // settings
      figure.repaint(attr);
      delete attr.path;
      delete attr.x;
      delete attr.y;
      if (figure instanceof shape_designer.figure.ExtPolygon) {
        shapes.push({
          constructor: "this.canvas.paper.path('" + figure.svgPathString + "')",
          attr: JSON.stringify(attr),
          extra: figure.getBlur() === 0 ? "" : "shape.blur(" + figure.getBlur() + ");\n",
          name: figure.getUserData().name
        });
      } else if (figure instanceof shape_designer.figure.PolyCircle) {
        shapes.push({
          constructor: "this.canvas.paper.ellipse()",
          attr: JSON.stringify(attr),
          extra: figure.getBlur() === 0 ? "" : "shape.blur(" + figure.getBlur() + ");\n",
          name: figure.getUserData().name
        });
      } else if (figure instanceof shape_designer.figure.ExtLine) {
        // drop shadow
        shapes.push({
          constructor: "this.canvas.paper.path('" + figure.svgPathString + "')",
          attr: JSON.stringify($.extend({}, attr, {
            "stroke-width": attr["stroke-width"] + figure.getOutlineStroke(),
            "stroke": figure.getOutlineColor().hash()
          })),
          extra: figure.getBlur() === 0 ? "" : "shape.blur(" + figure.getBlur() + ");\n",
          name: figure.getUserData().name + "_shadow"
        });

        // the line itself
        shapes.push({
          constructor: "this.canvas.paper.path('" + figure.svgPathString + "')",
          attr: JSON.stringify(attr),
          extra: figure.getBlur() === 0 ? "" : "shape.blur(" + figure.getBlur() + ");\n",
          name: figure.getUserData().name
        });
      } else if (figure instanceof shape_designer.figure.ExtLabel) {
        attr = figure.svgNodes[0].attr();
        attr.x = attr.x + figure.getAbsoluteX();
        attr.y = attr.y + figure.getAbsoluteY();
        delete attr.transform;
        shapes.push({
          constructor: "this.canvas.paper.text(0,0,'" + figure.getText() + "')",
          attr: JSON.stringify(attr),
          extra: "",
          name: figure.getUserData().name
        });
      } else if (figure instanceof shape_designer.figure.ExtPort) {
        ports.push({
          type: figure.getInputType() === "Input" ? "new DecoratedInputPort()" : '"' + figure.getInputType().toLowerCase() + '"',
          method: figure.getInputType() === "Input" ? "addPort" : 'createPort',
          direction: figure.getConnectionDirection(),
          x: 100 / b.w * figure.getCenter().x,
          y: 100 / b.h * figure.getCenter().y,
          color: figure.getBackgroundColor().hash(),
          name: figure.getUserData().name,
          fanout: figure.getMaxFanOut()
        });
      }
      figure.translate(x, y);
    });

    var template = $("#shape-base-template").text().trim();

    var tags = className.split("_");
    var compiled = _hogan2.default.compile(template);
    var tooltip = tags.length > 0 ? tags.slice(-1)[0] : name;
    tooltip = tooltip.split(/\s*(?=[A-Z][a-z])/).join(" ");
    var output = compiled.render({
      tooltip: tooltip,
      className: className,
      baseClass: baseClass,
      figures: shapes,
      ports: ports,
      width: b.w,
      height: b.h
    });

    output = output + "\n\n" + customCode;
    resultCallback(output, draw2d.util.Base64.encode(output));
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/policy/AbstractGeoToolPolicy.js":
/*!******************************************************************!*\
  !*** ./app/frontend/designer/js/policy/AbstractGeoToolPolicy.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AbstractToolPolicy = __webpack_require__(/*! ./AbstractToolPolicy */ "./app/frontend/designer/js/policy/AbstractToolPolicy.js");

var _AbstractToolPolicy2 = _interopRequireDefault(_AbstractToolPolicy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var jsts = __webpack_require__(/*! jsts/dist/jsts */ "./node_modules/jsts/dist/jsts.js");

/* jshint evil: true */
exports.default = _AbstractToolPolicy2.default.extend({

  init: function init() {
    this._super();
    this.firstFigure = null;
    this.operation = null;
  },

  onInstall: function onInstall(canvas) {
    this.setToolHeader("");
    this.setToolMessage("Select first figure..");
  },

  select: function select(canvas, figure) {

    if (canvas.getSelection().getAll().contains(figure)) {
      return; // nothing to to
    }

    // check if the element an valid polygon. otherwise an boolean operation
    // isn't possible
    if (!(figure instanceof shape_designer.figure.ExtPolygon)) {
      return;
    }

    if (canvas.getSelection().getPrimary() !== null) {
      this.unselect(canvas, canvas.getSelection().getPrimary());
    }

    if (figure !== null) {
      figure.select(true); // primary selection
    }

    canvas.getSelection().setPrimary(figure);

    // inform all selection listeners about the new selection.
    //
    canvas.fireEvent("select", { figure: figure });
  },

  execute: function execute(canvas, firstFigure, figure) {
    if (firstFigure instanceof draw2d.util.ArrayList) {
      if (firstFigure.getSize() < 2) {
        return; // silently
      }
      figure = firstFigure.get(1);
      firstFigure = firstFigure.get(0);
    }
    this.executeGeometryOperation(canvas, firstFigure, figure, this.operation);
  },

  executeGeometryOperation: function executeGeometryOperation(canvas, figure1, figure2, operationFunc) {
    var p1 = this.getGeometry(figure1);
    var p2 = this.getGeometry(figure2);
    var union = eval("p1." + operationFunc + "(p2)");
    var geo = new jsts.io.GeoJSONWriter().write(union);
    var memento = figure1.getPersistentAttributes();
    var cmd = new draw2d.command.CommandCollection();
    cmd.add(new draw2d.command.CommandDelete(figure1));
    cmd.add(new draw2d.command.CommandDelete(figure2));
    $.each(geo.coordinates, $.proxy(function (i, poly) {
      var figure = new shape_designer.figure.ExtPolygon();
      figure.setPersistentAttributes(memento);
      figure.vertices = new draw2d.util.ArrayList();
      $.each(poly, function (i, vertex) {
        figure.addVertex(vertex[0], vertex[1]);
      });
      var command = new draw2d.command.CommandAdd(canvas, figure, figure.getX(), figure.getY());
      cmd.add(command);
    }, this));
    canvas.getCommandStack().execute(cmd);
    this.executed();
  },

  getGeometry: function getGeometry(figure) {
    var reader = new jsts.io.WKTReader();
    var v = figure.getVertices().clone().asArray();
    v.push(v[0]);
    return reader.read("POLYGON((" + $.map(v, function (e) {
      return e.x + " " + e.y;
    }).join(", ") + "))");
  }

});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/policy/AbstractToolPolicy.js":
/*!***************************************************************!*\
  !*** ./app/frontend/designer/js/policy/AbstractToolPolicy.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = draw2d.policy.canvas.SelectionPolicy.extend({

  init: function init() {
    this._super();
  },

  setToolText: function setToolText(message) {
    $('#currentTool_message').fadeOut(200, function () {
      $("#currentTool_message").html(message);
      $('#currentTool_message').fadeIn(200);
    });
  },

  executed: function executed() {}
});
module.exports = exports['default'];

/***/ }),

/***/ "./app/frontend/designer/js/policy/CircleToolPolicy.js":
/*!*************************************************************!*\
  !*** ./app/frontend/designer/js/policy/CircleToolPolicy.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AbstractToolPolicy = __webpack_require__(/*! ./AbstractToolPolicy */ "./app/frontend/designer/js/policy/AbstractToolPolicy.js");

var _AbstractToolPolicy2 = _interopRequireDefault(_AbstractToolPolicy);

var _cursor_circle = __webpack_require__(/*! ../../images/cursors/cursor_circle.png */ "./app/frontend/designer/images/cursors/cursor_circle.png");

var _cursor_circle2 = _interopRequireDefault(_cursor_circle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _AbstractToolPolicy2.default.extend({

  TITLE: "Circle",

  init: function init() {
    this._super();

    this.center = null;
    this.boundingBoxFigure1 = null;
    this.boundingBoxFigure2 = null;
  },

  onInstall: function onInstall(canvas) {
    canvas.setCursor(_cursor_circle2.default);
  },

  onUninstall: function onUninstall(canvas) {
    if (this.boundingBoxFigure1 !== null) {
      this.boundingBoxFigure1.setCanvas(null);
      this.boundingBoxFigure1 = null;
      this.boundingBoxFigure2.setCanvas(null);
      this.boundingBoxFigure2 = null;
    }
    canvas.setCursor(null);
  },

  /**
   * @method
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseDown: function onMouseDown(canvas, x, y, shiftKey, ctrlKey) {
    this.center = new draw2d.geo.Point(x, y);
  },

  /**
   * @method
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} dx The x diff between start of dragging and this event
   * @param {Number} dy The y diff between start of dragging and this event
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   * @template
   */
  onMouseDrag: function onMouseDrag(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey) {
    var r = Math.sqrt(dx * dx + dy * dy);
    if (this.boundingBoxFigure1 !== null) {
      this.boundingBoxFigure1.setRadius(Math.abs(r));
      this.boundingBoxFigure2.setRadius(Math.abs(r));
    } else {
      this.boundingBoxFigure1 = new draw2d.shape.basic.Circle({ radius: 1 });
      this.boundingBoxFigure1.setCenter(this.center);
      this.boundingBoxFigure1.setCanvas(canvas);
      this.boundingBoxFigure1.setBackgroundColor("#333333");
      this.boundingBoxFigure1.setAlpha(0.1);

      this.boundingBoxFigure2 = new draw2d.shape.basic.Circle({ radius: 1 });
      this.boundingBoxFigure2.setCenter(this.center);
      this.boundingBoxFigure2.setCanvas(canvas);
      this.boundingBoxFigure2.setStroke(1);
      this.boundingBoxFigure2.setColor(new draw2d.util.Color("#333333"));
      this.boundingBoxFigure2.setBackgroundColor(null);
    }
  },

  /**
   * @method
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @template
   */
  onMouseUp: function onMouseUp(canvas, x, y) {
    var dx = Math.abs(this.center.x - x);
    var dy = Math.abs(this.center.y - y);
    var r = Math.sqrt(dx * dx + dy * dy);
    if (r > 3) {
      var circle = new shape_designer.figure.PolyCircle(this.center, r);
      var command = new draw2d.command.CommandAdd(canvas, circle, circle.getX(), circle.getY());
      canvas.getCommandStack().execute(command);
      canvas.setCurrentSelection(circle);
    }

    this.center = null;
    if (this.boundingBoxFigure1 !== null) {
      this.boundingBoxFigure1.setCanvas(null);
      this.boundingBoxFigure1 = null;
      this.boundingBoxFigure2.setCanvas(null);
      this.boundingBoxFigure2 = null;
    }
    this.executed();
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/policy/GeoDifferenceToolPolicy.js":
/*!********************************************************************!*\
  !*** ./app/frontend/designer/js/policy/GeoDifferenceToolPolicy.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AbstractGeoToolPolicy = __webpack_require__(/*! ./AbstractGeoToolPolicy */ "./app/frontend/designer/js/policy/AbstractGeoToolPolicy.js");

var _AbstractGeoToolPolicy2 = _interopRequireDefault(_AbstractGeoToolPolicy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _AbstractGeoToolPolicy2.default.extend({

  init: function init() {
    this._super();
    this.operation = "difference";
  },

  onInstall: function onInstall(canvas) {
    this.setToolText("Select polygon to subtract from");
  },

  /**
   * @method
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseDown: function onMouseDown(canvas, x, y, shiftKey, ctrlKey) {
    var figure = canvas.getBestFigure(x, y);

    // check if the user click on a child shape. DragDrop and movement must redirect
    // to the parent
    // Exception: Port's
    while (figure !== null && figure.getParent() !== null && !(figure instanceof draw2d.Port)) {
      figure = figure.getParent();
    }

    if (figure !== canvas.getSelection().getPrimary() && figure !== null && figure.isSelectable() === true) {
      if (this.firstFigure === null) {
        this.firstFigure = figure;
        this.select(canvas, figure);
        this.setToolText("Select polygon to subtract");
      } else {
        this.execute(canvas, this.firstFigure, figure);
        this.firstFigure = null;
        this.setToolText("Select polygon to subtract from");
      }
    }
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/policy/GeoIntersectionToolPolicy.js":
/*!**********************************************************************!*\
  !*** ./app/frontend/designer/js/policy/GeoIntersectionToolPolicy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AbstractGeoToolPolicy = __webpack_require__(/*! ./AbstractGeoToolPolicy */ "./app/frontend/designer/js/policy/AbstractGeoToolPolicy.js");

var _AbstractGeoToolPolicy2 = _interopRequireDefault(_AbstractGeoToolPolicy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _AbstractGeoToolPolicy2.default.extend({

  init: function init() {
    this._super();
    this.operation = "intersection";
  },

  onInstall: function onInstall(canvas) {
    this.setToolText("Select polygon to intersect with");
  },

  /**
   * @method
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseDown: function onMouseDown(canvas, x, y, shiftKey, ctrlKey) {

    var figure = canvas.getBestFigure(x, y);

    // check if the user click on a child shape. DragDrop and movement must redirect
    // to the parent
    // Exception: Port's
    while (figure !== null && figure.getParent() !== null && !(figure instanceof draw2d.Port)) {
      figure = figure.getParent();
    }

    if (figure !== canvas.getSelection().getPrimary() && figure !== null && figure.isSelectable() === true) {
      if (this.firstFigure === null) {
        this.firstFigure = figure;
        this.select(canvas, figure);
        this.setToolText("Select polygon to intersect");
      } else {
        this.execute(canvas, this.firstFigure, figure);
        this.firstFigure = null;
        this.setToolText("Select polygon to intersect with");
      }
    }
  }

});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/policy/GeoUnionToolPolicy.js":
/*!***************************************************************!*\
  !*** ./app/frontend/designer/js/policy/GeoUnionToolPolicy.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AbstractGeoToolPolicy = __webpack_require__(/*! ./AbstractGeoToolPolicy */ "./app/frontend/designer/js/policy/AbstractGeoToolPolicy.js");

var _AbstractGeoToolPolicy2 = _interopRequireDefault(_AbstractGeoToolPolicy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _AbstractGeoToolPolicy2.default.extend({

  init: function init() {
    this._super();
    this.operation = "union";
  },

  onInstall: function onInstall(canvas) {
    this.setToolText("Select polygon to add to..");
  },

  /**
   * @method
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseDown: function onMouseDown(canvas, x, y, shiftKey, ctrlKey) {

    var figure = canvas.getBestFigure(x, y);

    // check if the user click on a child shape. DragDrop and movement must redirect
    // to the parent
    // Exception: Port's
    while (figure !== null && figure.getParent() !== null && !(figure instanceof draw2d.Port)) {
      figure = figure.getParent();
    }

    if (figure !== canvas.getSelection().getPrimary() && figure !== null && figure.isSelectable() === true) {
      if (this.firstFigure === null) {
        this.firstFigure = figure;
        this.select(canvas, figure);
        this.setToolText("Select polygon to merge");
      } else {
        this.execute(canvas, this.firstFigure, figure);
        this.firstFigure = null;
        this.setToolText("Select polygon to add to");
      }
    }
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/policy/LineToolPolicy.js":
/*!***********************************************************!*\
  !*** ./app/frontend/designer/js/policy/LineToolPolicy.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AbstractToolPolicy = __webpack_require__(/*! ./AbstractToolPolicy */ "./app/frontend/designer/js/policy/AbstractToolPolicy.js");

var _AbstractToolPolicy2 = _interopRequireDefault(_AbstractToolPolicy);

var _cursor_line = __webpack_require__(/*! ../../images/cursors/cursor_line.png */ "./app/frontend/designer/images/cursors/cursor_line.png");

var _cursor_line2 = _interopRequireDefault(_cursor_line);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _AbstractToolPolicy2.default.extend({

  MESSAGE_STEP1: "Select start point of the line.",
  MESSAGE_STEP2: "Click to add additional vertex.<br>Double click to finish line.",

  init: function init() {
    this._super();

    this.lineFigure = null;
    this.canvas = null;
  },

  onInstall: function onInstall(canvas) {
    this.setToolText(this.MESSAGE_STEP1);
    this.canvas = canvas;
    canvas.setCursor(_cursor_line2.default);
  },

  onUninstall: function onUninstall(canvas) {
    if (this.lineFigure !== null) {
      if (this.lineFigure.getVertices().getSize() < 2) {
        canvas.remove(this.lineFigure);
        this.lineFigure = null;
      } else {
        // stay in the canvas and finalize the stroke if a doubleClick
        var last = this.lineFigure.vertices.last();
        this.onDoubleClick(this.lineFigure, last.x, last.y, false, false);
      }
    }
    this.canvas = null;
    canvas.setCursor(null);
  },

  /**
   * @method
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseDown: function onMouseDown(canvas, x, y, shiftKey, ctrlKey) {},

  /**
   * @method
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse event
   * @param {Number} y the y-coordinate of the mouse event
   * @template
   */
  onMouseMove: function onMouseMove(canvas, x, y) {

    if (this.lineFigure !== null) {
      this.lineFigure.setEndPoint(x, y);
    }
  },

  /**
   * @method
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} dx The x diff between start of dragging and this event
   * @param {Number} dy The y diff between start of dragging and this event
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   * @template
   */
  onMouseDrag: function onMouseDrag(canvas, dx, dy, dx2, dy2) {},

  onDoubleClick: function onDoubleClick(figure, x, y, shiftKey, ctrlKey) {
    this.onClick(figure, x, y, shiftKey, ctrlKey);

    // Remove duplicate points at the end of the polyLine. This happens during the DoubleClick.
    // Reason: before the double click is fired the two "single click" comes before. In this case we
    // added three vertex for a doubleClick event
    //

    // don't use the shortcut and assign the this.lineFigure.vertices to a local var.
    // the vertices are recreated in the "calculatePath" mnethod of the polygon and
    // the reference is in this case invalid...design flaw!
    //
    var last = this.lineFigure.vertices.last();
    var beforeLast = this.lineFigure.vertices.get(this.lineFigure.vertices.getSize() - 2);
    while (last.equals(beforeLast)) {
      this.lineFigure.removeVertexAt(this.lineFigure.vertices.getSize() - 2);
      beforeLast = this.lineFigure.vertices.get(this.lineFigure.vertices.getSize() - 2);
    }

    this.lineFigure = null;
    this.executed();
  },

  /**
   * @method
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @template
   */
  onClick: function onClick(figure, x, y, shiftKey, ctrlKey) {
    if (this.lineFigure === null) {
      this.setToolText(this.MESSAGE_STEP2);

      this.lineFigure = new shape_designer.figure.ExtLine();
      this.lineFigure.setStartPoint(x, y);
      this.lineFigure.setEndPoint(x, y);
      var command = new draw2d.command.CommandAdd(this.canvas, this.lineFigure, x, y);
      this.canvas.getCommandStack().execute(command);
      this.canvas.setCurrentSelection(this.lineFigure);
    } else {
      this.lineFigure.addVertex(x, y);
    }
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/policy/PortToolPolicy.js":
/*!***********************************************************!*\
  !*** ./app/frontend/designer/js/policy/PortToolPolicy.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SelectionToolPolicy = __webpack_require__(/*! ./SelectionToolPolicy */ "./app/frontend/designer/js/policy/SelectionToolPolicy.js");

var _SelectionToolPolicy2 = _interopRequireDefault(_SelectionToolPolicy);

var _cursor_port = __webpack_require__(/*! ../../images/cursors/cursor_port.png */ "./app/frontend/designer/images/cursors/cursor_port.png");

var _cursor_port2 = _interopRequireDefault(_cursor_port);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _SelectionToolPolicy2.default.extend({

  TITLE: "Port",
  MESSAGE_STEP1: "Select location to add port.<br>Click on port to move.",

  init: function init() {
    this._super();
  },

  onInstall: function onInstall(canvas) {
    this.setToolText(this.MESSAGE_STEP1);
    canvas.setCursor(_cursor_port2.default);
  },

  onUninstall: function onUninstall(canvas) {
    canvas.setCursor(null);
  },

  select: function select(canvas, figure) {
    // check if the element an valid polygon. otherwise an boolean operation
    // isn't possible
    if (!(figure instanceof shape_designer.figure.ExtPort)) {
      return;
    }

    this._super(canvas, figure);
  },

  onMouseDown: function onMouseDown(canvas, x, y, shiftKey, ctrlKey) {
    var figure = canvas.getBestFigure(x, y);

    if (figure === null || figure instanceof shape_designer.figure.ExtPort) {
      this._super(canvas, x, y, shiftKey, ctrlKey);
    }
  },

  /**
   * @method
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @template
   */
  onMouseUp: function onMouseUp(canvas, x, y) {

    if (this.mouseDownElement === null || !(this.mouseDownElement instanceof shape_designer.figure.ExtPort)) {
      var command = new draw2d.command.CommandAdd(canvas, new shape_designer.figure.ExtPort(), x, y);
      canvas.getCommandStack().execute(command);
      canvas.setCurrentSelection(command.figure);
      this.executed();
    } else {
      this._super(canvas, x, y);
    }
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/policy/RectangleToolPolicy.js":
/*!****************************************************************!*\
  !*** ./app/frontend/designer/js/policy/RectangleToolPolicy.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _PolyRect = __webpack_require__(/*! ../figure/PolyRect */ "./app/frontend/designer/js/figure/PolyRect.js");

var _PolyRect2 = _interopRequireDefault(_PolyRect);

var _AbstractToolPolicy = __webpack_require__(/*! ./AbstractToolPolicy */ "./app/frontend/designer/js/policy/AbstractToolPolicy.js");

var _AbstractToolPolicy2 = _interopRequireDefault(_AbstractToolPolicy);

var _cursor_rectangle = __webpack_require__(/*! ../../images/cursors/cursor_rectangle.png */ "./app/frontend/designer/images/cursors/cursor_rectangle.png");

var _cursor_rectangle2 = _interopRequireDefault(_cursor_rectangle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _AbstractToolPolicy2.default.extend({

  init: function init() {
    this._super();

    this.topLeftPoint = null;
    this.boundingBoxFigure1 = null;
    this.boundingBoxFigure2 = null;
  },

  onInstall: function onInstall(canvas) {
    this.setToolText("Select first corner of rectangle");
    canvas.setCursor(_cursor_rectangle2.default);
  },

  onUninstall: function onUninstall(canvas) {
    if (this.boundingBoxFigure1 !== null) {
      this.boundingBoxFigure1.setCanvas(null);
      this.boundingBoxFigure1 = null;
      this.boundingBoxFigure2.setCanvas(null);
      this.boundingBoxFigure2 = null;
    }
    canvas.setCursor(null);
  },

  /**
   * @method
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseDown: function onMouseDown(canvas, x, y, shiftKey, ctrlKey) {
    this.topLeftPoint = new draw2d.geo.Point(x, y);
  },

  /**
   * @method
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} dx The x diff between start of dragging and this event
   * @param {Number} dy The y diff between start of dragging and this event
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   * @template
   */
  onMouseDrag: function onMouseDrag(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey) {

    if (this.boundingBoxFigure1 === null) {
      this.boundingBoxFigure1 = new draw2d.shape.basic.Rectangle({
        width: 1,
        height: 1,
        x: this.topLeftPoint.x,
        y: this.topLeftPoint.y,
        bgColor: "#d4d1d4",
        alpha: 0.1
      });
      this.boundingBoxFigure1.setCanvas(canvas);

      this.boundingBoxFigure2 = new draw2d.shape.basic.Rectangle({
        width: 1,
        height: 1,
        x: this.topLeftPoint.x,
        y: this.topLeftPoint.y,
        dash: "--..",
        stroke: 0.5,
        color: "#37a8ff",
        bgColor: null
      });
      this.boundingBoxFigure2.setCanvas(canvas);
    }

    if (this.boundingBoxFigure1 !== null) {
      this.boundingBoxFigure1.setDimension(Math.abs(dx), Math.abs(dy));
      this.boundingBoxFigure1.setPosition(this.topLeftPoint.x + Math.min(0, dx), this.topLeftPoint.y + Math.min(0, dy));
      this.boundingBoxFigure2.setDimension(Math.abs(dx), Math.abs(dy));
      this.boundingBoxFigure2.setPosition(this.topLeftPoint.x + Math.min(0, dx), this.topLeftPoint.y + Math.min(0, dy));
    }
  },

  /**
   * @method
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @template
   */
  onMouseUp: function onMouseUp(canvas, x, y) {
    if (this.boundingBoxFigure1 !== null) {
      this.boundingBoxFigure1.setCanvas(null);
      this.boundingBoxFigure1 = null;
      this.boundingBoxFigure2.setCanvas(null);
      this.boundingBoxFigure2 = null;
    }

    var bottomRight = new draw2d.geo.Point(x, y);
    if (this.topLeftPoint.distance(bottomRight) > 3) {
      var rect = new _PolyRect2.default(this.topLeftPoint, bottomRight);
      var command = new draw2d.command.CommandAdd(canvas, rect, rect.getX(), rect.getY());
      canvas.getCommandStack().execute(command);
      canvas.setCurrentSelection(rect);
    }
    this.executed();
    this.topLeftPoint = null;
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/policy/SelectionToolPolicy.js":
/*!****************************************************************!*\
  !*** ./app/frontend/designer/js/policy/SelectionToolPolicy.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = draw2d.policy.canvas.BoundingboxSelectionPolicy.extend({

  init: function init() {
    this._super();
  },

  onInstall: function onInstall(canvas) {
    this.setToolText("Click on shape to select<br>Double click to edit");
  },

  setToolHeader: function setToolHeader(heading, icon) {
    $("#currentTool_image").attr({ "src": icon });
    $("#currentTool_heading").text(heading);
  },

  setToolText: function setToolText(message) {
    $("#currentTool_message").html(message);
  },

  /**
   * @method
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseDown: function onMouseDown(canvas, x, y, shiftKey, ctrlKey) {
    this.cloneOnDrag = shiftKey;
    this._super(canvas, x, y, shiftKey, ctrlKey);
  },

  /**
   * Copy the selected figure if the user start dragging the selection.
   *
   */
  onMouseDrag: function onMouseDrag(canvas, dx, dy, dx2, dy2) {
    if (!(this.mouseDraggingElement instanceof draw2d.ResizeHandle || this.mouseDraggingElement instanceof draw2d.Port)) {
      if (this.cloneOnDrag === true && this.mouseDraggingElement !== null) {
        // get the current position of the selected shape
        var pos = this.mouseDraggingElement.getPosition();

        // cancel the current drag&drop operation
        this.mouseDraggingElement.onDragEnd(pos.x, pos.y, false, false);
        this.mouseDraggingElement.unselect();

        // clone the selection
        this.mouseDraggingElement = this.mouseDraggingElement.clone();
        // add the clone to the canvas and start dragging of the clone
        canvas.add(this.mouseDraggingElement, pos);

        // select the cloned shape
        this.select(canvas, this.mouseDraggingElement);

        // start dragging if the clone accept this operation
        this.mouseDraggingElement.onDragStart(pos.x, pos.y, false, false);
      }
    }
    this.cloneOnDrag = false;
    this._super(canvas, dx, dy, dx2, dy2);
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/policy/TextToolPolicy.js":
/*!***********************************************************!*\
  !*** ./app/frontend/designer/js/policy/TextToolPolicy.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AbstractToolPolicy = __webpack_require__(/*! ./AbstractToolPolicy */ "./app/frontend/designer/js/policy/AbstractToolPolicy.js");

var _AbstractToolPolicy2 = _interopRequireDefault(_AbstractToolPolicy);

var _cursor_text = __webpack_require__(/*! ../../images/cursors/cursor_text.png */ "./app/frontend/designer/images/cursors/cursor_text.png");

var _cursor_text2 = _interopRequireDefault(_cursor_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _AbstractToolPolicy2.default.extend({

  TITLE: "Text",
  MESSAGE_STEP1: "Select location for text",
  MESSAGE_STEP2: "Enter Text",

  init: function init() {
    this._super();

    this.topLeft = null;
    this.newFigure = null;
  },

  onInstall: function onInstall(canvas) {
    this.setToolText(this.MESSAGE_STEP1);
    canvas.setCursor(_cursor_text2.default);
  },

  onUninstall: function onUninstall(canvas) {
    canvas.setCursor(null);
  },

  /**
   * @method
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseDown: function onMouseDown(canvas, x, y, shiftKey, ctrlKey) {},

  /**
   * @method
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse event
   * @param {Number} y the y-coordinate of the mouse event
   * @template
   */
  onMouseMove: function onMouseMove(canvas, x, y) {},

  /**
   * @method
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} dx The x diff between start of dragging and this event
   * @param {Number} dy The y diff between start of dragging and this event
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   * @template
   */
  onMouseDrag: function onMouseDrag(canvas, dx, dy, dx2, dy2) {},

  /**
   * @method
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @template
   */
  onMouseUp: function onMouseUp(canvas, x, y) {
    if (this.topLeft === null) {
      this.topLeft = new draw2d.geo.Point(x, y);
      this.setToolText(this.MESSAGE_STEP2);

      this.newFigure = new shape_designer.figure.ExtLabel();
      this.newFigure.setText("Text");
      this.newFigure.setStroke(0);
      this.newFigure.setPadding(5);
      this.newFigure.setFontSize(16);

      var command = new draw2d.command.CommandAdd(canvas, this.newFigure, parseInt(x), parseInt(y));
      canvas.getCommandStack().execute(command);
      canvas.setCurrentSelection(this.newFigure);

      // start inplace editing
      //
      setTimeout($.proxy(function () {
        this.newFigure.onDoubleClick();
      }, this), 100);

      this.executed();
    } else {
      this.topLeft = null;
    }
  }
});
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/util/mousetrap-global.js":
/*!***********************************************************!*\
  !*** ./app/frontend/designer/js/util/mousetrap-global.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * adds a bindGlobal method to Mousetrap that allows you to
 * bind specific keyboard shortcuts that will still work
 * inside a text input field
 *
 * usage:
 * Mousetrap.bindGlobal('ctrl+s', _saveChanges);
 */
/* global Mousetrap:true */
(function (Mousetrap) {
  var _globalCallbacks = {};
  var _originalStopCallback = Mousetrap.prototype.stopCallback;

  Mousetrap.prototype.stopCallback = function (e, element, combo, sequence) {
    var self = this;

    if (self.paused) {
      return true;
    }

    if (_globalCallbacks[combo] || _globalCallbacks[sequence]) {
      return false;
    }

    return _originalStopCallback.call(self, e, element, combo);
  };

  Mousetrap.prototype.bindGlobal = function (keys, callback, action) {
    var self = this;
    self.bind(keys, callback, action);

    if (keys instanceof Array) {
      for (var i = 0; i < keys.length; i++) {
        _globalCallbacks[keys[i]] = true;
      }
      return;
    }

    _globalCallbacks[keys] = true;
  };

  Mousetrap.init();
})(Mousetrap);

/***/ }),

/***/ "./app/frontend/designer/js/util/mousetrap-pause.js":
/*!**********************************************************!*\
  !*** ./app/frontend/designer/js/util/mousetrap-pause.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * adds a pause and unpause method to Mousetrap
 * this allows you to enable or disable keyboard shortcuts
 * without having to reset Mousetrap and rebind everything
 */
/* global Mousetrap:true */
(function (Mousetrap) {
  var _originalStopCallback = Mousetrap.prototype.stopCallback;

  Mousetrap.prototype.stopCallback = function (e, element, combo) {
    var self = this;

    if (self.paused) {
      return true;
    }

    return _originalStopCallback.call(self, e, element, combo);
  };

  Mousetrap.prototype.pause = function () {
    var self = this;
    self.paused = true;
  };

  Mousetrap.prototype.unpause = function () {
    var self = this;
    self.paused = false;
  };

  Mousetrap.init();
})(Mousetrap);

/***/ }),

/***/ "./app/frontend/designer/js/widget/jscolor/arrow.gif":
/*!***********************************************************!*\
  !*** ./app/frontend/designer/js/widget/jscolor/arrow.gif ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/5034704a76cd55c1cbcbc58ea6bf523f.gif";

/***/ }),

/***/ "./app/frontend/designer/js/widget/jscolor/cross.gif":
/*!***********************************************************!*\
  !*** ./app/frontend/designer/js/widget/jscolor/cross.gif ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/ba9a274b9323753cd95bc3b1eb2f4e5f.gif";

/***/ }),

/***/ "./app/frontend/designer/js/widget/jscolor/hs.png":
/*!********************************************************!*\
  !*** ./app/frontend/designer/js/widget/jscolor/hs.png ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/fefa1a03d92ebad25c88dca94a0b63db.png";

/***/ }),

/***/ "./app/frontend/designer/js/widget/jscolor/hv.png":
/*!********************************************************!*\
  !*** ./app/frontend/designer/js/widget/jscolor/hv.png ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/990d71cada17da100653636cf8490884.png";

/***/ }),

/***/ "./app/frontend/designer/js/widget/jscolor/jscolor.js":
/*!************************************************************!*\
  !*** ./app/frontend/designer/js/widget/jscolor/jscolor.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _arrow = __webpack_require__(/*! ./arrow.gif */ "./app/frontend/designer/js/widget/jscolor/arrow.gif");

var _arrow2 = _interopRequireDefault(_arrow);

var _cross = __webpack_require__(/*! ./cross.gif */ "./app/frontend/designer/js/widget/jscolor/cross.gif");

var _cross2 = _interopRequireDefault(_cross);

var _hs = __webpack_require__(/*! ./hs.png */ "./app/frontend/designer/js/widget/jscolor/hs.png");

var _hs2 = _interopRequireDefault(_hs);

var _hv = __webpack_require__(/*! ./hv.png */ "./app/frontend/designer/js/widget/jscolor/hv.png");

var _hv2 = _interopRequireDefault(_hv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * jscolor, JavaScript Color Picker
 *
 * @version 1.4.2
 * @license GNU Lesser General Public License, http://www.gnu.org/copyleft/lesser.html
 * @author  Jan Odvarko, http://odvarko.cz
 * @created 2008-06-15
 * @updated 2013-11-25
 * @link    http://jscolor.com
 */
var jscolor = null;
exports.default = jscolor = {

  dir: '', // location of jscolor directory (leave empty to autodetect)
  bindClass: 'color', // class name
  binding: true, // automatic binding via <input class="...">
  preloading: true, // use image preloading?


  install: function install() {
    jscolor.addEvent(window, 'load', jscolor.init);
  },

  init: function init() {
    if (jscolor.binding) {
      jscolor.bind();
    }
    if (jscolor.preloading) {
      jscolor.preload();
    }
  },

  bind: function bind() {
    var matchClass = new RegExp('(^|\\s)(' + jscolor.bindClass + ')\\s*(\\{[^}]*\\})?', 'i');
    var e = document.getElementsByTagName('input');
    for (var i = 0; i < e.length; i += 1) {
      var m;
      if (!e[i].color && e[i].className && (m = e[i].className.match(matchClass))) {
        var prop = {};
        if (m[3]) {
          try {
            prop = new Function('return (' + m[3] + ')')();
          } catch (eInvalidProp) {}
        }
        e[i].color = new jscolor.color(e[i], prop);
      }
    }
  },

  preload: function preload() {
    for (var fn in jscolor.imgRequire) {
      if (jscolor.imgRequire.hasOwnProperty(fn)) {
        jscolor.loadImage(fn);
      }
    }
  },

  images: {
    pad: [181, 101],
    sld: [16, 101],
    cross: [15, 15],
    arrow: [7, 11]
  },

  imgRequire: {},
  imgLoaded: {},

  requireImage: function requireImage(filename) {
    jscolor.imgRequire[filename] = true;
  },

  loadImage: function loadImage(filename) {
    if (!jscolor.imgLoaded[filename]) {
      jscolor.imgLoaded[filename] = new Image();
      jscolor.imgLoaded[filename].src = filename;
    }
  },

  fetchElement: function fetchElement(mixed) {
    return typeof mixed === 'string' ? document.getElementById(mixed) : mixed;
  },

  addEvent: function addEvent(el, evnt, func) {
    if (el.addEventListener) {
      el.addEventListener(evnt, func, false);
    } else if (el.attachEvent) {
      el.attachEvent('on' + evnt, func);
    }
  },

  fireEvent: function fireEvent(el, evnt) {
    if (!el) {
      return;
    }
    if (document.createEvent) {
      var ev = document.createEvent('HTMLEvents');
      ev.initEvent(evnt, true, true);
      el.dispatchEvent(ev);
    } else if (document.createEventObject) {
      var ev = document.createEventObject();
      el.fireEvent('on' + evnt, ev);
    } else if (el['on' + evnt]) {
      // alternatively use the traditional event model (IE5)
      el['on' + evnt]();
    }
  },

  getElementPos: function getElementPos(e) {
    var e1 = e,
        e2 = e;
    var x = 0,
        y = 0;
    if (e1.offsetParent) {
      do {
        x += e1.offsetLeft;
        y += e1.offsetTop;
      } while (e1 = e1.offsetParent);
    }
    while ((e2 = e2.parentNode) && e2.nodeName.toUpperCase() !== 'BODY') {
      x -= e2.scrollLeft;
      y -= e2.scrollTop;
    }
    return [x, y];
  },

  getElementSize: function getElementSize(e) {
    return [e.offsetWidth, e.offsetHeight];
  },

  getRelMousePos: function getRelMousePos(e) {
    var x = 0,
        y = 0;
    if (!e) {
      e = window.event;
    }
    if (typeof e.offsetX === 'number') {
      x = e.offsetX;
      y = e.offsetY;
    } else if (typeof e.layerX === 'number') {
      x = e.layerX;
      y = e.layerY;
    }
    return { x: x, y: y };
  },

  getViewPos: function getViewPos() {
    if (typeof window.pageYOffset === 'number') {
      return [window.pageXOffset, window.pageYOffset];
    } else if (document.body && (document.body.scrollLeft || document.body.scrollTop)) {
      return [document.body.scrollLeft, document.body.scrollTop];
    } else if (document.documentElement && (document.documentElement.scrollLeft || document.documentElement.scrollTop)) {
      return [document.documentElement.scrollLeft, document.documentElement.scrollTop];
    } else {
      return [0, 0];
    }
  },

  getViewSize: function getViewSize() {
    if (typeof window.innerWidth === 'number') {
      return [window.innerWidth, window.innerHeight];
    } else if (document.body && (document.body.clientWidth || document.body.clientHeight)) {
      return [document.body.clientWidth, document.body.clientHeight];
    } else if (document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight)) {
      return [document.documentElement.clientWidth, document.documentElement.clientHeight];
    } else {
      return [0, 0];
    }
  },

  URI: function URI(uri) {
    // See RFC3986

    this.scheme = null;
    this.authority = null;
    this.path = '';
    this.query = null;
    this.fragment = null;

    this.parse = function (uri) {
      var m = uri.match(/^(([A-Za-z][0-9A-Za-z+.-]*)(:))?((\/\/)([^\/?#]*))?([^?#]*)((\?)([^#]*))?((#)(.*))?/);
      this.scheme = m[3] ? m[2] : null;
      this.authority = m[5] ? m[6] : null;
      this.path = m[7];
      this.query = m[9] ? m[10] : null;
      this.fragment = m[12] ? m[13] : null;
      return this;
    };

    this.toString = function () {
      var result = '';
      if (this.scheme !== null) {
        result = result + this.scheme + ':';
      }
      if (this.authority !== null) {
        result = result + '//' + this.authority;
      }
      if (this.path !== null) {
        result = result + this.path;
      }
      if (this.query !== null) {
        result = result + '?' + this.query;
      }
      if (this.fragment !== null) {
        result = result + '#' + this.fragment;
      }
      return result;
    };

    this.toAbsolute = function (base) {
      var base = new jscolor.URI(base);
      var r = this;
      var t = new jscolor.URI();

      if (base.scheme === null) {
        return false;
      }

      if (r.scheme !== null && r.scheme.toLowerCase() === base.scheme.toLowerCase()) {
        r.scheme = null;
      }

      if (r.scheme !== null) {
        t.scheme = r.scheme;
        t.authority = r.authority;
        t.path = removeDotSegments(r.path);
        t.query = r.query;
      } else {
        if (r.authority !== null) {
          t.authority = r.authority;
          t.path = removeDotSegments(r.path);
          t.query = r.query;
        } else {
          if (r.path === '') {
            t.path = base.path;
            if (r.query !== null) {
              t.query = r.query;
            } else {
              t.query = base.query;
            }
          } else {
            if (r.path.substr(0, 1) === '/') {
              t.path = removeDotSegments(r.path);
            } else {
              if (base.authority !== null && base.path === '') {
                t.path = '/' + r.path;
              } else {
                t.path = base.path.replace(/[^\/]+$/, '') + r.path;
              }
              t.path = removeDotSegments(t.path);
            }
            t.query = r.query;
          }
          t.authority = base.authority;
        }
        t.scheme = base.scheme;
      }
      t.fragment = r.fragment;

      return t;
    };

    function removeDotSegments(path) {
      var out = '';
      while (path) {
        if (path.substr(0, 3) === '../' || path.substr(0, 2) === './') {
          path = path.replace(/^\.+/, '').substr(1);
        } else if (path.substr(0, 3) === '/./' || path === '/.') {
          path = '/' + path.substr(3);
        } else if (path.substr(0, 4) === '/../' || path === '/..') {
          path = '/' + path.substr(4);
          out = out.replace(/\/?[^\/]*$/, '');
        } else if (path === '.' || path === '..') {
          path = '';
        } else {
          var rm = path.match(/^\/?[^\/]*/)[0];
          path = path.substr(rm.length);
          out = out + rm;
        }
      }
      return out;
    }

    if (uri) {
      this.parse(uri);
    }
  },

  //
  // Usage example:
  // var myColor = new jscolor.color(myInputElement)
  //

  color: function color(target, prop) {

    this.required = true; // refuse empty values?
    this.adjust = true; // adjust value to uniform notation?
    this.hash = false; // prefix color with # symbol?
    this.caps = true; // uppercase?
    this.slider = true; // show the value/saturation slider?
    this.valueElement = target; // value holder
    this.styleElement = target; // where to reflect current color
    this.onImmediateChange = null; // onchange callback (can be either string or function)
    this.hsv = [0, 0, 1]; // read-only  0-6, 0-1, 0-1
    this.rgb = [1, 1, 1]; // read-only  0-1, 0-1, 0-1
    this.minH = 0; // read-only  0-6
    this.maxH = 6; // read-only  0-6
    this.minS = 0; // read-only  0-1
    this.maxS = 1; // read-only  0-1
    this.minV = 0; // read-only  0-1
    this.maxV = 1; // read-only  0-1

    this.pickerOnfocus = true; // display picker on focus?
    this.pickerMode = 'HSV'; // HSV | HVS
    this.pickerPosition = 'bottom'; // left | right | top | bottom
    this.pickerSmartPosition = true; // automatically adjust picker position when necessary
    this.pickerButtonHeight = 20; // px
    this.pickerClosable = false;
    this.pickerCloseText = 'Close';
    this.pickerButtonColor = 'ButtonText'; // px
    this.pickerFace = 10; // px
    this.pickerFaceColor = 'ThreeDFace'; // CSS color
    this.pickerBorder = 1; // px
    this.pickerBorderColor = 'ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight'; // CSS color
    this.pickerInset = 1; // px
    this.pickerInsetColor = 'ThreeDShadow ThreeDHighlight ThreeDHighlight ThreeDShadow'; // CSS color
    this.pickerZIndex = 10000;

    for (var p in prop) {
      if (prop.hasOwnProperty(p)) {
        this[p] = prop[p];
      }
    }

    this.hidePicker = function () {
      if (isPickerOwner()) {
        removePicker();
      }
    };

    this.showPicker = function () {
      if (!isPickerOwner()) {
        var tp = jscolor.getElementPos(target); // target pos
        var ts = jscolor.getElementSize(target); // target size
        var vp = jscolor.getViewPos(); // view pos
        var vs = jscolor.getViewSize(); // view size
        var ps = getPickerDims(this); // picker size
        var a, b, c;
        switch (this.pickerPosition.toLowerCase()) {
          case 'left':
            a = 1;
            b = 0;
            c = -1;
            break;
          case 'right':
            a = 1;
            b = 0;
            c = 1;
            break;
          case 'top':
            a = 0;
            b = 1;
            c = -1;
            break;
          default:
            a = 0;
            b = 1;
            c = 1;
            break;
        }
        var l = (ts[b] + ps[b]) / 2;

        // picker pos
        if (!this.pickerSmartPosition) {
          var pp = [tp[a], tp[b] + ts[b] - l + l * c];
        } else {
          var pp = [-vp[a] + tp[a] + ps[a] > vs[a] ? -vp[a] + tp[a] + ts[a] / 2 > vs[a] / 2 && tp[a] + ts[a] - ps[a] >= 0 ? tp[a] + ts[a] - ps[a] : tp[a] : tp[a], -vp[b] + tp[b] + ts[b] + ps[b] - l + l * c > vs[b] ? -vp[b] + tp[b] + ts[b] / 2 > vs[b] / 2 && tp[b] + ts[b] - l - l * c >= 0 ? tp[b] + ts[b] - l - l * c : tp[b] + ts[b] - l + l * c : tp[b] + ts[b] - l + l * c >= 0 ? tp[b] + ts[b] - l + l * c : tp[b] + ts[b] - l - l * c];
        }
        drawPicker(pp[a], pp[b]);
      }
    };

    this.importColor = function () {
      if (!valueElement) {
        this.exportColor();
      } else {
        if (!this.adjust) {
          if (!this.fromString(valueElement.value, leaveValue)) {
            styleElement.style.backgroundImage = styleElement.jscStyle.backgroundImage;
            styleElement.style.backgroundColor = styleElement.jscStyle.backgroundColor;
            styleElement.style.color = styleElement.jscStyle.color;
            this.exportColor(leaveValue | leaveStyle);
          }
        } else if (!this.required && /^\s*$/.test(valueElement.value)) {
          valueElement.value = '';
          styleElement.style.backgroundImage = styleElement.jscStyle.backgroundImage;
          styleElement.style.backgroundColor = styleElement.jscStyle.backgroundColor;
          styleElement.style.color = styleElement.jscStyle.color;
          this.exportColor(leaveValue | leaveStyle);
        } else if (this.fromString(valueElement.value)) {
          // OK
        } else {
          this.exportColor();
        }
      }
    };

    this.exportColor = function (flags) {
      if (!(flags & leaveValue) && valueElement) {
        var value = this.toString();
        if (this.caps) {
          value = value.toUpperCase();
        }
        if (this.hash) {
          value = '#' + value;
        }
        valueElement.value = value;
      }
      if (!(flags & leaveStyle) && styleElement) {
        styleElement.style.backgroundImage = "none";
        styleElement.style.backgroundColor = '#' + this.toString();
        styleElement.style.color = 0.213 * this.rgb[0] + 0.715 * this.rgb[1] + 0.072 * this.rgb[2] < 0.5 ? '#FFF' : '#000';
      }
      if (!(flags & leavePad) && isPickerOwner()) {
        redrawPad();
      }
      if (!(flags & leaveSld) && isPickerOwner()) {
        redrawSld();
      }
    };

    this.fromHSV = function (h, s, v, flags) {
      // null = don't change
      if (h !== null) {
        h = Math.max(0.0, this.minH, Math.min(6.0, this.maxH, h));
      }
      if (s !== null) {
        s = Math.max(0.0, this.minS, Math.min(1.0, this.maxS, s));
      }
      if (v !== null) {
        v = Math.max(0.0, this.minV, Math.min(1.0, this.maxV, v));
      }

      this.rgb = HSV_RGB(h === null ? this.hsv[0] : this.hsv[0] = h, s === null ? this.hsv[1] : this.hsv[1] = s, v === null ? this.hsv[2] : this.hsv[2] = v);

      this.exportColor(flags);
    };

    this.fromRGB = function (r, g, b, flags) {
      // null = don't change
      if (r !== null) {
        r = Math.max(0.0, Math.min(1.0, r));
      }
      if (g !== null) {
        g = Math.max(0.0, Math.min(1.0, g));
      }
      if (b !== null) {
        b = Math.max(0.0, Math.min(1.0, b));
      }

      var hsv = RGB_HSV(r === null ? this.rgb[0] : r, g === null ? this.rgb[1] : g, b === null ? this.rgb[2] : b);
      if (hsv[0] !== null) {
        this.hsv[0] = Math.max(0.0, this.minH, Math.min(6.0, this.maxH, hsv[0]));
      }
      if (hsv[2] !== 0) {
        this.hsv[1] = hsv[1] === null ? null : Math.max(0.0, this.minS, Math.min(1.0, this.maxS, hsv[1]));
      }
      this.hsv[2] = hsv[2] === null ? null : Math.max(0.0, this.minV, Math.min(1.0, this.maxV, hsv[2]));

      // update RGB according to final HSV, as some values might be trimmed
      var rgb = HSV_RGB(this.hsv[0], this.hsv[1], this.hsv[2]);
      this.rgb[0] = rgb[0];
      this.rgb[1] = rgb[1];
      this.rgb[2] = rgb[2];

      this.exportColor(flags);
    };

    this.fromString = function (hex, flags) {
      var m = hex.match(/^\W*([0-9A-F]{3}([0-9A-F]{3})?)\W*$/i);
      if (!m) {
        return false;
      } else {
        if (m[1].length === 6) {
          // 6-char notation
          this.fromRGB(parseInt(m[1].substr(0, 2), 16) / 255, parseInt(m[1].substr(2, 2), 16) / 255, parseInt(m[1].substr(4, 2), 16) / 255, flags);
        } else {
          // 3-char notation
          this.fromRGB(parseInt(m[1].charAt(0) + m[1].charAt(0), 16) / 255, parseInt(m[1].charAt(1) + m[1].charAt(1), 16) / 255, parseInt(m[1].charAt(2) + m[1].charAt(2), 16) / 255, flags);
        }
        return true;
      }
    };

    this.toString = function () {
      return (0x100 | Math.round(255 * this.rgb[0])).toString(16).substr(1) + (0x100 | Math.round(255 * this.rgb[1])).toString(16).substr(1) + (0x100 | Math.round(255 * this.rgb[2])).toString(16).substr(1);
    };

    function RGB_HSV(r, g, b) {
      var n = Math.min(Math.min(r, g), b);
      var v = Math.max(Math.max(r, g), b);
      var m = v - n;
      if (m === 0) {
        return [null, 0, v];
      }
      var h = r === n ? 3 + (b - g) / m : g === n ? 5 + (r - b) / m : 1 + (g - r) / m;
      return [h === 6 ? 0 : h, m / v, v];
    }

    function HSV_RGB(h, s, v) {
      if (h === null) {
        return [v, v, v];
      }
      var i = Math.floor(h);
      var f = i % 2 ? h - i : 1 - (h - i);
      var m = v * (1 - s);
      var n = v * (1 - s * f);
      switch (i) {
        case 6:
        case 0:
          return [v, n, m];
        case 1:
          return [n, v, m];
        case 2:
          return [m, v, n];
        case 3:
          return [m, n, v];
        case 4:
          return [n, m, v];
        case 5:
          return [v, m, n];
      }
    }

    function removePicker() {
      delete jscolor.picker.owner;
      document.getElementsByTagName('body')[0].removeChild(jscolor.picker.boxB);
    }

    function drawPicker(x, y) {
      if (!jscolor.picker) {
        jscolor.picker = {
          box: document.createElement('div'),
          boxB: document.createElement('div'),
          pad: document.createElement('div'),
          padB: document.createElement('div'),
          padM: document.createElement('div'),
          sld: document.createElement('div'),
          sldB: document.createElement('div'),
          sldM: document.createElement('div'),
          btn: document.createElement('div'),
          btnS: document.createElement('span'),
          btnT: document.createTextNode(THIS.pickerCloseText)
        };
        for (var i = 0, segSize = 4; i < jscolor.images.sld[1]; i += segSize) {
          var seg = document.createElement('div');
          seg.style.height = segSize + 'px';
          seg.style.fontSize = '1px';
          seg.style.lineHeight = '0';
          jscolor.picker.sld.appendChild(seg);
        }
        jscolor.picker.sldB.appendChild(jscolor.picker.sld);
        jscolor.picker.box.appendChild(jscolor.picker.sldB);
        jscolor.picker.box.appendChild(jscolor.picker.sldM);
        jscolor.picker.padB.appendChild(jscolor.picker.pad);
        jscolor.picker.box.appendChild(jscolor.picker.padB);
        jscolor.picker.box.appendChild(jscolor.picker.padM);
        jscolor.picker.btnS.appendChild(jscolor.picker.btnT);
        jscolor.picker.btn.appendChild(jscolor.picker.btnS);
        jscolor.picker.box.appendChild(jscolor.picker.btn);
        jscolor.picker.boxB.appendChild(jscolor.picker.box);
      }

      var p = jscolor.picker;

      // controls interaction
      p.box.onmouseup = p.box.onmouseout = function () {
        target.focus();
      };
      p.box.onmousedown = function () {
        abortBlur = true;
      };
      p.box.onmousemove = function (e) {
        if (holdPad || holdSld) {
          holdPad && setPad(e);
          holdSld && setSld(e);
          if (document.selection) {
            document.selection.empty();
          } else if (window.getSelection) {
            window.getSelection().removeAllRanges();
          }
          dispatchImmediateChange();
        }
      };
      if ('ontouchstart' in window) {
        // if touch device
        var handle_touchmove = function handle_touchmove(e) {
          var event = {
            'offsetX': e.touches[0].pageX - touchOffset.X,
            'offsetY': e.touches[0].pageY - touchOffset.Y
          };
          if (holdPad || holdSld) {
            holdPad && setPad(event);
            holdSld && setSld(event);
            dispatchImmediateChange();
          }
          e.stopPropagation(); // prevent move "view" on broswer
          e.preventDefault(); // prevent Default - Android Fix (else android generated only 1-2 touchmove events)
        };
        p.box.removeEventListener('touchmove', handle_touchmove, false);
        p.box.addEventListener('touchmove', handle_touchmove, false);
      }
      p.padM.onmouseup = p.padM.onmouseout = function () {
        if (holdPad) {
          holdPad = false;
          jscolor.fireEvent(valueElement, 'change');
        }
      };
      p.padM.onmousedown = function (e) {
        // if the slider is at the bottom, move it up
        switch (modeID) {
          case 0:
            if (THIS.hsv[2] === 0) {
              THIS.fromHSV(null, null, 1.0);
            }

            break;
          case 1:
            if (THIS.hsv[1] === 0) {
              THIS.fromHSV(null, 1.0, null);
            }

            break;
        }
        holdSld = false;
        holdPad = true;
        setPad(e);
        dispatchImmediateChange();
      };
      if ('ontouchstart' in window) {
        p.padM.addEventListener('touchstart', function (e) {
          touchOffset = {
            'X': e.target.offsetParent.offsetLeft,
            'Y': e.target.offsetParent.offsetTop
          };
          this.onmousedown({
            'offsetX': e.touches[0].pageX - touchOffset.X,
            'offsetY': e.touches[0].pageY - touchOffset.Y
          });
        });
      }
      p.sldM.onmouseup = p.sldM.onmouseout = function () {
        if (holdSld) {
          holdSld = false;
          jscolor.fireEvent(valueElement, 'change');
        }
      };
      p.sldM.onmousedown = function (e) {
        holdPad = false;
        holdSld = true;
        setSld(e);
        dispatchImmediateChange();
      };
      if ('ontouchstart' in window) {
        p.sldM.addEventListener('touchstart', function (e) {
          touchOffset = {
            'X': e.target.offsetParent.offsetLeft,
            'Y': e.target.offsetParent.offsetTop
          };
          this.onmousedown({
            'offsetX': e.touches[0].pageX - touchOffset.X,
            'offsetY': e.touches[0].pageY - touchOffset.Y
          });
        });
      }

      // picker
      var dims = getPickerDims(THIS);
      p.box.style.width = dims[0] + 'px';
      p.box.style.height = dims[1] + 'px';

      // picker border
      p.boxB.style.position = 'absolute';
      p.boxB.style.clear = 'both';
      p.boxB.style.left = x + 'px';
      p.boxB.style.top = y + 'px';
      p.boxB.style.zIndex = THIS.pickerZIndex;
      p.boxB.style.border = THIS.pickerBorder + 'px solid';
      p.boxB.style.borderColor = THIS.pickerBorderColor;
      p.boxB.style.background = THIS.pickerFaceColor;

      // pad image
      p.pad.style.width = jscolor.images.pad[0] + 'px';
      p.pad.style.height = jscolor.images.pad[1] + 'px';

      // pad border
      p.padB.style.position = 'absolute';
      p.padB.style.left = THIS.pickerFace + 'px';
      p.padB.style.top = THIS.pickerFace + 'px';
      p.padB.style.border = THIS.pickerInset + 'px solid';
      p.padB.style.borderColor = THIS.pickerInsetColor;

      // pad mouse area
      p.padM.style.position = 'absolute';
      p.padM.style.left = '0';
      p.padM.style.top = '0';
      p.padM.style.width = THIS.pickerFace + 2 * THIS.pickerInset + jscolor.images.pad[0] + jscolor.images.arrow[0] + 'px';
      p.padM.style.height = p.box.style.height;
      p.padM.style.cursor = 'crosshair';

      // slider image
      p.sld.style.overflow = 'hidden';
      p.sld.style.width = jscolor.images.sld[0] + 'px';
      p.sld.style.height = jscolor.images.sld[1] + 'px';

      // slider border
      p.sldB.style.display = THIS.slider ? 'block' : 'none';
      p.sldB.style.position = 'absolute';
      p.sldB.style.right = THIS.pickerFace + 'px';
      p.sldB.style.top = THIS.pickerFace + 'px';
      p.sldB.style.border = THIS.pickerInset + 'px solid';
      p.sldB.style.borderColor = THIS.pickerInsetColor;

      // slider mouse area
      p.sldM.style.display = THIS.slider ? 'block' : 'none';
      p.sldM.style.position = 'absolute';
      p.sldM.style.right = '0';
      p.sldM.style.top = '0';
      p.sldM.style.width = jscolor.images.sld[0] + jscolor.images.arrow[0] + THIS.pickerFace + 2 * THIS.pickerInset + 'px';
      p.sldM.style.height = p.box.style.height;
      try {
        p.sldM.style.cursor = 'pointer';
      } catch (eOldIE) {
        p.sldM.style.cursor = 'hand';
      }

      // "close" button
      function setBtnBorder() {
        var insetColors = THIS.pickerInsetColor.split(/\s+/);
        var pickerOutsetColor = insetColors.length < 2 ? insetColors[0] : insetColors[1] + ' ' + insetColors[0] + ' ' + insetColors[0] + ' ' + insetColors[1];
        p.btn.style.borderColor = pickerOutsetColor;
      }

      p.btn.style.display = THIS.pickerClosable ? 'block' : 'none';
      p.btn.style.position = 'absolute';
      p.btn.style.left = THIS.pickerFace + 'px';
      p.btn.style.bottom = THIS.pickerFace + 'px';
      p.btn.style.padding = '0 15px';
      p.btn.style.height = '18px';
      p.btn.style.border = THIS.pickerInset + 'px solid';
      setBtnBorder();
      p.btn.style.color = THIS.pickerButtonColor;
      p.btn.style.font = '12px sans-serif';
      p.btn.style.textAlign = 'center';
      try {
        p.btn.style.cursor = 'pointer';
      } catch (eOldIE) {
        p.btn.style.cursor = 'hand';
      }
      p.btn.onmousedown = function () {
        THIS.hidePicker();
      };
      p.btnS.style.lineHeight = p.btn.style.height;

      // load images in optimal order
      switch (modeID) {
        case 0:
          var padImg = _hs2.default;
          break;
        case 1:
          var padImg = _hv2.default;
          break;
      }

      p.padM.style.backgroundImage = "url('" + _cross2.default + "')";
      p.padM.style.backgroundRepeat = "no-repeat";
      p.sldM.style.backgroundImage = "url('./" + _arrow2.default + "')";
      p.sldM.style.backgroundRepeat = "no-repeat";
      p.pad.style.backgroundImage = "url('" + padImg + "')";
      p.pad.style.backgroundRepeat = "no-repeat";
      p.pad.style.backgroundPosition = "0 0";

      // place pointers
      redrawPad();
      redrawSld();

      jscolor.picker.owner = THIS;
      document.getElementsByTagName('body')[0].appendChild(p.boxB);
    }

    function getPickerDims(o) {
      var dims = [2 * o.pickerInset + 2 * o.pickerFace + jscolor.images.pad[0] + (o.slider ? 2 * o.pickerInset + 2 * jscolor.images.arrow[0] + jscolor.images.sld[0] : 0), o.pickerClosable ? 4 * o.pickerInset + 3 * o.pickerFace + jscolor.images.pad[1] + o.pickerButtonHeight : 2 * o.pickerInset + 2 * o.pickerFace + jscolor.images.pad[1]];
      return dims;
    }

    function redrawPad() {
      // redraw the pad pointer
      switch (modeID) {
        case 0:
          var yComponent = 1;
          break;
        case 1:
          var yComponent = 2;
          break;
      }
      var x = Math.round(THIS.hsv[0] / 6 * (jscolor.images.pad[0] - 1));
      var y = Math.round((1 - THIS.hsv[yComponent]) * (jscolor.images.pad[1] - 1));
      jscolor.picker.padM.style.backgroundPosition = THIS.pickerFace + THIS.pickerInset + x - Math.floor(jscolor.images.cross[0] / 2) + 'px ' + (THIS.pickerFace + THIS.pickerInset + y - Math.floor(jscolor.images.cross[1] / 2)) + 'px';

      // redraw the slider image
      var seg = jscolor.picker.sld.childNodes;

      switch (modeID) {
        case 0:
          var rgb = HSV_RGB(THIS.hsv[0], THIS.hsv[1], 1);
          for (var i = 0; i < seg.length; i += 1) {
            seg[i].style.backgroundColor = 'rgb(' + rgb[0] * (1 - i / seg.length) * 100 + '%,' + rgb[1] * (1 - i / seg.length) * 100 + '%,' + rgb[2] * (1 - i / seg.length) * 100 + '%)';
          }
          break;
        case 1:
          var rgb,
              s,
              c = [THIS.hsv[2], 0, 0];
          var i = Math.floor(THIS.hsv[0]);
          var f = i % 2 ? THIS.hsv[0] - i : 1 - (THIS.hsv[0] - i);
          switch (i) {
            case 6:
            case 0:
              rgb = [0, 1, 2];
              break;
            case 1:
              rgb = [1, 0, 2];
              break;
            case 2:
              rgb = [2, 0, 1];
              break;
            case 3:
              rgb = [2, 1, 0];
              break;
            case 4:
              rgb = [1, 2, 0];
              break;
            case 5:
              rgb = [0, 2, 1];
              break;
          }
          for (var i = 0; i < seg.length; i += 1) {
            s = 1 - 1 / (seg.length - 1) * i;
            c[1] = c[0] * (1 - s * f);
            c[2] = c[0] * (1 - s);
            seg[i].style.backgroundColor = 'rgb(' + c[rgb[0]] * 100 + '%,' + c[rgb[1]] * 100 + '%,' + c[rgb[2]] * 100 + '%)';
          }
          break;
      }
    }

    function redrawSld() {
      // redraw the slider pointer
      switch (modeID) {
        case 0:
          var yComponent = 2;
          break;
        case 1:
          var yComponent = 1;
          break;
      }
      var y = Math.round((1 - THIS.hsv[yComponent]) * (jscolor.images.sld[1] - 1));
      jscolor.picker.sldM.style.backgroundPosition = '0 ' + (THIS.pickerFace + THIS.pickerInset + y - Math.floor(jscolor.images.arrow[1] / 2)) + 'px';
    }

    function isPickerOwner() {
      return jscolor.picker && jscolor.picker.owner === THIS;
    }

    function blurTarget() {
      if (valueElement === target) {
        THIS.importColor();
      }
      if (THIS.pickerOnfocus) {
        THIS.hidePicker();
      }
    }

    function blurValue() {
      if (valueElement !== target) {
        THIS.importColor();
      }
    }

    function setPad(e) {
      var mpos = jscolor.getRelMousePos(e);
      var x = mpos.x - THIS.pickerFace - THIS.pickerInset;
      var y = mpos.y - THIS.pickerFace - THIS.pickerInset;
      switch (modeID) {
        case 0:
          THIS.fromHSV(x * (6 / (jscolor.images.pad[0] - 1)), 1 - y / (jscolor.images.pad[1] - 1), null, leaveSld);
          break;
        case 1:
          THIS.fromHSV(x * (6 / (jscolor.images.pad[0] - 1)), null, 1 - y / (jscolor.images.pad[1] - 1), leaveSld);
          break;
      }
    }

    function setSld(e) {
      var mpos = jscolor.getRelMousePos(e);
      var y = mpos.y - THIS.pickerFace - THIS.pickerInset;
      switch (modeID) {
        case 0:
          THIS.fromHSV(null, null, 1 - y / (jscolor.images.sld[1] - 1), leavePad);
          break;
        case 1:
          THIS.fromHSV(null, 1 - y / (jscolor.images.sld[1] - 1), null, leavePad);
          break;
      }
    }

    function dispatchImmediateChange() {
      if (THIS.onImmediateChange) {
        var callback;
        if (typeof THIS.onImmediateChange === 'string') {
          callback = new Function(THIS.onImmediateChange);
        } else {
          callback = THIS.onImmediateChange;
        }
        callback.call(THIS);
      }
    }

    var THIS = this;
    var modeID = this.pickerMode.toLowerCase() === 'hvs' ? 1 : 0;
    var abortBlur = false;
    var valueElement = jscolor.fetchElement(this.valueElement),
        styleElement = jscolor.fetchElement(this.styleElement);
    var holdPad = false,
        holdSld = false,
        touchOffset = {};
    var leaveValue = 1 << 0,
        leaveStyle = 1 << 1,
        leavePad = 1 << 2,
        leaveSld = 1 << 3;

    // target
    jscolor.addEvent(target, 'focus', function () {
      if (THIS.pickerOnfocus) {
        THIS.showPicker();
      }
    });
    jscolor.addEvent(target, 'blur', function () {
      if (!abortBlur) {
        window.setTimeout(function () {
          abortBlur || blurTarget();
          abortBlur = false;
        }, 0);
      } else {
        abortBlur = false;
      }
    });

    // valueElement
    if (valueElement) {
      var updateField = function updateField() {
        THIS.fromString(valueElement.value, leaveValue);
        dispatchImmediateChange();
      };
      jscolor.addEvent(valueElement, 'keyup', updateField);
      jscolor.addEvent(valueElement, 'input', updateField);
      jscolor.addEvent(valueElement, 'blur', blurValue);
      valueElement.setAttribute('autocomplete', 'off');
    }

    // styleElement
    if (styleElement) {
      styleElement.jscStyle = {
        backgroundImage: styleElement.style.backgroundImage,
        backgroundColor: styleElement.style.backgroundColor,
        color: styleElement.style.color
      };
    }

    // require images
    switch (modeID) {
      case 0:
        jscolor.requireImage(_hs2.default);
        break;
      case 1:
        jscolor.requireImage(_hv2.default);
        break;
    }
    jscolor.requireImage(_cross2.default);
    jscolor.requireImage(_arrow2.default);

    this.importColor();
  }

};
module.exports = exports["default"];

/***/ }),

/***/ "./app/frontend/designer/js/widget/ui.anglepicker.js":
/*!***********************************************************!*\
  !*** ./app/frontend/designer/js/widget/ui.anglepicker.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
    ui.anglepicker
*/

$.widget("ui.anglepicker", $.ui.mouse, {
  widgetEventPrefix: "angle",
  _init: function _init() {
    this._mouseInit();
    this.pointer = $('<div class="ui-anglepicker-pointer"></div>');
    this.pointer.append('<div class="ui-anglepicker-dot"></div>');
    this.pointer.append('<div class="ui-anglepicker-line"></div>');

    this.element.addClass("ui-anglepicker");
    this.element.append(this.pointer);

    this.setDegrees(this.options.value);
  },
  _propagate: function _propagate(name, event) {
    this._trigger(name, event, this.ui());
  },
  _create: function _create() {},
  destroy: function destroy() {
    this._mouseDestroy();

    this.element.removeClass("ui-anglepicker");
    this.pointer.remove();
  },
  _mouseStart: function _mouseStart(event) {
    var myOffset = this.element.offset();
    this.width = this.element.width();
    this.height = this.element.height();

    this.startOffset = {
      x: myOffset.left + this.width / 2,
      y: myOffset.top + this.height / 2
    };

    this.element.addClass("ui-anglepicker-dragging");
    this.setDegreesFromEvent(event);
    this._propagate("start", event);
  },
  _mouseStop: function _mouseStop(event) {
    this.element.removeClass("ui-anglepicker-dragging");
    this._propagate("stop", event);
  },
  _mouseDrag: function _mouseDrag(event) {
    this.setDegreesFromEvent(event);
    this._propagate("change", event);
  },
  _setOption: function _setOption(key, value) {

    this._super(key, value);
  },

  ui: function ui() {
    return {
      element: this.element,
      value: this.options.value
    };
  },
  value: function value(newValue) {

    if (!arguments.length) {
      return this.options.value;
    }

    var oldValue = this.options.value;
    this.setDegrees(newValue);

    if (oldValue !== this.options.value) {
      this._propagate("change");
    }

    return this;
  },
  drawRotation: function drawRotation() {
    var value = this.options.clockwise ? this.options.value : -this.options.value;
    var rotation = 'rotate(' + -value + 'deg)';

    this.pointer.css({
      '-webkit-transform': rotation,
      '-moz-transform': rotation,
      '-ms-transform': rotation,
      '-o-transform': rotation,
      'transform': rotation
    });
  },
  setDegrees: function setDegrees(degrees) {
    this.options.value = this.clamp(degrees);
    this.drawRotation();
  },
  clamp: function clamp(degrees) {
    if (typeof degrees !== "number") {
      degrees = 0;
    }

    var min = this.options.min,
        max = min + 360;

    while (degrees < min) {
      degrees += 360;
    }
    while (degrees > max) {
      degrees -= 360;
    }

    return degrees;
  },
  setDegreesFromEvent: function setDegreesFromEvent(event) {
    var opposite = this.startOffset.y - event.pageY;
    opposite = this.options.clockwise ? opposite : -opposite;

    var adjacent = event.pageX - this.startOffset.x,
        radians = Math.atan(opposite / adjacent),
        degrees = Math.round(radians * (180 / Math.PI), 10);

    if (event.shiftKey) {
      degrees = this.roundToMultiple(degrees, this.options.shiftSnap);
    } else {
      degrees = this.roundToMultiple(degrees, this.options.snap);
    }

    if (adjacent < 0 && opposite >= 0) {
      degrees += 180;
    } else if (opposite < 0 && adjacent < 0) {
      degrees -= 180;
    }

    this.setDegrees(degrees);
  },
  roundToMultiple: function roundToMultiple(number, multiple) {
    var value = number / multiple,
        integer = Math.floor(value),
        rest = value - integer;

    return rest > 0.5 ? (integer + 1) * multiple : integer * multiple;
  },
  options: {
    distance: 1,
    delay: 1,
    snap: 1,
    min: 0,
    shiftSnap: 15,
    value: 90,
    clockwise: true // anti-clockwise if false
  }
});

/***/ }),

/***/ "./app/frontend/designer/less/index.less":
/*!***********************************************!*\
  !*** ./app/frontend/designer/less/index.less ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../../node_modules/css-loader/dist/cjs.js!../../../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./app/frontend/designer/less/index.less");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./app/frontend/designer/lib/inlineSVG.js":
/*!************************************************!*\
  !*** ./app/frontend/designer/lib/inlineSVG.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (root, factory) {

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory(root)),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
})(typeof global !== "undefined" ? global : undefined.window || undefined.global, function (root) {

    // Variables
    var inlineSVG = {},
        supports = !!document.querySelector && !!root.addEventListener,
        settings;

    // Defaults
    var defaults = {
        initClass: 'js-inlinesvg',
        svgSelector: 'img.svg'
    };

    /**
     * Stolen from underscore.js
     * @private
     * @param {Int} times
     * @param {Function} func
     */

    var after = function after(times, func) {
        return function () {
            if (--times < 1) {
                return func.apply(this, arguments);
            }
        };
    };

    /**
     * Merge two objects together
     * @private
     * @param {Function} fn
     */
    var extend = function extend() {

        // Variables
        var extended = {};
        var deep = false;
        var i = 0;
        var length = arguments.length;

        // Check if a deep merge
        if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {
            deep = arguments[0];
            i++;
        }

        // Merge the object into the extended object
        var merge = function merge(obj) {
            for (var prop in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                    // If deep merge and property is an object, merge properties
                    if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {
                        extended[prop] = extend(true, extended[prop], obj[prop]);
                    } else {
                        extended[prop] = obj[prop];
                    }
                }
            }
        };

        // Loop through each object and conduct a merge
        for (; i < length; i++) {
            var obj = arguments[i];
            merge(obj);
        }

        return extended;
    };

    // Methods

    /**
     * Grab all the SVGs that match the selector
     * @public
     */
    var getAll = function getAll() {

        var svgs = document.querySelectorAll(settings.svgSelector);
        return svgs;
    };

    /**
     * Inline all the SVGs in the array
     * @public
     */
    var inliner = function inliner(cb) {

        var svgs = getAll();
        var callback = after(svgs.length, cb);

        Array.prototype.forEach.call(svgs, function (svg, i) {

            // Store some attributes of the image
            var src = svg.src || svg.getAttribute('data-src'),
                attributes = svg.attributes;

            // Get the contents of the SVG
            var request = new XMLHttpRequest();
            request.open('GET', src, true);

            request.onload = function () {

                if (request.status >= 200 && request.status < 400) {

                    // Setup a parser to convert the response to text/xml in order for it
                    // to be manipulated and changed
                    var parser = new DOMParser(),
                        result = parser.parseFromString(request.responseText, 'text/xml'),
                        inlinedSVG = result.getElementsByTagName('svg')[0];

                    var titles = inlinedSVG.getElementsByTagName('title');
                    while (titles[0]) {
                        titles[0].parentNode.removeChild(titles[0]);
                    }var descs = inlinedSVG.getElementsByTagName('desc');
                    while (descs[0]) {
                        descs[0].parentNode.removeChild(descs[0]);
                    } // Remove some of the attributes that aren't needed
                    inlinedSVG.removeAttribute('xmlns:a');
                    inlinedSVG.removeAttribute('width');
                    inlinedSVG.removeAttribute('height');
                    inlinedSVG.removeAttribute('x');
                    inlinedSVG.removeAttribute('y');
                    inlinedSVG.removeAttribute('enable-background');
                    inlinedSVG.removeAttribute('xmlns:xlink');
                    inlinedSVG.removeAttribute('xml:space');
                    inlinedSVG.removeAttribute('version');

                    // Add in the attributes from the original <img> except `src` or
                    // `alt`, we don't need either
                    Array.prototype.slice.call(attributes).forEach(function (attribute) {
                        if (attribute.name !== 'src' && attribute.name !== 'alt') {
                            inlinedSVG.setAttribute(attribute.name, attribute.value);
                        }
                    });

                    // Add an additional class to the inlined SVG to imply it was
                    // infact inlined, might be useful to know
                    if (inlinedSVG.classList) {
                        inlinedSVG.classList.add('inlined-svg');
                    } else {
                        inlinedSVG.className += ' ' + 'inlined-svg';
                    }

                    // Add in some accessibility quick wins
                    inlinedSVG.setAttribute('role', 'img');

                    // Use the `longdesc` attribute if one exists
                    if (attributes.longdesc) {
                        var description = document.createElementNS('http://www.w3.org/2000/svg', 'desc'),
                            descriptionText = document.createTextNode(attributes.longdesc.value);

                        description.appendChild(descriptionText);
                        inlinedSVG.insertBefore(description, inlinedSVG.firstChild);
                    }

                    // Use the `alt` attribute if one exists
                    if (attributes.alt) {
                        inlinedSVG.setAttribute('aria-labelledby', 'title');

                        var title = document.createElementNS('http://www.w3.org/2000/svg', 'title'),
                            titleText = document.createTextNode(attributes.alt.value);

                        title.appendChild(titleText);
                        inlinedSVG.insertBefore(title, inlinedSVG.firstChild);
                    }

                    // Replace the image with the SVG
                    svg.parentNode.replaceChild(inlinedSVG, svg);

                    // Fire the callback
                    callback(settings.svgSelector);
                } else {

                    console.error('There was an error retrieving the source of the SVG.');
                }
            };

            request.onerror = function () {
                console.error('There was an error connecting to the origin server.');
            };

            request.send();
        });
    };

    /**
     * Initialise the inliner
     * @public
     */
    inlineSVG.init = function (options, callback) {

        // Test for support
        if (!supports) return;

        // Merge users option with defaults
        settings = extend(defaults, options || {});

        // Kick-off the inliner
        inliner(callback || function () {});
    };

    return inlineSVG;
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/autolinker/dist/Autolinker.js":
/*!****************************************************!*\
  !*** ./node_modules/autolinker/dist/Autolinker.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Autolinker.js
 * 0.28.1
 *
 * Copyright(c) 2016 Gregory Jacobs <greg@greg-jacobs.com>
 * MIT License
 *
 * https://github.com/gregjacobs/Autolinker.js
 */
;(function(root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(this, function() {
/**
 * @class Autolinker
 * @extends Object
 *
 * Utility class used to process a given string of text, and wrap the matches in
 * the appropriate anchor (&lt;a&gt;) tags to turn them into links.
 *
 * Any of the configuration options may be provided in an Object (map) provided
 * to the Autolinker constructor, which will configure how the {@link #link link()}
 * method will process the links.
 *
 * For example:
 *
 *     var autolinker = new Autolinker( {
 *         newWindow : false,
 *         truncate  : 30
 *     } );
 *
 *     var html = autolinker.link( "Joe went to www.yahoo.com" );
 *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
 *
 *
 * The {@link #static-link static link()} method may also be used to inline
 * options into a single call, which may be more convenient for one-off uses.
 * For example:
 *
 *     var html = Autolinker.link( "Joe went to www.yahoo.com", {
 *         newWindow : false,
 *         truncate  : 30
 *     } );
 *     // produces: 'Joe went to <a href="http://www.yahoo.com">yahoo.com</a>'
 *
 *
 * ## Custom Replacements of Links
 *
 * If the configuration options do not provide enough flexibility, a {@link #replaceFn}
 * may be provided to fully customize the output of Autolinker. This function is
 * called once for each URL/Email/Phone#/Twitter Handle/Hashtag match that is
 * encountered.
 *
 * For example:
 *
 *     var input = "...";  // string with URLs, Email Addresses, Phone #s, Twitter Handles, and Hashtags
 *
 *     var linkedText = Autolinker.link( input, {
 *         replaceFn : function( autolinker, match ) {
 *             console.log( "href = ", match.getAnchorHref() );
 *             console.log( "text = ", match.getAnchorText() );
 *
 *             switch( match.getType() ) {
 *                 case 'url' :
 *                     console.log( "url: ", match.getUrl() );
 *
 *                     if( match.getUrl().indexOf( 'mysite.com' ) === -1 ) {
 *                         var tag = autolinker.getTagBuilder().build( match );  // returns an `Autolinker.HtmlTag` instance, which provides mutator methods for easy changes
 *                         tag.setAttr( 'rel', 'nofollow' );
 *                         tag.addClass( 'external-link' );
 *
 *                         return tag;
 *
 *                     } else {
 *                         return true;  // let Autolinker perform its normal anchor tag replacement
 *                     }
 *
 *                 case 'email' :
 *                     var email = match.getEmail();
 *                     console.log( "email: ", email );
 *
 *                     if( email === "my@own.address" ) {
 *                         return false;  // don't auto-link this particular email address; leave as-is
 *                     } else {
 *                         return;  // no return value will have Autolinker perform its normal anchor tag replacement (same as returning `true`)
 *                     }
 *
 *                 case 'phone' :
 *                     var phoneNumber = match.getPhoneNumber();
 *                     console.log( phoneNumber );
 *
 *                     return '<a href="http://newplace.to.link.phone.numbers.to/">' + phoneNumber + '</a>';
 *
 *                 case 'twitter' :
 *                     var twitterHandle = match.getTwitterHandle();
 *                     console.log( twitterHandle );
 *
 *                     return '<a href="http://newplace.to.link.twitter.handles.to/">' + twitterHandle + '</a>';
 *
 *                 case 'hashtag' :
 *                     var hashtag = match.getHashtag();
 *                     console.log( hashtag );
 *
 *                     return '<a href="http://newplace.to.link.hashtag.handles.to/">' + hashtag + '</a>';
 *             }
 *         }
 *     } );
 *
 *
 * The function may return the following values:
 *
 * - `true` (Boolean): Allow Autolinker to replace the match as it normally
 *   would.
 * - `false` (Boolean): Do not replace the current match at all - leave as-is.
 * - Any String: If a string is returned from the function, the string will be
 *   used directly as the replacement HTML for the match.
 * - An {@link Autolinker.HtmlTag} instance, which can be used to build/modify
 *   an HTML tag before writing out its HTML text.
 *
 * @constructor
 * @param {Object} [cfg] The configuration options for the Autolinker instance,
 *   specified in an Object (map).
 */
var Autolinker = function( cfg ) {
	cfg = cfg || {};

	this.version = Autolinker.version;

	this.urls = this.normalizeUrlsCfg( cfg.urls );
	this.email = typeof cfg.email === 'boolean' ? cfg.email : true;
	this.twitter = typeof cfg.twitter === 'boolean' ? cfg.twitter : true;
	this.phone = typeof cfg.phone === 'boolean' ? cfg.phone : true;
	this.hashtag = cfg.hashtag || false;
	this.newWindow = typeof cfg.newWindow === 'boolean' ? cfg.newWindow : true;
	this.stripPrefix = typeof cfg.stripPrefix === 'boolean' ? cfg.stripPrefix : true;

	// Validate the value of the `hashtag` cfg.
	var hashtag = this.hashtag;
	if( hashtag !== false && hashtag !== 'twitter' && hashtag !== 'facebook' && hashtag !== 'instagram' ) {
		throw new Error( "invalid `hashtag` cfg - see docs" );
	}

	this.truncate = this.normalizeTruncateCfg( cfg.truncate );
	this.className = cfg.className || '';
	this.replaceFn = cfg.replaceFn || null;

	this.htmlParser = null;
	this.matchers = null;
	this.tagBuilder = null;
};



/**
 * Automatically links URLs, Email addresses, Phone Numbers, Twitter handles,
 * and Hashtags found in the given chunk of HTML. Does not link URLs found
 * within HTML tags.
 *
 * For instance, if given the text: `You should go to http://www.yahoo.com`,
 * then the result will be `You should go to &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
 *
 * Example:
 *
 *     var linkedText = Autolinker.link( "Go to google.com", { newWindow: false } );
 *     // Produces: "Go to <a href="http://google.com">google.com</a>"
 *
 * @static
 * @param {String} textOrHtml The HTML or text to find matches within (depending
 *   on if the {@link #urls}, {@link #email}, {@link #phone}, {@link #twitter},
 *   and {@link #hashtag} options are enabled).
 * @param {Object} [options] Any of the configuration options for the Autolinker
 *   class, specified in an Object (map). See the class description for an
 *   example call.
 * @return {String} The HTML text, with matches automatically linked.
 */
Autolinker.link = function( textOrHtml, options ) {
	var autolinker = new Autolinker( options );
	return autolinker.link( textOrHtml );
};


/**
 * @static
 * @property {String} version (readonly)
 *
 * The Autolinker version number in the form major.minor.patch
 *
 * Ex: 0.25.1
 */
Autolinker.version = '0.28.1';


Autolinker.prototype = {
	constructor : Autolinker,  // fix constructor property

	/**
	 * @cfg {Boolean/Object} [urls=true]
	 *
	 * `true` if URLs should be automatically linked, `false` if they should not
	 * be.
	 *
	 * This option also accepts an Object form with 3 properties, to allow for
	 * more customization of what exactly gets linked. All default to `true`:
	 *
	 * @param {Boolean} schemeMatches `true` to match URLs found prefixed with a
	 *   scheme, i.e. `http://google.com`, or `other+scheme://google.com`,
	 *   `false` to prevent these types of matches.
	 * @param {Boolean} wwwMatches `true` to match urls found prefixed with
	 *   `'www.'`, i.e. `www.google.com`. `false` to prevent these types of
	 *   matches. Note that if the URL had a prefixed scheme, and
	 *   `schemeMatches` is true, it will still be linked.
	 * @param {Boolean} tldMatches `true` to match URLs with known top level
	 *   domains (.com, .net, etc.) that are not prefixed with a scheme or
	 *   `'www.'`. This option attempts to match anything that looks like a URL
	 *   in the given text. Ex: `google.com`, `asdf.org/?page=1`, etc. `false`
	 *   to prevent these types of matches.
	 */

	/**
	 * @cfg {Boolean} [email=true]
	 *
	 * `true` if email addresses should be automatically linked, `false` if they
	 * should not be.
	 */

	/**
	 * @cfg {Boolean} [twitter=true]
	 *
	 * `true` if Twitter handles ("@example") should be automatically linked,
	 * `false` if they should not be.
	 */

	/**
	 * @cfg {Boolean} [phone=true]
	 *
	 * `true` if Phone numbers ("(555)555-5555") should be automatically linked,
	 * `false` if they should not be.
	 */

	/**
	 * @cfg {Boolean/String} [hashtag=false]
	 *
	 * A string for the service name to have hashtags (ex: "#myHashtag")
	 * auto-linked to. The currently-supported values are:
	 *
	 * - 'twitter'
	 * - 'facebook'
	 * - 'instagram'
	 *
	 * Pass `false` to skip auto-linking of hashtags.
	 */

	/**
	 * @cfg {Boolean} [newWindow=true]
	 *
	 * `true` if the links should open in a new window, `false` otherwise.
	 */

	/**
	 * @cfg {Boolean} [stripPrefix=true]
	 *
	 * `true` if 'http://' or 'https://' and/or the 'www.' should be stripped
	 * from the beginning of URL links' text, `false` otherwise.
	 */

	/**
	 * @cfg {Number/Object} [truncate=0]
	 *
	 * ## Number Form
	 *
	 * A number for how many characters matched text should be truncated to
	 * inside the text of a link. If the matched text is over this number of
	 * characters, it will be truncated to this length by adding a two period
	 * ellipsis ('..') to the end of the string.
	 *
	 * For example: A url like 'http://www.yahoo.com/some/long/path/to/a/file'
	 * truncated to 25 characters might look something like this:
	 * 'yahoo.com/some/long/pat..'
	 *
	 * Example Usage:
	 *
	 *     truncate: 25
	 *
	 *
	 *  Defaults to `0` for "no truncation."
	 *
	 *
	 * ## Object Form
	 *
	 * An Object may also be provided with two properties: `length` (Number) and
	 * `location` (String). `location` may be one of the following: 'end'
	 * (default), 'middle', or 'smart'.
	 *
	 * Example Usage:
	 *
	 *     truncate: { length: 25, location: 'middle' }
	 *
	 * @cfg {Number} [truncate.length=0] How many characters to allow before
	 *   truncation will occur. Defaults to `0` for "no truncation."
	 * @cfg {"end"/"middle"/"smart"} [truncate.location="end"]
	 *
	 * - 'end' (default): will truncate up to the number of characters, and then
	 *   add an ellipsis at the end. Ex: 'yahoo.com/some/long/pat..'
	 * - 'middle': will truncate and add the ellipsis in the middle. Ex:
	 *   'yahoo.com/s..th/to/a/file'
	 * - 'smart': for URLs where the algorithm attempts to strip out unnecessary
	 *   parts first (such as the 'www.', then URL scheme, hash, etc.),
	 *   attempting to make the URL human-readable before looking for a good
	 *   point to insert the ellipsis if it is still too long. Ex:
	 *   'yahoo.com/some..to/a/file'. For more details, see
	 *   {@link Autolinker.truncate.TruncateSmart}.
	 */

	/**
	 * @cfg {String} className
	 *
	 * A CSS class name to add to the generated links. This class will be added
	 * to all links, as well as this class plus match suffixes for styling
	 * url/email/phone/twitter/hashtag links differently.
	 *
	 * For example, if this config is provided as "myLink", then:
	 *
	 * - URL links will have the CSS classes: "myLink myLink-url"
	 * - Email links will have the CSS classes: "myLink myLink-email", and
	 * - Twitter links will have the CSS classes: "myLink myLink-twitter"
	 * - Phone links will have the CSS classes: "myLink myLink-phone"
	 * - Hashtag links will have the CSS classes: "myLink myLink-hashtag"
	 */

	/**
	 * @cfg {Function} replaceFn
	 *
	 * A function to individually process each match found in the input string.
	 *
	 * See the class's description for usage.
	 *
	 * This function is called with the following parameters:
	 *
	 * @cfg {Autolinker} replaceFn.autolinker The Autolinker instance, which may
	 *   be used to retrieve child objects from (such as the instance's
	 *   {@link #getTagBuilder tag builder}).
	 * @cfg {Autolinker.match.Match} replaceFn.match The Match instance which
	 *   can be used to retrieve information about the match that the `replaceFn`
	 *   is currently processing. See {@link Autolinker.match.Match} subclasses
	 *   for details.
	 */


	/**
	 * @property {String} version (readonly)
	 *
	 * The Autolinker version number in the form major.minor.patch
	 *
	 * Ex: 0.25.1
	 */

	/**
	 * @private
	 * @property {Autolinker.htmlParser.HtmlParser} htmlParser
	 *
	 * The HtmlParser instance used to skip over HTML tags, while finding text
	 * nodes to process. This is lazily instantiated in the {@link #getHtmlParser}
	 * method.
	 */

	/**
	 * @private
	 * @property {Autolinker.matcher.Matcher[]} matchers
	 *
	 * The {@link Autolinker.matcher.Matcher} instances for this Autolinker
	 * instance.
	 *
	 * This is lazily created in {@link #getMatchers}.
	 */

	/**
	 * @private
	 * @property {Autolinker.AnchorTagBuilder} tagBuilder
	 *
	 * The AnchorTagBuilder instance used to build match replacement anchor tags.
	 * Note: this is lazily instantiated in the {@link #getTagBuilder} method.
	 */


	/**
	 * Normalizes the {@link #urls} config into an Object with 3 properties:
	 * `schemeMatches`, `wwwMatches`, and `tldMatches`, all Booleans.
	 *
	 * See {@link #urls} config for details.
	 *
	 * @private
	 * @param {Boolean/Object} urls
	 * @return {Object}
	 */
	normalizeUrlsCfg : function( urls ) {
		if( urls == null ) urls = true;  // default to `true`

		if( typeof urls === 'boolean' ) {
			return { schemeMatches: urls, wwwMatches: urls, tldMatches: urls };

		} else {  // object form
			return {
				schemeMatches : typeof urls.schemeMatches === 'boolean' ? urls.schemeMatches : true,
				wwwMatches    : typeof urls.wwwMatches === 'boolean'    ? urls.wwwMatches    : true,
				tldMatches    : typeof urls.tldMatches === 'boolean'    ? urls.tldMatches    : true
			};
		}
	},


	/**
	 * Normalizes the {@link #truncate} config into an Object with 2 properties:
	 * `length` (Number), and `location` (String).
	 *
	 * See {@link #truncate} config for details.
	 *
	 * @private
	 * @param {Number/Object} truncate
	 * @return {Object}
	 */
	normalizeTruncateCfg : function( truncate ) {
		if( typeof truncate === 'number' ) {
			return { length: truncate, location: 'end' };

		} else {  // object, or undefined/null
			return Autolinker.Util.defaults( truncate || {}, {
				length   : Number.POSITIVE_INFINITY,
				location : 'end'
			} );
		}
	},


	/**
	 * Parses the input `textOrHtml` looking for URLs, email addresses, phone
	 * numbers, username handles, and hashtags (depending on the configuration
	 * of the Autolinker instance), and returns an array of {@link Autolinker.match.Match}
	 * objects describing those matches.
	 *
	 * This method is used by the {@link #link} method, but can also be used to
	 * simply do parsing of the input in order to discover what kinds of links
	 * there are and how many.
	 *
	 * @param {String} textOrHtml The HTML or text to find matches within
	 *   (depending on if the {@link #urls}, {@link #email}, {@link #phone},
	 *   {@link #twitter}, and {@link #hashtag} options are enabled).
	 * @return {Autolinker.match.Match[]} The array of Matches found in the
	 *   given input `textOrHtml`.
	 */
	parse : function( textOrHtml ) {
		var htmlParser = this.getHtmlParser(),
		    htmlNodes = htmlParser.parse( textOrHtml ),
		    anchorTagStackCount = 0,  // used to only process text around anchor tags, and any inner text/html they may have;
		    matches = [];

		// Find all matches within the `textOrHtml` (but not matches that are
		// already nested within <a> tags)
		for( var i = 0, len = htmlNodes.length; i < len; i++ ) {
			var node = htmlNodes[ i ],
			    nodeType = node.getType();

			if( nodeType === 'element' && node.getTagName() === 'a' ) {  // Process HTML anchor element nodes in the input `textOrHtml` to find out when we're within an <a> tag
				if( !node.isClosing() ) {  // it's the start <a> tag
					anchorTagStackCount++;
				} else {  // it's the end </a> tag
					anchorTagStackCount = Math.max( anchorTagStackCount - 1, 0 );  // attempt to handle extraneous </a> tags by making sure the stack count never goes below 0
				}

			} else if( nodeType === 'text' && anchorTagStackCount === 0 ) {  // Process text nodes that are not within an <a> tag
				var textNodeMatches = this.parseText( node.getText(), node.getOffset() );

				matches.push.apply( matches, textNodeMatches );
			}
		}


		// After we have found all matches, remove subsequent matches that
		// overlap with a previous match. This can happen for instance with URLs,
		// where the url 'google.com/#link' would match '#link' as a hashtag.
		matches = this.compactMatches( matches );

		// And finally, remove matches for match types that have been turned
		// off. We needed to have all match types turned on initially so that
		// things like hashtags could be filtered out if they were really just
		// part of a URL match (for instance, as a named anchor).
		matches = this.removeUnwantedMatches( matches );

		return matches;
	},


	/**
	 * After we have found all matches, we need to remove subsequent matches
	 * that overlap with a previous match. This can happen for instance with
	 * URLs, where the url 'google.com/#link' would match '#link' as a hashtag.
	 *
	 * @private
	 * @param {Autolinker.match.Match[]} matches
	 * @return {Autolinker.match.Match[]}
	 */
	compactMatches : function( matches ) {
		// First, the matches need to be sorted in order of offset
		matches.sort( function( a, b ) { return a.getOffset() - b.getOffset(); } );

		for( var i = 0; i < matches.length - 1; i++ ) {
			var match = matches[ i ],
			    endIdx = match.getOffset() + match.getMatchedText().length;

			// Remove subsequent matches that overlap with the current match
			while( i + 1 < matches.length && matches[ i + 1 ].getOffset() <= endIdx ) {
				matches.splice( i + 1, 1 );
			}
		}

		return matches;
	},


	/**
	 * Removes matches for matchers that were turned off in the options. For
	 * example, if {@link #hashtag hashtags} were not to be matched, we'll
	 * remove them from the `matches` array here.
	 *
	 * @private
	 * @param {Autolinker.match.Match[]} matches The array of matches to remove
	 *   the unwanted matches from. Note: this array is mutated for the
	 *   removals.
	 * @return {Autolinker.match.Match[]} The mutated input `matches` array.
	 */
	removeUnwantedMatches : function( matches ) {
		var remove = Autolinker.Util.remove;

		if( !this.hashtag ) remove( matches, function( match ) { return match.getType() === 'hashtag'; } );
		if( !this.email )   remove( matches, function( match ) { return match.getType() === 'email'; } );
		if( !this.phone )   remove( matches, function( match ) { return match.getType() === 'phone'; } );
		if( !this.twitter ) remove( matches, function( match ) { return match.getType() === 'twitter'; } );
		if( !this.urls.schemeMatches ) {
			remove( matches, function( m ) { return m.getType() === 'url' && m.getUrlMatchType() === 'scheme'; } );
		}
		if( !this.urls.wwwMatches ) {
			remove( matches, function( m ) { return m.getType() === 'url' && m.getUrlMatchType() === 'www'; } );
		}
		if( !this.urls.tldMatches ) {
			remove( matches, function( m ) { return m.getType() === 'url' && m.getUrlMatchType() === 'tld'; } );
		}

		return matches;
	},


	/**
	 * Parses the input `text` looking for URLs, email addresses, phone
	 * numbers, username handles, and hashtags (depending on the configuration
	 * of the Autolinker instance), and returns an array of {@link Autolinker.match.Match}
	 * objects describing those matches.
	 *
	 * This method processes a **non-HTML string**, and is used to parse and
	 * match within the text nodes of an HTML string. This method is used
	 * internally by {@link #parse}.
	 *
	 * @private
	 * @param {String} text The text to find matches within (depending on if the
	 *   {@link #urls}, {@link #email}, {@link #phone}, {@link #twitter}, and
	 *   {@link #hashtag} options are enabled). This must be a non-HTML string.
	 * @param {Number} [offset=0] The offset of the text node within the
	 *   original string. This is used when parsing with the {@link #parse}
	 *   method to generate correct offsets within the {@link Autolinker.match.Match}
	 *   instances, but may be omitted if calling this method publicly.
	 * @return {Autolinker.match.Match[]} The array of Matches found in the
	 *   given input `text`.
	 */
	parseText : function( text, offset ) {
		offset = offset || 0;
		var matchers = this.getMatchers(),
		    matches = [];

		for( var i = 0, numMatchers = matchers.length; i < numMatchers; i++ ) {
			var textMatches = matchers[ i ].parseMatches( text );

			// Correct the offset of each of the matches. They are originally
			// the offset of the match within the provided text node, but we
			// need to correct them to be relative to the original HTML input
			// string (i.e. the one provided to #parse).
			for( var j = 0, numTextMatches = textMatches.length; j < numTextMatches; j++ ) {
				textMatches[ j ].setOffset( offset + textMatches[ j ].getOffset() );
			}

			matches.push.apply( matches, textMatches );
		}
		return matches;
	},


	/**
	 * Automatically links URLs, Email addresses, Phone numbers, Twitter
	 * handles, and Hashtags found in the given chunk of HTML. Does not link
	 * URLs found within HTML tags.
	 *
	 * For instance, if given the text: `You should go to http://www.yahoo.com`,
	 * then the result will be `You should go to
	 * &lt;a href="http://www.yahoo.com"&gt;http://www.yahoo.com&lt;/a&gt;`
	 *
	 * This method finds the text around any HTML elements in the input
	 * `textOrHtml`, which will be the text that is processed. Any original HTML
	 * elements will be left as-is, as well as the text that is already wrapped
	 * in anchor (&lt;a&gt;) tags.
	 *
	 * @param {String} textOrHtml The HTML or text to autolink matches within
	 *   (depending on if the {@link #urls}, {@link #email}, {@link #phone},
	 *   {@link #twitter}, and {@link #hashtag} options are enabled).
	 * @return {String} The HTML, with matches automatically linked.
	 */
	link : function( textOrHtml ) {
		if( !textOrHtml ) { return ""; }  // handle `null` and `undefined`

		var matches = this.parse( textOrHtml ),
			newHtml = [],
			lastIndex = 0;

		for( var i = 0, len = matches.length; i < len; i++ ) {
			var match = matches[ i ];

			newHtml.push( textOrHtml.substring( lastIndex, match.getOffset() ) );
			newHtml.push( this.createMatchReturnVal( match ) );

			lastIndex = match.getOffset() + match.getMatchedText().length;
		}
		newHtml.push( textOrHtml.substring( lastIndex ) );  // handle the text after the last match

		return newHtml.join( '' );
	},


	/**
	 * Creates the return string value for a given match in the input string.
	 *
	 * This method handles the {@link #replaceFn}, if one was provided.
	 *
	 * @private
	 * @param {Autolinker.match.Match} match The Match object that represents
	 *   the match.
	 * @return {String} The string that the `match` should be replaced with.
	 *   This is usually the anchor tag string, but may be the `matchStr` itself
	 *   if the match is not to be replaced.
	 */
	createMatchReturnVal : function( match ) {
		// Handle a custom `replaceFn` being provided
		var replaceFnResult;
		if( this.replaceFn ) {
			replaceFnResult = this.replaceFn.call( this, this, match );  // Autolinker instance is the context, and the first arg
		}

		if( typeof replaceFnResult === 'string' ) {
			return replaceFnResult;  // `replaceFn` returned a string, use that

		} else if( replaceFnResult === false ) {
			return match.getMatchedText();  // no replacement for the match

		} else if( replaceFnResult instanceof Autolinker.HtmlTag ) {
			return replaceFnResult.toAnchorString();

		} else {  // replaceFnResult === true, or no/unknown return value from function
			// Perform Autolinker's default anchor tag generation
			var anchorTag = match.buildTag();  // returns an Autolinker.HtmlTag instance

			return anchorTag.toAnchorString();
		}
	},


	/**
	 * Lazily instantiates and returns the {@link #htmlParser} instance for this
	 * Autolinker instance.
	 *
	 * @protected
	 * @return {Autolinker.htmlParser.HtmlParser}
	 */
	getHtmlParser : function() {
		var htmlParser = this.htmlParser;

		if( !htmlParser ) {
			htmlParser = this.htmlParser = new Autolinker.htmlParser.HtmlParser();
		}

		return htmlParser;
	},


	/**
	 * Lazily instantiates and returns the {@link Autolinker.matcher.Matcher}
	 * instances for this Autolinker instance.
	 *
	 * @protected
	 * @return {Autolinker.matcher.Matcher[]}
	 */
	getMatchers : function() {
		if( !this.matchers ) {
			var matchersNs = Autolinker.matcher,
			    tagBuilder = this.getTagBuilder();

			var matchers = [
				new matchersNs.Hashtag( { tagBuilder: tagBuilder, serviceName: this.hashtag } ),
				new matchersNs.Email( { tagBuilder: tagBuilder } ),
				new matchersNs.Phone( { tagBuilder: tagBuilder } ),
				new matchersNs.Twitter( { tagBuilder: tagBuilder } ),
				new matchersNs.Url( { tagBuilder: tagBuilder, stripPrefix: this.stripPrefix } )
			];

			return ( this.matchers = matchers );

		} else {
			return this.matchers;
		}
	},


	/**
	 * Returns the {@link #tagBuilder} instance for this Autolinker instance, lazily instantiating it
	 * if it does not yet exist.
	 *
	 * This method may be used in a {@link #replaceFn} to generate the {@link Autolinker.HtmlTag HtmlTag} instance that
	 * Autolinker would normally generate, and then allow for modifications before returning it. For example:
	 *
	 *     var html = Autolinker.link( "Test google.com", {
	 *         replaceFn : function( autolinker, match ) {
	 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance
	 *             tag.setAttr( 'rel', 'nofollow' );
	 *
	 *             return tag;
	 *         }
	 *     } );
	 *
	 *     // generated html:
	 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
	 *
	 * @return {Autolinker.AnchorTagBuilder}
	 */
	getTagBuilder : function() {
		var tagBuilder = this.tagBuilder;

		if( !tagBuilder ) {
			tagBuilder = this.tagBuilder = new Autolinker.AnchorTagBuilder( {
				newWindow   : this.newWindow,
				truncate    : this.truncate,
				className   : this.className
			} );
		}

		return tagBuilder;
	}

};


// Autolinker Namespaces

Autolinker.match = {};
Autolinker.matcher = {};
Autolinker.htmlParser = {};
Autolinker.truncate = {};

/*global Autolinker */
/*jshint eqnull:true, boss:true */
/**
 * @class Autolinker.Util
 * @singleton
 *
 * A few utility methods for Autolinker.
 */
Autolinker.Util = {

	/**
	 * @property {Function} abstractMethod
	 *
	 * A function object which represents an abstract method.
	 */
	abstractMethod : function() { throw "abstract"; },


	/**
	 * @private
	 * @property {RegExp} trimRegex
	 *
	 * The regular expression used to trim the leading and trailing whitespace
	 * from a string.
	 */
	trimRegex : /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,


	/**
	 * Assigns (shallow copies) the properties of `src` onto `dest`.
	 *
	 * @param {Object} dest The destination object.
	 * @param {Object} src The source object.
	 * @return {Object} The destination object (`dest`)
	 */
	assign : function( dest, src ) {
		for( var prop in src ) {
			if( src.hasOwnProperty( prop ) ) {
				dest[ prop ] = src[ prop ];
			}
		}

		return dest;
	},


	/**
	 * Assigns (shallow copies) the properties of `src` onto `dest`, if the
	 * corresponding property on `dest` === `undefined`.
	 *
	 * @param {Object} dest The destination object.
	 * @param {Object} src The source object.
	 * @return {Object} The destination object (`dest`)
	 */
	defaults : function( dest, src ) {
		for( var prop in src ) {
			if( src.hasOwnProperty( prop ) && dest[ prop ] === undefined ) {
				dest[ prop ] = src[ prop ];
			}
		}

		return dest;
	},


	/**
	 * Extends `superclass` to create a new subclass, adding the `protoProps` to the new subclass's prototype.
	 *
	 * @param {Function} superclass The constructor function for the superclass.
	 * @param {Object} protoProps The methods/properties to add to the subclass's prototype. This may contain the
	 *   special property `constructor`, which will be used as the new subclass's constructor function.
	 * @return {Function} The new subclass function.
	 */
	extend : function( superclass, protoProps ) {
		var superclassProto = superclass.prototype;

		var F = function() {};
		F.prototype = superclassProto;

		var subclass;
		if( protoProps.hasOwnProperty( 'constructor' ) ) {
			subclass = protoProps.constructor;
		} else {
			subclass = function() { superclassProto.constructor.apply( this, arguments ); };
		}

		var subclassProto = subclass.prototype = new F();  // set up prototype chain
		subclassProto.constructor = subclass;  // fix constructor property
		subclassProto.superclass = superclassProto;

		delete protoProps.constructor;  // don't re-assign constructor property to the prototype, since a new function may have been created (`subclass`), which is now already there
		Autolinker.Util.assign( subclassProto, protoProps );

		return subclass;
	},


	/**
	 * Truncates the `str` at `len - ellipsisChars.length`, and adds the `ellipsisChars` to the
	 * end of the string (by default, two periods: '..'). If the `str` length does not exceed
	 * `len`, the string will be returned unchanged.
	 *
	 * @param {String} str The string to truncate and add an ellipsis to.
	 * @param {Number} truncateLen The length to truncate the string at.
	 * @param {String} [ellipsisChars=..] The ellipsis character(s) to add to the end of `str`
	 *   when truncated. Defaults to '..'
	 */
	ellipsis : function( str, truncateLen, ellipsisChars ) {
		if( str.length > truncateLen ) {
			ellipsisChars = ( ellipsisChars == null ) ? '..' : ellipsisChars;
			str = str.substring( 0, truncateLen - ellipsisChars.length ) + ellipsisChars;
		}
		return str;
	},


	/**
	 * Supports `Array.prototype.indexOf()` functionality for old IE (IE8 and below).
	 *
	 * @param {Array} arr The array to find an element of.
	 * @param {*} element The element to find in the array, and return the index of.
	 * @return {Number} The index of the `element`, or -1 if it was not found.
	 */
	indexOf : function( arr, element ) {
		if( Array.prototype.indexOf ) {
			return arr.indexOf( element );

		} else {
			for( var i = 0, len = arr.length; i < len; i++ ) {
				if( arr[ i ] === element ) return i;
			}
			return -1;
		}
	},


	/**
	 * Removes array elements based on a filtering function. Mutates the input
	 * array.
	 *
	 * Using this instead of the ES5 Array.prototype.filter() function, to allow
	 * Autolinker compatibility with IE8, and also to prevent creating many new
	 * arrays in memory for filtering.
	 *
	 * @param {Array} arr The array to remove elements from. This array is
	 *   mutated.
	 * @param {Function} fn A function which should return `true` to
	 *   remove an element.
	 * @return {Array} The mutated input `arr`.
	 */
	remove : function( arr, fn ) {
		for( var i = arr.length - 1; i >= 0; i-- ) {
			if( fn( arr[ i ] ) === true ) {
				arr.splice( i, 1 );
			}
		}
	},


	/**
	 * Performs the functionality of what modern browsers do when `String.prototype.split()` is called
	 * with a regular expression that contains capturing parenthesis.
	 *
	 * For example:
	 *
	 *     // Modern browsers:
	 *     "a,b,c".split( /(,)/ );  // --> [ 'a', ',', 'b', ',', 'c' ]
	 *
	 *     // Old IE (including IE8):
	 *     "a,b,c".split( /(,)/ );  // --> [ 'a', 'b', 'c' ]
	 *
	 * This method emulates the functionality of modern browsers for the old IE case.
	 *
	 * @param {String} str The string to split.
	 * @param {RegExp} splitRegex The regular expression to split the input `str` on. The splitting
	 *   character(s) will be spliced into the array, as in the "modern browsers" example in the
	 *   description of this method.
	 *   Note #1: the supplied regular expression **must** have the 'g' flag specified.
	 *   Note #2: for simplicity's sake, the regular expression does not need
	 *   to contain capturing parenthesis - it will be assumed that any match has them.
	 * @return {String[]} The split array of strings, with the splitting character(s) included.
	 */
	splitAndCapture : function( str, splitRegex ) {
		if( !splitRegex.global ) throw new Error( "`splitRegex` must have the 'g' flag set" );

		var result = [],
		    lastIdx = 0,
		    match;

		while( match = splitRegex.exec( str ) ) {
			result.push( str.substring( lastIdx, match.index ) );
			result.push( match[ 0 ] );  // push the splitting char(s)

			lastIdx = match.index + match[ 0 ].length;
		}
		result.push( str.substring( lastIdx ) );

		return result;
	},


	/**
	 * Trims the leading and trailing whitespace from a string.
	 *
	 * @param {String} str The string to trim.
	 * @return {String}
	 */
	trim : function( str ) {
		return str.replace( this.trimRegex, '' );
	}

};
/*global Autolinker */
/*jshint boss:true */
/**
 * @class Autolinker.HtmlTag
 * @extends Object
 *
 * Represents an HTML tag, which can be used to easily build/modify HTML tags programmatically.
 *
 * Autolinker uses this abstraction to create HTML tags, and then write them out as strings. You may also use
 * this class in your code, especially within a {@link Autolinker#replaceFn replaceFn}.
 *
 * ## Examples
 *
 * Example instantiation:
 *
 *     var tag = new Autolinker.HtmlTag( {
 *         tagName : 'a',
 *         attrs   : { 'href': 'http://google.com', 'class': 'external-link' },
 *         innerHtml : 'Google'
 *     } );
 *
 *     tag.toAnchorString();  // <a href="http://google.com" class="external-link">Google</a>
 *
 *     // Individual accessor methods
 *     tag.getTagName();                 // 'a'
 *     tag.getAttr( 'href' );            // 'http://google.com'
 *     tag.hasClass( 'external-link' );  // true
 *
 *
 * Using mutator methods (which may be used in combination with instantiation config properties):
 *
 *     var tag = new Autolinker.HtmlTag();
 *     tag.setTagName( 'a' );
 *     tag.setAttr( 'href', 'http://google.com' );
 *     tag.addClass( 'external-link' );
 *     tag.setInnerHtml( 'Google' );
 *
 *     tag.getTagName();                 // 'a'
 *     tag.getAttr( 'href' );            // 'http://google.com'
 *     tag.hasClass( 'external-link' );  // true
 *
 *     tag.toAnchorString();  // <a href="http://google.com" class="external-link">Google</a>
 *
 *
 * ## Example use within a {@link Autolinker#replaceFn replaceFn}
 *
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( autolinker, match ) {
 *             var tag = match.buildTag();  // returns an {@link Autolinker.HtmlTag} instance, configured with the Match's href and anchor text
 *             tag.setAttr( 'rel', 'nofollow' );
 *
 *             return tag;
 *         }
 *     } );
 *
 *     // generated html:
 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
 *
 *
 * ## Example use with a new tag for the replacement
 *
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( autolinker, match ) {
 *             var tag = new Autolinker.HtmlTag( {
 *                 tagName : 'button',
 *                 attrs   : { 'title': 'Load URL: ' + match.getAnchorHref() },
 *                 innerHtml : 'Load URL: ' + match.getAnchorText()
 *             } );
 *
 *             return tag;
 *         }
 *     } );
 *
 *     // generated html:
 *     //   Test <button title="Load URL: http://google.com">Load URL: google.com</button>
 */
Autolinker.HtmlTag = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {String} tagName
	 *
	 * The tag name. Ex: 'a', 'button', etc.
	 *
	 * Not required at instantiation time, but should be set using {@link #setTagName} before {@link #toAnchorString}
	 * is executed.
	 */

	/**
	 * @cfg {Object.<String, String>} attrs
	 *
	 * An key/value Object (map) of attributes to create the tag with. The keys are the attribute names, and the
	 * values are the attribute values.
	 */

	/**
	 * @cfg {String} innerHtml
	 *
	 * The inner HTML for the tag.
	 *
	 * Note the camel case name on `innerHtml`. Acronyms are camelCased in this utility (such as not to run into the acronym
	 * naming inconsistency that the DOM developers created with `XMLHttpRequest`). You may alternatively use {@link #innerHTML}
	 * if you prefer, but this one is recommended.
	 */

	/**
	 * @cfg {String} innerHTML
	 *
	 * Alias of {@link #innerHtml}, accepted for consistency with the browser DOM api, but prefer the camelCased version
	 * for acronym names.
	 */


	/**
	 * @protected
	 * @property {RegExp} whitespaceRegex
	 *
	 * Regular expression used to match whitespace in a string of CSS classes.
	 */
	whitespaceRegex : /\s+/,


	/**
	 * @constructor
	 * @param {Object} [cfg] The configuration properties for this class, in an Object (map)
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );

		this.innerHtml = this.innerHtml || this.innerHTML;  // accept either the camelCased form or the fully capitalized acronym
	},


	/**
	 * Sets the tag name that will be used to generate the tag with.
	 *
	 * @param {String} tagName
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setTagName : function( tagName ) {
		this.tagName = tagName;
		return this;
	},


	/**
	 * Retrieves the tag name.
	 *
	 * @return {String}
	 */
	getTagName : function() {
		return this.tagName || "";
	},


	/**
	 * Sets an attribute on the HtmlTag.
	 *
	 * @param {String} attrName The attribute name to set.
	 * @param {String} attrValue The attribute value to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setAttr : function( attrName, attrValue ) {
		var tagAttrs = this.getAttrs();
		tagAttrs[ attrName ] = attrValue;

		return this;
	},


	/**
	 * Retrieves an attribute from the HtmlTag. If the attribute does not exist, returns `undefined`.
	 *
	 * @param {String} attrName The attribute name to retrieve.
	 * @return {String} The attribute's value, or `undefined` if it does not exist on the HtmlTag.
	 */
	getAttr : function( attrName ) {
		return this.getAttrs()[ attrName ];
	},


	/**
	 * Sets one or more attributes on the HtmlTag.
	 *
	 * @param {Object.<String, String>} attrs A key/value Object (map) of the attributes to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setAttrs : function( attrs ) {
		var tagAttrs = this.getAttrs();
		Autolinker.Util.assign( tagAttrs, attrs );

		return this;
	},


	/**
	 * Retrieves the attributes Object (map) for the HtmlTag.
	 *
	 * @return {Object.<String, String>} A key/value object of the attributes for the HtmlTag.
	 */
	getAttrs : function() {
		return this.attrs || ( this.attrs = {} );
	},


	/**
	 * Sets the provided `cssClass`, overwriting any current CSS classes on the HtmlTag.
	 *
	 * @param {String} cssClass One or more space-separated CSS classes to set (overwrite).
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setClass : function( cssClass ) {
		return this.setAttr( 'class', cssClass );
	},


	/**
	 * Convenience method to add one or more CSS classes to the HtmlTag. Will not add duplicate CSS classes.
	 *
	 * @param {String} cssClass One or more space-separated CSS classes to add.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	addClass : function( cssClass ) {
		var classAttr = this.getClass(),
		    whitespaceRegex = this.whitespaceRegex,
		    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below
		    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),
		    newClasses = cssClass.split( whitespaceRegex ),
		    newClass;

		while( newClass = newClasses.shift() ) {
			if( indexOf( classes, newClass ) === -1 ) {
				classes.push( newClass );
			}
		}

		this.getAttrs()[ 'class' ] = classes.join( " " );
		return this;
	},


	/**
	 * Convenience method to remove one or more CSS classes from the HtmlTag.
	 *
	 * @param {String} cssClass One or more space-separated CSS classes to remove.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	removeClass : function( cssClass ) {
		var classAttr = this.getClass(),
		    whitespaceRegex = this.whitespaceRegex,
		    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below
		    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),
		    removeClasses = cssClass.split( whitespaceRegex ),
		    removeClass;

		while( classes.length && ( removeClass = removeClasses.shift() ) ) {
			var idx = indexOf( classes, removeClass );
			if( idx !== -1 ) {
				classes.splice( idx, 1 );
			}
		}

		this.getAttrs()[ 'class' ] = classes.join( " " );
		return this;
	},


	/**
	 * Convenience method to retrieve the CSS class(es) for the HtmlTag, which will each be separated by spaces when
	 * there are multiple.
	 *
	 * @return {String}
	 */
	getClass : function() {
		return this.getAttrs()[ 'class' ] || "";
	},


	/**
	 * Convenience method to check if the tag has a CSS class or not.
	 *
	 * @param {String} cssClass The CSS class to check for.
	 * @return {Boolean} `true` if the HtmlTag has the CSS class, `false` otherwise.
	 */
	hasClass : function( cssClass ) {
		return ( ' ' + this.getClass() + ' ' ).indexOf( ' ' + cssClass + ' ' ) !== -1;
	},


	/**
	 * Sets the inner HTML for the tag.
	 *
	 * @param {String} html The inner HTML to set.
	 * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.
	 */
	setInnerHtml : function( html ) {
		this.innerHtml = html;

		return this;
	},


	/**
	 * Retrieves the inner HTML for the tag.
	 *
	 * @return {String}
	 */
	getInnerHtml : function() {
		return this.innerHtml || "";
	},


	/**
	 * Override of superclass method used to generate the HTML string for the tag.
	 *
	 * @return {String}
	 */
	toAnchorString : function() {
		var tagName = this.getTagName(),
		    attrsStr = this.buildAttrsStr();

		attrsStr = ( attrsStr ) ? ' ' + attrsStr : '';  // prepend a space if there are actually attributes

		return [ '<', tagName, attrsStr, '>', this.getInnerHtml(), '</', tagName, '>' ].join( "" );
	},


	/**
	 * Support method for {@link #toAnchorString}, returns the string space-separated key="value" pairs, used to populate
	 * the stringified HtmlTag.
	 *
	 * @protected
	 * @return {String} Example return: `attr1="value1" attr2="value2"`
	 */
	buildAttrsStr : function() {
		if( !this.attrs ) return "";  // no `attrs` Object (map) has been set, return empty string

		var attrs = this.getAttrs(),
		    attrsArr = [];

		for( var prop in attrs ) {
			if( attrs.hasOwnProperty( prop ) ) {
				attrsArr.push( prop + '="' + attrs[ prop ] + '"' );
			}
		}
		return attrsArr.join( " " );
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.RegexLib
 * @singleton
 *
 * Builds and stores a library of the common regular expressions used by the
 * Autolinker utility.
 *
 * Other regular expressions may exist ad-hoc, but these are generally the
 * regular expressions that are shared between source files.
 */
Autolinker.RegexLib = (function() {

	/**
	 * The string form of a regular expression that would match all of the
	 * alphabetic ("letter") chars in the unicode character set when placed in a
	 * RegExp character class (`[]`). This includes all international alphabetic
	 * characters.
	 *
	 * These would be the characters matched by unicode regex engines `\p{L}`
	 * escape ("all letters").
	 *
	 * Taken from the XRegExp library: http://xregexp.com/
	 * Specifically: http://xregexp.com/v/3.0.0/unicode-categories.js
	 *
	 * @private
	 * @type {String}
	 */
	var alphaCharsStr = 'A-Za-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC';

	/**
	 * The string form of a regular expression that would match all of the
	 * decimal number chars in the unicode character set when placed in a RegExp
	 * character class (`[]`).
	 *
	 * These would be the characters matched by unicode regex engines `\p{Nd}`
	 * escape ("all decimal numbers")
	 *
	 * Taken from the XRegExp library: http://xregexp.com/
	 * Specifically: http://xregexp.com/v/3.0.0/unicode-categories.js
	 *
	 * @private
	 * @type {String}
	 */
	var decimalNumbersStr = '0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19';


	// See documentation below
	var alphaNumericCharsStr = alphaCharsStr + decimalNumbersStr;


	// See documentation below
	var domainNameRegex = new RegExp( '[' + alphaNumericCharsStr + '.\\-]*[' + alphaNumericCharsStr + '\\-]' );


	// See documentation below
	var tldRegex = /(?:travelersinsurance|sandvikcoromant|kerryproperties|cancerresearch|weatherchannel|kerrylogistics|spreadbetting|international|wolterskluwer|lifeinsurance|construction|pamperedchef|scholarships|versicherung|bridgestone|creditunion|kerryhotels|investments|productions|blackfriday|enterprises|lamborghini|photography|motorcycles|williamhill|playstation|contractors|barclaycard|accountants|redumbrella|engineering|management|telefonica|protection|consulting|tatamotors|creditcard|vlaanderen|schaeffler|associates|properties|foundation|republican|bnpparibas|boehringer|eurovision|extraspace|industries|immobilien|university|technology|volkswagen|healthcare|restaurant|cuisinella|vistaprint|apartments|accountant|travelers|homedepot|institute|vacations|furniture|fresenius|insurance|christmas|bloomberg|solutions|barcelona|firestone|financial|kuokgroup|fairwinds|community|passagens|goldpoint|equipment|lifestyle|yodobashi|aquarelle|marketing|analytics|education|amsterdam|statefarm|melbourne|allfinanz|directory|microsoft|stockholm|montblanc|accenture|lancaster|landrover|everbank|istanbul|graphics|grainger|ipiranga|softbank|attorney|pharmacy|saarland|catering|airforce|yokohama|mortgage|frontier|mutuelle|stcgroup|memorial|pictures|football|symantec|cipriani|ventures|telecity|cityeats|verisign|flsmidth|boutique|cleaning|firmdale|clinique|clothing|redstone|infiniti|deloitte|feedback|services|broadway|plumbing|commbank|training|barclays|exchange|computer|brussels|software|delivery|barefoot|builders|business|bargains|engineer|holdings|download|security|helsinki|lighting|movistar|discount|hdfcbank|supplies|marriott|property|diamonds|capetown|partners|democrat|jpmorgan|bradesco|budapest|rexroth|zuerich|shriram|academy|science|support|youtube|singles|surgery|alibaba|statoil|dentist|schwarz|android|cruises|cricket|digital|markets|starhub|systems|courses|coupons|netbank|country|domains|corsica|network|neustar|realtor|lincoln|limited|schmidt|yamaxun|cooking|contact|auction|spiegel|liaison|leclerc|latrobe|lasalle|abogado|compare|lanxess|exposed|express|company|cologne|college|avianca|lacaixa|fashion|recipes|ferrero|komatsu|storage|wanggou|clubmed|sandvik|fishing|fitness|bauhaus|kitchen|flights|florist|flowers|watches|weather|temasek|samsung|bentley|forsale|channel|theater|frogans|theatre|okinawa|website|tickets|jewelry|gallery|tiffany|iselect|shiksha|brother|organic|wedding|genting|toshiba|origins|philips|hyundai|hotmail|hoteles|hosting|rentals|windows|cartier|bugatti|holiday|careers|whoswho|hitachi|panerai|caravan|reviews|guitars|capital|trading|hamburg|hangout|finance|stream|family|abbott|health|review|travel|report|hermes|hiphop|gratis|career|toyota|hockey|dating|repair|google|social|soccer|reisen|global|otsuka|giving|unicom|casino|photos|center|broker|rocher|orange|bostik|garden|insure|ryukyu|bharti|safety|physio|sakura|oracle|online|jaguar|gallup|piaget|tienda|futbol|pictet|joburg|webcam|berlin|office|juegos|kaufen|chanel|chrome|xihuan|church|tennis|circle|kinder|flickr|bayern|claims|clinic|viajes|nowruz|xperia|norton|yachts|studio|coffee|camera|sanofi|nissan|author|expert|events|comsec|lawyer|tattoo|viking|estate|villas|condos|realty|yandex|energy|emerck|virgin|vision|durban|living|school|coupon|london|taobao|natura|taipei|nagoya|luxury|walter|aramco|sydney|madrid|credit|maison|makeup|schule|market|anquan|direct|design|swatch|suzuki|alsace|vuelos|dental|alipay|voyage|shouji|voting|airtel|mutual|degree|supply|agency|museum|mobily|dealer|monash|select|mormon|active|moscow|racing|datsun|quebec|nissay|rodeo|email|gifts|works|photo|chloe|edeka|cheap|earth|vista|tushu|koeln|glass|shoes|globo|tunes|gmail|nokia|space|kyoto|black|ricoh|seven|lamer|sener|epson|cisco|praxi|trust|citic|crown|shell|lease|green|legal|lexus|ninja|tatar|gripe|nikon|group|video|wales|autos|gucci|party|nexus|guide|linde|adult|parts|amica|lixil|boats|azure|loans|locus|cymru|lotte|lotto|stada|click|poker|quest|dabur|lupin|nadex|paris|faith|dance|canon|place|gives|trade|skype|rocks|mango|cloud|boots|smile|final|swiss|homes|honda|media|horse|cards|deals|watch|bosch|house|pizza|miami|osaka|tours|total|xerox|coach|sucks|style|delta|toray|iinet|tools|money|codes|beats|tokyo|salon|archi|movie|baidu|study|actor|yahoo|store|apple|world|forex|today|bible|tmall|tirol|irish|tires|forum|reise|vegas|vodka|sharp|omega|weber|jetzt|audio|promo|build|bingo|chase|gallo|drive|dubai|rehab|press|solar|sale|beer|bbva|bank|band|auto|sapo|sarl|saxo|audi|asia|arte|arpa|army|yoga|ally|zara|scor|scot|sexy|seat|zero|seek|aero|adac|zone|aarp|maif|meet|meme|menu|surf|mini|mobi|mtpc|porn|desi|star|ltda|name|talk|navy|love|loan|live|link|news|limo|like|spot|life|nico|lidl|lgbt|land|taxi|team|tech|kred|kpmg|sony|song|kiwi|kddi|jprs|jobs|sohu|java|itau|tips|info|immo|icbc|hsbc|town|host|page|toys|here|help|pars|haus|guru|guge|tube|goog|golf|gold|sncf|gmbh|gift|ggee|gent|gbiz|game|vana|pics|fund|ford|ping|pink|fish|film|fast|farm|play|fans|fail|plus|skin|pohl|fage|moda|post|erni|dvag|prod|doha|prof|docs|viva|diet|luxe|site|dell|sina|dclk|show|qpon|date|vote|cyou|voto|read|coop|cool|wang|club|city|chat|cern|cash|reit|rent|casa|cars|care|camp|rest|call|cafe|weir|wien|rich|wiki|buzz|wine|book|bond|room|work|rsvp|shia|ruhr|blue|bing|shaw|bike|safe|xbox|best|pwc|mtn|lds|aig|boo|fyi|nra|nrw|ntt|car|gal|obi|zip|aeg|vin|how|one|ong|onl|dad|ooo|bet|esq|org|htc|bar|uol|ibm|ovh|gdn|ice|icu|uno|gea|ifm|bot|top|wtf|lol|day|pet|eus|wtc|ubs|tvs|aco|ing|ltd|ink|tab|abb|afl|cat|int|pid|pin|bid|cba|gle|com|cbn|ads|man|wed|ceb|gmo|sky|ist|gmx|tui|mba|fan|ski|iwc|app|pro|med|ceo|jcb|jcp|goo|dev|men|aaa|meo|pub|jlc|bom|jll|gop|jmp|mil|got|gov|win|jot|mma|joy|trv|red|cfa|cfd|bio|moe|moi|mom|ren|biz|aws|xin|bbc|dnp|buy|kfh|mov|thd|xyz|fit|kia|rio|rip|kim|dog|vet|nyc|bcg|mtr|bcn|bms|bmw|run|bzh|rwe|tel|stc|axa|kpn|fly|krd|cab|bnl|foo|crs|eat|tci|sap|srl|nec|sas|net|cal|sbs|sfr|sca|scb|csc|edu|new|xxx|hiv|fox|wme|ngo|nhk|vip|sex|frl|lat|yun|law|you|tax|soy|sew|om|ac|hu|se|sc|sg|sh|sb|sa|rw|ru|rs|ro|re|qa|py|si|pw|pt|ps|sj|sk|pr|pn|pm|pl|sl|sm|pk|sn|ph|so|pg|pf|pe|pa|zw|nz|nu|nr|np|no|nl|ni|ng|nf|sr|ne|st|nc|na|mz|my|mx|mw|mv|mu|mt|ms|mr|mq|mp|mo|su|mn|mm|ml|mk|mh|mg|me|sv|md|mc|sx|sy|ma|ly|lv|sz|lu|lt|ls|lr|lk|li|lc|lb|la|tc|kz|td|ky|kw|kr|kp|kn|km|ki|kh|tf|tg|th|kg|ke|jp|jo|jm|je|it|is|ir|tj|tk|tl|tm|iq|tn|to|io|in|im|il|ie|ad|sd|ht|hr|hn|hm|tr|hk|gy|gw|gu|gt|gs|gr|gq|tt|gp|gn|gm|gl|tv|gi|tw|tz|ua|gh|ug|uk|gg|gf|ge|gd|us|uy|uz|va|gb|ga|vc|ve|fr|fo|fm|fk|fj|vg|vi|fi|eu|et|es|er|eg|ee|ec|dz|do|dm|dk|vn|dj|de|cz|cy|cx|cw|vu|cv|cu|cr|co|cn|cm|cl|ck|ci|ch|cg|cf|cd|cc|ca|wf|bz|by|bw|bv|bt|bs|br|bo|bn|bm|bj|bi|ws|bh|bg|bf|be|bd|bb|ba|az|ax|aw|au|at|as|ye|ar|aq|ao|am|al|yt|ai|za|ag|af|ae|zm|id)\b/;


	return {

		/**
		 * The string form of a regular expression that would match all of the
		 * letters and decimal number chars in the unicode character set when placed
		 * in a RegExp character class (`[]`).
		 *
		 * These would be the characters matched by unicode regex engines `[\p{L}\p{Nd}]`
		 * escape ("all letters and decimal numbers")
		 *
		 * @property {String} alphaNumericCharsStr
		 */
		alphaNumericCharsStr : alphaNumericCharsStr,

		/**
		 * A regular expression to match domain names of a URL or email address.
		 * Ex: 'google', 'yahoo', 'some-other-company', etc.
		 *
		 * @property {RegExp} domainNameRegex
		 */
		domainNameRegex : domainNameRegex,

		/**
		 * A regular expression to match top level domains (TLDs) for a URL or
		 * email address. Ex: 'com', 'org', 'net', etc.
		 *
		 * @property {RegExp} tldRegex
		 */
		tldRegex : tldRegex

	};


}() );
/*global Autolinker */
/*jshint sub:true */
/**
 * @protected
 * @class Autolinker.AnchorTagBuilder
 * @extends Object
 *
 * Builds anchor (&lt;a&gt;) tags for the Autolinker utility when a match is
 * found.
 *
 * Normally this class is instantiated, configured, and used internally by an
 * {@link Autolinker} instance, but may actually be retrieved in a {@link Autolinker#replaceFn replaceFn}
 * to create {@link Autolinker.HtmlTag HtmlTag} instances which may be modified
 * before returning from the {@link Autolinker#replaceFn replaceFn}. For
 * example:
 *
 *     var html = Autolinker.link( "Test google.com", {
 *         replaceFn : function( autolinker, match ) {
 *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance
 *             tag.setAttr( 'rel', 'nofollow' );
 *
 *             return tag;
 *         }
 *     } );
 *
 *     // generated html:
 *     //   Test <a href="http://google.com" target="_blank" rel="nofollow">google.com</a>
 */
Autolinker.AnchorTagBuilder = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {Boolean} newWindow
	 * @inheritdoc Autolinker#newWindow
	 */

	/**
	 * @cfg {Object} truncate
	 * @inheritdoc Autolinker#truncate
	 */

	/**
	 * @cfg {String} className
	 * @inheritdoc Autolinker#className
	 */


	/**
	 * @constructor
	 * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );
	},


	/**
	 * Generates the actual anchor (&lt;a&gt;) tag to use in place of the
	 * matched text, via its `match` object.
	 *
	 * @param {Autolinker.match.Match} match The Match instance to generate an
	 *   anchor tag from.
	 * @return {Autolinker.HtmlTag} The HtmlTag instance for the anchor tag.
	 */
	build : function( match ) {
		return new Autolinker.HtmlTag( {
			tagName   : 'a',
			attrs     : this.createAttrs( match.getType(), match.getAnchorHref() ),
			innerHtml : this.processAnchorText( match.getAnchorText() )
		} );
	},


	/**
	 * Creates the Object (map) of the HTML attributes for the anchor (&lt;a&gt;)
	 *   tag being generated.
	 *
	 * @protected
	 * @param {"url"/"email"/"phone"/"twitter"/"hashtag"} matchType The type of
	 *   match that an anchor tag is being generated for.
	 * @param {String} anchorHref The href for the anchor tag.
	 * @return {Object} A key/value Object (map) of the anchor tag's attributes.
	 */
	createAttrs : function( matchType, anchorHref ) {
		var attrs = {
			'href' : anchorHref  // we'll always have the `href` attribute
		};

		var cssClass = this.createCssClass( matchType );
		if( cssClass ) {
			attrs[ 'class' ] = cssClass;
		}
		if( this.newWindow ) {
			attrs[ 'target' ] = "_blank";
			attrs[ 'rel' ] = "noopener noreferrer";
		}

		return attrs;
	},


	/**
	 * Creates the CSS class that will be used for a given anchor tag, based on
	 * the `matchType` and the {@link #className} config.
	 *
	 * @private
	 * @param {"url"/"email"/"phone"/"twitter"/"hashtag"} matchType The type of
	 *   match that an anchor tag is being generated for.
	 * @return {String} The CSS class string for the link. Example return:
	 *   "myLink myLink-url". If no {@link #className} was configured, returns
	 *   an empty string.
	 */
	createCssClass : function( matchType ) {
		var className = this.className;

		if( !className )
			return "";
		else
			return className + " " + className + "-" + matchType;  // ex: "myLink myLink-url", "myLink myLink-email", "myLink myLink-phone", "myLink myLink-twitter", or "myLink myLink-hashtag"
	},


	/**
	 * Processes the `anchorText` by truncating the text according to the
	 * {@link #truncate} config.
	 *
	 * @private
	 * @param {String} anchorText The anchor tag's text (i.e. what will be
	 *   displayed).
	 * @return {String} The processed `anchorText`.
	 */
	processAnchorText : function( anchorText ) {
		anchorText = this.doTruncate( anchorText );

		return anchorText;
	},


	/**
	 * Performs the truncation of the `anchorText` based on the {@link #truncate}
	 * option. If the `anchorText` is longer than the length specified by the
	 * {@link #truncate} option, the truncation is performed based on the
	 * `location` property. See {@link #truncate} for details.
	 *
	 * @private
	 * @param {String} anchorText The anchor tag's text (i.e. what will be
	 *   displayed).
	 * @return {String} The truncated anchor text.
	 */
	doTruncate : function( anchorText ) {
		var truncate = this.truncate;
		if( !truncate || !truncate.length ) return anchorText;

		var truncateLength = truncate.length,
			truncateLocation = truncate.location;

		if( truncateLocation === 'smart' ) {
			return Autolinker.truncate.TruncateSmart( anchorText, truncateLength, '..' );

		} else if( truncateLocation === 'middle' ) {
			return Autolinker.truncate.TruncateMiddle( anchorText, truncateLength, '..' );

		} else {
			return Autolinker.truncate.TruncateEnd( anchorText, truncateLength, '..' );
		}
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.htmlParser.HtmlParser
 * @extends Object
 *
 * An HTML parser implementation which simply walks an HTML string and returns an array of
 * {@link Autolinker.htmlParser.HtmlNode HtmlNodes} that represent the basic HTML structure of the input string.
 *
 * Autolinker uses this to only link URLs/emails/Twitter handles within text nodes, effectively ignoring / "walking
 * around" HTML tags.
 */
Autolinker.htmlParser.HtmlParser = Autolinker.Util.extend( Object, {

	/**
	 * @private
	 * @property {RegExp} htmlRegex
	 *
	 * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and
	 * attribute names, as specified by http://www.w3.org/TR/html-markup/syntax.html.
	 *
	 * Capturing groups:
	 *
	 * 1. The "!DOCTYPE" tag name, if a tag is a &lt;!DOCTYPE&gt; tag.
	 * 2. If it is an end tag, this group will have the '/'.
	 * 3. If it is a comment tag, this group will hold the comment text (i.e.
	 *    the text inside the `&lt;!--` and `--&gt;`.
	 * 4. The tag name for all tags (other than the &lt;!DOCTYPE&gt; tag)
	 */
	htmlRegex : (function() {
		var commentTagRegex = /!--([\s\S]+?)--/,
		    tagNameRegex = /[0-9a-zA-Z][0-9a-zA-Z:]*/,
		    attrNameRegex = /[^\s"'>\/=\x00-\x1F\x7F]+/,   // the unicode range accounts for excluding control chars, and the delete char
		    attrValueRegex = /(?:"[^"]*?"|'[^']*?'|[^'"=<>`\s]+)/, // double quoted, single quoted, or unquoted attribute values
		    nameEqualsValueRegex = attrNameRegex.source + '(?:\\s*=\\s*' + attrValueRegex.source + ')?';  // optional '=[value]'

		return new RegExp( [
			// for <!DOCTYPE> tag. Ex: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">)
			'(?:',
				'<(!DOCTYPE)',  // *** Capturing Group 1 - If it's a doctype tag

					// Zero or more attributes following the tag name
					'(?:',
						'\\s+',  // one or more whitespace chars before an attribute

						// Either:
						// A. attr="value", or
						// B. "value" alone (To cover example doctype tag: <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">)
						'(?:', nameEqualsValueRegex, '|', attrValueRegex.source + ')',
					')*',
				'>',
			')',

			'|',

			// All other HTML tags (i.e. tags that are not <!DOCTYPE>)
			'(?:',
				'<(/)?',  // Beginning of a tag or comment. Either '<' for a start tag, or '</' for an end tag.
				          // *** Capturing Group 2: The slash or an empty string. Slash ('/') for end tag, empty string for start or self-closing tag.

					'(?:',
						commentTagRegex.source,  // *** Capturing Group 3 - A Comment Tag's Text

						'|',

						'(?:',

							// *** Capturing Group 4 - The tag name
							'(' + tagNameRegex.source + ')',

							// Zero or more attributes following the tag name
							'(?:',
								'(?:\\s+|\\b)',        // any number of whitespace chars before an attribute. NOTE: Using \s* here throws Chrome into an infinite loop for some reason, so using \s+|\b instead
								nameEqualsValueRegex,  // attr="value" (with optional ="value" part)
							')*',

							'\\s*/?',  // any trailing spaces and optional '/' before the closing '>'

						')',
					')',
				'>',
			')'
		].join( "" ), 'gi' );
	} )(),

	/**
	 * @private
	 * @property {RegExp} htmlCharacterEntitiesRegex
	 *
	 * The regular expression that matches common HTML character entities.
	 *
	 * Ignoring &amp; as it could be part of a query string -- handling it separately.
	 */
	htmlCharacterEntitiesRegex: /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi,


	/**
	 * Parses an HTML string and returns a simple array of {@link Autolinker.htmlParser.HtmlNode HtmlNodes}
	 * to represent the HTML structure of the input string.
	 *
	 * @param {String} html The HTML to parse.
	 * @return {Autolinker.htmlParser.HtmlNode[]}
	 */
	parse : function( html ) {
		var htmlRegex = this.htmlRegex,
		    currentResult,
		    lastIndex = 0,
		    textAndEntityNodes,
		    nodes = [];  // will be the result of the method

		while( ( currentResult = htmlRegex.exec( html ) ) !== null ) {
			var tagText = currentResult[ 0 ],
			    commentText = currentResult[ 3 ], // if we've matched a comment
			    tagName = currentResult[ 1 ] || currentResult[ 4 ],  // The <!DOCTYPE> tag (ex: "!DOCTYPE"), or another tag (ex: "a" or "img")
			    isClosingTag = !!currentResult[ 2 ],
			    offset = currentResult.index,
			    inBetweenTagsText = html.substring( lastIndex, offset );

			// Push TextNodes and EntityNodes for any text found between tags
			if( inBetweenTagsText ) {
				textAndEntityNodes = this.parseTextAndEntityNodes( lastIndex, inBetweenTagsText );
				nodes.push.apply( nodes, textAndEntityNodes );
			}

			// Push the CommentNode or ElementNode
			if( commentText ) {
				nodes.push( this.createCommentNode( offset, tagText, commentText ) );
			} else {
				nodes.push( this.createElementNode( offset, tagText, tagName, isClosingTag ) );
			}

			lastIndex = offset + tagText.length;
		}

		// Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.
		if( lastIndex < html.length ) {
			var text = html.substring( lastIndex );

			// Push TextNodes and EntityNodes for any text found between tags
			if( text ) {
				textAndEntityNodes = this.parseTextAndEntityNodes( lastIndex, text );
				nodes.push.apply( nodes, textAndEntityNodes );
			}
		}

		return nodes;
	},


	/**
	 * Parses text and HTML entity nodes from a given string. The input string
	 * should not have any HTML tags (elements) within it.
	 *
	 * @private
	 * @param {Number} offset The offset of the text node match within the
	 *   original HTML string.
	 * @param {String} text The string of text to parse. This is from an HTML
	 *   text node.
	 * @return {Autolinker.htmlParser.HtmlNode[]} An array of HtmlNodes to
	 *   represent the {@link Autolinker.htmlParser.TextNode TextNodes} and
	 *   {@link Autolinker.htmlParser.EntityNode EntityNodes} found.
	 */
	parseTextAndEntityNodes : function( offset, text ) {
		var nodes = [],
		    textAndEntityTokens = Autolinker.Util.splitAndCapture( text, this.htmlCharacterEntitiesRegex );  // split at HTML entities, but include the HTML entities in the results array

		// Every even numbered token is a TextNode, and every odd numbered token is an EntityNode
		// For example: an input `text` of "Test &quot;this&quot; today" would turn into the
		//   `textAndEntityTokens`: [ 'Test ', '&quot;', 'this', '&quot;', ' today' ]
		for( var i = 0, len = textAndEntityTokens.length; i < len; i += 2 ) {
			var textToken = textAndEntityTokens[ i ],
			    entityToken = textAndEntityTokens[ i + 1 ];

			if( textToken ) {
				nodes.push( this.createTextNode( offset, textToken ) );
				offset += textToken.length;
			}
			if( entityToken ) {
				nodes.push( this.createEntityNode( offset, entityToken ) );
				offset += entityToken.length;
			}
		}
		return nodes;
	},


	/**
	 * Factory method to create an {@link Autolinker.htmlParser.CommentNode CommentNode}.
	 *
	 * @private
	 * @param {Number} offset The offset of the match within the original HTML
	 *   string.
	 * @param {String} tagText The full text of the tag (comment) that was
	 *   matched, including its &lt;!-- and --&gt;.
	 * @param {String} commentText The full text of the comment that was matched.
	 */
	createCommentNode : function( offset, tagText, commentText ) {
		return new Autolinker.htmlParser.CommentNode( {
			offset : offset,
			text   : tagText,
			comment: Autolinker.Util.trim( commentText )
		} );
	},


	/**
	 * Factory method to create an {@link Autolinker.htmlParser.ElementNode ElementNode}.
	 *
	 * @private
	 * @param {Number} offset The offset of the match within the original HTML
	 *   string.
	 * @param {String} tagText The full text of the tag (element) that was
	 *   matched, including its attributes.
	 * @param {String} tagName The name of the tag. Ex: An &lt;img&gt; tag would
	 *   be passed to this method as "img".
	 * @param {Boolean} isClosingTag `true` if it's a closing tag, false
	 *   otherwise.
	 * @return {Autolinker.htmlParser.ElementNode}
	 */
	createElementNode : function( offset, tagText, tagName, isClosingTag ) {
		return new Autolinker.htmlParser.ElementNode( {
			offset  : offset,
			text    : tagText,
			tagName : tagName.toLowerCase(),
			closing : isClosingTag
		} );
	},


	/**
	 * Factory method to create a {@link Autolinker.htmlParser.EntityNode EntityNode}.
	 *
	 * @private
	 * @param {Number} offset The offset of the match within the original HTML
	 *   string.
	 * @param {String} text The text that was matched for the HTML entity (such
	 *   as '&amp;nbsp;').
	 * @return {Autolinker.htmlParser.EntityNode}
	 */
	createEntityNode : function( offset, text ) {
		return new Autolinker.htmlParser.EntityNode( { offset: offset, text: text } );
	},


	/**
	 * Factory method to create a {@link Autolinker.htmlParser.TextNode TextNode}.
	 *
	 * @private
	 * @param {Number} offset The offset of the match within the original HTML
	 *   string.
	 * @param {String} text The text that was matched.
	 * @return {Autolinker.htmlParser.TextNode}
	 */
	createTextNode : function( offset, text ) {
		return new Autolinker.htmlParser.TextNode( { offset: offset, text: text } );
	}

} );
/*global Autolinker */
/**
 * @abstract
 * @class Autolinker.htmlParser.HtmlNode
 *
 * Represents an HTML node found in an input string. An HTML node is one of the
 * following:
 *
 * 1. An {@link Autolinker.htmlParser.ElementNode ElementNode}, which represents
 *    HTML tags.
 * 2. A {@link Autolinker.htmlParser.CommentNode CommentNode}, which represents
 *    HTML comments.
 * 3. A {@link Autolinker.htmlParser.TextNode TextNode}, which represents text
 *    outside or within HTML tags.
 * 4. A {@link Autolinker.htmlParser.EntityNode EntityNode}, which represents
 *    one of the known HTML entities that Autolinker looks for. This includes
 *    common ones such as &amp;quot; and &amp;nbsp;
 */
Autolinker.htmlParser.HtmlNode = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {Number} offset (required)
	 *
	 * The offset of the HTML node in the original text that was parsed.
	 */
	offset : undefined,

	/**
	 * @cfg {String} text (required)
	 *
	 * The text that was matched for the HtmlNode.
	 *
	 * - In the case of an {@link Autolinker.htmlParser.ElementNode ElementNode},
	 *   this will be the tag's text.
	 * - In the case of an {@link Autolinker.htmlParser.CommentNode CommentNode},
	 *   this will be the comment's text.
	 * - In the case of a {@link Autolinker.htmlParser.TextNode TextNode}, this
	 *   will be the text itself.
	 * - In the case of a {@link Autolinker.htmlParser.EntityNode EntityNode},
	 *   this will be the text of the HTML entity.
	 */
	text : undefined,


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match instance,
	 * specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.Util.assign( this, cfg );

		if( this.offset == null ) throw new Error( '`offset` cfg required' );
		if( this.text == null ) throw new Error( '`text` cfg required' );
	},


	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @abstract
	 * @return {String}
	 */
	getType : Autolinker.Util.abstractMethod,


	/**
	 * Retrieves the {@link #offset} of the HtmlNode. This is the offset of the
	 * HTML node in the original string that was parsed.
	 *
	 * @return {Number}
	 */
	getOffset : function() {
		return this.offset;
	},


	/**
	 * Retrieves the {@link #text} for the HtmlNode.
	 *
	 * @return {String}
	 */
	getText : function() {
		return this.text;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.CommentNode
 * @extends Autolinker.htmlParser.HtmlNode
 *
 * Represents an HTML comment node that has been parsed by the
 * {@link Autolinker.htmlParser.HtmlParser}.
 *
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
 * details.
 */
Autolinker.htmlParser.CommentNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {

	/**
	 * @cfg {String} comment (required)
	 *
	 * The text inside the comment tag. This text is stripped of any leading or
	 * trailing whitespace.
	 */
	comment : '',


	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'comment';
	},


	/**
	 * Returns the comment inside the comment tag.
	 *
	 * @return {String}
	 */
	getComment : function() {
		return this.comment;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.ElementNode
 * @extends Autolinker.htmlParser.HtmlNode
 *
 * Represents an HTML element node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 *
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
 * details.
 */
Autolinker.htmlParser.ElementNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {

	/**
	 * @cfg {String} tagName (required)
	 *
	 * The name of the tag that was matched.
	 */
	tagName : '',

	/**
	 * @cfg {Boolean} closing (required)
	 *
	 * `true` if the element (tag) is a closing tag, `false` if its an opening
	 * tag.
	 */
	closing : false,


	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'element';
	},


	/**
	 * Returns the HTML element's (tag's) name. Ex: for an &lt;img&gt; tag,
	 * returns "img".
	 *
	 * @return {String}
	 */
	getTagName : function() {
		return this.tagName;
	},


	/**
	 * Determines if the HTML element (tag) is a closing tag. Ex: &lt;div&gt;
	 * returns `false`, while &lt;/div&gt; returns `true`.
	 *
	 * @return {Boolean}
	 */
	isClosing : function() {
		return this.closing;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.EntityNode
 * @extends Autolinker.htmlParser.HtmlNode
 *
 * Represents a known HTML entity node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 * Ex: '&amp;nbsp;', or '&amp#160;' (which will be retrievable from the {@link #getText}
 * method.
 *
 * Note that this class will only be returned from the HtmlParser for the set of
 * checked HTML entity nodes  defined by the {@link Autolinker.htmlParser.HtmlParser#htmlCharacterEntitiesRegex}.
 *
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
 * details.
 */
Autolinker.htmlParser.EntityNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {

	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'entity';
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.htmlParser.TextNode
 * @extends Autolinker.htmlParser.HtmlNode
 *
 * Represents a text node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.
 *
 * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more
 * details.
 */
Autolinker.htmlParser.TextNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {

	/**
	 * Returns a string name for the type of node that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'text';
	}

} );
/*global Autolinker */
/**
 * @abstract
 * @class Autolinker.match.Match
 *
 * Represents a match found in an input string which should be Autolinked. A Match object is what is provided in a
 * {@link Autolinker#replaceFn replaceFn}, and may be used to query for details about the match.
 *
 * For example:
 *
 *     var input = "...";  // string with URLs, Email Addresses, and Twitter Handles
 *
 *     var linkedText = Autolinker.link( input, {
 *         replaceFn : function( autolinker, match ) {
 *             console.log( "href = ", match.getAnchorHref() );
 *             console.log( "text = ", match.getAnchorText() );
 *
 *             switch( match.getType() ) {
 *                 case 'url' :
 *                     console.log( "url: ", match.getUrl() );
 *
 *                 case 'email' :
 *                     console.log( "email: ", match.getEmail() );
 *
 *                 case 'twitter' :
 *                     console.log( "twitter: ", match.getTwitterHandle() );
 *             }
 *         }
 *     } );
 *
 * See the {@link Autolinker} class for more details on using the {@link Autolinker#replaceFn replaceFn}.
 */
Autolinker.match.Match = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {Autolinker.AnchorTagBuilder} tagBuilder (required)
	 *
	 * Reference to the AnchorTagBuilder instance to use to generate an anchor
	 * tag for the Match.
	 */

	/**
	 * @cfg {String} matchedText (required)
	 *
	 * The original text that was matched by the {@link Autolinker.matcher.Matcher}.
	 */

	/**
	 * @cfg {Number} offset (required)
	 *
	 * The offset of where the match was made in the input string.
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		if( cfg.tagBuilder == null ) throw new Error( '`tagBuilder` cfg required' );
		if( cfg.matchedText == null ) throw new Error( '`matchedText` cfg required' );
		if( cfg.offset == null ) throw new Error( '`offset` cfg required' );

		this.tagBuilder = cfg.tagBuilder;
		this.matchedText = cfg.matchedText;
		this.offset = cfg.offset;
	},


	/**
	 * Returns a string name for the type of match that this class represents.
	 *
	 * @abstract
	 * @return {String}
	 */
	getType : Autolinker.Util.abstractMethod,


	/**
	 * Returns the original text that was matched.
	 *
	 * @return {String}
	 */
	getMatchedText : function() {
		return this.matchedText;
	},


	/**
	 * Sets the {@link #offset} of where the match was made in the input string.
	 *
	 * A {@link Autolinker.matcher.Matcher} will be fed only HTML text nodes,
	 * and will therefore set an original offset that is relative to the HTML
	 * text node itself. However, we want this offset to be relative to the full
	 * HTML input string, and thus if using {@link Autolinker#parse} (rather
	 * than calling a {@link Autolinker.matcher.Matcher} directly), then this
	 * offset is corrected after the Matcher itself has done its job.
	 *
	 * @param {Number} offset
	 */
	setOffset : function( offset ) {
		this.offset = offset;
	},


	/**
	 * Returns the offset of where the match was made in the input string. This
	 * is the 0-based index of the match.
	 *
	 * @return {Number}
	 */
	getOffset : function() {
		return this.offset;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @abstract
	 * @return {String}
	 */
	getAnchorHref : Autolinker.Util.abstractMethod,


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @abstract
	 * @return {String}
	 */
	getAnchorText : Autolinker.Util.abstractMethod,


	/**
	 * Builds and returns an {@link Autolinker.HtmlTag} instance based on the
	 * Match.
	 *
	 * This can be used to easily generate anchor tags from matches, and either
	 * return their HTML string, or modify them before doing so.
	 *
	 * Example Usage:
	 *
	 *     var tag = match.buildTag();
	 *     tag.addClass( 'cordova-link' );
	 *     tag.setAttr( 'target', '_system' );
	 *
	 *     tag.toAnchorString();  // <a href="http://google.com" class="cordova-link" target="_system">Google</a>
	 */
	buildTag : function() {
		return this.tagBuilder.build( this );
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.match.Email
 * @extends Autolinker.match.Match
 *
 * Represents a Email match found in an input string which should be Autolinked.
 *
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Email = Autolinker.Util.extend( Autolinker.match.Match, {

	/**
	 * @cfg {String} email (required)
	 *
	 * The email address that was matched.
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.match.Match.prototype.constructor.call( this, cfg );

		if( !cfg.email ) throw new Error( '`email` cfg required' );

		this.email = cfg.email;
	},


	/**
	 * Returns a string name for the type of match that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'email';
	},


	/**
	 * Returns the email address that was matched.
	 *
	 * @return {String}
	 */
	getEmail : function() {
		return this.email;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorHref : function() {
		return 'mailto:' + this.email;
	},


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorText : function() {
		return this.email;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.match.Hashtag
 * @extends Autolinker.match.Match
 *
 * Represents a Hashtag match found in an input string which should be
 * Autolinked.
 *
 * See this class's superclass ({@link Autolinker.match.Match}) for more
 * details.
 */
Autolinker.match.Hashtag = Autolinker.Util.extend( Autolinker.match.Match, {

	/**
	 * @cfg {String} serviceName
	 *
	 * The service to point hashtag matches to. See {@link Autolinker#hashtag}
	 * for available values.
	 */

	/**
	 * @cfg {String} hashtag (required)
	 *
	 * The Hashtag that was matched, without the '#'.
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.match.Match.prototype.constructor.call( this, cfg );

		// TODO: if( !serviceName ) throw new Error( '`serviceName` cfg required' );
		if( !cfg.hashtag ) throw new Error( '`hashtag` cfg required' );

		this.serviceName = cfg.serviceName;
		this.hashtag = cfg.hashtag;
	},


	/**
	 * Returns the type of match that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'hashtag';
	},


	/**
	 * Returns the configured {@link #serviceName} to point the Hashtag to.
	 * Ex: 'facebook', 'twitter'.
	 *
	 * @return {String}
	 */
	getServiceName : function() {
		return this.serviceName;
	},


	/**
	 * Returns the matched hashtag, without the '#' character.
	 *
	 * @return {String}
	 */
	getHashtag : function() {
		return this.hashtag;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorHref : function() {
		var serviceName = this.serviceName,
		    hashtag = this.hashtag;

		switch( serviceName ) {
			case 'twitter' :
				return 'https://twitter.com/hashtag/' + hashtag;
			case 'facebook' :
				return 'https://www.facebook.com/hashtag/' + hashtag;
			case 'instagram' :
				return 'https://instagram.com/explore/tags/' + hashtag;

			default :  // Shouldn't happen because Autolinker's constructor should block any invalid values, but just in case.
				throw new Error( 'Unknown service name to point hashtag to: ', serviceName );
		}
	},


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorText : function() {
		return '#' + this.hashtag;
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.match.Phone
 * @extends Autolinker.match.Match
 *
 * Represents a Phone number match found in an input string which should be
 * Autolinked.
 *
 * See this class's superclass ({@link Autolinker.match.Match}) for more
 * details.
 */
Autolinker.match.Phone = Autolinker.Util.extend( Autolinker.match.Match, {

	/**
	 * @protected
	 * @property {String} number (required)
	 *
	 * The phone number that was matched, without any delimiter characters.
	 *
	 * Note: This is a string to allow for prefixed 0's.
	 */

	/**
	 * @protected
	 * @property  {Boolean} plusSign (required)
	 *
	 * `true` if the matched phone number started with a '+' sign. We'll include
	 * it in the `tel:` URL if so, as this is needed for international numbers.
	 *
	 * Ex: '+1 (123) 456 7879'
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.match.Match.prototype.constructor.call( this, cfg );

		if( !cfg.number ) throw new Error( '`number` cfg required' );
		if( cfg.plusSign == null ) throw new Error( '`plusSign` cfg required' );

		this.number = cfg.number;
		this.plusSign = cfg.plusSign;
	},


	/**
	 * Returns a string name for the type of match that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'phone';
	},


	/**
	 * Returns the phone number that was matched as a string, without any
	 * delimiter characters.
	 *
	 * Note: This is a string to allow for prefixed 0's.
	 *
	 * @return {String}
	 */
	getNumber: function() {
		return this.number;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorHref : function() {
		return 'tel:' + ( this.plusSign ? '+' : '' ) + this.number;
	},


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorText : function() {
		return this.matchedText;
	}

} );

/*global Autolinker */
/**
 * @class Autolinker.match.Twitter
 * @extends Autolinker.match.Match
 *
 * Represents a Twitter match found in an input string which should be Autolinked.
 *
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Twitter = Autolinker.Util.extend( Autolinker.match.Match, {

	/**
	 * @cfg {String} twitterHandle (required)
	 *
	 * The Twitter handle that was matched, without the '@' character.
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg) {
		Autolinker.match.Match.prototype.constructor.call( this, cfg );

		if( !cfg.twitterHandle ) throw new Error( '`twitterHandle` cfg required' );

		this.twitterHandle = cfg.twitterHandle;
	},


	/**
	 * Returns the type of match that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'twitter';
	},


	/**
	 * Returns the twitter handle, without the '@' character.
	 *
	 * @return {String}
	 */
	getTwitterHandle : function() {
		return this.twitterHandle;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorHref : function() {
		return 'https://twitter.com/' + this.twitterHandle;
	},


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorText : function() {
		return '@' + this.twitterHandle;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.match.Url
 * @extends Autolinker.match.Match
 *
 * Represents a Url match found in an input string which should be Autolinked.
 *
 * See this class's superclass ({@link Autolinker.match.Match}) for more details.
 */
Autolinker.match.Url = Autolinker.Util.extend( Autolinker.match.Match, {

	/**
	 * @cfg {String} url (required)
	 *
	 * The url that was matched.
	 */

	/**
	 * @cfg {"scheme"/"www"/"tld"} urlMatchType (required)
	 *
	 * The type of URL match that this class represents. This helps to determine
	 * if the match was made in the original text with a prefixed scheme (ex:
	 * 'http://www.google.com'), a prefixed 'www' (ex: 'www.google.com'), or
	 * was matched by a known top-level domain (ex: 'google.com').
	 */

	/**
	 * @cfg {Boolean} protocolUrlMatch (required)
	 *
	 * `true` if the URL is a match which already has a protocol (i.e.
	 * 'http://'), `false` if the match was from a 'www' or known TLD match.
	 */

	/**
	 * @cfg {Boolean} protocolRelativeMatch (required)
	 *
	 * `true` if the URL is a protocol-relative match. A protocol-relative match
	 * is a URL that starts with '//', and will be either http:// or https://
	 * based on the protocol that the site is loaded under.
	 */

	/**
	 * @cfg {Boolean} stripPrefix (required)
	 * @inheritdoc Autolinker#cfg-stripPrefix
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.match.Match.prototype.constructor.call( this, cfg );

		if( cfg.urlMatchType !== 'scheme' && cfg.urlMatchType !== 'www' && cfg.urlMatchType !== 'tld' ) throw new Error( '`urlMatchType` cfg must be one of: "scheme", "www", or "tld"' );
		if( !cfg.url ) throw new Error( '`url` cfg required' );
		if( cfg.protocolUrlMatch == null ) throw new Error( '`protocolUrlMatch` cfg required' );
		if( cfg.protocolRelativeMatch == null ) throw new Error( '`protocolRelativeMatch` cfg required' );
		if( cfg.stripPrefix == null ) throw new Error( '`stripPrefix` cfg required' );

		this.urlMatchType = cfg.urlMatchType;
		this.url = cfg.url;
		this.protocolUrlMatch = cfg.protocolUrlMatch;
		this.protocolRelativeMatch = cfg.protocolRelativeMatch;
		this.stripPrefix = cfg.stripPrefix;
	},


	/**
	 * @private
	 * @property {RegExp} urlPrefixRegex
	 *
	 * A regular expression used to remove the 'http://' or 'https://' and/or the 'www.' from URLs.
	 */
	urlPrefixRegex: /^(https?:\/\/)?(www\.)?/i,

	/**
	 * @private
	 * @property {RegExp} protocolRelativeRegex
	 *
	 * The regular expression used to remove the protocol-relative '//' from the {@link #url} string, for purposes
	 * of {@link #getAnchorText}. A protocol-relative URL is, for example, "//yahoo.com"
	 */
	protocolRelativeRegex : /^\/\//,

	/**
	 * @private
	 * @property {Boolean} protocolPrepended
	 *
	 * Will be set to `true` if the 'http://' protocol has been prepended to the {@link #url} (because the
	 * {@link #url} did not have a protocol)
	 */
	protocolPrepended : false,


	/**
	 * Returns a string name for the type of match that this class represents.
	 *
	 * @return {String}
	 */
	getType : function() {
		return 'url';
	},


	/**
	 * Returns a string name for the type of URL match that this class
	 * represents.
	 *
	 * This helps to determine if the match was made in the original text with a
	 * prefixed scheme (ex: 'http://www.google.com'), a prefixed 'www' (ex:
	 * 'www.google.com'), or was matched by a known top-level domain (ex:
	 * 'google.com').
	 *
	 * @return {"scheme"/"www"/"tld"}
	 */
	getUrlMatchType : function() {
		return this.urlMatchType;
	},


	/**
	 * Returns the url that was matched, assuming the protocol to be 'http://' if the original
	 * match was missing a protocol.
	 *
	 * @return {String}
	 */
	getUrl : function() {
		var url = this.url;

		// if the url string doesn't begin with a protocol, assume 'http://'
		if( !this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended ) {
			url = this.url = 'http://' + url;

			this.protocolPrepended = true;
		}

		return url;
	},


	/**
	 * Returns the anchor href that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorHref : function() {
		var url = this.getUrl();

		return url.replace( /&amp;/g, '&' );  // any &amp;'s in the URL should be converted back to '&' if they were displayed as &amp; in the source html
	},


	/**
	 * Returns the anchor text that should be generated for the match.
	 *
	 * @return {String}
	 */
	getAnchorText : function() {
		var anchorText = this.getMatchedText();

		if( this.protocolRelativeMatch ) {
			// Strip off any protocol-relative '//' from the anchor text
			anchorText = this.stripProtocolRelativePrefix( anchorText );
		}
		if( this.stripPrefix ) {
			anchorText = this.stripUrlPrefix( anchorText );
		}
		anchorText = this.removeTrailingSlash( anchorText );  // remove trailing slash, if there is one

		return anchorText;
	},


	// ---------------------------------------

	// Utility Functionality

	/**
	 * Strips the URL prefix (such as "http://" or "https://") from the given text.
	 *
	 * @private
	 * @param {String} text The text of the anchor that is being generated, for which to strip off the
	 *   url prefix (such as stripping off "http://")
	 * @return {String} The `anchorText`, with the prefix stripped.
	 */
	stripUrlPrefix : function( text ) {
		return text.replace( this.urlPrefixRegex, '' );
	},


	/**
	 * Strips any protocol-relative '//' from the anchor text.
	 *
	 * @private
	 * @param {String} text The text of the anchor that is being generated, for which to strip off the
	 *   protocol-relative prefix (such as stripping off "//")
	 * @return {String} The `anchorText`, with the protocol-relative prefix stripped.
	 */
	stripProtocolRelativePrefix : function( text ) {
		return text.replace( this.protocolRelativeRegex, '' );
	},


	/**
	 * Removes any trailing slash from the given `anchorText`, in preparation for the text to be displayed.
	 *
	 * @private
	 * @param {String} anchorText The text of the anchor that is being generated, for which to remove any trailing
	 *   slash ('/') that may exist.
	 * @return {String} The `anchorText`, with the trailing slash removed.
	 */
	removeTrailingSlash : function( anchorText ) {
		if( anchorText.charAt( anchorText.length - 1 ) === '/' ) {
			anchorText = anchorText.slice( 0, -1 );
		}
		return anchorText;
	}

} );
/*global Autolinker */
/**
 * @abstract
 * @class Autolinker.matcher.Matcher
 *
 * An abstract class and interface for individual matchers to find matches in
 * an input string with linkified versions of them.
 *
 * Note that Matchers do not take HTML into account - they must be fed the text
 * nodes of any HTML string, which is handled by {@link Autolinker#parse}.
 */
Autolinker.matcher.Matcher = Autolinker.Util.extend( Object, {

	/**
	 * @cfg {Autolinker.AnchorTagBuilder} tagBuilder (required)
	 *
	 * Reference to the AnchorTagBuilder instance to use to generate HTML tags
	 * for {@link Autolinker.match.Match Matches}.
	 */


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Matcher
	 *   instance, specified in an Object (map).
	 */
	constructor : function( cfg ) {
		if( !cfg.tagBuilder ) throw new Error( '`tagBuilder` cfg required' );

		this.tagBuilder = cfg.tagBuilder;
	},


	/**
	 * Parses the input `text` and returns the array of {@link Autolinker.match.Match Matches}
	 * for the matcher.
	 *
	 * @abstract
	 * @param {String} text The text to scan and replace matches in.
	 * @return {Autolinker.match.Match[]}
	 */
	parseMatches : Autolinker.Util.abstractMethod

} );
/*global Autolinker */
/**
 * @class Autolinker.matcher.Email
 * @extends Autolinker.matcher.Matcher
 *
 * Matcher to find email matches in an input string.
 *
 * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.
 */
Autolinker.matcher.Email = Autolinker.Util.extend( Autolinker.matcher.Matcher, {

	/**
	 * The regular expression to match email addresses. Example match:
	 *
	 *     person@place.com
	 *
	 * @private
	 * @property {RegExp} matcherRegex
	 */
	matcherRegex : (function() {
		var alphaNumericChars = Autolinker.RegexLib.alphaNumericCharsStr,
		    emailRegex = new RegExp( '[' + alphaNumericChars + '\\-_\';:&=+$.,]+@' ),  // something@ for email addresses (a.k.a. local-part)
			domainNameRegex = Autolinker.RegexLib.domainNameRegex,
			tldRegex = Autolinker.RegexLib.tldRegex;  // match our known top level domains (TLDs)

		return new RegExp( [
			emailRegex.source,
			domainNameRegex.source,
			'\\.', tldRegex.source   // '.com', '.net', etc
		].join( "" ), 'gi' );
	} )(),


	/**
	 * @inheritdoc
	 */
	parseMatches : function( text ) {
		var matcherRegex = this.matcherRegex,
		    tagBuilder = this.tagBuilder,
		    matches = [],
		    match;

		while( ( match = matcherRegex.exec( text ) ) !== null ) {
			var matchedText = match[ 0 ];

			matches.push( new Autolinker.match.Email( {
				tagBuilder  : tagBuilder,
				matchedText : matchedText,
				offset      : match.index,
				email       : matchedText
			} ) );
		}

		return matches;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.matcher.Hashtag
 * @extends Autolinker.matcher.Matcher
 *
 * Matcher to find Hashtag matches in an input string.
 */
Autolinker.matcher.Hashtag = Autolinker.Util.extend( Autolinker.matcher.Matcher, {

	/**
	 * @cfg {String} serviceName
	 *
	 * The service to point hashtag matches to. See {@link Autolinker#hashtag}
	 * for available values.
	 */


	/**
	 * The regular expression to match Hashtags. Example match:
	 *
	 *     #asdf
	 *
	 * @private
	 * @property {RegExp} matcherRegex
	 */
	matcherRegex : new RegExp( '#[_' + Autolinker.RegexLib.alphaNumericCharsStr + ']{1,139}', 'g' ),

	/**
	 * The regular expression to use to check the character before a username match to
	 * make sure we didn't accidentally match an email address.
	 *
	 * For example, the string "asdf@asdf.com" should not match "@asdf" as a username.
	 *
	 * @private
	 * @property {RegExp} nonWordCharRegex
	 */
	nonWordCharRegex : new RegExp( '[^' + Autolinker.RegexLib.alphaNumericCharsStr + ']' ),


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match instance,
	 *   specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.matcher.Matcher.prototype.constructor.call( this, cfg );

		this.serviceName = cfg.serviceName;
	},


	/**
	 * @inheritdoc
	 */
	parseMatches : function( text ) {
		var matcherRegex = this.matcherRegex,
		    nonWordCharRegex = this.nonWordCharRegex,
		    serviceName = this.serviceName,
		    tagBuilder = this.tagBuilder,
		    matches = [],
		    match;

		while( ( match = matcherRegex.exec( text ) ) !== null ) {
			var offset = match.index,
			    prevChar = text.charAt( offset - 1 );

			// If we found the match at the beginning of the string, or we found the match
			// and there is a whitespace char in front of it (meaning it is not a '#' char
			// in the middle of a word), then it is a hashtag match.
			if( offset === 0 || nonWordCharRegex.test( prevChar ) ) {
				var matchedText = match[ 0 ],
				    hashtag = match[ 0 ].slice( 1 );  // strip off the '#' character at the beginning

				matches.push( new Autolinker.match.Hashtag( {
					tagBuilder  : tagBuilder,
					matchedText : matchedText,
					offset      : offset,
					serviceName : serviceName,
					hashtag     : hashtag
				} ) );
			}
		}

		return matches;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.matcher.Phone
 * @extends Autolinker.matcher.Matcher
 *
 * Matcher to find Phone number matches in an input string.
 *
 * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more
 * details.
 */
Autolinker.matcher.Phone = Autolinker.Util.extend( Autolinker.matcher.Matcher, {

	/**
	 * The regular expression to match Phone numbers. Example match:
	 *
	 *     (123) 456-7890
	 *
	 * This regular expression has the following capturing groups:
	 *
	 * 1. The prefixed '+' sign, if there is one.
	 *
	 * @private
	 * @property {RegExp} matcherRegex
	 */
	matcherRegex : /(?:(\+)?\d{1,3}[-\040.])?\(?\d{3}\)?[-\040.]?\d{3}[-\040.]\d{4}/g,  // ex: (123) 456-7890, 123 456 7890, 123-456-7890, etc.

	/**
	 * @inheritdoc
	 */
	parseMatches : function( text ) {
		var matcherRegex = this.matcherRegex,
		    tagBuilder = this.tagBuilder,
		    matches = [],
		    match;

		while( ( match = matcherRegex.exec( text ) ) !== null ) {
			// Remove non-numeric values from phone number string
			var matchedText = match[ 0 ],
			    cleanNumber = matchedText.replace( /\D/g, '' ),  // strip out non-digit characters
			    plusSign = !!match[ 1 ];  // match[ 1 ] is the prefixed plus sign, if there is one

			matches.push( new Autolinker.match.Phone( {
				tagBuilder  : tagBuilder,
				matchedText : matchedText,
				offset      : match.index,
				number      : cleanNumber,
				plusSign    : plusSign
			} ) );
		}

		return matches;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.matcher.Twitter
 * @extends Autolinker.matcher.Matcher
 *
 * Matcher to find/replace username matches in an input string.
 */
Autolinker.matcher.Twitter = Autolinker.Util.extend( Autolinker.matcher.Matcher, {

	/**
	 * The regular expression to match username handles. Example match:
	 *
	 *     @asdf
	 *
	 * @private
	 * @property {RegExp} matcherRegex
	 */
	matcherRegex : new RegExp( '@[_' + Autolinker.RegexLib.alphaNumericCharsStr + ']{1,20}', 'g' ),

	/**
	 * The regular expression to use to check the character before a username match to
	 * make sure we didn't accidentally match an email address.
	 *
	 * For example, the string "asdf@asdf.com" should not match "@asdf" as a username.
	 *
	 * @private
	 * @property {RegExp} nonWordCharRegex
	 */
	nonWordCharRegex : new RegExp( '[^' + Autolinker.RegexLib.alphaNumericCharsStr + ']' ),


	/**
	 * @inheritdoc
	 */
	parseMatches : function( text ) {
		var matcherRegex = this.matcherRegex,
		    nonWordCharRegex = this.nonWordCharRegex,
		    tagBuilder = this.tagBuilder,
		    matches = [],
		    match;

		while( ( match = matcherRegex.exec( text ) ) !== null ) {
			var offset = match.index,
			    prevChar = text.charAt( offset - 1 );

			// If we found the match at the beginning of the string, or we found the match
			// and there is a whitespace char in front of it (meaning it is not an email
			// address), then it is a username match.
			if( offset === 0 || nonWordCharRegex.test( prevChar ) ) {
				var matchedText = match[ 0 ],
				    twitterHandle = match[ 0 ].slice( 1 );  // strip off the '@' character at the beginning

				matches.push( new Autolinker.match.Twitter( {
					tagBuilder    : tagBuilder,
					matchedText   : matchedText,
					offset        : offset,
					twitterHandle : twitterHandle
				} ) );
			}
		}

		return matches;
	}

} );
/*global Autolinker */
/**
 * @class Autolinker.matcher.Url
 * @extends Autolinker.matcher.Matcher
 *
 * Matcher to find URL matches in an input string.
 *
 * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.
 */
Autolinker.matcher.Url = Autolinker.Util.extend( Autolinker.matcher.Matcher, {

	/**
	 * @cfg {Boolean} stripPrefix (required)
	 * @inheritdoc Autolinker#stripPrefix
	 */


	/**
	 * @private
	 * @property {RegExp} matcherRegex
	 *
	 * The regular expression to match URLs with an optional scheme, port
	 * number, path, query string, and hash anchor.
	 *
	 * Example matches:
	 *
	 *     http://google.com
	 *     www.google.com
	 *     google.com/path/to/file?q1=1&q2=2#myAnchor
	 *
	 *
	 * This regular expression will have the following capturing groups:
	 *
	 * 1.  Group that matches a scheme-prefixed URL (i.e. 'http://google.com').
	 *     This is used to match scheme URLs with just a single word, such as
	 *     'http://localhost', where we won't double check that the domain name
	 *     has at least one dot ('.') in it.
	 * 2.  Group that matches a 'www.' prefixed URL. This is only matched if the
	 *     'www.' text was not prefixed by a scheme (i.e.: not prefixed by
	 *     'http://', 'ftp:', etc.)
	 * 3.  A protocol-relative ('//') match for the case of a 'www.' prefixed
	 *     URL. Will be an empty string if it is not a protocol-relative match.
	 *     We need to know the character before the '//' in order to determine
	 *     if it is a valid match or the // was in a string we don't want to
	 *     auto-link.
	 * 4.  Group that matches a known TLD (top level domain), when a scheme
	 *     or 'www.'-prefixed domain is not matched.
	 * 5.  A protocol-relative ('//') match for the case of a known TLD prefixed
	 *     URL. Will be an empty string if it is not a protocol-relative match.
	 *     See #3 for more info.
	 */
	matcherRegex : (function() {
		var schemeRegex = /(?:[A-Za-z][-.+A-Za-z0-9]*:(?![A-Za-z][-.+A-Za-z0-9]*:\/\/)(?!\d+\/?)(?:\/\/)?)/,  // match protocol, allow in format "http://" or "mailto:". However, do not match the first part of something like 'link:http://www.google.com' (i.e. don't match "link:"). Also, make sure we don't interpret 'google.com:8000' as if 'google.com' was a protocol here (i.e. ignore a trailing port number in this regex)
		    wwwRegex = /(?:www\.)/,                  // starting with 'www.'
		    domainNameRegex = Autolinker.RegexLib.domainNameRegex,
		    tldRegex = Autolinker.RegexLib.tldRegex,  // match our known top level domains (TLDs)
		    alphaNumericCharsStr = Autolinker.RegexLib.alphaNumericCharsStr,

		    // Allow optional path, query string, and hash anchor, not ending in the following characters: "?!:,.;"
		    // http://blog.codinghorror.com/the-problem-with-urls/
		    urlSuffixRegex = new RegExp( '[' + alphaNumericCharsStr + '\\-+&@#/%=~_()|\'$*\\[\\]?!:,.;]*[' + alphaNumericCharsStr + '\\-+&@#/%=~_()|\'$*\\[\\]]' );

		return new RegExp( [
			'(?:', // parens to cover match for scheme (optional), and domain
				'(',  // *** Capturing group $1, for a scheme-prefixed url (ex: http://google.com)
					schemeRegex.source,
					domainNameRegex.source,
				')',

				'|',

				'(',  // *** Capturing group $2, for a 'www.' prefixed url (ex: www.google.com)
					'(//)?',  // *** Capturing group $3 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character (handled later)
					wwwRegex.source,
					domainNameRegex.source,
				')',

				'|',

				'(',  // *** Capturing group $4, for known a TLD url (ex: google.com)
					'(//)?',  // *** Capturing group $5 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character (handled later)
					domainNameRegex.source + '\\.',
					tldRegex.source,
				')',
			')',

			'(?:' + urlSuffixRegex.source + ')?'  // match for path, query string, and/or hash anchor - optional
		].join( "" ), 'gi' );
	} )(),


	/**
	 * A regular expression to use to check the character before a protocol-relative
	 * URL match. We don't want to match a protocol-relative URL if it is part
	 * of another word.
	 *
	 * For example, we want to match something like "Go to: //google.com",
	 * but we don't want to match something like "abc//google.com"
	 *
	 * This regular expression is used to test the character before the '//'.
	 *
	 * @private
	 * @type {RegExp} wordCharRegExp
	 */
	wordCharRegExp : /\w/,


	/**
	 * The regular expression to match opening parenthesis in a URL match.
	 *
	 * This is to determine if we have unbalanced parenthesis in the URL, and to
	 * drop the final parenthesis that was matched if so.
	 *
	 * Ex: The text "(check out: wikipedia.com/something_(disambiguation))"
	 * should only autolink the inner "wikipedia.com/something_(disambiguation)"
	 * part, so if we find that we have unbalanced parenthesis, we will drop the
	 * last one for the match.
	 *
	 * @private
	 * @property {RegExp}
	 */
	openParensRe : /\(/g,

	/**
	 * The regular expression to match closing parenthesis in a URL match. See
	 * {@link #openParensRe} for more information.
	 *
	 * @private
	 * @property {RegExp}
	 */
	closeParensRe : /\)/g,


	/**
	 * @constructor
	 * @param {Object} cfg The configuration properties for the Match instance,
	 *   specified in an Object (map).
	 */
	constructor : function( cfg ) {
		Autolinker.matcher.Matcher.prototype.constructor.call( this, cfg );

		this.stripPrefix = cfg.stripPrefix;

		if( this.stripPrefix == null ) throw new Error( '`stripPrefix` cfg required' );
	},


	/**
	 * @inheritdoc
	 */
	parseMatches : function( text ) {
		var matcherRegex = this.matcherRegex,
		    stripPrefix = this.stripPrefix,
		    tagBuilder = this.tagBuilder,
		    matches = [],
		    match;

		while( ( match = matcherRegex.exec( text ) ) !== null ) {
			var matchStr = match[ 0 ],
			    schemeUrlMatch = match[ 1 ],
			    wwwUrlMatch = match[ 2 ],
			    wwwProtocolRelativeMatch = match[ 3 ],
			    //tldUrlMatch = match[ 4 ],  -- not needed at the moment
			    tldProtocolRelativeMatch = match[ 5 ],
			    offset = match.index,
			    protocolRelativeMatch = wwwProtocolRelativeMatch || tldProtocolRelativeMatch,
				prevChar = text.charAt( offset - 1 );

			if( !Autolinker.matcher.UrlMatchValidator.isValid( matchStr, schemeUrlMatch ) ) {
				continue;
			}

			// If the match is preceded by an '@' character, then it is either
			// an email address or a username. Skip these types of matches.
			if( offset > 0 && prevChar === '@' ) {
				continue;
			}

			// If it's a protocol-relative '//' match, but the character before the '//'
			// was a word character (i.e. a letter/number), then we found the '//' in the
			// middle of another word (such as "asdf//asdf.com"). In this case, skip the
			// match.
			if( offset > 0 && protocolRelativeMatch && this.wordCharRegExp.test( prevChar ) ) {
				continue;
			}

			// Handle a closing parenthesis at the end of the match, and exclude
			// it if there is not a matching open parenthesis in the match
			// itself.
			if( this.matchHasUnbalancedClosingParen( matchStr ) ) {
				matchStr = matchStr.substr( 0, matchStr.length - 1 );  // remove the trailing ")"
			} else {
				// Handle an invalid character after the TLD
				var pos = this.matchHasInvalidCharAfterTld( matchStr, schemeUrlMatch );
				if( pos > -1 ) {
					matchStr = matchStr.substr( 0, pos ); // remove the trailing invalid chars
				}
			}

			var urlMatchType = schemeUrlMatch ? 'scheme' : ( wwwUrlMatch ? 'www' : 'tld' ),
			    protocolUrlMatch = !!schemeUrlMatch;

			matches.push( new Autolinker.match.Url( {
				tagBuilder            : tagBuilder,
				matchedText           : matchStr,
				offset                : offset,
				urlMatchType          : urlMatchType,
				url                   : matchStr,
				protocolUrlMatch      : protocolUrlMatch,
				protocolRelativeMatch : !!protocolRelativeMatch,
				stripPrefix           : stripPrefix
			} ) );
		}

		return matches;
	},


	/**
	 * Determines if a match found has an unmatched closing parenthesis. If so,
	 * this parenthesis will be removed from the match itself, and appended
	 * after the generated anchor tag.
	 *
	 * A match may have an extra closing parenthesis at the end of the match
	 * because the regular expression must include parenthesis for URLs such as
	 * "wikipedia.com/something_(disambiguation)", which should be auto-linked.
	 *
	 * However, an extra parenthesis *will* be included when the URL itself is
	 * wrapped in parenthesis, such as in the case of "(wikipedia.com/something_(disambiguation))".
	 * In this case, the last closing parenthesis should *not* be part of the
	 * URL itself, and this method will return `true`.
	 *
	 * @private
	 * @param {String} matchStr The full match string from the {@link #matcherRegex}.
	 * @return {Boolean} `true` if there is an unbalanced closing parenthesis at
	 *   the end of the `matchStr`, `false` otherwise.
	 */
	matchHasUnbalancedClosingParen : function( matchStr ) {
		var lastChar = matchStr.charAt( matchStr.length - 1 );

		if( lastChar === ')' ) {
			var openParensMatch = matchStr.match( this.openParensRe ),
			    closeParensMatch = matchStr.match( this.closeParensRe ),
			    numOpenParens = ( openParensMatch && openParensMatch.length ) || 0,
			    numCloseParens = ( closeParensMatch && closeParensMatch.length ) || 0;

			if( numOpenParens < numCloseParens ) {
				return true;
			}
		}

		return false;
	},


	/**
	 * Determine if there's an invalid character after the TLD in a URL. Valid
	 * characters after TLD are ':/?#'. Exclude scheme matched URLs from this
	 * check.
	 *
	 * @private
	 * @param {String} urlMatch The matched URL, if there was one. Will be an
	 *   empty string if the match is not a URL match.
	 * @param {String} schemeUrlMatch The match URL string for a scheme
	 *   match. Ex: 'http://yahoo.com'. This is used to match something like
	 *   'http://localhost', where we won't double check that the domain name
	 *   has at least one '.' in it.
	 * @return {Number} the position where the invalid character was found. If
	 *   no such character was found, returns -1
	 */
	matchHasInvalidCharAfterTld : function( urlMatch, schemeUrlMatch ) {
		if( !urlMatch ) {
			return -1;
		}

		var offset = 0;
		if ( schemeUrlMatch ) {
			offset = urlMatch.indexOf(':');
			urlMatch = urlMatch.slice(offset);
		}

		var re = /^((.?\/\/)?[A-Za-z0-9\u00C0-\u017F\.\-]*[A-Za-z0-9\u00C0-\u017F\-]\.[A-Za-z]+)/;
		var res = re.exec( urlMatch );
		if ( res === null ) {
			return -1;
		}

		offset += res[1].length;
		urlMatch = urlMatch.slice(res[1].length);
		if (/^[^.A-Za-z:\/?#]/.test(urlMatch)) {
			return offset;
		}

		return -1;
	}

} );
/*global Autolinker */
/*jshint scripturl:true */
/**
 * @private
 * @class Autolinker.matcher.UrlMatchValidator
 * @singleton
 *
 * Used by Autolinker to filter out false URL positives from the
 * {@link Autolinker.matcher.Url UrlMatcher}.
 *
 * Due to the limitations of regular expressions (including the missing feature
 * of look-behinds in JS regular expressions), we cannot always determine the
 * validity of a given match. This class applies a bit of additional logic to
 * filter out any false positives that have been matched by the
 * {@link Autolinker.matcher.Url UrlMatcher}.
 */
Autolinker.matcher.UrlMatchValidator = {

	/**
	 * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'
	 *
	 * @private
	 * @property {RegExp} hasFullProtocolRegex
	 */
	hasFullProtocolRegex : /^[A-Za-z][-.+A-Za-z0-9]*:\/\//,

	/**
	 * Regex to find the URI scheme, such as 'mailto:'.
	 *
	 * This is used to filter out 'javascript:' and 'vbscript:' schemes.
	 *
	 * @private
	 * @property {RegExp} uriSchemeRegex
	 */
	uriSchemeRegex : /^[A-Za-z][-.+A-Za-z0-9]*:/,

	/**
	 * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')
	 *
	 * @private
	 * @property {RegExp} hasWordCharAfterProtocolRegex
	 */
	hasWordCharAfterProtocolRegex : /:[^\s]*?[A-Za-z\u00C0-\u017F]/,

	/**
	 * Regex to determine if the string is a valid IP address
	 *
	 * @private
	 * @property {RegExp} ipRegex
	 */
	ipRegex: /[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?(:[0-9]*)?\/?$/,

	/**
	 * Determines if a given URL match found by the {@link Autolinker.matcher.Url UrlMatcher}
	 * is valid. Will return `false` for:
	 *
	 * 1) URL matches which do not have at least have one period ('.') in the
	 *    domain name (effectively skipping over matches like "abc:def").
	 *    However, URL matches with a protocol will be allowed (ex: 'http://localhost')
	 * 2) URL matches which do not have at least one word character in the
	 *    domain name (effectively skipping over matches like "git:1.0").
	 * 3) A protocol-relative url match (a URL beginning with '//') whose
	 *    previous character is a word character (effectively skipping over
	 *    strings like "abc//google.com")
	 *
	 * Otherwise, returns `true`.
	 *
	 * @param {String} urlMatch The matched URL, if there was one. Will be an
	 *   empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol
	 *   match. Ex: 'http://yahoo.com'. This is used to match something like
	 *   'http://localhost', where we won't double check that the domain name
	 *   has at least one '.' in it.
	 * @return {Boolean} `true` if the match given is valid and should be
	 *   processed, or `false` if the match is invalid and/or should just not be
	 *   processed.
	 */
	isValid : function( urlMatch, protocolUrlMatch ) {
		if(
			( protocolUrlMatch && !this.isValidUriScheme( protocolUrlMatch ) ) ||
			this.urlMatchDoesNotHaveProtocolOrDot( urlMatch, protocolUrlMatch ) ||    // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')
			(this.urlMatchDoesNotHaveAtLeastOneWordChar( urlMatch, protocolUrlMatch ) && // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like "git:1.0"
			 !this.isValidIpAddress( urlMatch ) // Except if it's an IP address
			)
		) {
			return false;
		}

		return true;
	},


	isValidIpAddress : function ( uriSchemeMatch ) {
		var newRegex = new RegExp(this.hasFullProtocolRegex.source + this.ipRegex.source);
		var uriScheme = uriSchemeMatch.match( newRegex );

		return uriScheme !== null;
	},

	/**
	 * Determines if the URI scheme is a valid scheme to be autolinked. Returns
	 * `false` if the scheme is 'javascript:' or 'vbscript:'
	 *
	 * @private
	 * @param {String} uriSchemeMatch The match URL string for a full URI scheme
	 *   match. Ex: 'http://yahoo.com' or 'mailto:a@a.com'.
	 * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.
	 */
	isValidUriScheme : function( uriSchemeMatch ) {
		var uriScheme = uriSchemeMatch.match( this.uriSchemeRegex )[ 0 ].toLowerCase();

		return ( uriScheme !== 'javascript:' && uriScheme !== 'vbscript:' );
	},


	/**
	 * Determines if a URL match does not have either:
	 *
	 * a) a full protocol (i.e. 'http://'), or
	 * b) at least one dot ('.') in the domain name (for a non-full-protocol
	 *    match).
	 *
	 * Either situation is considered an invalid URL (ex: 'git:d' does not have
	 * either the '://' part, or at least one dot in the domain name. If the
	 * match was 'git:abc.com', we would consider this valid.)
	 *
	 * @private
	 * @param {String} urlMatch The matched URL, if there was one. Will be an
	 *   empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol
	 *   match. Ex: 'http://yahoo.com'. This is used to match something like
	 *   'http://localhost', where we won't double check that the domain name
	 *   has at least one '.' in it.
	 * @return {Boolean} `true` if the URL match does not have a full protocol,
	 *   or at least one dot ('.') in a non-full-protocol match.
	 */
	urlMatchDoesNotHaveProtocolOrDot : function( urlMatch, protocolUrlMatch ) {
		return ( !!urlMatch && ( !protocolUrlMatch || !this.hasFullProtocolRegex.test( protocolUrlMatch ) ) && urlMatch.indexOf( '.' ) === -1 );
	},


	/**
	 * Determines if a URL match does not have at least one word character after
	 * the protocol (i.e. in the domain name).
	 *
	 * At least one letter character must exist in the domain name after a
	 * protocol match. Ex: skip over something like "git:1.0"
	 *
	 * @private
	 * @param {String} urlMatch The matched URL, if there was one. Will be an
	 *   empty string if the match is not a URL match.
	 * @param {String} protocolUrlMatch The match URL string for a protocol
	 *   match. Ex: 'http://yahoo.com'. This is used to know whether or not we
	 *   have a protocol in the URL string, in order to check for a word
	 *   character after the protocol separator (':').
	 * @return {Boolean} `true` if the URL match does not have at least one word
	 *   character in it after the protocol, `false` otherwise.
	 */
	urlMatchDoesNotHaveAtLeastOneWordChar : function( urlMatch, protocolUrlMatch ) {
		if( urlMatch && protocolUrlMatch ) {
			return !this.hasWordCharAfterProtocolRegex.test( urlMatch );
		} else {
			return false;
		}
	}

};
/*global Autolinker */
/**
 * A truncation feature where the ellipsis will be placed at the end of the URL.
 *
 * @param {String} anchorText
 * @param {Number} truncateLen The maximum length of the truncated output URL string.
 * @param {String} ellipsisChars The characters to place within the url, e.g. "..".
 * @return {String} The truncated URL.
 */
Autolinker.truncate.TruncateEnd = function(anchorText, truncateLen, ellipsisChars){
	return Autolinker.Util.ellipsis( anchorText, truncateLen, ellipsisChars );
};

/*global Autolinker */
/**
 * Date: 2015-10-05
 * Author: Kasper Søfren <soefritz@gmail.com> (https://github.com/kafoso)
 *
 * A truncation feature, where the ellipsis will be placed in the dead-center of the URL.
 *
 * @param {String} url             A URL.
 * @param {Number} truncateLen     The maximum length of the truncated output URL string.
 * @param {String} ellipsisChars   The characters to place within the url, e.g. "..".
 * @return {String} The truncated URL.
 */
Autolinker.truncate.TruncateMiddle = function(url, truncateLen, ellipsisChars){
  if (url.length <= truncateLen) {
    return url;
  }
  var availableLength = truncateLen - ellipsisChars.length;
  var end = "";
  if (availableLength > 0) {
    end = url.substr((-1)*Math.floor(availableLength/2));
  }
  return (url.substr(0, Math.ceil(availableLength/2)) + ellipsisChars + end).substr(0, truncateLen);
};

/*global Autolinker */
/**
 * Date: 2015-10-05
 * Author: Kasper Søfren <soefritz@gmail.com> (https://github.com/kafoso)
 *
 * A truncation feature, where the ellipsis will be placed at a section within
 * the URL making it still somewhat human readable.
 *
 * @param {String} url						 A URL.
 * @param {Number} truncateLen		 The maximum length of the truncated output URL string.
 * @param {String} ellipsisChars	 The characters to place within the url, e.g. "..".
 * @return {String} The truncated URL.
 */
Autolinker.truncate.TruncateSmart = function(url, truncateLen, ellipsisChars){
	var parse_url = function(url){ // Functionality inspired by PHP function of same name
		var urlObj = {};
		var urlSub = url;
		var match = urlSub.match(/^([a-z]+):\/\//i);
		if (match) {
			urlObj.scheme = match[1];
			urlSub = urlSub.substr(match[0].length);
		}
		match = urlSub.match(/^(.*?)(?=(\?|#|\/|$))/i);
		if (match) {
			urlObj.host = match[1];
			urlSub = urlSub.substr(match[0].length);
		}
		match = urlSub.match(/^\/(.*?)(?=(\?|#|$))/i);
		if (match) {
			urlObj.path = match[1];
			urlSub = urlSub.substr(match[0].length);
		}
		match = urlSub.match(/^\?(.*?)(?=(#|$))/i);
		if (match) {
			urlObj.query = match[1];
			urlSub = urlSub.substr(match[0].length);
		}
		match = urlSub.match(/^#(.*?)$/i);
		if (match) {
			urlObj.fragment = match[1];
			//urlSub = urlSub.substr(match[0].length);  -- not used. Uncomment if adding another block.
		}
		return urlObj;
	};

	var buildUrl = function(urlObj){
		var url = "";
		if (urlObj.scheme && urlObj.host) {
			url += urlObj.scheme + "://";
		}
		if (urlObj.host) {
			url += urlObj.host;
		}
		if (urlObj.path) {
			url += "/" + urlObj.path;
		}
		if (urlObj.query) {
			url += "?" + urlObj.query;
		}
		if (urlObj.fragment) {
			url += "#" + urlObj.fragment;
		}
		return url;
	};

	var buildSegment = function(segment, remainingAvailableLength){
		var remainingAvailableLengthHalf = remainingAvailableLength/ 2,
				startOffset = Math.ceil(remainingAvailableLengthHalf),
				endOffset = (-1)*Math.floor(remainingAvailableLengthHalf),
				end = "";
		if (endOffset < 0) {
			end = segment.substr(endOffset);
		}
		return segment.substr(0, startOffset) + ellipsisChars + end;
	};
	if (url.length <= truncateLen) {
		return url;
	}
	var availableLength = truncateLen - ellipsisChars.length;
	var urlObj = parse_url(url);
	// Clean up the URL
	if (urlObj.query) {
		var matchQuery = urlObj.query.match(/^(.*?)(?=(\?|\#))(.*?)$/i);
		if (matchQuery) {
			// Malformed URL; two or more "?". Removed any content behind the 2nd.
			urlObj.query = urlObj.query.substr(0, matchQuery[1].length);
			url = buildUrl(urlObj);
		}
	}
	if (url.length <= truncateLen) {
		return url;
	}
	if (urlObj.host) {
		urlObj.host = urlObj.host.replace(/^www\./, "");
		url = buildUrl(urlObj);
	}
	if (url.length <= truncateLen) {
		return url;
	}
	// Process and build the URL
	var str = "";
	if (urlObj.host) {
		str += urlObj.host;
	}
	if (str.length >= availableLength) {
		if (urlObj.host.length == truncateLen) {
			return (urlObj.host.substr(0, (truncateLen - ellipsisChars.length)) + ellipsisChars).substr(0, truncateLen);
		}
		return buildSegment(str, availableLength).substr(0, truncateLen);
	}
	var pathAndQuery = "";
	if (urlObj.path) {
		pathAndQuery += "/" + urlObj.path;
	}
	if (urlObj.query) {
		pathAndQuery += "?" + urlObj.query;
	}
	if (pathAndQuery) {
		if ((str+pathAndQuery).length >= availableLength) {
			if ((str+pathAndQuery).length == truncateLen) {
				return (str + pathAndQuery).substr(0, truncateLen);
			}
			var remainingAvailableLength = availableLength - str.length;
			return (str + buildSegment(pathAndQuery, remainingAvailableLength)).substr(0, truncateLen);
		} else {
			str += pathAndQuery;
		}
	}
	if (urlObj.fragment) {
		var fragment = "#"+urlObj.fragment;
		if ((str+fragment).length >= availableLength) {
			if ((str+fragment).length == truncateLen) {
				return (str + fragment).substr(0, truncateLen);
			}
			var remainingAvailableLength2 = availableLength - str.length;
			return (str + buildSegment(fragment, remainingAvailableLength2)).substr(0, truncateLen);
		} else {
			str += fragment;
		}
	}
	if (urlObj.scheme && urlObj.host) {
		var scheme = urlObj.scheme + "://";
		if ((str+scheme).length < availableLength) {
			return (scheme + str).substr(0, truncateLen);
		}
	}
	if (str.length <= truncateLen) {
		return str;
	}
	var end = "";
	if (availableLength > 0) {
		end = str.substr((-1)*Math.floor(availableLength/2));
	}
	return (str.substr(0, Math.ceil(availableLength/2)) + ellipsisChars + end).substr(0, truncateLen);
};

return Autolinker;
}));


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/font-awesome/css/font-awesome.css":
/*!**********************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/font-awesome/css/font-awesome.css ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
var ___CSS_LOADER_GET_URL_IMPORT___ = __webpack_require__(/*! ../../css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
var ___CSS_LOADER_URL_IMPORT_0___ = __webpack_require__(/*! ../fonts/fontawesome-webfont.eot?v=4.7.0 */ "./node_modules/font-awesome/fonts/fontawesome-webfont.eot?v=4.7.0");
var ___CSS_LOADER_URL_IMPORT_1___ = __webpack_require__(/*! ../fonts/fontawesome-webfont.eot */ "./node_modules/font-awesome/fonts/fontawesome-webfont.eot");
var ___CSS_LOADER_URL_IMPORT_2___ = __webpack_require__(/*! ../fonts/fontawesome-webfont.woff2?v=4.7.0 */ "./node_modules/font-awesome/fonts/fontawesome-webfont.woff2?v=4.7.0");
var ___CSS_LOADER_URL_IMPORT_3___ = __webpack_require__(/*! ../fonts/fontawesome-webfont.woff?v=4.7.0 */ "./node_modules/font-awesome/fonts/fontawesome-webfont.woff?v=4.7.0");
var ___CSS_LOADER_URL_IMPORT_4___ = __webpack_require__(/*! ../fonts/fontawesome-webfont.ttf?v=4.7.0 */ "./node_modules/font-awesome/fonts/fontawesome-webfont.ttf?v=4.7.0");
var ___CSS_LOADER_URL_IMPORT_5___ = __webpack_require__(/*! ../fonts/fontawesome-webfont.svg?v=4.7.0 */ "./node_modules/font-awesome/fonts/fontawesome-webfont.svg?v=4.7.0");
exports = ___CSS_LOADER_API_IMPORT___(false);
var ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___, { hash: "?#iefix&v=4.7.0" });
var ___CSS_LOADER_URL_REPLACEMENT_2___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_2___);
var ___CSS_LOADER_URL_REPLACEMENT_3___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_3___);
var ___CSS_LOADER_URL_REPLACEMENT_4___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_4___);
var ___CSS_LOADER_URL_REPLACEMENT_5___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_5___, { hash: "#fontawesomeregular" });
// Module
exports.push([module.i, "/*!\n *  Font Awesome 4.7.0 by @davegandy - http://fontawesome.io - @fontawesome\n *  License - http://fontawesome.io/license (Font: SIL OFL 1.1, CSS: MIT License)\n */\n/* FONT PATH\n * -------------------------- */\n@font-face {\n  font-family: 'FontAwesome';\n  src: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ");\n  src: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ") format('embedded-opentype'), url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ") format('woff2'), url(" + ___CSS_LOADER_URL_REPLACEMENT_3___ + ") format('woff'), url(" + ___CSS_LOADER_URL_REPLACEMENT_4___ + ") format('truetype'), url(" + ___CSS_LOADER_URL_REPLACEMENT_5___ + ") format('svg');\n  font-weight: normal;\n  font-style: normal;\n}\n.fa {\n  display: inline-block;\n  font: normal normal normal 14px/1 FontAwesome;\n  font-size: inherit;\n  text-rendering: auto;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n/* makes the font 33% larger relative to the icon container */\n.fa-lg {\n  font-size: 1.33333333em;\n  line-height: 0.75em;\n  vertical-align: -15%;\n}\n.fa-2x {\n  font-size: 2em;\n}\n.fa-3x {\n  font-size: 3em;\n}\n.fa-4x {\n  font-size: 4em;\n}\n.fa-5x {\n  font-size: 5em;\n}\n.fa-fw {\n  width: 1.28571429em;\n  text-align: center;\n}\n.fa-ul {\n  padding-left: 0;\n  margin-left: 2.14285714em;\n  list-style-type: none;\n}\n.fa-ul > li {\n  position: relative;\n}\n.fa-li {\n  position: absolute;\n  left: -2.14285714em;\n  width: 2.14285714em;\n  top: 0.14285714em;\n  text-align: center;\n}\n.fa-li.fa-lg {\n  left: -1.85714286em;\n}\n.fa-border {\n  padding: .2em .25em .15em;\n  border: solid 0.08em #eeeeee;\n  border-radius: .1em;\n}\n.fa-pull-left {\n  float: left;\n}\n.fa-pull-right {\n  float: right;\n}\n.fa.fa-pull-left {\n  margin-right: .3em;\n}\n.fa.fa-pull-right {\n  margin-left: .3em;\n}\n/* Deprecated as of 4.4.0 */\n.pull-right {\n  float: right;\n}\n.pull-left {\n  float: left;\n}\n.fa.pull-left {\n  margin-right: .3em;\n}\n.fa.pull-right {\n  margin-left: .3em;\n}\n.fa-spin {\n  -webkit-animation: fa-spin 2s infinite linear;\n  animation: fa-spin 2s infinite linear;\n}\n.fa-pulse {\n  -webkit-animation: fa-spin 1s infinite steps(8);\n  animation: fa-spin 1s infinite steps(8);\n}\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n    transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(359deg);\n    transform: rotate(359deg);\n  }\n}\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n    transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(359deg);\n    transform: rotate(359deg);\n  }\n}\n.fa-rotate-90 {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)\";\n  -webkit-transform: rotate(90deg);\n  -ms-transform: rotate(90deg);\n  transform: rotate(90deg);\n}\n.fa-rotate-180 {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)\";\n  -webkit-transform: rotate(180deg);\n  -ms-transform: rotate(180deg);\n  transform: rotate(180deg);\n}\n.fa-rotate-270 {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)\";\n  -webkit-transform: rotate(270deg);\n  -ms-transform: rotate(270deg);\n  transform: rotate(270deg);\n}\n.fa-flip-horizontal {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)\";\n  -webkit-transform: scale(-1, 1);\n  -ms-transform: scale(-1, 1);\n  transform: scale(-1, 1);\n}\n.fa-flip-vertical {\n  -ms-filter: \"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)\";\n  -webkit-transform: scale(1, -1);\n  -ms-transform: scale(1, -1);\n  transform: scale(1, -1);\n}\n:root .fa-rotate-90,\n:root .fa-rotate-180,\n:root .fa-rotate-270,\n:root .fa-flip-horizontal,\n:root .fa-flip-vertical {\n  filter: none;\n}\n.fa-stack {\n  position: relative;\n  display: inline-block;\n  width: 2em;\n  height: 2em;\n  line-height: 2em;\n  vertical-align: middle;\n}\n.fa-stack-1x,\n.fa-stack-2x {\n  position: absolute;\n  left: 0;\n  width: 100%;\n  text-align: center;\n}\n.fa-stack-1x {\n  line-height: inherit;\n}\n.fa-stack-2x {\n  font-size: 2em;\n}\n.fa-inverse {\n  color: #ffffff;\n}\n/* Font Awesome uses the Unicode Private Use Area (PUA) to ensure screen\n   readers do not read off random characters that represent icons */\n.fa-glass:before {\n  content: \"\\f000\";\n}\n.fa-music:before {\n  content: \"\\f001\";\n}\n.fa-search:before {\n  content: \"\\f002\";\n}\n.fa-envelope-o:before {\n  content: \"\\f003\";\n}\n.fa-heart:before {\n  content: \"\\f004\";\n}\n.fa-star:before {\n  content: \"\\f005\";\n}\n.fa-star-o:before {\n  content: \"\\f006\";\n}\n.fa-user:before {\n  content: \"\\f007\";\n}\n.fa-film:before {\n  content: \"\\f008\";\n}\n.fa-th-large:before {\n  content: \"\\f009\";\n}\n.fa-th:before {\n  content: \"\\f00a\";\n}\n.fa-th-list:before {\n  content: \"\\f00b\";\n}\n.fa-check:before {\n  content: \"\\f00c\";\n}\n.fa-remove:before,\n.fa-close:before,\n.fa-times:before {\n  content: \"\\f00d\";\n}\n.fa-search-plus:before {\n  content: \"\\f00e\";\n}\n.fa-search-minus:before {\n  content: \"\\f010\";\n}\n.fa-power-off:before {\n  content: \"\\f011\";\n}\n.fa-signal:before {\n  content: \"\\f012\";\n}\n.fa-gear:before,\n.fa-cog:before {\n  content: \"\\f013\";\n}\n.fa-trash-o:before {\n  content: \"\\f014\";\n}\n.fa-home:before {\n  content: \"\\f015\";\n}\n.fa-file-o:before {\n  content: \"\\f016\";\n}\n.fa-clock-o:before {\n  content: \"\\f017\";\n}\n.fa-road:before {\n  content: \"\\f018\";\n}\n.fa-download:before {\n  content: \"\\f019\";\n}\n.fa-arrow-circle-o-down:before {\n  content: \"\\f01a\";\n}\n.fa-arrow-circle-o-up:before {\n  content: \"\\f01b\";\n}\n.fa-inbox:before {\n  content: \"\\f01c\";\n}\n.fa-play-circle-o:before {\n  content: \"\\f01d\";\n}\n.fa-rotate-right:before,\n.fa-repeat:before {\n  content: \"\\f01e\";\n}\n.fa-refresh:before {\n  content: \"\\f021\";\n}\n.fa-list-alt:before {\n  content: \"\\f022\";\n}\n.fa-lock:before {\n  content: \"\\f023\";\n}\n.fa-flag:before {\n  content: \"\\f024\";\n}\n.fa-headphones:before {\n  content: \"\\f025\";\n}\n.fa-volume-off:before {\n  content: \"\\f026\";\n}\n.fa-volume-down:before {\n  content: \"\\f027\";\n}\n.fa-volume-up:before {\n  content: \"\\f028\";\n}\n.fa-qrcode:before {\n  content: \"\\f029\";\n}\n.fa-barcode:before {\n  content: \"\\f02a\";\n}\n.fa-tag:before {\n  content: \"\\f02b\";\n}\n.fa-tags:before {\n  content: \"\\f02c\";\n}\n.fa-book:before {\n  content: \"\\f02d\";\n}\n.fa-bookmark:before {\n  content: \"\\f02e\";\n}\n.fa-print:before {\n  content: \"\\f02f\";\n}\n.fa-camera:before {\n  content: \"\\f030\";\n}\n.fa-font:before {\n  content: \"\\f031\";\n}\n.fa-bold:before {\n  content: \"\\f032\";\n}\n.fa-italic:before {\n  content: \"\\f033\";\n}\n.fa-text-height:before {\n  content: \"\\f034\";\n}\n.fa-text-width:before {\n  content: \"\\f035\";\n}\n.fa-align-left:before {\n  content: \"\\f036\";\n}\n.fa-align-center:before {\n  content: \"\\f037\";\n}\n.fa-align-right:before {\n  content: \"\\f038\";\n}\n.fa-align-justify:before {\n  content: \"\\f039\";\n}\n.fa-list:before {\n  content: \"\\f03a\";\n}\n.fa-dedent:before,\n.fa-outdent:before {\n  content: \"\\f03b\";\n}\n.fa-indent:before {\n  content: \"\\f03c\";\n}\n.fa-video-camera:before {\n  content: \"\\f03d\";\n}\n.fa-photo:before,\n.fa-image:before,\n.fa-picture-o:before {\n  content: \"\\f03e\";\n}\n.fa-pencil:before {\n  content: \"\\f040\";\n}\n.fa-map-marker:before {\n  content: \"\\f041\";\n}\n.fa-adjust:before {\n  content: \"\\f042\";\n}\n.fa-tint:before {\n  content: \"\\f043\";\n}\n.fa-edit:before,\n.fa-pencil-square-o:before {\n  content: \"\\f044\";\n}\n.fa-share-square-o:before {\n  content: \"\\f045\";\n}\n.fa-check-square-o:before {\n  content: \"\\f046\";\n}\n.fa-arrows:before {\n  content: \"\\f047\";\n}\n.fa-step-backward:before {\n  content: \"\\f048\";\n}\n.fa-fast-backward:before {\n  content: \"\\f049\";\n}\n.fa-backward:before {\n  content: \"\\f04a\";\n}\n.fa-play:before {\n  content: \"\\f04b\";\n}\n.fa-pause:before {\n  content: \"\\f04c\";\n}\n.fa-stop:before {\n  content: \"\\f04d\";\n}\n.fa-forward:before {\n  content: \"\\f04e\";\n}\n.fa-fast-forward:before {\n  content: \"\\f050\";\n}\n.fa-step-forward:before {\n  content: \"\\f051\";\n}\n.fa-eject:before {\n  content: \"\\f052\";\n}\n.fa-chevron-left:before {\n  content: \"\\f053\";\n}\n.fa-chevron-right:before {\n  content: \"\\f054\";\n}\n.fa-plus-circle:before {\n  content: \"\\f055\";\n}\n.fa-minus-circle:before {\n  content: \"\\f056\";\n}\n.fa-times-circle:before {\n  content: \"\\f057\";\n}\n.fa-check-circle:before {\n  content: \"\\f058\";\n}\n.fa-question-circle:before {\n  content: \"\\f059\";\n}\n.fa-info-circle:before {\n  content: \"\\f05a\";\n}\n.fa-crosshairs:before {\n  content: \"\\f05b\";\n}\n.fa-times-circle-o:before {\n  content: \"\\f05c\";\n}\n.fa-check-circle-o:before {\n  content: \"\\f05d\";\n}\n.fa-ban:before {\n  content: \"\\f05e\";\n}\n.fa-arrow-left:before {\n  content: \"\\f060\";\n}\n.fa-arrow-right:before {\n  content: \"\\f061\";\n}\n.fa-arrow-up:before {\n  content: \"\\f062\";\n}\n.fa-arrow-down:before {\n  content: \"\\f063\";\n}\n.fa-mail-forward:before,\n.fa-share:before {\n  content: \"\\f064\";\n}\n.fa-expand:before {\n  content: \"\\f065\";\n}\n.fa-compress:before {\n  content: \"\\f066\";\n}\n.fa-plus:before {\n  content: \"\\f067\";\n}\n.fa-minus:before {\n  content: \"\\f068\";\n}\n.fa-asterisk:before {\n  content: \"\\f069\";\n}\n.fa-exclamation-circle:before {\n  content: \"\\f06a\";\n}\n.fa-gift:before {\n  content: \"\\f06b\";\n}\n.fa-leaf:before {\n  content: \"\\f06c\";\n}\n.fa-fire:before {\n  content: \"\\f06d\";\n}\n.fa-eye:before {\n  content: \"\\f06e\";\n}\n.fa-eye-slash:before {\n  content: \"\\f070\";\n}\n.fa-warning:before,\n.fa-exclamation-triangle:before {\n  content: \"\\f071\";\n}\n.fa-plane:before {\n  content: \"\\f072\";\n}\n.fa-calendar:before {\n  content: \"\\f073\";\n}\n.fa-random:before {\n  content: \"\\f074\";\n}\n.fa-comment:before {\n  content: \"\\f075\";\n}\n.fa-magnet:before {\n  content: \"\\f076\";\n}\n.fa-chevron-up:before {\n  content: \"\\f077\";\n}\n.fa-chevron-down:before {\n  content: \"\\f078\";\n}\n.fa-retweet:before {\n  content: \"\\f079\";\n}\n.fa-shopping-cart:before {\n  content: \"\\f07a\";\n}\n.fa-folder:before {\n  content: \"\\f07b\";\n}\n.fa-folder-open:before {\n  content: \"\\f07c\";\n}\n.fa-arrows-v:before {\n  content: \"\\f07d\";\n}\n.fa-arrows-h:before {\n  content: \"\\f07e\";\n}\n.fa-bar-chart-o:before,\n.fa-bar-chart:before {\n  content: \"\\f080\";\n}\n.fa-twitter-square:before {\n  content: \"\\f081\";\n}\n.fa-facebook-square:before {\n  content: \"\\f082\";\n}\n.fa-camera-retro:before {\n  content: \"\\f083\";\n}\n.fa-key:before {\n  content: \"\\f084\";\n}\n.fa-gears:before,\n.fa-cogs:before {\n  content: \"\\f085\";\n}\n.fa-comments:before {\n  content: \"\\f086\";\n}\n.fa-thumbs-o-up:before {\n  content: \"\\f087\";\n}\n.fa-thumbs-o-down:before {\n  content: \"\\f088\";\n}\n.fa-star-half:before {\n  content: \"\\f089\";\n}\n.fa-heart-o:before {\n  content: \"\\f08a\";\n}\n.fa-sign-out:before {\n  content: \"\\f08b\";\n}\n.fa-linkedin-square:before {\n  content: \"\\f08c\";\n}\n.fa-thumb-tack:before {\n  content: \"\\f08d\";\n}\n.fa-external-link:before {\n  content: \"\\f08e\";\n}\n.fa-sign-in:before {\n  content: \"\\f090\";\n}\n.fa-trophy:before {\n  content: \"\\f091\";\n}\n.fa-github-square:before {\n  content: \"\\f092\";\n}\n.fa-upload:before {\n  content: \"\\f093\";\n}\n.fa-lemon-o:before {\n  content: \"\\f094\";\n}\n.fa-phone:before {\n  content: \"\\f095\";\n}\n.fa-square-o:before {\n  content: \"\\f096\";\n}\n.fa-bookmark-o:before {\n  content: \"\\f097\";\n}\n.fa-phone-square:before {\n  content: \"\\f098\";\n}\n.fa-twitter:before {\n  content: \"\\f099\";\n}\n.fa-facebook-f:before,\n.fa-facebook:before {\n  content: \"\\f09a\";\n}\n.fa-github:before {\n  content: \"\\f09b\";\n}\n.fa-unlock:before {\n  content: \"\\f09c\";\n}\n.fa-credit-card:before {\n  content: \"\\f09d\";\n}\n.fa-feed:before,\n.fa-rss:before {\n  content: \"\\f09e\";\n}\n.fa-hdd-o:before {\n  content: \"\\f0a0\";\n}\n.fa-bullhorn:before {\n  content: \"\\f0a1\";\n}\n.fa-bell:before {\n  content: \"\\f0f3\";\n}\n.fa-certificate:before {\n  content: \"\\f0a3\";\n}\n.fa-hand-o-right:before {\n  content: \"\\f0a4\";\n}\n.fa-hand-o-left:before {\n  content: \"\\f0a5\";\n}\n.fa-hand-o-up:before {\n  content: \"\\f0a6\";\n}\n.fa-hand-o-down:before {\n  content: \"\\f0a7\";\n}\n.fa-arrow-circle-left:before {\n  content: \"\\f0a8\";\n}\n.fa-arrow-circle-right:before {\n  content: \"\\f0a9\";\n}\n.fa-arrow-circle-up:before {\n  content: \"\\f0aa\";\n}\n.fa-arrow-circle-down:before {\n  content: \"\\f0ab\";\n}\n.fa-globe:before {\n  content: \"\\f0ac\";\n}\n.fa-wrench:before {\n  content: \"\\f0ad\";\n}\n.fa-tasks:before {\n  content: \"\\f0ae\";\n}\n.fa-filter:before {\n  content: \"\\f0b0\";\n}\n.fa-briefcase:before {\n  content: \"\\f0b1\";\n}\n.fa-arrows-alt:before {\n  content: \"\\f0b2\";\n}\n.fa-group:before,\n.fa-users:before {\n  content: \"\\f0c0\";\n}\n.fa-chain:before,\n.fa-link:before {\n  content: \"\\f0c1\";\n}\n.fa-cloud:before {\n  content: \"\\f0c2\";\n}\n.fa-flask:before {\n  content: \"\\f0c3\";\n}\n.fa-cut:before,\n.fa-scissors:before {\n  content: \"\\f0c4\";\n}\n.fa-copy:before,\n.fa-files-o:before {\n  content: \"\\f0c5\";\n}\n.fa-paperclip:before {\n  content: \"\\f0c6\";\n}\n.fa-save:before,\n.fa-floppy-o:before {\n  content: \"\\f0c7\";\n}\n.fa-square:before {\n  content: \"\\f0c8\";\n}\n.fa-navicon:before,\n.fa-reorder:before,\n.fa-bars:before {\n  content: \"\\f0c9\";\n}\n.fa-list-ul:before {\n  content: \"\\f0ca\";\n}\n.fa-list-ol:before {\n  content: \"\\f0cb\";\n}\n.fa-strikethrough:before {\n  content: \"\\f0cc\";\n}\n.fa-underline:before {\n  content: \"\\f0cd\";\n}\n.fa-table:before {\n  content: \"\\f0ce\";\n}\n.fa-magic:before {\n  content: \"\\f0d0\";\n}\n.fa-truck:before {\n  content: \"\\f0d1\";\n}\n.fa-pinterest:before {\n  content: \"\\f0d2\";\n}\n.fa-pinterest-square:before {\n  content: \"\\f0d3\";\n}\n.fa-google-plus-square:before {\n  content: \"\\f0d4\";\n}\n.fa-google-plus:before {\n  content: \"\\f0d5\";\n}\n.fa-money:before {\n  content: \"\\f0d6\";\n}\n.fa-caret-down:before {\n  content: \"\\f0d7\";\n}\n.fa-caret-up:before {\n  content: \"\\f0d8\";\n}\n.fa-caret-left:before {\n  content: \"\\f0d9\";\n}\n.fa-caret-right:before {\n  content: \"\\f0da\";\n}\n.fa-columns:before {\n  content: \"\\f0db\";\n}\n.fa-unsorted:before,\n.fa-sort:before {\n  content: \"\\f0dc\";\n}\n.fa-sort-down:before,\n.fa-sort-desc:before {\n  content: \"\\f0dd\";\n}\n.fa-sort-up:before,\n.fa-sort-asc:before {\n  content: \"\\f0de\";\n}\n.fa-envelope:before {\n  content: \"\\f0e0\";\n}\n.fa-linkedin:before {\n  content: \"\\f0e1\";\n}\n.fa-rotate-left:before,\n.fa-undo:before {\n  content: \"\\f0e2\";\n}\n.fa-legal:before,\n.fa-gavel:before {\n  content: \"\\f0e3\";\n}\n.fa-dashboard:before,\n.fa-tachometer:before {\n  content: \"\\f0e4\";\n}\n.fa-comment-o:before {\n  content: \"\\f0e5\";\n}\n.fa-comments-o:before {\n  content: \"\\f0e6\";\n}\n.fa-flash:before,\n.fa-bolt:before {\n  content: \"\\f0e7\";\n}\n.fa-sitemap:before {\n  content: \"\\f0e8\";\n}\n.fa-umbrella:before {\n  content: \"\\f0e9\";\n}\n.fa-paste:before,\n.fa-clipboard:before {\n  content: \"\\f0ea\";\n}\n.fa-lightbulb-o:before {\n  content: \"\\f0eb\";\n}\n.fa-exchange:before {\n  content: \"\\f0ec\";\n}\n.fa-cloud-download:before {\n  content: \"\\f0ed\";\n}\n.fa-cloud-upload:before {\n  content: \"\\f0ee\";\n}\n.fa-user-md:before {\n  content: \"\\f0f0\";\n}\n.fa-stethoscope:before {\n  content: \"\\f0f1\";\n}\n.fa-suitcase:before {\n  content: \"\\f0f2\";\n}\n.fa-bell-o:before {\n  content: \"\\f0a2\";\n}\n.fa-coffee:before {\n  content: \"\\f0f4\";\n}\n.fa-cutlery:before {\n  content: \"\\f0f5\";\n}\n.fa-file-text-o:before {\n  content: \"\\f0f6\";\n}\n.fa-building-o:before {\n  content: \"\\f0f7\";\n}\n.fa-hospital-o:before {\n  content: \"\\f0f8\";\n}\n.fa-ambulance:before {\n  content: \"\\f0f9\";\n}\n.fa-medkit:before {\n  content: \"\\f0fa\";\n}\n.fa-fighter-jet:before {\n  content: \"\\f0fb\";\n}\n.fa-beer:before {\n  content: \"\\f0fc\";\n}\n.fa-h-square:before {\n  content: \"\\f0fd\";\n}\n.fa-plus-square:before {\n  content: \"\\f0fe\";\n}\n.fa-angle-double-left:before {\n  content: \"\\f100\";\n}\n.fa-angle-double-right:before {\n  content: \"\\f101\";\n}\n.fa-angle-double-up:before {\n  content: \"\\f102\";\n}\n.fa-angle-double-down:before {\n  content: \"\\f103\";\n}\n.fa-angle-left:before {\n  content: \"\\f104\";\n}\n.fa-angle-right:before {\n  content: \"\\f105\";\n}\n.fa-angle-up:before {\n  content: \"\\f106\";\n}\n.fa-angle-down:before {\n  content: \"\\f107\";\n}\n.fa-desktop:before {\n  content: \"\\f108\";\n}\n.fa-laptop:before {\n  content: \"\\f109\";\n}\n.fa-tablet:before {\n  content: \"\\f10a\";\n}\n.fa-mobile-phone:before,\n.fa-mobile:before {\n  content: \"\\f10b\";\n}\n.fa-circle-o:before {\n  content: \"\\f10c\";\n}\n.fa-quote-left:before {\n  content: \"\\f10d\";\n}\n.fa-quote-right:before {\n  content: \"\\f10e\";\n}\n.fa-spinner:before {\n  content: \"\\f110\";\n}\n.fa-circle:before {\n  content: \"\\f111\";\n}\n.fa-mail-reply:before,\n.fa-reply:before {\n  content: \"\\f112\";\n}\n.fa-github-alt:before {\n  content: \"\\f113\";\n}\n.fa-folder-o:before {\n  content: \"\\f114\";\n}\n.fa-folder-open-o:before {\n  content: \"\\f115\";\n}\n.fa-smile-o:before {\n  content: \"\\f118\";\n}\n.fa-frown-o:before {\n  content: \"\\f119\";\n}\n.fa-meh-o:before {\n  content: \"\\f11a\";\n}\n.fa-gamepad:before {\n  content: \"\\f11b\";\n}\n.fa-keyboard-o:before {\n  content: \"\\f11c\";\n}\n.fa-flag-o:before {\n  content: \"\\f11d\";\n}\n.fa-flag-checkered:before {\n  content: \"\\f11e\";\n}\n.fa-terminal:before {\n  content: \"\\f120\";\n}\n.fa-code:before {\n  content: \"\\f121\";\n}\n.fa-mail-reply-all:before,\n.fa-reply-all:before {\n  content: \"\\f122\";\n}\n.fa-star-half-empty:before,\n.fa-star-half-full:before,\n.fa-star-half-o:before {\n  content: \"\\f123\";\n}\n.fa-location-arrow:before {\n  content: \"\\f124\";\n}\n.fa-crop:before {\n  content: \"\\f125\";\n}\n.fa-code-fork:before {\n  content: \"\\f126\";\n}\n.fa-unlink:before,\n.fa-chain-broken:before {\n  content: \"\\f127\";\n}\n.fa-question:before {\n  content: \"\\f128\";\n}\n.fa-info:before {\n  content: \"\\f129\";\n}\n.fa-exclamation:before {\n  content: \"\\f12a\";\n}\n.fa-superscript:before {\n  content: \"\\f12b\";\n}\n.fa-subscript:before {\n  content: \"\\f12c\";\n}\n.fa-eraser:before {\n  content: \"\\f12d\";\n}\n.fa-puzzle-piece:before {\n  content: \"\\f12e\";\n}\n.fa-microphone:before {\n  content: \"\\f130\";\n}\n.fa-microphone-slash:before {\n  content: \"\\f131\";\n}\n.fa-shield:before {\n  content: \"\\f132\";\n}\n.fa-calendar-o:before {\n  content: \"\\f133\";\n}\n.fa-fire-extinguisher:before {\n  content: \"\\f134\";\n}\n.fa-rocket:before {\n  content: \"\\f135\";\n}\n.fa-maxcdn:before {\n  content: \"\\f136\";\n}\n.fa-chevron-circle-left:before {\n  content: \"\\f137\";\n}\n.fa-chevron-circle-right:before {\n  content: \"\\f138\";\n}\n.fa-chevron-circle-up:before {\n  content: \"\\f139\";\n}\n.fa-chevron-circle-down:before {\n  content: \"\\f13a\";\n}\n.fa-html5:before {\n  content: \"\\f13b\";\n}\n.fa-css3:before {\n  content: \"\\f13c\";\n}\n.fa-anchor:before {\n  content: \"\\f13d\";\n}\n.fa-unlock-alt:before {\n  content: \"\\f13e\";\n}\n.fa-bullseye:before {\n  content: \"\\f140\";\n}\n.fa-ellipsis-h:before {\n  content: \"\\f141\";\n}\n.fa-ellipsis-v:before {\n  content: \"\\f142\";\n}\n.fa-rss-square:before {\n  content: \"\\f143\";\n}\n.fa-play-circle:before {\n  content: \"\\f144\";\n}\n.fa-ticket:before {\n  content: \"\\f145\";\n}\n.fa-minus-square:before {\n  content: \"\\f146\";\n}\n.fa-minus-square-o:before {\n  content: \"\\f147\";\n}\n.fa-level-up:before {\n  content: \"\\f148\";\n}\n.fa-level-down:before {\n  content: \"\\f149\";\n}\n.fa-check-square:before {\n  content: \"\\f14a\";\n}\n.fa-pencil-square:before {\n  content: \"\\f14b\";\n}\n.fa-external-link-square:before {\n  content: \"\\f14c\";\n}\n.fa-share-square:before {\n  content: \"\\f14d\";\n}\n.fa-compass:before {\n  content: \"\\f14e\";\n}\n.fa-toggle-down:before,\n.fa-caret-square-o-down:before {\n  content: \"\\f150\";\n}\n.fa-toggle-up:before,\n.fa-caret-square-o-up:before {\n  content: \"\\f151\";\n}\n.fa-toggle-right:before,\n.fa-caret-square-o-right:before {\n  content: \"\\f152\";\n}\n.fa-euro:before,\n.fa-eur:before {\n  content: \"\\f153\";\n}\n.fa-gbp:before {\n  content: \"\\f154\";\n}\n.fa-dollar:before,\n.fa-usd:before {\n  content: \"\\f155\";\n}\n.fa-rupee:before,\n.fa-inr:before {\n  content: \"\\f156\";\n}\n.fa-cny:before,\n.fa-rmb:before,\n.fa-yen:before,\n.fa-jpy:before {\n  content: \"\\f157\";\n}\n.fa-ruble:before,\n.fa-rouble:before,\n.fa-rub:before {\n  content: \"\\f158\";\n}\n.fa-won:before,\n.fa-krw:before {\n  content: \"\\f159\";\n}\n.fa-bitcoin:before,\n.fa-btc:before {\n  content: \"\\f15a\";\n}\n.fa-file:before {\n  content: \"\\f15b\";\n}\n.fa-file-text:before {\n  content: \"\\f15c\";\n}\n.fa-sort-alpha-asc:before {\n  content: \"\\f15d\";\n}\n.fa-sort-alpha-desc:before {\n  content: \"\\f15e\";\n}\n.fa-sort-amount-asc:before {\n  content: \"\\f160\";\n}\n.fa-sort-amount-desc:before {\n  content: \"\\f161\";\n}\n.fa-sort-numeric-asc:before {\n  content: \"\\f162\";\n}\n.fa-sort-numeric-desc:before {\n  content: \"\\f163\";\n}\n.fa-thumbs-up:before {\n  content: \"\\f164\";\n}\n.fa-thumbs-down:before {\n  content: \"\\f165\";\n}\n.fa-youtube-square:before {\n  content: \"\\f166\";\n}\n.fa-youtube:before {\n  content: \"\\f167\";\n}\n.fa-xing:before {\n  content: \"\\f168\";\n}\n.fa-xing-square:before {\n  content: \"\\f169\";\n}\n.fa-youtube-play:before {\n  content: \"\\f16a\";\n}\n.fa-dropbox:before {\n  content: \"\\f16b\";\n}\n.fa-stack-overflow:before {\n  content: \"\\f16c\";\n}\n.fa-instagram:before {\n  content: \"\\f16d\";\n}\n.fa-flickr:before {\n  content: \"\\f16e\";\n}\n.fa-adn:before {\n  content: \"\\f170\";\n}\n.fa-bitbucket:before {\n  content: \"\\f171\";\n}\n.fa-bitbucket-square:before {\n  content: \"\\f172\";\n}\n.fa-tumblr:before {\n  content: \"\\f173\";\n}\n.fa-tumblr-square:before {\n  content: \"\\f174\";\n}\n.fa-long-arrow-down:before {\n  content: \"\\f175\";\n}\n.fa-long-arrow-up:before {\n  content: \"\\f176\";\n}\n.fa-long-arrow-left:before {\n  content: \"\\f177\";\n}\n.fa-long-arrow-right:before {\n  content: \"\\f178\";\n}\n.fa-apple:before {\n  content: \"\\f179\";\n}\n.fa-windows:before {\n  content: \"\\f17a\";\n}\n.fa-android:before {\n  content: \"\\f17b\";\n}\n.fa-linux:before {\n  content: \"\\f17c\";\n}\n.fa-dribbble:before {\n  content: \"\\f17d\";\n}\n.fa-skype:before {\n  content: \"\\f17e\";\n}\n.fa-foursquare:before {\n  content: \"\\f180\";\n}\n.fa-trello:before {\n  content: \"\\f181\";\n}\n.fa-female:before {\n  content: \"\\f182\";\n}\n.fa-male:before {\n  content: \"\\f183\";\n}\n.fa-gittip:before,\n.fa-gratipay:before {\n  content: \"\\f184\";\n}\n.fa-sun-o:before {\n  content: \"\\f185\";\n}\n.fa-moon-o:before {\n  content: \"\\f186\";\n}\n.fa-archive:before {\n  content: \"\\f187\";\n}\n.fa-bug:before {\n  content: \"\\f188\";\n}\n.fa-vk:before {\n  content: \"\\f189\";\n}\n.fa-weibo:before {\n  content: \"\\f18a\";\n}\n.fa-renren:before {\n  content: \"\\f18b\";\n}\n.fa-pagelines:before {\n  content: \"\\f18c\";\n}\n.fa-stack-exchange:before {\n  content: \"\\f18d\";\n}\n.fa-arrow-circle-o-right:before {\n  content: \"\\f18e\";\n}\n.fa-arrow-circle-o-left:before {\n  content: \"\\f190\";\n}\n.fa-toggle-left:before,\n.fa-caret-square-o-left:before {\n  content: \"\\f191\";\n}\n.fa-dot-circle-o:before {\n  content: \"\\f192\";\n}\n.fa-wheelchair:before {\n  content: \"\\f193\";\n}\n.fa-vimeo-square:before {\n  content: \"\\f194\";\n}\n.fa-turkish-lira:before,\n.fa-try:before {\n  content: \"\\f195\";\n}\n.fa-plus-square-o:before {\n  content: \"\\f196\";\n}\n.fa-space-shuttle:before {\n  content: \"\\f197\";\n}\n.fa-slack:before {\n  content: \"\\f198\";\n}\n.fa-envelope-square:before {\n  content: \"\\f199\";\n}\n.fa-wordpress:before {\n  content: \"\\f19a\";\n}\n.fa-openid:before {\n  content: \"\\f19b\";\n}\n.fa-institution:before,\n.fa-bank:before,\n.fa-university:before {\n  content: \"\\f19c\";\n}\n.fa-mortar-board:before,\n.fa-graduation-cap:before {\n  content: \"\\f19d\";\n}\n.fa-yahoo:before {\n  content: \"\\f19e\";\n}\n.fa-google:before {\n  content: \"\\f1a0\";\n}\n.fa-reddit:before {\n  content: \"\\f1a1\";\n}\n.fa-reddit-square:before {\n  content: \"\\f1a2\";\n}\n.fa-stumbleupon-circle:before {\n  content: \"\\f1a3\";\n}\n.fa-stumbleupon:before {\n  content: \"\\f1a4\";\n}\n.fa-delicious:before {\n  content: \"\\f1a5\";\n}\n.fa-digg:before {\n  content: \"\\f1a6\";\n}\n.fa-pied-piper-pp:before {\n  content: \"\\f1a7\";\n}\n.fa-pied-piper-alt:before {\n  content: \"\\f1a8\";\n}\n.fa-drupal:before {\n  content: \"\\f1a9\";\n}\n.fa-joomla:before {\n  content: \"\\f1aa\";\n}\n.fa-language:before {\n  content: \"\\f1ab\";\n}\n.fa-fax:before {\n  content: \"\\f1ac\";\n}\n.fa-building:before {\n  content: \"\\f1ad\";\n}\n.fa-child:before {\n  content: \"\\f1ae\";\n}\n.fa-paw:before {\n  content: \"\\f1b0\";\n}\n.fa-spoon:before {\n  content: \"\\f1b1\";\n}\n.fa-cube:before {\n  content: \"\\f1b2\";\n}\n.fa-cubes:before {\n  content: \"\\f1b3\";\n}\n.fa-behance:before {\n  content: \"\\f1b4\";\n}\n.fa-behance-square:before {\n  content: \"\\f1b5\";\n}\n.fa-steam:before {\n  content: \"\\f1b6\";\n}\n.fa-steam-square:before {\n  content: \"\\f1b7\";\n}\n.fa-recycle:before {\n  content: \"\\f1b8\";\n}\n.fa-automobile:before,\n.fa-car:before {\n  content: \"\\f1b9\";\n}\n.fa-cab:before,\n.fa-taxi:before {\n  content: \"\\f1ba\";\n}\n.fa-tree:before {\n  content: \"\\f1bb\";\n}\n.fa-spotify:before {\n  content: \"\\f1bc\";\n}\n.fa-deviantart:before {\n  content: \"\\f1bd\";\n}\n.fa-soundcloud:before {\n  content: \"\\f1be\";\n}\n.fa-database:before {\n  content: \"\\f1c0\";\n}\n.fa-file-pdf-o:before {\n  content: \"\\f1c1\";\n}\n.fa-file-word-o:before {\n  content: \"\\f1c2\";\n}\n.fa-file-excel-o:before {\n  content: \"\\f1c3\";\n}\n.fa-file-powerpoint-o:before {\n  content: \"\\f1c4\";\n}\n.fa-file-photo-o:before,\n.fa-file-picture-o:before,\n.fa-file-image-o:before {\n  content: \"\\f1c5\";\n}\n.fa-file-zip-o:before,\n.fa-file-archive-o:before {\n  content: \"\\f1c6\";\n}\n.fa-file-sound-o:before,\n.fa-file-audio-o:before {\n  content: \"\\f1c7\";\n}\n.fa-file-movie-o:before,\n.fa-file-video-o:before {\n  content: \"\\f1c8\";\n}\n.fa-file-code-o:before {\n  content: \"\\f1c9\";\n}\n.fa-vine:before {\n  content: \"\\f1ca\";\n}\n.fa-codepen:before {\n  content: \"\\f1cb\";\n}\n.fa-jsfiddle:before {\n  content: \"\\f1cc\";\n}\n.fa-life-bouy:before,\n.fa-life-buoy:before,\n.fa-life-saver:before,\n.fa-support:before,\n.fa-life-ring:before {\n  content: \"\\f1cd\";\n}\n.fa-circle-o-notch:before {\n  content: \"\\f1ce\";\n}\n.fa-ra:before,\n.fa-resistance:before,\n.fa-rebel:before {\n  content: \"\\f1d0\";\n}\n.fa-ge:before,\n.fa-empire:before {\n  content: \"\\f1d1\";\n}\n.fa-git-square:before {\n  content: \"\\f1d2\";\n}\n.fa-git:before {\n  content: \"\\f1d3\";\n}\n.fa-y-combinator-square:before,\n.fa-yc-square:before,\n.fa-hacker-news:before {\n  content: \"\\f1d4\";\n}\n.fa-tencent-weibo:before {\n  content: \"\\f1d5\";\n}\n.fa-qq:before {\n  content: \"\\f1d6\";\n}\n.fa-wechat:before,\n.fa-weixin:before {\n  content: \"\\f1d7\";\n}\n.fa-send:before,\n.fa-paper-plane:before {\n  content: \"\\f1d8\";\n}\n.fa-send-o:before,\n.fa-paper-plane-o:before {\n  content: \"\\f1d9\";\n}\n.fa-history:before {\n  content: \"\\f1da\";\n}\n.fa-circle-thin:before {\n  content: \"\\f1db\";\n}\n.fa-header:before {\n  content: \"\\f1dc\";\n}\n.fa-paragraph:before {\n  content: \"\\f1dd\";\n}\n.fa-sliders:before {\n  content: \"\\f1de\";\n}\n.fa-share-alt:before {\n  content: \"\\f1e0\";\n}\n.fa-share-alt-square:before {\n  content: \"\\f1e1\";\n}\n.fa-bomb:before {\n  content: \"\\f1e2\";\n}\n.fa-soccer-ball-o:before,\n.fa-futbol-o:before {\n  content: \"\\f1e3\";\n}\n.fa-tty:before {\n  content: \"\\f1e4\";\n}\n.fa-binoculars:before {\n  content: \"\\f1e5\";\n}\n.fa-plug:before {\n  content: \"\\f1e6\";\n}\n.fa-slideshare:before {\n  content: \"\\f1e7\";\n}\n.fa-twitch:before {\n  content: \"\\f1e8\";\n}\n.fa-yelp:before {\n  content: \"\\f1e9\";\n}\n.fa-newspaper-o:before {\n  content: \"\\f1ea\";\n}\n.fa-wifi:before {\n  content: \"\\f1eb\";\n}\n.fa-calculator:before {\n  content: \"\\f1ec\";\n}\n.fa-paypal:before {\n  content: \"\\f1ed\";\n}\n.fa-google-wallet:before {\n  content: \"\\f1ee\";\n}\n.fa-cc-visa:before {\n  content: \"\\f1f0\";\n}\n.fa-cc-mastercard:before {\n  content: \"\\f1f1\";\n}\n.fa-cc-discover:before {\n  content: \"\\f1f2\";\n}\n.fa-cc-amex:before {\n  content: \"\\f1f3\";\n}\n.fa-cc-paypal:before {\n  content: \"\\f1f4\";\n}\n.fa-cc-stripe:before {\n  content: \"\\f1f5\";\n}\n.fa-bell-slash:before {\n  content: \"\\f1f6\";\n}\n.fa-bell-slash-o:before {\n  content: \"\\f1f7\";\n}\n.fa-trash:before {\n  content: \"\\f1f8\";\n}\n.fa-copyright:before {\n  content: \"\\f1f9\";\n}\n.fa-at:before {\n  content: \"\\f1fa\";\n}\n.fa-eyedropper:before {\n  content: \"\\f1fb\";\n}\n.fa-paint-brush:before {\n  content: \"\\f1fc\";\n}\n.fa-birthday-cake:before {\n  content: \"\\f1fd\";\n}\n.fa-area-chart:before {\n  content: \"\\f1fe\";\n}\n.fa-pie-chart:before {\n  content: \"\\f200\";\n}\n.fa-line-chart:before {\n  content: \"\\f201\";\n}\n.fa-lastfm:before {\n  content: \"\\f202\";\n}\n.fa-lastfm-square:before {\n  content: \"\\f203\";\n}\n.fa-toggle-off:before {\n  content: \"\\f204\";\n}\n.fa-toggle-on:before {\n  content: \"\\f205\";\n}\n.fa-bicycle:before {\n  content: \"\\f206\";\n}\n.fa-bus:before {\n  content: \"\\f207\";\n}\n.fa-ioxhost:before {\n  content: \"\\f208\";\n}\n.fa-angellist:before {\n  content: \"\\f209\";\n}\n.fa-cc:before {\n  content: \"\\f20a\";\n}\n.fa-shekel:before,\n.fa-sheqel:before,\n.fa-ils:before {\n  content: \"\\f20b\";\n}\n.fa-meanpath:before {\n  content: \"\\f20c\";\n}\n.fa-buysellads:before {\n  content: \"\\f20d\";\n}\n.fa-connectdevelop:before {\n  content: \"\\f20e\";\n}\n.fa-dashcube:before {\n  content: \"\\f210\";\n}\n.fa-forumbee:before {\n  content: \"\\f211\";\n}\n.fa-leanpub:before {\n  content: \"\\f212\";\n}\n.fa-sellsy:before {\n  content: \"\\f213\";\n}\n.fa-shirtsinbulk:before {\n  content: \"\\f214\";\n}\n.fa-simplybuilt:before {\n  content: \"\\f215\";\n}\n.fa-skyatlas:before {\n  content: \"\\f216\";\n}\n.fa-cart-plus:before {\n  content: \"\\f217\";\n}\n.fa-cart-arrow-down:before {\n  content: \"\\f218\";\n}\n.fa-diamond:before {\n  content: \"\\f219\";\n}\n.fa-ship:before {\n  content: \"\\f21a\";\n}\n.fa-user-secret:before {\n  content: \"\\f21b\";\n}\n.fa-motorcycle:before {\n  content: \"\\f21c\";\n}\n.fa-street-view:before {\n  content: \"\\f21d\";\n}\n.fa-heartbeat:before {\n  content: \"\\f21e\";\n}\n.fa-venus:before {\n  content: \"\\f221\";\n}\n.fa-mars:before {\n  content: \"\\f222\";\n}\n.fa-mercury:before {\n  content: \"\\f223\";\n}\n.fa-intersex:before,\n.fa-transgender:before {\n  content: \"\\f224\";\n}\n.fa-transgender-alt:before {\n  content: \"\\f225\";\n}\n.fa-venus-double:before {\n  content: \"\\f226\";\n}\n.fa-mars-double:before {\n  content: \"\\f227\";\n}\n.fa-venus-mars:before {\n  content: \"\\f228\";\n}\n.fa-mars-stroke:before {\n  content: \"\\f229\";\n}\n.fa-mars-stroke-v:before {\n  content: \"\\f22a\";\n}\n.fa-mars-stroke-h:before {\n  content: \"\\f22b\";\n}\n.fa-neuter:before {\n  content: \"\\f22c\";\n}\n.fa-genderless:before {\n  content: \"\\f22d\";\n}\n.fa-facebook-official:before {\n  content: \"\\f230\";\n}\n.fa-pinterest-p:before {\n  content: \"\\f231\";\n}\n.fa-whatsapp:before {\n  content: \"\\f232\";\n}\n.fa-server:before {\n  content: \"\\f233\";\n}\n.fa-user-plus:before {\n  content: \"\\f234\";\n}\n.fa-user-times:before {\n  content: \"\\f235\";\n}\n.fa-hotel:before,\n.fa-bed:before {\n  content: \"\\f236\";\n}\n.fa-viacoin:before {\n  content: \"\\f237\";\n}\n.fa-train:before {\n  content: \"\\f238\";\n}\n.fa-subway:before {\n  content: \"\\f239\";\n}\n.fa-medium:before {\n  content: \"\\f23a\";\n}\n.fa-yc:before,\n.fa-y-combinator:before {\n  content: \"\\f23b\";\n}\n.fa-optin-monster:before {\n  content: \"\\f23c\";\n}\n.fa-opencart:before {\n  content: \"\\f23d\";\n}\n.fa-expeditedssl:before {\n  content: \"\\f23e\";\n}\n.fa-battery-4:before,\n.fa-battery:before,\n.fa-battery-full:before {\n  content: \"\\f240\";\n}\n.fa-battery-3:before,\n.fa-battery-three-quarters:before {\n  content: \"\\f241\";\n}\n.fa-battery-2:before,\n.fa-battery-half:before {\n  content: \"\\f242\";\n}\n.fa-battery-1:before,\n.fa-battery-quarter:before {\n  content: \"\\f243\";\n}\n.fa-battery-0:before,\n.fa-battery-empty:before {\n  content: \"\\f244\";\n}\n.fa-mouse-pointer:before {\n  content: \"\\f245\";\n}\n.fa-i-cursor:before {\n  content: \"\\f246\";\n}\n.fa-object-group:before {\n  content: \"\\f247\";\n}\n.fa-object-ungroup:before {\n  content: \"\\f248\";\n}\n.fa-sticky-note:before {\n  content: \"\\f249\";\n}\n.fa-sticky-note-o:before {\n  content: \"\\f24a\";\n}\n.fa-cc-jcb:before {\n  content: \"\\f24b\";\n}\n.fa-cc-diners-club:before {\n  content: \"\\f24c\";\n}\n.fa-clone:before {\n  content: \"\\f24d\";\n}\n.fa-balance-scale:before {\n  content: \"\\f24e\";\n}\n.fa-hourglass-o:before {\n  content: \"\\f250\";\n}\n.fa-hourglass-1:before,\n.fa-hourglass-start:before {\n  content: \"\\f251\";\n}\n.fa-hourglass-2:before,\n.fa-hourglass-half:before {\n  content: \"\\f252\";\n}\n.fa-hourglass-3:before,\n.fa-hourglass-end:before {\n  content: \"\\f253\";\n}\n.fa-hourglass:before {\n  content: \"\\f254\";\n}\n.fa-hand-grab-o:before,\n.fa-hand-rock-o:before {\n  content: \"\\f255\";\n}\n.fa-hand-stop-o:before,\n.fa-hand-paper-o:before {\n  content: \"\\f256\";\n}\n.fa-hand-scissors-o:before {\n  content: \"\\f257\";\n}\n.fa-hand-lizard-o:before {\n  content: \"\\f258\";\n}\n.fa-hand-spock-o:before {\n  content: \"\\f259\";\n}\n.fa-hand-pointer-o:before {\n  content: \"\\f25a\";\n}\n.fa-hand-peace-o:before {\n  content: \"\\f25b\";\n}\n.fa-trademark:before {\n  content: \"\\f25c\";\n}\n.fa-registered:before {\n  content: \"\\f25d\";\n}\n.fa-creative-commons:before {\n  content: \"\\f25e\";\n}\n.fa-gg:before {\n  content: \"\\f260\";\n}\n.fa-gg-circle:before {\n  content: \"\\f261\";\n}\n.fa-tripadvisor:before {\n  content: \"\\f262\";\n}\n.fa-odnoklassniki:before {\n  content: \"\\f263\";\n}\n.fa-odnoklassniki-square:before {\n  content: \"\\f264\";\n}\n.fa-get-pocket:before {\n  content: \"\\f265\";\n}\n.fa-wikipedia-w:before {\n  content: \"\\f266\";\n}\n.fa-safari:before {\n  content: \"\\f267\";\n}\n.fa-chrome:before {\n  content: \"\\f268\";\n}\n.fa-firefox:before {\n  content: \"\\f269\";\n}\n.fa-opera:before {\n  content: \"\\f26a\";\n}\n.fa-internet-explorer:before {\n  content: \"\\f26b\";\n}\n.fa-tv:before,\n.fa-television:before {\n  content: \"\\f26c\";\n}\n.fa-contao:before {\n  content: \"\\f26d\";\n}\n.fa-500px:before {\n  content: \"\\f26e\";\n}\n.fa-amazon:before {\n  content: \"\\f270\";\n}\n.fa-calendar-plus-o:before {\n  content: \"\\f271\";\n}\n.fa-calendar-minus-o:before {\n  content: \"\\f272\";\n}\n.fa-calendar-times-o:before {\n  content: \"\\f273\";\n}\n.fa-calendar-check-o:before {\n  content: \"\\f274\";\n}\n.fa-industry:before {\n  content: \"\\f275\";\n}\n.fa-map-pin:before {\n  content: \"\\f276\";\n}\n.fa-map-signs:before {\n  content: \"\\f277\";\n}\n.fa-map-o:before {\n  content: \"\\f278\";\n}\n.fa-map:before {\n  content: \"\\f279\";\n}\n.fa-commenting:before {\n  content: \"\\f27a\";\n}\n.fa-commenting-o:before {\n  content: \"\\f27b\";\n}\n.fa-houzz:before {\n  content: \"\\f27c\";\n}\n.fa-vimeo:before {\n  content: \"\\f27d\";\n}\n.fa-black-tie:before {\n  content: \"\\f27e\";\n}\n.fa-fonticons:before {\n  content: \"\\f280\";\n}\n.fa-reddit-alien:before {\n  content: \"\\f281\";\n}\n.fa-edge:before {\n  content: \"\\f282\";\n}\n.fa-credit-card-alt:before {\n  content: \"\\f283\";\n}\n.fa-codiepie:before {\n  content: \"\\f284\";\n}\n.fa-modx:before {\n  content: \"\\f285\";\n}\n.fa-fort-awesome:before {\n  content: \"\\f286\";\n}\n.fa-usb:before {\n  content: \"\\f287\";\n}\n.fa-product-hunt:before {\n  content: \"\\f288\";\n}\n.fa-mixcloud:before {\n  content: \"\\f289\";\n}\n.fa-scribd:before {\n  content: \"\\f28a\";\n}\n.fa-pause-circle:before {\n  content: \"\\f28b\";\n}\n.fa-pause-circle-o:before {\n  content: \"\\f28c\";\n}\n.fa-stop-circle:before {\n  content: \"\\f28d\";\n}\n.fa-stop-circle-o:before {\n  content: \"\\f28e\";\n}\n.fa-shopping-bag:before {\n  content: \"\\f290\";\n}\n.fa-shopping-basket:before {\n  content: \"\\f291\";\n}\n.fa-hashtag:before {\n  content: \"\\f292\";\n}\n.fa-bluetooth:before {\n  content: \"\\f293\";\n}\n.fa-bluetooth-b:before {\n  content: \"\\f294\";\n}\n.fa-percent:before {\n  content: \"\\f295\";\n}\n.fa-gitlab:before {\n  content: \"\\f296\";\n}\n.fa-wpbeginner:before {\n  content: \"\\f297\";\n}\n.fa-wpforms:before {\n  content: \"\\f298\";\n}\n.fa-envira:before {\n  content: \"\\f299\";\n}\n.fa-universal-access:before {\n  content: \"\\f29a\";\n}\n.fa-wheelchair-alt:before {\n  content: \"\\f29b\";\n}\n.fa-question-circle-o:before {\n  content: \"\\f29c\";\n}\n.fa-blind:before {\n  content: \"\\f29d\";\n}\n.fa-audio-description:before {\n  content: \"\\f29e\";\n}\n.fa-volume-control-phone:before {\n  content: \"\\f2a0\";\n}\n.fa-braille:before {\n  content: \"\\f2a1\";\n}\n.fa-assistive-listening-systems:before {\n  content: \"\\f2a2\";\n}\n.fa-asl-interpreting:before,\n.fa-american-sign-language-interpreting:before {\n  content: \"\\f2a3\";\n}\n.fa-deafness:before,\n.fa-hard-of-hearing:before,\n.fa-deaf:before {\n  content: \"\\f2a4\";\n}\n.fa-glide:before {\n  content: \"\\f2a5\";\n}\n.fa-glide-g:before {\n  content: \"\\f2a6\";\n}\n.fa-signing:before,\n.fa-sign-language:before {\n  content: \"\\f2a7\";\n}\n.fa-low-vision:before {\n  content: \"\\f2a8\";\n}\n.fa-viadeo:before {\n  content: \"\\f2a9\";\n}\n.fa-viadeo-square:before {\n  content: \"\\f2aa\";\n}\n.fa-snapchat:before {\n  content: \"\\f2ab\";\n}\n.fa-snapchat-ghost:before {\n  content: \"\\f2ac\";\n}\n.fa-snapchat-square:before {\n  content: \"\\f2ad\";\n}\n.fa-pied-piper:before {\n  content: \"\\f2ae\";\n}\n.fa-first-order:before {\n  content: \"\\f2b0\";\n}\n.fa-yoast:before {\n  content: \"\\f2b1\";\n}\n.fa-themeisle:before {\n  content: \"\\f2b2\";\n}\n.fa-google-plus-circle:before,\n.fa-google-plus-official:before {\n  content: \"\\f2b3\";\n}\n.fa-fa:before,\n.fa-font-awesome:before {\n  content: \"\\f2b4\";\n}\n.fa-handshake-o:before {\n  content: \"\\f2b5\";\n}\n.fa-envelope-open:before {\n  content: \"\\f2b6\";\n}\n.fa-envelope-open-o:before {\n  content: \"\\f2b7\";\n}\n.fa-linode:before {\n  content: \"\\f2b8\";\n}\n.fa-address-book:before {\n  content: \"\\f2b9\";\n}\n.fa-address-book-o:before {\n  content: \"\\f2ba\";\n}\n.fa-vcard:before,\n.fa-address-card:before {\n  content: \"\\f2bb\";\n}\n.fa-vcard-o:before,\n.fa-address-card-o:before {\n  content: \"\\f2bc\";\n}\n.fa-user-circle:before {\n  content: \"\\f2bd\";\n}\n.fa-user-circle-o:before {\n  content: \"\\f2be\";\n}\n.fa-user-o:before {\n  content: \"\\f2c0\";\n}\n.fa-id-badge:before {\n  content: \"\\f2c1\";\n}\n.fa-drivers-license:before,\n.fa-id-card:before {\n  content: \"\\f2c2\";\n}\n.fa-drivers-license-o:before,\n.fa-id-card-o:before {\n  content: \"\\f2c3\";\n}\n.fa-quora:before {\n  content: \"\\f2c4\";\n}\n.fa-free-code-camp:before {\n  content: \"\\f2c5\";\n}\n.fa-telegram:before {\n  content: \"\\f2c6\";\n}\n.fa-thermometer-4:before,\n.fa-thermometer:before,\n.fa-thermometer-full:before {\n  content: \"\\f2c7\";\n}\n.fa-thermometer-3:before,\n.fa-thermometer-three-quarters:before {\n  content: \"\\f2c8\";\n}\n.fa-thermometer-2:before,\n.fa-thermometer-half:before {\n  content: \"\\f2c9\";\n}\n.fa-thermometer-1:before,\n.fa-thermometer-quarter:before {\n  content: \"\\f2ca\";\n}\n.fa-thermometer-0:before,\n.fa-thermometer-empty:before {\n  content: \"\\f2cb\";\n}\n.fa-shower:before {\n  content: \"\\f2cc\";\n}\n.fa-bathtub:before,\n.fa-s15:before,\n.fa-bath:before {\n  content: \"\\f2cd\";\n}\n.fa-podcast:before {\n  content: \"\\f2ce\";\n}\n.fa-window-maximize:before {\n  content: \"\\f2d0\";\n}\n.fa-window-minimize:before {\n  content: \"\\f2d1\";\n}\n.fa-window-restore:before {\n  content: \"\\f2d2\";\n}\n.fa-times-rectangle:before,\n.fa-window-close:before {\n  content: \"\\f2d3\";\n}\n.fa-times-rectangle-o:before,\n.fa-window-close-o:before {\n  content: \"\\f2d4\";\n}\n.fa-bandcamp:before {\n  content: \"\\f2d5\";\n}\n.fa-grav:before {\n  content: \"\\f2d6\";\n}\n.fa-etsy:before {\n  content: \"\\f2d7\";\n}\n.fa-imdb:before {\n  content: \"\\f2d8\";\n}\n.fa-ravelry:before {\n  content: \"\\f2d9\";\n}\n.fa-eercast:before {\n  content: \"\\f2da\";\n}\n.fa-microchip:before {\n  content: \"\\f2db\";\n}\n.fa-snowflake-o:before {\n  content: \"\\f2dc\";\n}\n.fa-superpowers:before {\n  content: \"\\f2dd\";\n}\n.fa-wpexplorer:before {\n  content: \"\\f2de\";\n}\n.fa-meetup:before {\n  content: \"\\f2e0\";\n}\n.sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  border: 0;\n}\n.sr-only-focusable:active,\n.sr-only-focusable:focus {\n  position: static;\n  width: auto;\n  height: auto;\n  margin: 0;\n  overflow: visible;\n  clip: auto;\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./app/frontend/designer/less/index.less":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./app/frontend/designer/less/index.less ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
var ___CSS_LOADER_GET_URL_IMPORT___ = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
var ___CSS_LOADER_URL_IMPORT_0___ = __webpack_require__(/*! ../images/layer_line.svg */ "./app/frontend/designer/images/layer_line.svg");
var ___CSS_LOADER_URL_IMPORT_1___ = __webpack_require__(/*! ../images/layer_rect.svg */ "./app/frontend/designer/images/layer_rect.svg");
var ___CSS_LOADER_URL_IMPORT_2___ = __webpack_require__(/*! ../images/layer_circle.svg */ "./app/frontend/designer/images/layer_circle.svg");
var ___CSS_LOADER_URL_IMPORT_3___ = __webpack_require__(/*! ../images/layer_text.svg */ "./app/frontend/designer/images/layer_text.svg");
var ___CSS_LOADER_URL_IMPORT_4___ = __webpack_require__(/*! ../images/layer_port.svg */ "./app/frontend/designer/images/layer_port.svg");
exports = ___CSS_LOADER_API_IMPORT___(false);
var ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);
var ___CSS_LOADER_URL_REPLACEMENT_2___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_2___);
var ___CSS_LOADER_URL_REPLACEMENT_3___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_3___);
var ___CSS_LOADER_URL_REPLACEMENT_4___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_4___);
// Module
exports.push([module.i, ".toolbar {\n  margin: 0;\n  padding-top: 0;\n  padding-right: 10px;\n  top: 0;\n  right: 0;\n  left: 220px;\n  height: 60px;\n  overflow: visible;\n  z-index: 1000 !important;\n  position: absolute;\n  background-color: #ebf0f5;\n  border: none !important;\n}\n.toolbar * {\n  outline: none;\n}\n.toolbar .group {\n  padding-right: 20px;\n  display: inline-block;\n  vertical-align: top;\n}\n.toolbar .group .image-button {\n  display: inline-block;\n}\n.toolbar .group .image-button img {\n  margin: 5px;\n  margin-bottom: 0;\n  padding: 0;\n  width: 40px;\n  height: 40px;\n  position: relative;\n  display: inline-block;\n  text-align: center;\n  color: #777;\n  font-size: 45px;\n  transition: all 0.5s;\n}\n.toolbar .group .image-button .img_span {\n  margin: 5px;\n  margin-bottom: 0;\n  padding: 0;\n  width: 40px;\n  height: 40px;\n  position: relative;\n  display: inline-block;\n  text-align: center;\n  color: #777;\n  font-size: 45px;\n  transition: all 0.5s;\n}\n.toolbar .group .image-button div {\n  color: rgba(0, 0, 0, 0.5);\n  text-align: center;\n  font-size: 10px;\n}\n.toolbar .group .image-button.disabled {\n  opacity: 0.2;\n}\n.toolbar .group .image-button:not(.disabled) img {\n  cursor: pointer;\n}\n.toolbar .group .image-button:not(.disabled) img:hover {\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);\n}\n.modal-backdrop.in {\n  opacity: 0.7;\n  background-color: black;\n  transition: opacity 0.4s linear;\n}\n.genericDialog .modal-content {\n  border-radius: 4px;\n  box-shadow: 0 19px 38px rgba(0, 0, 0, 0.3), 0 15px 12px rgba(0, 0, 0, 0.22);\n  background-color: #ffffff;\n}\n.genericDialog .modal-content .modal-header {\n  border-bottom: 0;\n  font-weight: 400;\n  box-shadow: 0 3px 5px rgba(57, 63, 72, 0.3);\n}\n.genericDialog .modal-content .modal-body {\n  padding: 1px;\n  min-height: 120px;\n}\n.genericDialog .modal-content .modal-body .form-control {\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n  box-sizing: border-box;\n  border-radius: 4px;\n  margin: 0;\n  padding: 0;\n  color: #4D4D4D;\n  display: inline-block;\n  font: inherit;\n  border: 1px solid #DFDFDF;\n  box-shadow: none;\n  height: 24px;\n  padding: 0 3px;\n}\n.genericDialog .modal-content .modal-body .form-control:focus {\n  background-color: #f5f5f5;\n}\n.genericDialog .modal-content .modal-body .list-group {\n  overflow-y: auto;\n  overflow-x: auto;\n}\n.genericDialog .modal-content .modal-body .list-group *[data-draw2d=\"true\"] {\n  font-weight: bold;\n  color: #41aaaa;\n}\n.genericDialog .modal-content .modal-body .list-group .glyphicon,\n.genericDialog .modal-content .modal-body .list-group .fa {\n  font-size: 20px;\n  padding-right: 10px;\n  color: #41aaaa;\n}\n.genericDialog .modal-content .modal-body .list-group .list-group-item {\n  background-color: transparent;\n  font-weight: 300;\n}\n.genericDialog .modal-content .modal-body .list-group .list-group-item:hover {\n  text-decoration: underline;\n}\n.genericDialog .modal-content .modal-body .list-group *[data-draw2d=\"false\"][data-type=\"file\"] {\n  color: gray;\n  cursor: default;\n  text-decoration: none !important;\n}\n.genericDialog .modal-content .modal-body .list-group *[data-draw2d=\"false\"][data-type=\"file\"] .fa {\n  color: gray;\n}\n.genericDialog .modal-content .modal-footer {\n  background-color: transparent;\n  border-top: 0;\n}\n.genericDialog .modal-content .modal-footer .btn {\n  border: 0;\n  text-transform: uppercase;\n  background-color: transparent;\n  color: #41aaaa;\n  transition: all 0.5s;\n}\n.genericDialog .modal-content .modal-footer .btn:hover {\n  background-color: rgba(65, 170, 170, 0.04);\n  transition: all 0.5s;\n}\n.genericDialog .modal-content .modal-footer .btn-primary {\n  font-weight: bold;\n}\n#fileOpenDialog .list-group {\n  height: 60%;\n}\n#fileSaveDialog .filePreview {\n  max-width: 200px;\n  max-height: 200px;\n}\n#fileSaveDialog .modal-body .media {\n  padding: 20px;\n}\n#githubFileSaveAsDialog .filePreview {\n  max-width: 200px;\n  max-height: 200px;\n}\n#githubFileSaveAsDialog .list-group {\n  height: 250px;\n}\n#canvas_zoom {\n  position: fixed;\n  bottom: 20px;\n  right: 270px;\n  background-color: rgba(235, 240, 245, 0.3);\n  border-radius: 5px;\n}\n#canvas_zoom button {\n  background-color: transparent;\n  font-weight: 300;\n  padding: 5px;\n  padding-left: 10px;\n  padding-right: 10px;\n  border: 1px solid transparent;\n  outline: none;\n  transition: all 0.5s;\n}\n#canvas_zoom button:hover {\n  border: 1px solid #41aaaa;\n}\n/***BOOTSTRAP****/\n.btn {\n  border-radius: 0 !important;\n}\n.tooltip-inner {\n  border-radius: 0 !important;\n  padding: 10px !important;\n  padding-top: 5px !important;\n  padding-bottom: 5px !important;\n  font-family: 'Roboto', sans-serif !important;\n  font-weight: 300 !important;\n  font-size: 14px !important;\n  color: #b0b0b0 !important;\n}\n/********/\nbody {\n  overflow: hidden;\n  font-family: 'Roboto', sans-serif !important;\n  font-weight: 300;\n}\ninput {\n  background: none repeat scroll 0 0 #f8f8f8;\n  border-color: #C6C6C6 #DADADA #EAEAEA;\n  border-radius: 4px 4px 4px 4px;\n  -moz-box-sizing: border-box;\n  padding-left: 7px;\n  border-style: solid ;\n  border-width: 1px;\n  vertical-align: middle;\n  height: 25px;\n  font-size: 14px;\n  line-height: 25px;\n}\n.input-block-level {\n  display: block;\n  width: 100%;\n  min-height: 28px;\n}\n.control-label {\n  font-family: 'Roboto', sans-serif;\n  font-weight: 300;\n}\n/******************************************************************\n * Einstellungen der PropertyViews im Editmodus der \"Form\".\n ******************************************************************/\n.palette_node_element {\n  width: 48px;\n  height: 48px;\n  cursor: move;\n  margin: 10px auto 10px auto;\n}\n.tooltip {\n  z-index: 1000000;\n}\n/* Effects */\n.overlay-scale {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 10000;\n  visibility: hidden;\n  opacity: 0;\n  -webkit-transform: scale(0.9);\n  transform: scale(0.9);\n  -webkit-transition: all 0.4s;\n  transition: all 0.4s;\n}\n.overlay-scale.open {\n  visibility: visible;\n  opacity: 1;\n  -webkit-transform: scale(1);\n  transform: scale(1);\n  -webkit-transition: all 0.4s;\n  transition: all 0.4s;\n}\n.readonly-highlight {\n  background-color: rgba(50, 43, 168, 0.5);\n  opacity: 0.2;\n  color: darkblue;\n  position: absolute;\n}\n#canvas {\n  padding: 0;\n  margin: 0;\n  border: 0;\n  position: absolute;\n  top: 60px;\n  right: 250px;\n  left: 220px;\n  bottom: 0;\n  overflow: scroll;\n  background-color: #FFFFFF;\n}\n#canvas_config {\n  position: fixed;\n  width: 40px;\n  top: 65px;\n  left: 225px;\n  cursor: pointer;\n  border: 1px solid transparent;\n  background-color: rgba(235, 240, 245, 0.3);\n}\n#canvas_config:hover {\n  border: 1px solid #41aaaa !important;\n}\n#canvas_config:hover {\n  color: #41aaaa;\n}\n#canvas_config_items {\n  position: fixed;\n  top: 90px;\n  left: 225px;\n  cursor: pointer;\n  padding: 10px;\n  white-space: nowrap;\n  min-width: 250px;\n}\n.layer-name-prompt .modal-title {\n  font-weight: 100;\n}\n.layer-name-prompt .modal-footer {\n  border: 0;\n}\n.layer-name-prompt .modal-header {\n  border-bottom: 3px solid #41aaaa;\n}\n.layer-name-prompt input {\n  outline: none !important;\n  -webkit-box-shadow: inset !important;\n  box-shadow: inset !important;\n  background-color: rgba(0, 0, 0, 0.02) !important;\n  border-radius: 1px !important;\n}\n.layer-name-prompt input:focus {\n  border: 1px solid #41aaaa;\n}\n.layer-name-prompt .btn-primary {\n  background-color: #41aaaa;\n  border: 0;\n}\n.layer-name-prompt .btn-primary:hover {\n  background-color: #338585;\n}\n#layer {\n  padding: 0;\n  margin: 0;\n  border: 0;\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  width: 220px;\n  background-color: #ffffff;\n  text-align: center;\n  box-shadow: 5px 0 20px -3px rgba(31, 73, 125, 0.3);\n  z-index: 1;\n}\n#layer .title {\n  left: 10px;\n  right: 0px;\n  top: 10px;\n  position: absolute;\n}\n#layer .title img {\n  padding-right: 20px;\n  position: absolute;\n  left: 10px;\n  max-height: 28px;\n}\n#layer .title div {\n  position: absolute;\n  left: 90px;\n}\n#layer .title div h1 {\n  font-size: 25px;\n  font-weight: 200;\n  line-height: 45px;\n  margin: 0;\n  padding: 0;\n  text-align: left;\n}\n#layer .title div h2 {\n  font-size: 15px;\n  font-weight: 200;\n  margin: 0;\n  padding: 0;\n  text-align: left;\n}\n#layer .panetitle {\n  position: fixed;\n  height: 30px;\n  width: 220px;\n  top: 60px;\n  border-bottom: 1px solid #222222;\n  font-weight: 500;\n  font-size: 12px;\n  padding: 4px 4px 4px 20px;\n  letter-spacing: 5px;\n  text-align: left;\n  color: #41aaaa;\n  box-shadow: 0 4px 2px -2px rgba(31, 73, 125, 0.3);\n}\n#layer #layer_elements {\n  padding: 0;\n  margin: 0;\n  border: 0;\n  position: fixed;\n  top: 90px;\n  left: 0;\n  bottom: 0;\n  width: 220px;\n  overflow: auto;\n}\n#layer #layer_elements .layerElement {\n  background-color: #fafafa;\n  color: black;\n  cursor: move;\n  font-weight: 400;\n  font-size: 12px;\n  letter-spacing: 1px;\n  padding: 4px 4px 4px 5px;\n  text-align: left;\n  border: 1px solid transparent;\n  border-bottom: 1px solid #222222;\n}\n#layer #layer_elements .layerElement::before {\n  content: \"\";\n  display: block;\n  width: 20px;\n  height: 20px;\n  float: left;\n  margin-right: 5px;\n}\n#layer #layer_elements .layerElement.ExtLine::before {\n  background: url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ") no-repeat;\n  background-size: cover;\n}\n#layer #layer_elements .layerElement.PolyRect::before {\n  background: url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ") no-repeat;\n  background-size: cover;\n}\n#layer #layer_elements .layerElement.PolyCircle::before {\n  background: url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ") no-repeat;\n  background-size: cover;\n}\n#layer #layer_elements .layerElement.ExtLabel::before {\n  background: url(" + ___CSS_LOADER_URL_REPLACEMENT_3___ + ") no-repeat;\n  background-size: cover;\n}\n#layer #layer_elements .layerElement.ExtPort::before {\n  background: url(" + ___CSS_LOADER_URL_REPLACEMENT_4___ + ") no-repeat;\n  background-size: cover;\n}\n#layer #layer_elements .layerElement[data-visibility=\"false\"] {\n  opacity: 0.5;\n  font-style: italic;\n}\n#layer #layer_elements .layerElement .icon {\n  cursor: pointer;\n  padding-right: 4px;\n  width: 20px;\n  height: 20px;\n}\n#layer #layer_elements .layerElement .icon * {\n  stroke: black !important;\n}\n#layer #layer_elements .layerElement .icon:hover * {\n  stroke: #41aaaa !important;\n}\n#layer #layer_elements .layerSelectedElement {\n  background-color: #f5f5f5;\n  color: black;\n  border-style: dotted;\n  border-width: 1px;\n  border-color: #41aaaa;\n  font-weight: 600;\n}\n#code_overlay {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 100%;\n  height: 100%;\n  background-color: white;\n  z-index: 10000;\n}\n#code_close {\n  position: fixed;\n  right: 40px;\n  top: 10px;\n  width: 32px;\n  height: 32px;\n  z-index: 10000;\n  cursor: pointer;\n  font-size: 50px;\n}\n#code_close:hover {\n  color: #41aaaa;\n}\n#test_run {\n  position: fixed;\n  right: 90px;\n  top: 10px;\n  width: 32px;\n  height: 32px;\n  z-index: 10000;\n  cursor: pointer;\n  font-size: 50px;\n}\n#test_run:hover {\n  color: #41aaaa;\n}\n#test_info {\n  position: absolute;\n  color: black;\n  z-index: 20000;\n  top: 20px;\n  left: 20px;\n  border: 1px solid lightgray;\n  padding: 7px;\n  background-color: white;\n  border-radius: 2px;\n}\n#test_canvas {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 100%;\n  height: 100%;\n  background-color: white;\n  z-index: 10000;\n}\n#test_close {\n  position: fixed;\n  right: 40px;\n  top: 10px;\n  width: 32px;\n  height: 32px;\n  z-index: 10000;\n  cursor: pointer;\n  font-size: 50px;\n}\n#test_close:hover {\n  color: #41aaaa;\n}\n#test_clipboard {\n  position: fixed;\n  right: 100px;\n  top: 10px;\n  width: 32px;\n  height: 32px;\n  z-index: 10000;\n  cursor: pointer;\n  font-size: 50px;\n}\n#test_clipboard:hover {\n  color: #41aaaa;\n}\n.portDirectionOption {\n  height: 60px;\n  text-align: center;\n}\n.portDirectionOption label > input {\n  /* HIDE RADIO */\n  display: none;\n}\n.portDirectionOption label > input + span {\n  /* IMAGE STYLES */\n  cursor: pointer;\n  color: gray !important;\n  padding-right: 5px;\n}\n.portDirectionOption label > input:checked + span {\n  /* (CHECKED) IMAGE STYLES */\n  color: #41aaaa !important;\n}\n.portTypeOption {\n  height: 65px;\n  padding-left: 60px;\n}\n.portTypeOption label > input {\n  /* HIDE RADIO */\n  display: none;\n}\n.portTypeOption label > input + span {\n  /* IMAGE STYLES */\n  cursor: pointer;\n  color: gray !important;\n  padding-right: 5px;\n  font-weight: 100;\n  font-size: 14px;\n}\n.portTypeOption label > input + span:before {\n  padding-right: 10px;\n}\n.portTypeOption label > input:checked + span {\n  /* (CHECKED) IMAGE STYLES */\n  color: #41aaaa !important;\n}\n#filter {\n  position: absolute;\n  top: 60px;\n  right: 0;\n  bottom: 0;\n  width: 250px;\n  padding: 0;\n  margin: 0;\n  border-radius: 0;\n  border: 0;\n  background-color: #282a30;\n}\n#filter .filter_header {\n  background: none repeat scroll 0 0 #303030;\n  position: fixed;\n  height: 30px;\n  width: 250px;\n  top: 60px;\n  border-bottom: 1px solid #222222;\n  border-top: 1px solid #111111;\n  font-weight: 500;\n  font-size: 12px;\n  padding-top: 5px;\n  letter-spacing: 5px;\n  text-align: center;\n  color: #41aaaa;\n}\n#filter .filter_toolbar {\n  overflow: visible;\n  border: 0;\n  padding: 3px;\n  padding-left: 10px;\n  position: absolute;\n  bottom: 0;\n  right: 0;\n  width: 250px;\n  height: 30px;\n  background: none repeat scroll 0 0 #303030;\n}\n#filter .filter_actions {\n  position: fixed;\n  top: 90px;\n  bottom: 30px;\n  width: 250px;\n  border: 0;\n  padding: 0;\n  overflow-y: auto;\n}\n#filter .filter_actions .panel-body {\n  padding: 7px;\n  padding-top: 0;\n}\n#filter .filter_actions .form-group {\n  margin-bottom: 2px !important;\n}\n#filter .filter_actions .form-group > .input-group {\n  margin-bottom: 10px;\n}\n#filter .filter_actions .form-group > .input-group:last-child {\n  margin-bottom: 0px;\n}\n#filter .filter_actions .icon {\n  color: #26B4A8;\n  padding: 0;\n  top: -4px;\n  color: rgba(255, 255, 255, 0.25);\n}\n#filter .filter_actions .icon:hover {\n  color: #41aaaa;\n}\n#filter .filter_actions .filter-heading {\n  color: #DDDDDD !important;\n  font-size: 12px;\n  padding-right: 10px !important;\n  padding-top: 1px !important;\n  padding-bottom: 0 !important;\n  background-color: transparent !important;\n  background-image: none !important;\n  border: 0 !important;\n  margin-top: 4px;\n  cursor: pointer;\n  font-weight: 300;\n}\n#filter .filter_actions .filter-heading .icon {\n  width: 15px;\n}\n#filter .filter_actions .filter-heading .icon * {\n  stroke: white !important;\n}\n#filter .form-control {\n  height: 25px;\n}\n#filter .btn {\n  padding-left: 5px;\n  padding-right: 5px;\n  padding-top: 1px;\n  padding-bottom: 2px;\n}\n#filter .input-group-addon {\n  padding: 0;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: rgba(0, 0, 0, 0.3);\n  background-color: white;\n  border-left: 0;\n  border-radius: 0;\n  font-weight: 100;\n  text-transform: lowercase;\n  font-size: 12px;\n}\n#filter .panel-default {\n  margin: 0;\n  border-radius: 0;\n  background-color: rgba(65, 170, 170, 0.02);\n  border: 0;\n  border-top: 1px solid #303030;\n  border-bottom: 1px solid #202525;\n  margin-top: 3px;\n}\n#FigureMarkdownEdit .header {\n  width: 100%;\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  display: inline-block;\n  height: 60px;\n  background-color: white;\n  overflow: hidden;\n}\n#FigureMarkdownEdit .header .left {\n  width: 50%;\n  display: inline-block;\n  height: 60px;\n  font-size: 20px;\n  padding: 6px;\n  color: #CC4F5A;\n  background-color: rgba(0, 0, 0, 0.1);\n  vertical-align: top;\n}\n#FigureMarkdownEdit .header .left small {\n  font-size: 16px;\n}\n#FigureMarkdownEdit .header .right {\n  width: 50%;\n  display: inline-block;\n  height: 60px;\n  font-size: 20px;\n  padding: 6px;\n  color: #CC4F5A;\n  background-color: rgba(0, 0, 0, 0.05);\n  vertical-align: top;\n}\n#FigureMarkdownEdit .source {\n  width: 50%;\n  display: inline-block;\n  font-family: Menlo, Monaco, Consolas, \"Courier New\", monospace;\n  font-size: 13px;\n  padding: 2px;\n  top: 60px;\n  bottom: 0px;\n  position: absolute;\n}\n#FigureMarkdownEdit .preview {\n  width: 50%;\n  display: inline-block;\n  top: 0px;\n  left: 50%;\n  position: absolute;\n  background-color: white;\n  padding: 30px;\n  overflow: auto;\n  top: 60px;\n  bottom: 0px;\n}\n#FigureMarkdownEdit .preview img {\n  max-width: 35%;\n}\n#FigureMarkdownEdit .preview table {\n  font-family: Arial, Helvetica, sans-serif;\n  color: #666;\n  font-size: 12px;\n  text-shadow: 1px 1px 0px #fff;\n  background: #eaebec;\n  margin: 20px;\n  margin-left: 0;\n  border: #ccc 1px solid;\n  -moz-border-radius: 3px;\n  -webkit-border-radius: 3px;\n  border-radius: 3px;\n  -moz-box-shadow: 0 1px 2px #d1d1d1;\n  -webkit-box-shadow: 0 1px 2px #d1d1d1;\n  box-shadow: 0 1px 2px #d1d1d1;\n}\n#FigureMarkdownEdit .preview table th {\n  padding: 21px 25px 22px 25px;\n  border-top: 1px solid #fafafa;\n  border-bottom: 1px solid #e0e0e0;\n}\n#FigureMarkdownEdit .preview table th:first-child {\n  text-align: left;\n  padding-left: 20px;\n}\n#FigureMarkdownEdit .preview table tr:first-child th:first-child {\n  -moz-border-radius-topleft: 3px;\n  -webkit-border-top-left-radius: 3px;\n  border-top-left-radius: 3px;\n}\n#FigureMarkdownEdit .preview table tr:first-child th:last-child {\n  -moz-border-radius-topright: 3px;\n  -webkit-border-top-right-radius: 3px;\n  border-top-right-radius: 3px;\n}\n#FigureMarkdownEdit .preview table tr {\n  text-align: center;\n  padding-left: 20px;\n}\n#FigureMarkdownEdit .preview table tr td:first-child {\n  text-align: left;\n  padding-left: 20px;\n  border-left: 0;\n}\n#FigureMarkdownEdit .preview table tr td {\n  padding: 18px;\n  border-top: 1px solid #ffffff;\n  border-bottom: 1px solid #e0e0e0;\n  border-left: 1px solid #e0e0e0;\n}\n#FigureMarkdownEdit .preview tbody tr:nth-child(odd) {\n  background: #fafafa;\n}\n#FigureMarkdownEdit .preview tbody tr:nth-child(even) {\n  background: #f3f3f3;\n}\n#FigureMarkdownEdit .preview table tr:last-child td {\n  border-bottom: 0;\n}\n#FigureMarkdownEdit .preview table tr:last-child td:first-child {\n  -moz-border-radius-bottomleft: 3px;\n  -webkit-border-bottom-left-radius: 3px;\n  border-bottom-left-radius: 3px;\n}\n#FigureMarkdownEdit .preview table tr:last-child td:last-child {\n  -moz-border-radius-bottomright: 3px;\n  -webkit-border-bottom-right-radius: 3px;\n  border-bottom-right-radius: 3px;\n}\n.ui-anglepicker {\n  width: 52px;\n  height: 52px;\n  background: #dbdbdb;\n  background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEgMSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkLXVjZ2ctZ2VuZXJhdGVkIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iI2RiZGJkYiIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjIwJSIgc3RvcC1jb2xvcj0iI2UxZTFkZSIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiNmOGY4ZjMiIHN0b3Atb3BhY2l0eT0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0idXJsKCNncmFkLXVjZ2ctZ2VuZXJhdGVkKSIgLz4KPC9zdmc+);\n  background: -moz-linear-gradient(top, #dbdbdb 0%, #e1e1de 20%, #f8f8f3 100%);\n  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #dbdbdb), color-stop(20%, #e1e1de), color-stop(100%, #f8f8f3));\n  background: -webkit-linear-gradient(top, #dbdbdb 0%, #e1e1de 20%, #f8f8f3 100%);\n  background: -o-linear-gradient(top, #dbdbdb 0%, #e1e1de 20%, #f8f8f3 100%);\n  background: -ms-linear-gradient(top, #dbdbdb 0%, #e1e1de 20%, #f8f8f3 100%);\n  background: linear-gradient(to bottom, #dbdbdb 0%, #e1e1de 20%, #f8f8f3 100%);\n  border: 2px solid #666;\n  -moz-box-shadow: inset 0 2px 3px white, inset 0 -1px 2px #fffef8;\n  -webkit-box-shadow: inset 0 2px 3px white, inset 0 -1px 2px #fffef8;\n  box-shadow: inset 0 2px 3px white, inset 0 -1px 2px #fffef8;\n  -moz-border-radius: 50%;\n  -webkit-border-radius: 50%;\n  border-radius: 50%;\n  position: relative;\n  display: inline-block;\n}\n.ui-anglepicker-pointer {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 50%;\n  margin: -2px 0 0 -2px;\n  -moz-transform-origin: 2px 2px;\n  -webkit-transform-origin: 2px 2px;\n  -ms-transform-origin: 2px 2px;\n  -o-transform-origin: 2px 2px;\n  transform-origin: 2px 2px;\n}\n.ui-anglepicker:hover,\n.ui-anglepicker.ui-anglepicker-dragging {\n  border-color: #494949;\n}\n.ui-anglepicker-dragging .ui-anglepicker-dot,\n.ui-anglepicker-dragging .ui-anglepicker-line,\n.ui-anglepicker:hover .ui-anglepicker-dot,\n.ui-anglepicker:hover .ui-anglepicker-line {\n  background: #494949;\n}\n.ui-anglepicker-dot {\n  height: 4px;\n  width: 4px;\n  position: absolute;\n  background: #838383;\n  -moz-border-radius: 50%;\n  -webkit-border-radius: 50%;\n  border-radius: 50%;\n}\n.ui-anglepicker-line {\n  margin-top: 1.5px;\n  margin-right: -2px;\n  height: 1px;\n  background: #838383;\n}\n#tool_shape.open .dropdown-menu {\n  -webkit-transform: scale(1, 1);\n  opacity: 1;\n  transform: scale(1, 1);\n}\n#tool_shape .dropdown-menu {\n  opacity: 0.1;\n  animation-fill-mode: forwards;\n  transform: scale(1, 0);\n  transform-origin: 0 0 ;\n  display: block;\n  transition: all 0.2s ease;\n}\n#tool_shape .tool_shape_entry {\n  text-align: left;\n}\n#tool_shape .tool_shape_entry img {\n  height: 30px;\n  padding-right: 20px;\n}\n#tool_shape .tool_shape_entry .tool_label {\n  min-width: 95px;\n  display: inline-block;\n}\n#tool_shape .tool_shape_entry .tool_shortcut {\n  color: rgba(0, 0, 0, 0.5);\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    // eslint-disable-next-line no-param-reassign
    options = {};
  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign


  url = url && url.__esModule ? url.default : url;

  if (typeof url !== 'string') {
    return url;
  } // If url is already wrapped in quotes, remove them


  if (/^['"].*['"]$/.test(url)) {
    // eslint-disable-next-line no-param-reassign
    url = url.slice(1, -1);
  }

  if (options.hash) {
    // eslint-disable-next-line no-param-reassign
    url += options.hash;
  } // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls


  if (/["'() \t\n]/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, '\\n'), "\"");
  }

  return url;
};

/***/ }),

/***/ "./node_modules/font-awesome/css/font-awesome.css":
/*!********************************************************!*\
  !*** ./node_modules/font-awesome/css/font-awesome.css ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../css-loader/dist/cjs.js!./font-awesome.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/font-awesome/css/font-awesome.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./node_modules/font-awesome/fonts/fontawesome-webfont.eot":
/*!*****************************************************************!*\
  !*** ./node_modules/font-awesome/fonts/fontawesome-webfont.eot ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/674f50d287a8c48dc19ba404d20fe713.eot";

/***/ }),

/***/ "./node_modules/font-awesome/fonts/fontawesome-webfont.eot?v=4.7.0":
/*!*************************************************************************!*\
  !*** ./node_modules/font-awesome/fonts/fontawesome-webfont.eot?v=4.7.0 ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/674f50d287a8c48dc19ba404d20fe713.eot";

/***/ }),

/***/ "./node_modules/font-awesome/fonts/fontawesome-webfont.svg?v=4.7.0":
/*!*************************************************************************!*\
  !*** ./node_modules/font-awesome/fonts/fontawesome-webfont.svg?v=4.7.0 ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/912ec66d7572ff821749319396470bde.svg";

/***/ }),

/***/ "./node_modules/font-awesome/fonts/fontawesome-webfont.ttf?v=4.7.0":
/*!*************************************************************************!*\
  !*** ./node_modules/font-awesome/fonts/fontawesome-webfont.ttf?v=4.7.0 ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/b06871f281fee6b241d60582ae9369b9.ttf";

/***/ }),

/***/ "./node_modules/font-awesome/fonts/fontawesome-webfont.woff2?v=4.7.0":
/*!***************************************************************************!*\
  !*** ./node_modules/font-awesome/fonts/fontawesome-webfont.woff2?v=4.7.0 ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/af7ae505a9eed503f8b8e6982036873e.woff2";

/***/ }),

/***/ "./node_modules/font-awesome/fonts/fontawesome-webfont.woff?v=4.7.0":
/*!**************************************************************************!*\
  !*** ./node_modules/font-awesome/fonts/fontawesome-webfont.woff?v=4.7.0 ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "js/webpack/fee66e712a8a08eef5805a46892932ad.woff";

/***/ }),

/***/ "./node_modules/hogan.js/lib/compiler.js":
/*!***********************************************!*\
  !*** ./node_modules/hogan.js/lib/compiler.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

(function (Hogan) {
  // Setup regex  assignments
  // remove whitespace according to Mustache spec
  var rIsWhitespace = /\S/,
      rQuot = /\"/g,
      rNewline =  /\n/g,
      rCr = /\r/g,
      rSlash = /\\/g,
      rLineSep = /\u2028/,
      rParagraphSep = /\u2029/;

  Hogan.tags = {
    '#': 1, '^': 2, '<': 3, '$': 4,
    '/': 5, '!': 6, '>': 7, '=': 8, '_v': 9,
    '{': 10, '&': 11, '_t': 12
  };

  Hogan.scan = function scan(text, delimiters) {
    var len = text.length,
        IN_TEXT = 0,
        IN_TAG_TYPE = 1,
        IN_TAG = 2,
        state = IN_TEXT,
        tagType = null,
        tag = null,
        buf = '',
        tokens = [],
        seenTag = false,
        i = 0,
        lineStart = 0,
        otag = '{{',
        ctag = '}}';

    function addBuf() {
      if (buf.length > 0) {
        tokens.push({tag: '_t', text: new String(buf)});
        buf = '';
      }
    }

    function lineIsWhitespace() {
      var isAllWhitespace = true;
      for (var j = lineStart; j < tokens.length; j++) {
        isAllWhitespace =
          (Hogan.tags[tokens[j].tag] < Hogan.tags['_v']) ||
          (tokens[j].tag == '_t' && tokens[j].text.match(rIsWhitespace) === null);
        if (!isAllWhitespace) {
          return false;
        }
      }

      return isAllWhitespace;
    }

    function filterLine(haveSeenTag, noNewLine) {
      addBuf();

      if (haveSeenTag && lineIsWhitespace()) {
        for (var j = lineStart, next; j < tokens.length; j++) {
          if (tokens[j].text) {
            if ((next = tokens[j+1]) && next.tag == '>') {
              // set indent to token value
              next.indent = tokens[j].text.toString()
            }
            tokens.splice(j, 1);
          }
        }
      } else if (!noNewLine) {
        tokens.push({tag:'\n'});
      }

      seenTag = false;
      lineStart = tokens.length;
    }

    function changeDelimiters(text, index) {
      var close = '=' + ctag,
          closeIndex = text.indexOf(close, index),
          delimiters = trim(
            text.substring(text.indexOf('=', index) + 1, closeIndex)
          ).split(' ');

      otag = delimiters[0];
      ctag = delimiters[delimiters.length - 1];

      return closeIndex + close.length - 1;
    }

    if (delimiters) {
      delimiters = delimiters.split(' ');
      otag = delimiters[0];
      ctag = delimiters[1];
    }

    for (i = 0; i < len; i++) {
      if (state == IN_TEXT) {
        if (tagChange(otag, text, i)) {
          --i;
          addBuf();
          state = IN_TAG_TYPE;
        } else {
          if (text.charAt(i) == '\n') {
            filterLine(seenTag);
          } else {
            buf += text.charAt(i);
          }
        }
      } else if (state == IN_TAG_TYPE) {
        i += otag.length - 1;
        tag = Hogan.tags[text.charAt(i + 1)];
        tagType = tag ? text.charAt(i + 1) : '_v';
        if (tagType == '=') {
          i = changeDelimiters(text, i);
          state = IN_TEXT;
        } else {
          if (tag) {
            i++;
          }
          state = IN_TAG;
        }
        seenTag = i;
      } else {
        if (tagChange(ctag, text, i)) {
          tokens.push({tag: tagType, n: trim(buf), otag: otag, ctag: ctag,
                       i: (tagType == '/') ? seenTag - otag.length : i + ctag.length});
          buf = '';
          i += ctag.length - 1;
          state = IN_TEXT;
          if (tagType == '{') {
            if (ctag == '}}') {
              i++;
            } else {
              cleanTripleStache(tokens[tokens.length - 1]);
            }
          }
        } else {
          buf += text.charAt(i);
        }
      }
    }

    filterLine(seenTag, true);

    return tokens;
  }

  function cleanTripleStache(token) {
    if (token.n.substr(token.n.length - 1) === '}') {
      token.n = token.n.substring(0, token.n.length - 1);
    }
  }

  function trim(s) {
    if (s.trim) {
      return s.trim();
    }

    return s.replace(/^\s*|\s*$/g, '');
  }

  function tagChange(tag, text, index) {
    if (text.charAt(index) != tag.charAt(0)) {
      return false;
    }

    for (var i = 1, l = tag.length; i < l; i++) {
      if (text.charAt(index + i) != tag.charAt(i)) {
        return false;
      }
    }

    return true;
  }

  // the tags allowed inside super templates
  var allowedInSuper = {'_t': true, '\n': true, '$': true, '/': true};

  function buildTree(tokens, kind, stack, customTags) {
    var instructions = [],
        opener = null,
        tail = null,
        token = null;

    tail = stack[stack.length - 1];

    while (tokens.length > 0) {
      token = tokens.shift();

      if (tail && tail.tag == '<' && !(token.tag in allowedInSuper)) {
        throw new Error('Illegal content in < super tag.');
      }

      if (Hogan.tags[token.tag] <= Hogan.tags['$'] || isOpener(token, customTags)) {
        stack.push(token);
        token.nodes = buildTree(tokens, token.tag, stack, customTags);
      } else if (token.tag == '/') {
        if (stack.length === 0) {
          throw new Error('Closing tag without opener: /' + token.n);
        }
        opener = stack.pop();
        if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {
          throw new Error('Nesting error: ' + opener.n + ' vs. ' + token.n);
        }
        opener.end = token.i;
        return instructions;
      } else if (token.tag == '\n') {
        token.last = (tokens.length == 0) || (tokens[0].tag == '\n');
      }

      instructions.push(token);
    }

    if (stack.length > 0) {
      throw new Error('missing closing tag: ' + stack.pop().n);
    }

    return instructions;
  }

  function isOpener(token, tags) {
    for (var i = 0, l = tags.length; i < l; i++) {
      if (tags[i].o == token.n) {
        token.tag = '#';
        return true;
      }
    }
  }

  function isCloser(close, open, tags) {
    for (var i = 0, l = tags.length; i < l; i++) {
      if (tags[i].c == close && tags[i].o == open) {
        return true;
      }
    }
  }

  function stringifySubstitutions(obj) {
    var items = [];
    for (var key in obj) {
      items.push('"' + esc(key) + '": function(c,p,t,i) {' + obj[key] + '}');
    }
    return "{ " + items.join(",") + " }";
  }

  function stringifyPartials(codeObj) {
    var partials = [];
    for (var key in codeObj.partials) {
      partials.push('"' + esc(key) + '":{name:"' + esc(codeObj.partials[key].name) + '", ' + stringifyPartials(codeObj.partials[key]) + "}");
    }
    return "partials: {" + partials.join(",") + "}, subs: " + stringifySubstitutions(codeObj.subs);
  }

  Hogan.stringify = function(codeObj, text, options) {
    return "{code: function (c,p,i) { " + Hogan.wrapMain(codeObj.code) + " }," + stringifyPartials(codeObj) +  "}";
  }

  var serialNo = 0;
  Hogan.generate = function(tree, text, options) {
    serialNo = 0;
    var context = { code: '', subs: {}, partials: {} };
    Hogan.walk(tree, context);

    if (options.asString) {
      return this.stringify(context, text, options);
    }

    return this.makeTemplate(context, text, options);
  }

  Hogan.wrapMain = function(code) {
    return 'var t=this;t.b(i=i||"");' + code + 'return t.fl();';
  }

  Hogan.template = Hogan.Template;

  Hogan.makeTemplate = function(codeObj, text, options) {
    var template = this.makePartials(codeObj);
    template.code = new Function('c', 'p', 'i', this.wrapMain(codeObj.code));
    return new this.template(template, text, this, options);
  }

  Hogan.makePartials = function(codeObj) {
    var key, template = {subs: {}, partials: codeObj.partials, name: codeObj.name};
    for (key in template.partials) {
      template.partials[key] = this.makePartials(template.partials[key]);
    }
    for (key in codeObj.subs) {
      template.subs[key] = new Function('c', 'p', 't', 'i', codeObj.subs[key]);
    }
    return template;
  }

  function esc(s) {
    return s.replace(rSlash, '\\\\')
            .replace(rQuot, '\\\"')
            .replace(rNewline, '\\n')
            .replace(rCr, '\\r')
            .replace(rLineSep, '\\u2028')
            .replace(rParagraphSep, '\\u2029');
  }

  function chooseMethod(s) {
    return (~s.indexOf('.')) ? 'd' : 'f';
  }

  function createPartial(node, context) {
    var prefix = "<" + (context.prefix || "");
    var sym = prefix + node.n + serialNo++;
    context.partials[sym] = {name: node.n, partials: {}};
    context.code += 't.b(t.rp("' +  esc(sym) + '",c,p,"' + (node.indent || '') + '"));';
    return sym;
  }

  Hogan.codegen = {
    '#': function(node, context) {
      context.code += 'if(t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),' +
                      'c,p,0,' + node.i + ',' + node.end + ',"' + node.otag + " " + node.ctag + '")){' +
                      't.rs(c,p,' + 'function(c,p,t){';
      Hogan.walk(node.nodes, context);
      context.code += '});c.pop();}';
    },

    '^': function(node, context) {
      context.code += 'if(!t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),c,p,1,0,0,"")){';
      Hogan.walk(node.nodes, context);
      context.code += '};';
    },

    '>': createPartial,
    '<': function(node, context) {
      var ctx = {partials: {}, code: '', subs: {}, inPartial: true};
      Hogan.walk(node.nodes, ctx);
      var template = context.partials[createPartial(node, context)];
      template.subs = ctx.subs;
      template.partials = ctx.partials;
    },

    '$': function(node, context) {
      var ctx = {subs: {}, code: '', partials: context.partials, prefix: node.n};
      Hogan.walk(node.nodes, ctx);
      context.subs[node.n] = ctx.code;
      if (!context.inPartial) {
        context.code += 't.sub("' + esc(node.n) + '",c,p,i);';
      }
    },

    '\n': function(node, context) {
      context.code += write('"\\n"' + (node.last ? '' : ' + i'));
    },

    '_v': function(node, context) {
      context.code += 't.b(t.v(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
    },

    '_t': function(node, context) {
      context.code += write('"' + esc(node.text) + '"');
    },

    '{': tripleStache,

    '&': tripleStache
  }

  function tripleStache(node, context) {
    context.code += 't.b(t.t(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
  }

  function write(s) {
    return 't.b(' + s + ');';
  }

  Hogan.walk = function(nodelist, context) {
    var func;
    for (var i = 0, l = nodelist.length; i < l; i++) {
      func = Hogan.codegen[nodelist[i].tag];
      func && func(nodelist[i], context);
    }
    return context;
  }

  Hogan.parse = function(tokens, text, options) {
    options = options || {};
    return buildTree(tokens, '', [], options.sectionTags || []);
  }

  Hogan.cache = {};

  Hogan.cacheKey = function(text, options) {
    return [text, !!options.asString, !!options.disableLambda, options.delimiters, !!options.modelGet].join('||');
  }

  Hogan.compile = function(text, options) {
    options = options || {};
    var key = Hogan.cacheKey(text, options);
    var template = this.cache[key];

    if (template) {
      var partials = template.partials;
      for (var name in partials) {
        delete partials[name].instance;
      }
      return template;
    }

    template = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);
    return this.cache[key] = template;
  }
})( true ? exports : undefined);


/***/ }),

/***/ "./node_modules/hogan.js/lib/hogan.js":
/*!********************************************!*\
  !*** ./node_modules/hogan.js/lib/hogan.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

// This file is for use with Node.js. See dist/ for browser files.

var Hogan = __webpack_require__(/*! ./compiler */ "./node_modules/hogan.js/lib/compiler.js");
Hogan.Template = __webpack_require__(/*! ./template */ "./node_modules/hogan.js/lib/template.js").Template;
Hogan.template = Hogan.Template;
module.exports = Hogan;


/***/ }),

/***/ "./node_modules/hogan.js/lib/template.js":
/*!***********************************************!*\
  !*** ./node_modules/hogan.js/lib/template.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

var Hogan = {};

(function (Hogan) {
  Hogan.Template = function (codeObj, text, compiler, options) {
    codeObj = codeObj || {};
    this.r = codeObj.code || this.r;
    this.c = compiler;
    this.options = options || {};
    this.text = text || '';
    this.partials = codeObj.partials || {};
    this.subs = codeObj.subs || {};
    this.buf = '';
  }

  Hogan.Template.prototype = {
    // render: replaced by generated code.
    r: function (context, partials, indent) { return ''; },

    // variable escaping
    v: hoganEscape,

    // triple stache
    t: coerceToString,

    render: function render(context, partials, indent) {
      return this.ri([context], partials || {}, indent);
    },

    // render internal -- a hook for overrides that catches partials too
    ri: function (context, partials, indent) {
      return this.r(context, partials, indent);
    },

    // ensurePartial
    ep: function(symbol, partials) {
      var partial = this.partials[symbol];

      // check to see that if we've instantiated this partial before
      var template = partials[partial.name];
      if (partial.instance && partial.base == template) {
        return partial.instance;
      }

      if (typeof template == 'string') {
        if (!this.c) {
          throw new Error("No compiler available.");
        }
        template = this.c.compile(template, this.options);
      }

      if (!template) {
        return null;
      }

      // We use this to check whether the partials dictionary has changed
      this.partials[symbol].base = template;

      if (partial.subs) {
        // Make sure we consider parent template now
        if (!partials.stackText) partials.stackText = {};
        for (key in partial.subs) {
          if (!partials.stackText[key]) {
            partials.stackText[key] = (this.activeSub !== undefined && partials.stackText[this.activeSub]) ? partials.stackText[this.activeSub] : this.text;
          }
        }
        template = createSpecializedPartial(template, partial.subs, partial.partials,
          this.stackSubs, this.stackPartials, partials.stackText);
      }
      this.partials[symbol].instance = template;

      return template;
    },

    // tries to find a partial in the current scope and render it
    rp: function(symbol, context, partials, indent) {
      var partial = this.ep(symbol, partials);
      if (!partial) {
        return '';
      }

      return partial.ri(context, partials, indent);
    },

    // render a section
    rs: function(context, partials, section) {
      var tail = context[context.length - 1];

      if (!isArray(tail)) {
        section(context, partials, this);
        return;
      }

      for (var i = 0; i < tail.length; i++) {
        context.push(tail[i]);
        section(context, partials, this);
        context.pop();
      }
    },

    // maybe start a section
    s: function(val, ctx, partials, inverted, start, end, tags) {
      var pass;

      if (isArray(val) && val.length === 0) {
        return false;
      }

      if (typeof val == 'function') {
        val = this.ms(val, ctx, partials, inverted, start, end, tags);
      }

      pass = !!val;

      if (!inverted && pass && ctx) {
        ctx.push((typeof val == 'object') ? val : ctx[ctx.length - 1]);
      }

      return pass;
    },

    // find values with dotted names
    d: function(key, ctx, partials, returnFound) {
      var found,
          names = key.split('.'),
          val = this.f(names[0], ctx, partials, returnFound),
          doModelGet = this.options.modelGet,
          cx = null;

      if (key === '.' && isArray(ctx[ctx.length - 2])) {
        val = ctx[ctx.length - 1];
      } else {
        for (var i = 1; i < names.length; i++) {
          found = findInScope(names[i], val, doModelGet);
          if (found !== undefined) {
            cx = val;
            val = found;
          } else {
            val = '';
          }
        }
      }

      if (returnFound && !val) {
        return false;
      }

      if (!returnFound && typeof val == 'function') {
        ctx.push(cx);
        val = this.mv(val, ctx, partials);
        ctx.pop();
      }

      return val;
    },

    // find values with normal names
    f: function(key, ctx, partials, returnFound) {
      var val = false,
          v = null,
          found = false,
          doModelGet = this.options.modelGet;

      for (var i = ctx.length - 1; i >= 0; i--) {
        v = ctx[i];
        val = findInScope(key, v, doModelGet);
        if (val !== undefined) {
          found = true;
          break;
        }
      }

      if (!found) {
        return (returnFound) ? false : "";
      }

      if (!returnFound && typeof val == 'function') {
        val = this.mv(val, ctx, partials);
      }

      return val;
    },

    // higher order templates
    ls: function(func, cx, partials, text, tags) {
      var oldTags = this.options.delimiters;

      this.options.delimiters = tags;
      this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));
      this.options.delimiters = oldTags;

      return false;
    },

    // compile text
    ct: function(text, cx, partials) {
      if (this.options.disableLambda) {
        throw new Error('Lambda features disabled.');
      }
      return this.c.compile(text, this.options).render(cx, partials);
    },

    // template result buffering
    b: function(s) { this.buf += s; },

    fl: function() { var r = this.buf; this.buf = ''; return r; },

    // method replace section
    ms: function(func, ctx, partials, inverted, start, end, tags) {
      var textSource,
          cx = ctx[ctx.length - 1],
          result = func.call(cx);

      if (typeof result == 'function') {
        if (inverted) {
          return true;
        } else {
          textSource = (this.activeSub && this.subsText && this.subsText[this.activeSub]) ? this.subsText[this.activeSub] : this.text;
          return this.ls(result, cx, partials, textSource.substring(start, end), tags);
        }
      }

      return result;
    },

    // method replace variable
    mv: function(func, ctx, partials) {
      var cx = ctx[ctx.length - 1];
      var result = func.call(cx);

      if (typeof result == 'function') {
        return this.ct(coerceToString(result.call(cx)), cx, partials);
      }

      return result;
    },

    sub: function(name, context, partials, indent) {
      var f = this.subs[name];
      if (f) {
        this.activeSub = name;
        f(context, partials, this, indent);
        this.activeSub = false;
      }
    }

  };

  //Find a key in an object
  function findInScope(key, scope, doModelGet) {
    var val;

    if (scope && typeof scope == 'object') {

      if (scope[key] !== undefined) {
        val = scope[key];

      // try lookup with get for backbone or similar model data
      } else if (doModelGet && scope.get && typeof scope.get == 'function') {
        val = scope.get(key);
      }
    }

    return val;
  }

  function createSpecializedPartial(instance, subs, partials, stackSubs, stackPartials, stackText) {
    function PartialTemplate() {};
    PartialTemplate.prototype = instance;
    function Substitutions() {};
    Substitutions.prototype = instance.subs;
    var key;
    var partial = new PartialTemplate();
    partial.subs = new Substitutions();
    partial.subsText = {};  //hehe. substext.
    partial.buf = '';

    stackSubs = stackSubs || {};
    partial.stackSubs = stackSubs;
    partial.subsText = stackText;
    for (key in subs) {
      if (!stackSubs[key]) stackSubs[key] = subs[key];
    }
    for (key in stackSubs) {
      partial.subs[key] = stackSubs[key];
    }

    stackPartials = stackPartials || {};
    partial.stackPartials = stackPartials;
    for (key in partials) {
      if (!stackPartials[key]) stackPartials[key] = partials[key];
    }
    for (key in stackPartials) {
      partial.partials[key] = stackPartials[key];
    }

    return partial;
  }

  var rAmp = /&/g,
      rLt = /</g,
      rGt = />/g,
      rApos = /\'/g,
      rQuot = /\"/g,
      hChars = /[&<>\"\']/;

  function coerceToString(val) {
    return String((val === null || val === undefined) ? '' : val);
  }

  function hoganEscape(str) {
    str = coerceToString(str);
    return hChars.test(str) ?
      str
        .replace(rAmp, '&amp;')
        .replace(rLt, '&lt;')
        .replace(rGt, '&gt;')
        .replace(rApos, '&#39;')
        .replace(rQuot, '&quot;') :
      str;
  }

  var isArray = Array.isArray || function(a) {
    return Object.prototype.toString.call(a) === '[object Array]';
  };

})( true ? exports : undefined);


/***/ }),

/***/ "./node_modules/jsts/dist/jsts.js":
/*!****************************************!*\
  !*** ./node_modules/jsts/dist/jsts.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * JSTS. See https://github.com/bjornharrtell/jsts
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_LICENSE_ES6_COLLECTIONS.txt
 * @license
 */

(function (global, factory) {
	 true ? factory(exports) :
	undefined;
}(this, (function (exports) { 'use strict';

/* Polyfill service v3.13.0
 * For detailed credits and licence information see http://github.com/financial-times/polyfill-service
 *
 * - Array.prototype.fill, License: CC0 */

if (!('fill' in Array.prototype)) {
  Object.defineProperty(Array.prototype, 'fill', {
    configurable: true,
    value: function fill(value) {
      if (this === undefined || this === null) {
        throw new TypeError(this + ' is not an object');
      }

      var arrayLike = Object(this);

      var length = Math.max(Math.min(arrayLike.length, 9007199254740991), 0) || 0;

      var relativeStart = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;

      relativeStart = relativeStart < 0 ? Math.max(length + relativeStart, 0) : Math.min(relativeStart, length);

      var relativeEnd = 2 in arguments && arguments[2] !== undefined ? parseInt(Number(arguments[2]), 10) || 0 : length;

      relativeEnd = relativeEnd < 0 ? Math.max(length + arguments[2], 0) : Math.min(relativeEnd, length);

      while (relativeStart < relativeEnd) {
        arrayLike[relativeStart] = value;

        ++relativeStart;
      }

      return arrayLike;
    },
    writable: true
  });
}

Number.isFinite = Number.isFinite || function (value) {
  return typeof value === 'number' && isFinite(value);
};

Number.isInteger = Number.isInteger || function (val) {
  return typeof val === 'number' && isFinite(val) && Math.floor(val) === val;
};

Number.parseFloat = Number.parseFloat || parseFloat;

Number.isNaN = Number.isNaN || function (value) {
  return value !== value; // eslint-disable-line
};

Math.trunc = Math.trunc || function (x) {
  return x < 0 ? Math.ceil(x) : Math.floor(x);
};

function extend (target, source) {
  for (var key in source) {
    if (source.hasOwnProperty(key)) target[key] = source[key];
  }
}

function NumberUtil() {}
extend(NumberUtil.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return NumberUtil;
	}
});
NumberUtil.equalsWithTolerance = function (x1, x2, tolerance) {
	return Math.abs(x1 - x2) <= tolerance;
};

function IllegalArgumentException() {}

function Long(high, low) {
  this.low = low | 0;
  this.high = high | 0;
}

Long.toBinaryString = function (i) {
  var result = '';
  for (var mask = 0x80000000; mask > 0; mask >>>= 1) {
    result += (i.high & mask) === mask ? '1' : '0';
  }for (var mask = 0x80000000; mask > 0; mask >>>= 1) {
    result += (i.low & mask) === mask ? '1' : '0';
  }return result;
};

function Double() {}

Double.isNaN = function (n) {
	return Number.isNaN(n);
};
Double.isInfinite = function (n) {
	return !Number.isFinite(n);
};
Double.MAX_VALUE = Number.MAX_VALUE;

if (typeof Float64Array == 'function' && typeof Int32Array == 'function') {
	// Simple and fast conversion between double and long bits
	// using TypedArrays and ArrayViewBuffers.
	(function () {
		var EXP_BIT_MASK = 0x7ff00000;
		var SIGNIF_BIT_MASK = 0xFFFFF;
		var f64buf = new Float64Array(1);
		var i32buf = new Int32Array(f64buf.buffer);
		Double.doubleToLongBits = function (value) {
			f64buf[0] = value;
			var low = i32buf[0] | 0;
			var high = i32buf[1] | 0;
			// Check for NaN based on values of bit fields, maximum
			// exponent and nonzero significand.
			if ((high & EXP_BIT_MASK) === EXP_BIT_MASK && (high & SIGNIF_BIT_MASK) !== 0 && low !== 0) {
				low = 0 | 0;
				high = 0x7ff80000 | 0;
			}
			return new Long(high, low);
		};
		Double.longBitsToDouble = function (bits) {
			i32buf[0] = bits.low;
			i32buf[1] = bits.high;
			return f64buf[0];
		};
	})();
} else {
	// More complex and slower fallback implementation using 
	// math and the divide-by-two and multiply-by-two algorithms.
	(function () {
		var BIAS = 1023;
		var log2 = Math.log2;
		var floor = Math.floor;
		var pow = Math.pow;
		var MAX_REL_BITS_INTEGER = function () {
			for (var i = 53; i > 0; i--) {
				var bits = pow(2, i) - 1;
				if (floor(log2(bits)) + 1 === i) {
					return bits;
				}
			}
			return 0;
		}();
		Double.doubleToLongBits = function (value) {
			var x, y, f, bits, skip;
			var sign, exp, high, low;

			// Get the sign bit and absolute value.
			if (value < 0 || 1 / value === Number.NEGATIVE_INFINITY) {
				sign = 1 << 31;
				value = -value;
			} else {
				sign = 0;
			}

			// Handle some special values.
			if (value === 0) {
				// Handle zeros (+/-0).
				low = 0 | 0;
				high = sign; // exponent: 00..00, significand: 00..00
				return new Long(high, low);
			}

			if (value === Infinity) {
				// Handle infinity (only positive values for value possible).
				low = 0 | 0;
				high = sign | 0x7ff00000; // exponent: 11..11, significand: 00..00
				return new Long(high, low);
			}

			if (value !== value) {
				// Handle NaNs (boiled down to only one distinct NaN).
				low = 0 | 0;
				high = 0x7ff80000; // exponent: 11..11, significand: 10..00
				return new Long(high, low);
			}

			// Preinitialize variables, that are not neccessarily set by
			// the algorithm.
			bits = 0;
			low = 0 | 0;

			// Get the (always positive) integer part of value.
			x = floor(value);

			// Process the integer part if it's greater than 1. Zero requires
			// no bits at all, 1 represents the implicit (hidden) leading bit,
			// which must not be written as well.
			if (x > 1) {
				// If we can reliably determine the number of bits required for
				// the integer part,
				if (x <= MAX_REL_BITS_INTEGER) {
					// get the number of bits required to represent it minus 1
					bits = floor(log2(x)) /* + 1 - 1*/;
					// and simply copy/shift the integer bits into low and high.
					// That's much faster than the divide-by-two algorithm (saves
					// up to ~60%).
					// We always need to mask out the most significant bit, which
					// is the implicit (aka hidden) bit.
					if (bits <= 20) {
						// The simple case in which the integer fits into the
						// lower 20 bits of the high word is worth to be handled
						// separately (saves ~25%).
						low = 0 | 0;
						high = x << 20 - bits & 0xfffff;
					} else {
						// Here, the integer part is split into low and high.
						// Since its value may require more than 32 bits, we
						// cannot use bitwise operators (which implicitly cast
						// to Int32), but use arithmetic operators % and / to
						// get low and high parts. The uppper 20 bits go to high,
						// the remaining bits (in f) to low.
						f = bits - 20;
						// Like (1 << f) but safe with even more than 32 bits.
						y = pow(2, f);
						low = x % y << 32 - f;
						high = x / y & 0xfffff;
					}
				} else {
					// For greater values, we must use the much slower divide-by-two
					// algorithm. Bits are generated from right to left, that is from
					// least to most significant bit. For each bit, we left-shift both
					// low and high by one and carry bit #0 from high to #31 in low.
					// The next bit is then copied into bit #19 in high, the leftmost
					// bit of the double's significand.

					// Preserve x for later user, so work with f.
					f = x;
					low = 0 | 0;
					while (true) {
						y = f / 2;
						f = floor(y);
						if (f === 0) {
							// We just found the most signigicant (1-)bit, which
							// is the implicit bit and so, not stored in the double
							// value. So, it's time to leave the loop.
							break;
						}
						// Count this bit, shift low and carry bit #0 from high.
						bits++;
						low >>>= 1;
						low |= (high & 0x1) << 31;
						// Shift high.
						high >>>= 1;
						if (y !== f) {
							// Copy the new bit into bit #19 in high (only required if 1).
							high |= 0x80000;
						}
					}
				}
			}

			// Bias the exponent.
			exp = bits + BIAS;

			// If the integer part is zero, we've not yet seen the implicit
			// leading bit. Variable skip is later used while processing the 
			// fractional part (if any).
			skip = x === 0;

			// Get fraction only into x.
			x = value - x;

			// If some significand bits are still left to be filled and
			// the fractional part is not zero, convert the fraction using
			// the multiply-by-2 algorithm.
			if (bits < 52 && x !== 0) {

				// Initialize 'buffer' f, into which newly created bits get
				// shifted from right to left.
				f = 0;

				while (true) {
					y = x * 2;
					if (y >= 1) {
						// This is a new 1-bit. Add and count this bit, if not
						// prohibited by skip.
						x = y - 1;
						if (!skip) {
							f <<= 1;
							f |= 1;
							bits++;
						} else {
							// Otherwise, decrement the exponent and unset
							// skip, so that all following bits get written.
							exp--;
							skip = false;
						}
					} else {
						// This is a new 0-bit. Add and count this bit, if not
						// prohibited by skip.
						x = y;
						if (!skip) {
							f <<= 1;
							bits++;
						} else if (--exp === 0) {
							// Otherwise we've just decremented the exponent. If the
							// biased exponent is zero now (-1023), we process a
							// subnormal number, which has no impled leading 1-bit.
							// So, count this 0-bit and unset skip to write out
							// all the following bits.
							bits++;
							skip = false;
						}
					}
					if (bits === 20) {
						// When 20 bits have been created in total, we're done with
						// the high word. Copy the bits from 'buffer' f into high
						// and reset 'buffer' f. Following bits will end up in the
						// low word.
						high |= f;
						f = 0;
					} else if (bits === 52) {
						// When 52 bits have been created in total, we're done with
						// low word as well. Copy the bits from 'buffer' f into low
						// and exit the loop.
						low |= f;
						break;
					}
					if (y === 1) {
						// When y is exactly 1, there is no remainder and the process
						// is complete (the number is finite). Copy the bits from
						// 'buffer' f into either low or high and exit the loop.
						if (bits < 20) {
							high |= f << 20 - bits;
						} else if (bits < 52) {
							low |= f << 52 - bits;
						}
						break;
					}
				}
			}

			// Copy/shift the exponent and sign bits into the high word.
			high |= exp << 20;
			high |= sign;

			return new Long(high, low);
		};
		Double.longBitsToDouble = function (bits) {
			var x, sign, exp, fract;
			var high = bits.high;
			var low = bits.low;

			// Extract the sign.
			sign = high & 1 << 31 ? -1 : 1;

			// Extract the unbiased exponent.
			exp = ((high & 0x7ff00000) >> 20) - BIAS;

			// Calculate the fraction from left to right. Start
			// off with the 20 lower bits from the high word.
			fract = 0;
			x = 1 << 19;
			for (var i = 1; i <= 20; i++) {
				if (high & x) {
					fract += pow(2, -i);
				}
				x >>>= 1;
			}
			// Continue with all 32 bits from the low word.
			x = 1 << 31;
			for (var i = 21; i <= 52; i++) {
				if (low & x) {
					fract += pow(2, -i);
				}
				x >>>= 1;
			}

			// Handle special values.
			// Check for zero and subnormal values.
			if (exp === -BIAS) {
				if (fract === 0) {
					// +/-1.0 * 0.0 => +/-0.0
					return sign * 0;
				}
				exp = -1022;
			}
			// Check for +/-Infinity or NaN.
			else if (exp === BIAS + 1) {
					if (fract === 0) {
						// +/-1.0 / 0.0 => +/-Infinity
						return sign / 0;
					}
					return NaN;
				}
				// Nothing special? Seems to be a normal number.
				else {
						// Add the implicit leading bit (1*2^0).
						fract += 1;
					}

			return sign * fract * pow(2, exp);
		};
	})();
}

function Comparable() {}

function Clonable() {}

function Comparator() {}

function Serializable() {}

function RuntimeException(message) {
  this.name = 'RuntimeException';
  this.message = message;
  this.stack = new Error().stack;
  Error.call(this, message);
}

RuntimeException.prototype = Object.create(Error.prototype);
RuntimeException.prototype.constructor = Error;

function inherits (c, p) {
  c.prototype = Object.create(p.prototype);
  c.prototype.constructor = c;
}

function AssertionFailedException() {
	if (arguments.length === 0) {
		RuntimeException.call(this);
	} else if (arguments.length === 1) {
		var message = arguments[0];
		RuntimeException.call(this, message);
	}
}
inherits(AssertionFailedException, RuntimeException);
extend(AssertionFailedException.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return AssertionFailedException;
	}
});

function Assert() {}
extend(Assert.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Assert;
	}
});
Assert.shouldNeverReachHere = function () {
	if (arguments.length === 0) {
		Assert.shouldNeverReachHere(null);
	} else if (arguments.length === 1) {
		var message = arguments[0];
		throw new AssertionFailedException("Should never reach here" + (message !== null ? ": " + message : ""));
	}
};
Assert.isTrue = function () {
	if (arguments.length === 1) {
		var assertion = arguments[0];
		Assert.isTrue(assertion, null);
	} else if (arguments.length === 2) {
		var _assertion = arguments[0],
		    message = arguments[1];
		if (!_assertion) {
			if (message === null) {
				throw new AssertionFailedException();
			} else {
				throw new AssertionFailedException(message);
			}
		}
	}
};
Assert.equals = function () {
	if (arguments.length === 2) {
		var expectedValue = arguments[0],
		    actualValue = arguments[1];
		Assert.equals(expectedValue, actualValue, null);
	} else if (arguments.length === 3) {
		var _expectedValue = arguments[0],
		    _actualValue = arguments[1],
		    message = arguments[2];
		if (!_actualValue.equals(_expectedValue)) {
			throw new AssertionFailedException("Expected " + _expectedValue + " but encountered " + _actualValue + (message !== null ? ": " + message : ""));
		}
	}
};

function Coordinate() {
	this.x = null;
	this.y = null;
	this.z = null;
	if (arguments.length === 0) {
		Coordinate.call(this, 0.0, 0.0);
	} else if (arguments.length === 1) {
		var c = arguments[0];
		Coordinate.call(this, c.x, c.y, c.z);
	} else if (arguments.length === 2) {
		var x = arguments[0],
		    y = arguments[1];
		Coordinate.call(this, x, y, Coordinate.NULL_ORDINATE);
	} else if (arguments.length === 3) {
		var _x = arguments[0],
		    _y = arguments[1],
		    z = arguments[2];
		this.x = _x;
		this.y = _y;
		this.z = z;
	}
}
extend(Coordinate.prototype, {
	setOrdinate: function setOrdinate(ordinateIndex, value) {
		switch (ordinateIndex) {
			case Coordinate.X:
				this.x = value;
				break;
			case Coordinate.Y:
				this.y = value;
				break;
			case Coordinate.Z:
				this.z = value;
				break;
			default:
				throw new IllegalArgumentException("Invalid ordinate index: " + ordinateIndex);
		}
	},
	equals2D: function equals2D() {
		if (arguments.length === 1) {
			var other = arguments[0];
			if (this.x !== other.x) {
				return false;
			}
			if (this.y !== other.y) {
				return false;
			}
			return true;
		} else if (arguments.length === 2) {
			var c = arguments[0],
			    tolerance = arguments[1];
			if (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {
				return false;
			}
			if (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {
				return false;
			}
			return true;
		}
	},
	getOrdinate: function getOrdinate(ordinateIndex) {
		switch (ordinateIndex) {
			case Coordinate.X:
				return this.x;
			case Coordinate.Y:
				return this.y;
			case Coordinate.Z:
				return this.z;
		}
		throw new IllegalArgumentException("Invalid ordinate index: " + ordinateIndex);
	},
	equals3D: function equals3D(other) {
		return this.x === other.x && this.y === other.y && (this.z === other.z || Double.isNaN(this.z) && Double.isNaN(other.z));
	},
	equals: function equals(other) {
		if (!(other instanceof Coordinate)) {
			return false;
		}
		return this.equals2D(other);
	},
	equalInZ: function equalInZ(c, tolerance) {
		return NumberUtil.equalsWithTolerance(this.z, c.z, tolerance);
	},
	compareTo: function compareTo(o) {
		var other = o;
		if (this.x < other.x) return -1;
		if (this.x > other.x) return 1;
		if (this.y < other.y) return -1;
		if (this.y > other.y) return 1;
		return 0;
	},
	clone: function clone() {
		try {
			var coord = null;
			return coord;
		} catch (e) {
			if (e instanceof CloneNotSupportedException) {
				Assert.shouldNeverReachHere("this shouldn't happen because this class is Cloneable");
				return null;
			} else throw e;
		} finally {}
	},
	copy: function copy() {
		return new Coordinate(this);
	},
	toString: function toString() {
		return "(" + this.x + ", " + this.y + ", " + this.z + ")";
	},
	distance3D: function distance3D(c) {
		var dx = this.x - c.x;
		var dy = this.y - c.y;
		var dz = this.z - c.z;
		return Math.sqrt(dx * dx + dy * dy + dz * dz);
	},
	distance: function distance(c) {
		var dx = this.x - c.x;
		var dy = this.y - c.y;
		return Math.sqrt(dx * dx + dy * dy);
	},
	hashCode: function hashCode() {
		var result = 17;
		result = 37 * result + Coordinate.hashCode(this.x);
		result = 37 * result + Coordinate.hashCode(this.y);
		return result;
	},
	setCoordinate: function setCoordinate(other) {
		this.x = other.x;
		this.y = other.y;
		this.z = other.z;
	},
	interfaces_: function interfaces_() {
		return [Comparable, Clonable, Serializable];
	},
	getClass: function getClass() {
		return Coordinate;
	}
});
Coordinate.hashCode = function () {
	if (arguments.length === 1 && typeof arguments[0] === "number") {
		var x = arguments[0];
		var f = Double.doubleToLongBits(x);
		return Math.trunc(f ^ f >>> 32);
	}
};
function DimensionalComparator() {
	this._dimensionsToTest = 2;
	if (arguments.length === 0) {
		DimensionalComparator.call(this, 2);
	} else if (arguments.length === 1) {
		var dimensionsToTest = arguments[0];
		if (dimensionsToTest !== 2 && dimensionsToTest !== 3) throw new IllegalArgumentException("only 2 or 3 dimensions may be specified");
		this._dimensionsToTest = dimensionsToTest;
	}
}
extend(DimensionalComparator.prototype, {
	compare: function compare(o1, o2) {
		var c1 = o1;
		var c2 = o2;
		var compX = DimensionalComparator.compare(c1.x, c2.x);
		if (compX !== 0) return compX;
		var compY = DimensionalComparator.compare(c1.y, c2.y);
		if (compY !== 0) return compY;
		if (this._dimensionsToTest <= 2) return 0;
		var compZ = DimensionalComparator.compare(c1.z, c2.z);
		return compZ;
	},
	interfaces_: function interfaces_() {
		return [Comparator];
	},
	getClass: function getClass() {
		return DimensionalComparator;
	}
});
DimensionalComparator.compare = function (a, b) {
	if (a < b) return -1;
	if (a > b) return 1;
	if (Double.isNaN(a)) {
		if (Double.isNaN(b)) return 0;
		return -1;
	}
	if (Double.isNaN(b)) return 1;
	return 0;
};
Coordinate.DimensionalComparator = DimensionalComparator;
Coordinate.serialVersionUID = 6683108902428366910;
Coordinate.NULL_ORDINATE = Double.NaN;
Coordinate.X = 0;
Coordinate.Y = 1;
Coordinate.Z = 2;

function hasInterface (o, i) {
  return o.interfaces_ && o.interfaces_().indexOf(i) > -1;
}

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html
 * @constructor
 * @private
 */
function Iterator() {}

/**
 * Returns true if the iteration has more elements.
 * @return {boolean}
 */
Iterator.prototype.hasNext = function () {};

/**
 * Returns the next element in the iteration.
 * @return {Object}
 */
Iterator.prototype.next = function () {};

/**
 * Removes from the underlying collection the last element returned by the
 * iterator (optional operation).
 */
Iterator.prototype.remove = function () {};

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html
 *
 * @constructor
 * @private
 */
function Collection() {}

/**
 * Ensures that this collection contains the specified element (optional
 * operation).
 * @param {Object} e
 * @return {boolean}
 */
Collection.prototype.add = function () {};

/**
 * Appends all of the elements in the specified collection to the end of this
 * list, in the order that they are returned by the specified collection's
 * iterator (optional operation).
 * @param {javascript.util.Collection} c
 * @return {boolean}
 */
Collection.prototype.addAll = function () {};

/**
 * Returns true if this collection contains no elements.
 * @return {boolean}
 */
Collection.prototype.isEmpty = function () {};

/**
 * Returns an iterator over the elements in this collection.
 * @return {javascript.util.Iterator}
 */
Collection.prototype.iterator = function () {};

/**
 * Returns an iterator over the elements in this collection.
 * @return {number}
 */
Collection.prototype.size = function () {};

/**
 * Returns an array containing all of the elements in this collection.
 * @return {Array}
 */
Collection.prototype.toArray = function () {};

/**
 * Removes a single instance of the specified element from this collection if it
 * is present. (optional)
 * @param {Object} e
 * @return {boolean}
 */
Collection.prototype.remove = function () {};

/**
 * @param {string=} message Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
function IndexOutOfBoundsException$1(message) {
  this.message = message || '';
}
IndexOutOfBoundsException$1.prototype = new Error();

/**
 * @type {string}
 */
IndexOutOfBoundsException$1.prototype.name = 'IndexOutOfBoundsException';

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html
 *
 * @extends {javascript.util.Collection}
 * @constructor
 * @private
 */
function List() {}
List.prototype = Object.create(Collection.prototype);
List.prototype.constructor = List;

/**
 * Returns the element at the specified position in this list.
 * @param {number} index
 * @return {Object}
 */
List.prototype.get = function () {};

/**
 * Replaces the element at the specified position in this list with the
 * specified element (optional operation).
 * @param {number} index
 * @param {Object} e
 * @return {Object}
 */
List.prototype.set = function () {};

/**
 * Returns true if this collection contains no elements.
 * @return {boolean}
 */
List.prototype.isEmpty = function () {};

/**
 * @param {string=} message Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
function NoSuchElementException(message) {
  this.message = message || '';
}
NoSuchElementException.prototype = new Error();

/**
 * @type {string}
 */
NoSuchElementException.prototype.name = 'NoSuchElementException';

/**
 * @param {string=} message Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
function OperationNotSupported(message) {
  this.message = message || '';
}
OperationNotSupported.prototype = new Error();

/**
 * @type {string}
 */
OperationNotSupported.prototype.name = 'OperationNotSupported';

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html
 *
 * @extends List
 * @private
 */
function ArrayList() {
  /**
   * @type {Array}
   * @private
  */
  this.array_ = [];

  if (arguments[0] instanceof Collection) {
    this.addAll(arguments[0]);
  }
}
ArrayList.prototype = Object.create(List.prototype);
ArrayList.prototype.constructor = ArrayList;

ArrayList.prototype.ensureCapacity = function () {};
ArrayList.prototype.interfaces_ = function () {
  return [List, Collection];
};

/**
 * @override
 */
ArrayList.prototype.add = function (e) {
  if (arguments.length === 1) {
    this.array_.push(e);
  } else {
    this.array_.splice(arguments[0], 0, arguments[1]);
  }
  return true;
};

ArrayList.prototype.clear = function () {
  this.array_ = [];
};

/**
 * @override
 */
ArrayList.prototype.addAll = function (c) {
  for (var i = c.iterator(); i.hasNext();) {
    this.add(i.next());
  }
  return true;
};

/**
 * @override
 */
ArrayList.prototype.set = function (index, element) {
  var oldElement = this.array_[index];
  this.array_[index] = element;
  return oldElement;
};

/**
 * @override
 */
ArrayList.prototype.iterator = function () {
  return new Iterator_(this);
};

/**
 * @override
 */
ArrayList.prototype.get = function (index) {
  if (index < 0 || index >= this.size()) {
    throw new IndexOutOfBoundsException$1();
  }

  return this.array_[index];
};

/**
 * @override
 */
ArrayList.prototype.isEmpty = function () {
  return this.array_.length === 0;
};

/**
 * @override
 */
ArrayList.prototype.size = function () {
  return this.array_.length;
};

/**
 * @override
 */
ArrayList.prototype.toArray = function () {
  var array = [];

  for (var i = 0, len = this.array_.length; i < len; i++) {
    array.push(this.array_[i]);
  }

  return array;
};

/**
 * @override
 */
ArrayList.prototype.remove = function (o) {
  var found = false;

  for (var i = 0, len = this.array_.length; i < len; i++) {
    if (this.array_[i] === o) {
      this.array_.splice(i, 1);
      found = true;
      break;
    }
  }

  return found;
};

/**
 * @extends {Iterator}
 * @param {ArrayList} arrayList
 * @constructor
 * @private
 */
var Iterator_ = function Iterator_(arrayList) {
  /**
   * @type {ArrayList}
   * @private
  */
  this.arrayList_ = arrayList;
  /**
   * @type {number}
   * @private
  */
  this.position_ = 0;
};

/**
 * @override
 */
Iterator_.prototype.next = function () {
  if (this.position_ === this.arrayList_.size()) {
    throw new NoSuchElementException();
  }
  return this.arrayList_.get(this.position_++);
};

/**
 * @override
 */
Iterator_.prototype.hasNext = function () {
  if (this.position_ < this.arrayList_.size()) {
    return true;
  } else {
    return false;
  }
};

/**
 * TODO: should be in ListIterator
 * @override
 */
Iterator_.prototype.set = function (element) {
  return this.arrayList_.set(this.position_ - 1, element);
};

/**
 * @override
 */
Iterator_.prototype.remove = function () {
  this.arrayList_.remove(this.arrayList_.get(this.position_));
};

function CoordinateList() {
	ArrayList.apply(this);
	if (arguments.length === 0) {} else if (arguments.length === 1) {
		var coord = arguments[0];
		this.ensureCapacity(coord.length);
		this.add(coord, true);
	} else if (arguments.length === 2) {
		var _coord = arguments[0],
		    allowRepeated = arguments[1];
		this.ensureCapacity(_coord.length);
		this.add(_coord, allowRepeated);
	}
}
inherits(CoordinateList, ArrayList);
extend(CoordinateList.prototype, {
	getCoordinate: function getCoordinate(i) {
		return this.get(i);
	},
	addAll: function addAll() {
		if (arguments.length === 2 && typeof arguments[1] === "boolean" && hasInterface(arguments[0], Collection)) {
			var coll = arguments[0],
			    allowRepeated = arguments[1];
			var isChanged = false;
			for (var i = coll.iterator(); i.hasNext();) {
				this.add(i.next(), allowRepeated);
				isChanged = true;
			}
			return isChanged;
		} else return ArrayList.prototype.addAll.apply(this, arguments);
	},
	clone: function clone() {
		var clone = ArrayList.prototype.clone.call(this);
		for (var i = 0; i < this.size(); i++) {
			clone.add(i, this.get(i).clone());
		}
		return clone;
	},
	toCoordinateArray: function toCoordinateArray() {
		return this.toArray(CoordinateList.coordArrayType);
	},
	add: function add() {
		if (arguments.length === 1) {
			var coord = arguments[0];
			ArrayList.prototype.add.call(this, coord);
		} else if (arguments.length === 2) {
			if (arguments[0] instanceof Array && typeof arguments[1] === "boolean") {
				var _coord2 = arguments[0],
				    allowRepeated = arguments[1];
				this.add(_coord2, allowRepeated, true);
				return true;
			} else if (arguments[0] instanceof Coordinate && typeof arguments[1] === "boolean") {
				var _coord3 = arguments[0],
				    _allowRepeated = arguments[1];
				if (!_allowRepeated) {
					if (this.size() >= 1) {
						var last = this.get(this.size() - 1);
						if (last.equals2D(_coord3)) return null;
					}
				}
				ArrayList.prototype.add.call(this, _coord3);
			} else if (arguments[0] instanceof Object && typeof arguments[1] === "boolean") {
				var obj = arguments[0],
				    _allowRepeated2 = arguments[1];
				this.add(obj, _allowRepeated2);
				return true;
			}
		} else if (arguments.length === 3) {
			if (typeof arguments[2] === "boolean" && arguments[0] instanceof Array && typeof arguments[1] === "boolean") {
				var _coord4 = arguments[0],
				    _allowRepeated3 = arguments[1],
				    direction = arguments[2];
				if (direction) {
					for (var i = 0; i < _coord4.length; i++) {
						this.add(_coord4[i], _allowRepeated3);
					}
				} else {
					for (var i = _coord4.length - 1; i >= 0; i--) {
						this.add(_coord4[i], _allowRepeated3);
					}
				}
				return true;
			} else if (typeof arguments[2] === "boolean" && Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate) {
				var _i = arguments[0],
				    _coord5 = arguments[1],
				    _allowRepeated4 = arguments[2];
				if (!_allowRepeated4) {
					var size = this.size();
					if (size > 0) {
						if (_i > 0) {
							var prev = this.get(_i - 1);
							if (prev.equals2D(_coord5)) return null;
						}
						if (_i < size) {
							var next = this.get(_i);
							if (next.equals2D(_coord5)) return null;
						}
					}
				}
				ArrayList.prototype.add.call(this, _i, _coord5);
			}
		} else if (arguments.length === 4) {
			var _coord6 = arguments[0],
			    _allowRepeated5 = arguments[1],
			    start = arguments[2],
			    end = arguments[3];
			var inc = 1;
			if (start > end) inc = -1;
			for (var i = start; i !== end; i += inc) {
				this.add(_coord6[i], _allowRepeated5);
			}
			return true;
		}
	},
	closeRing: function closeRing() {
		if (this.size() > 0) this.add(new Coordinate(this.get(0)), false);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return CoordinateList;
	}
});
CoordinateList.coordArrayType = new Array(0).fill(null);

function Envelope() {
	this._minx = null;
	this._maxx = null;
	this._miny = null;
	this._maxy = null;
	if (arguments.length === 0) {
		this.init();
	} else if (arguments.length === 1) {
		if (arguments[0] instanceof Coordinate) {
			var p = arguments[0];
			this.init(p.x, p.x, p.y, p.y);
		} else if (arguments[0] instanceof Envelope) {
			var env = arguments[0];
			this.init(env);
		}
	} else if (arguments.length === 2) {
		var p1 = arguments[0],
		    p2 = arguments[1];
		this.init(p1.x, p2.x, p1.y, p2.y);
	} else if (arguments.length === 4) {
		var x1 = arguments[0],
		    x2 = arguments[1],
		    y1 = arguments[2],
		    y2 = arguments[3];
		this.init(x1, x2, y1, y2);
	}
}
extend(Envelope.prototype, {
	getArea: function getArea() {
		return this.getWidth() * this.getHeight();
	},
	equals: function equals(other) {
		if (!(other instanceof Envelope)) {
			return false;
		}
		var otherEnvelope = other;
		if (this.isNull()) {
			return otherEnvelope.isNull();
		}
		return this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY();
	},
	intersection: function intersection(env) {
		if (this.isNull() || env.isNull() || !this.intersects(env)) return new Envelope();
		var intMinX = this._minx > env._minx ? this._minx : env._minx;
		var intMinY = this._miny > env._miny ? this._miny : env._miny;
		var intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;
		var intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;
		return new Envelope(intMinX, intMaxX, intMinY, intMaxY);
	},
	isNull: function isNull() {
		return this._maxx < this._minx;
	},
	getMaxX: function getMaxX() {
		return this._maxx;
	},
	covers: function covers() {
		if (arguments.length === 1) {
			if (arguments[0] instanceof Coordinate) {
				var p = arguments[0];
				return this.covers(p.x, p.y);
			} else if (arguments[0] instanceof Envelope) {
				var other = arguments[0];
				if (this.isNull() || other.isNull()) {
					return false;
				}
				return other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy;
			}
		} else if (arguments.length === 2) {
			var x = arguments[0],
			    y = arguments[1];
			if (this.isNull()) return false;
			return x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy;
		}
	},
	intersects: function intersects() {
		if (arguments.length === 1) {
			if (arguments[0] instanceof Envelope) {
				var other = arguments[0];
				if (this.isNull() || other.isNull()) {
					return false;
				}
				return !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny);
			} else if (arguments[0] instanceof Coordinate) {
				var p = arguments[0];
				return this.intersects(p.x, p.y);
			}
		} else if (arguments.length === 2) {
			if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
				var a = arguments[0],
				    b = arguments[1];
				if (this.isNull()) {
					return false;
				}
				var envminx = a.x < b.x ? a.x : b.x;
				if (envminx > this._maxx) return false;
				var envmaxx = a.x > b.x ? a.x : b.x;
				if (envmaxx < this._minx) return false;
				var envminy = a.y < b.y ? a.y : b.y;
				if (envminy > this._maxy) return false;
				var envmaxy = a.y > b.y ? a.y : b.y;
				if (envmaxy < this._miny) return false;
				return true;
			} else if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
				var x = arguments[0],
				    y = arguments[1];
				if (this.isNull()) return false;
				return !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny);
			}
		}
	},
	getMinY: function getMinY() {
		return this._miny;
	},
	getMinX: function getMinX() {
		return this._minx;
	},
	expandToInclude: function expandToInclude() {
		if (arguments.length === 1) {
			if (arguments[0] instanceof Coordinate) {
				var p = arguments[0];
				this.expandToInclude(p.x, p.y);
			} else if (arguments[0] instanceof Envelope) {
				var other = arguments[0];
				if (other.isNull()) {
					return null;
				}
				if (this.isNull()) {
					this._minx = other.getMinX();
					this._maxx = other.getMaxX();
					this._miny = other.getMinY();
					this._maxy = other.getMaxY();
				} else {
					if (other._minx < this._minx) {
						this._minx = other._minx;
					}
					if (other._maxx > this._maxx) {
						this._maxx = other._maxx;
					}
					if (other._miny < this._miny) {
						this._miny = other._miny;
					}
					if (other._maxy > this._maxy) {
						this._maxy = other._maxy;
					}
				}
			}
		} else if (arguments.length === 2) {
			var x = arguments[0],
			    y = arguments[1];
			if (this.isNull()) {
				this._minx = x;
				this._maxx = x;
				this._miny = y;
				this._maxy = y;
			} else {
				if (x < this._minx) {
					this._minx = x;
				}
				if (x > this._maxx) {
					this._maxx = x;
				}
				if (y < this._miny) {
					this._miny = y;
				}
				if (y > this._maxy) {
					this._maxy = y;
				}
			}
		}
	},
	minExtent: function minExtent() {
		if (this.isNull()) return 0.0;
		var w = this.getWidth();
		var h = this.getHeight();
		if (w < h) return w;
		return h;
	},
	getWidth: function getWidth() {
		if (this.isNull()) {
			return 0;
		}
		return this._maxx - this._minx;
	},
	compareTo: function compareTo(o) {
		var env = o;
		if (this.isNull()) {
			if (env.isNull()) return 0;
			return -1;
		} else {
			if (env.isNull()) return 1;
		}
		if (this._minx < env._minx) return -1;
		if (this._minx > env._minx) return 1;
		if (this._miny < env._miny) return -1;
		if (this._miny > env._miny) return 1;
		if (this._maxx < env._maxx) return -1;
		if (this._maxx > env._maxx) return 1;
		if (this._maxy < env._maxy) return -1;
		if (this._maxy > env._maxy) return 1;
		return 0;
	},
	translate: function translate(transX, transY) {
		if (this.isNull()) {
			return null;
		}
		this.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);
	},
	toString: function toString() {
		return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
	},
	setToNull: function setToNull() {
		this._minx = 0;
		this._maxx = -1;
		this._miny = 0;
		this._maxy = -1;
	},
	getHeight: function getHeight() {
		if (this.isNull()) {
			return 0;
		}
		return this._maxy - this._miny;
	},
	maxExtent: function maxExtent() {
		if (this.isNull()) return 0.0;
		var w = this.getWidth();
		var h = this.getHeight();
		if (w > h) return w;
		return h;
	},
	expandBy: function expandBy() {
		if (arguments.length === 1) {
			var distance = arguments[0];
			this.expandBy(distance, distance);
		} else if (arguments.length === 2) {
			var deltaX = arguments[0],
			    deltaY = arguments[1];
			if (this.isNull()) return null;
			this._minx -= deltaX;
			this._maxx += deltaX;
			this._miny -= deltaY;
			this._maxy += deltaY;
			if (this._minx > this._maxx || this._miny > this._maxy) this.setToNull();
		}
	},
	contains: function contains() {
		if (arguments.length === 1) {
			if (arguments[0] instanceof Envelope) {
				var other = arguments[0];
				return this.covers(other);
			} else if (arguments[0] instanceof Coordinate) {
				var p = arguments[0];
				return this.covers(p);
			}
		} else if (arguments.length === 2) {
			var x = arguments[0],
			    y = arguments[1];
			return this.covers(x, y);
		}
	},
	centre: function centre() {
		if (this.isNull()) return null;
		return new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0);
	},
	init: function init() {
		if (arguments.length === 0) {
			this.setToNull();
		} else if (arguments.length === 1) {
			if (arguments[0] instanceof Coordinate) {
				var p = arguments[0];
				this.init(p.x, p.x, p.y, p.y);
			} else if (arguments[0] instanceof Envelope) {
				var env = arguments[0];
				this._minx = env._minx;
				this._maxx = env._maxx;
				this._miny = env._miny;
				this._maxy = env._maxy;
			}
		} else if (arguments.length === 2) {
			var p1 = arguments[0],
			    p2 = arguments[1];
			this.init(p1.x, p2.x, p1.y, p2.y);
		} else if (arguments.length === 4) {
			var x1 = arguments[0],
			    x2 = arguments[1],
			    y1 = arguments[2],
			    y2 = arguments[3];
			if (x1 < x2) {
				this._minx = x1;
				this._maxx = x2;
			} else {
				this._minx = x2;
				this._maxx = x1;
			}
			if (y1 < y2) {
				this._miny = y1;
				this._maxy = y2;
			} else {
				this._miny = y2;
				this._maxy = y1;
			}
		}
	},
	getMaxY: function getMaxY() {
		return this._maxy;
	},
	distance: function distance(env) {
		if (this.intersects(env)) return 0;
		var dx = 0.0;
		if (this._maxx < env._minx) dx = env._minx - this._maxx;else if (this._minx > env._maxx) dx = this._minx - env._maxx;
		var dy = 0.0;
		if (this._maxy < env._miny) dy = env._miny - this._maxy;else if (this._miny > env._maxy) dy = this._miny - env._maxy;
		if (dx === 0.0) return dy;
		if (dy === 0.0) return dx;
		return Math.sqrt(dx * dx + dy * dy);
	},
	hashCode: function hashCode() {
		var result = 17;
		result = 37 * result + Coordinate.hashCode(this._minx);
		result = 37 * result + Coordinate.hashCode(this._maxx);
		result = 37 * result + Coordinate.hashCode(this._miny);
		result = 37 * result + Coordinate.hashCode(this._maxy);
		return result;
	},
	interfaces_: function interfaces_() {
		return [Comparable, Serializable];
	},
	getClass: function getClass() {
		return Envelope;
	}
});
Envelope.intersects = function () {
	if (arguments.length === 3) {
		var p1 = arguments[0],
		    p2 = arguments[1],
		    q = arguments[2];
		if (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y)) {
			return true;
		}
		return false;
	} else if (arguments.length === 4) {
		var _p = arguments[0],
		    _p2 = arguments[1],
		    q1 = arguments[2],
		    q2 = arguments[3];
		var minq = Math.min(q1.x, q2.x);
		var maxq = Math.max(q1.x, q2.x);
		var minp = Math.min(_p.x, _p2.x);
		var maxp = Math.max(_p.x, _p2.x);
		if (minp > maxq) return false;
		if (maxp < minq) return false;
		minq = Math.min(q1.y, q2.y);
		maxq = Math.max(q1.y, q2.y);
		minp = Math.min(_p.y, _p2.y);
		maxp = Math.max(_p.y, _p2.y);
		if (minp > maxq) return false;
		if (maxp < minq) return false;
		return true;
	}
};
Envelope.serialVersionUID = 5873921885273102420;

function Exception() {}

function NotRepresentableException() {
	Exception.call(this, "Projective point not representable on the Cartesian plane.");
}
inherits(NotRepresentableException, Exception);
extend(NotRepresentableException.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return NotRepresentableException;
	}
});

function StringBuffer(str) {
  this.str = str;
}

StringBuffer.prototype.append = function (e) {
  this.str += e;
};

StringBuffer.prototype.setCharAt = function (i, c) {
  this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);
};

StringBuffer.prototype.toString = function (e) {
  return this.str;
};

function Integer(value) {
  this.value = value;
}

Integer.prototype.intValue = function () {
  return this.value;
};
Integer.prototype.compareTo = function (o) {
  if (this.value < o) return -1;
  if (this.value > o) return 1;
  return 0;
};

Integer.isNaN = function (n) {
  return Number.isNaN(n);
};

function Character() {}
Character.isWhitespace = function (c) {
  return c <= 32 && c >= 0 || c == 127;
};
Character.toUpperCase = function (c) {
  return c.toUpperCase();
};

function DD() {
	this._hi = 0.0;
	this._lo = 0.0;
	if (arguments.length === 0) {
		this.init(0.0);
	} else if (arguments.length === 1) {
		if (typeof arguments[0] === "number") {
			var x = arguments[0];
			this.init(x);
		} else if (arguments[0] instanceof DD) {
			var dd = arguments[0];
			this.init(dd);
		} else if (typeof arguments[0] === "string") {
			var str = arguments[0];
			DD.call(this, DD.parse(str));
		}
	} else if (arguments.length === 2) {
		var hi = arguments[0],
		    lo = arguments[1];
		this.init(hi, lo);
	}
}
extend(DD.prototype, {
	le: function le(y) {
		return this._hi < y._hi || this._hi === y._hi && this._lo <= y._lo;
	},
	extractSignificantDigits: function extractSignificantDigits(insertDecimalPoint, magnitude) {
		var y = this.abs();
		var mag = DD.magnitude(y._hi);
		var scale = DD.TEN.pow(mag);
		y = y.divide(scale);
		if (y.gt(DD.TEN)) {
			y = y.divide(DD.TEN);
			mag += 1;
		} else if (y.lt(DD.ONE)) {
			y = y.multiply(DD.TEN);
			mag -= 1;
		}
		var decimalPointPos = mag + 1;
		var buf = new StringBuffer();
		var numDigits = DD.MAX_PRINT_DIGITS - 1;
		for (var i = 0; i <= numDigits; i++) {
			if (insertDecimalPoint && i === decimalPointPos) {
				buf.append('.');
			}
			var digit = Math.trunc(y._hi);
			if (digit < 0) {
				break;
			}
			var rebiasBy10 = false;
			var digitChar = 0;
			if (digit > 9) {
				rebiasBy10 = true;
				digitChar = '9';
			} else {
				digitChar = '0' + digit;
			}
			buf.append(digitChar);
			y = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);
			if (rebiasBy10) y.selfAdd(DD.TEN);
			var continueExtractingDigits = true;
			var remMag = DD.magnitude(y._hi);
			if (remMag < 0 && Math.abs(remMag) >= numDigits - i) continueExtractingDigits = false;
			if (!continueExtractingDigits) break;
		}
		magnitude[0] = mag;
		return buf.toString();
	},
	sqr: function sqr() {
		return this.multiply(this);
	},
	doubleValue: function doubleValue() {
		return this._hi + this._lo;
	},
	subtract: function subtract() {
		if (arguments[0] instanceof DD) {
			var y = arguments[0];
			return this.add(y.negate());
		} else if (typeof arguments[0] === "number") {
			var _y = arguments[0];
			return this.add(-_y);
		}
	},
	equals: function equals() {
		if (arguments.length === 1 && arguments[0] instanceof DD) {
			var y = arguments[0];
			return this._hi === y._hi && this._lo === y._lo;
		}
	},
	isZero: function isZero() {
		return this._hi === 0.0 && this._lo === 0.0;
	},
	selfSubtract: function selfSubtract() {
		if (arguments[0] instanceof DD) {
			var y = arguments[0];
			if (this.isNaN()) return this;
			return this.selfAdd(-y._hi, -y._lo);
		} else if (typeof arguments[0] === "number") {
			var _y2 = arguments[0];
			if (this.isNaN()) return this;
			return this.selfAdd(-_y2, 0.0);
		}
	},
	getSpecialNumberString: function getSpecialNumberString() {
		if (this.isZero()) return "0.0";
		if (this.isNaN()) return "NaN ";
		return null;
	},
	min: function min(x) {
		if (this.le(x)) {
			return this;
		} else {
			return x;
		}
	},
	selfDivide: function selfDivide() {
		if (arguments.length === 1) {
			if (arguments[0] instanceof DD) {
				var y = arguments[0];
				return this.selfDivide(y._hi, y._lo);
			} else if (typeof arguments[0] === "number") {
				var _y3 = arguments[0];
				return this.selfDivide(_y3, 0.0);
			}
		} else if (arguments.length === 2) {
			var yhi = arguments[0],
			    ylo = arguments[1];
			var hc = null,
			    tc = null,
			    hy = null,
			    ty = null,
			    C = null,
			    c = null,
			    U = null,
			    u = null;
			C = this._hi / yhi;
			c = DD.SPLIT * C;
			hc = c - C;
			u = DD.SPLIT * yhi;
			hc = c - hc;
			tc = C - hc;
			hy = u - yhi;
			U = C * yhi;
			hy = u - hy;
			ty = yhi - hy;
			u = hc * hy - U + hc * ty + tc * hy + tc * ty;
			c = (this._hi - U - u + this._lo - C * ylo) / yhi;
			u = C + c;
			this._hi = u;
			this._lo = C - u + c;
			return this;
		}
	},
	dump: function dump() {
		return "DD<" + this._hi + ", " + this._lo + ">";
	},
	divide: function divide() {
		if (arguments[0] instanceof DD) {
			var y = arguments[0];
			var hc = null,
			    tc = null,
			    hy = null,
			    ty = null,
			    C = null,
			    c = null,
			    U = null,
			    u = null;
			C = this._hi / y._hi;
			c = DD.SPLIT * C;
			hc = c - C;
			u = DD.SPLIT * y._hi;
			hc = c - hc;
			tc = C - hc;
			hy = u - y._hi;
			U = C * y._hi;
			hy = u - hy;
			ty = y._hi - hy;
			u = hc * hy - U + hc * ty + tc * hy + tc * ty;
			c = (this._hi - U - u + this._lo - C * y._lo) / y._hi;
			u = C + c;
			var zhi = u;
			var zlo = C - u + c;
			return new DD(zhi, zlo);
		} else if (typeof arguments[0] === "number") {
			var _y4 = arguments[0];
			if (Double.isNaN(_y4)) return DD.createNaN();
			return DD.copy(this).selfDivide(_y4, 0.0);
		}
	},
	ge: function ge(y) {
		return this._hi > y._hi || this._hi === y._hi && this._lo >= y._lo;
	},
	pow: function pow(exp) {
		if (exp === 0.0) return DD.valueOf(1.0);
		var r = new DD(this);
		var s = DD.valueOf(1.0);
		var n = Math.abs(exp);
		if (n > 1) {
			while (n > 0) {
				if (n % 2 === 1) {
					s.selfMultiply(r);
				}
				n /= 2;
				if (n > 0) r = r.sqr();
			}
		} else {
			s = r;
		}
		if (exp < 0) return s.reciprocal();
		return s;
	},
	ceil: function ceil() {
		if (this.isNaN()) return DD.NaN;
		var fhi = Math.ceil(this._hi);
		var flo = 0.0;
		if (fhi === this._hi) {
			flo = Math.ceil(this._lo);
		}
		return new DD(fhi, flo);
	},
	compareTo: function compareTo(o) {
		var other = o;
		if (this._hi < other._hi) return -1;
		if (this._hi > other._hi) return 1;
		if (this._lo < other._lo) return -1;
		if (this._lo > other._lo) return 1;
		return 0;
	},
	rint: function rint() {
		if (this.isNaN()) return this;
		var plus5 = this.add(0.5);
		return plus5.floor();
	},
	setValue: function setValue() {
		if (arguments[0] instanceof DD) {
			var value = arguments[0];
			this.init(value);
			return this;
		} else if (typeof arguments[0] === "number") {
			var _value = arguments[0];
			this.init(_value);
			return this;
		}
	},
	max: function max(x) {
		if (this.ge(x)) {
			return this;
		} else {
			return x;
		}
	},
	sqrt: function sqrt() {
		if (this.isZero()) return DD.valueOf(0.0);
		if (this.isNegative()) {
			return DD.NaN;
		}
		var x = 1.0 / Math.sqrt(this._hi);
		var ax = this._hi * x;
		var axdd = DD.valueOf(ax);
		var diffSq = this.subtract(axdd.sqr());
		var d2 = diffSq._hi * (x * 0.5);
		return axdd.add(d2);
	},
	selfAdd: function selfAdd() {
		if (arguments.length === 1) {
			if (arguments[0] instanceof DD) {
				var y = arguments[0];
				return this.selfAdd(y._hi, y._lo);
			} else if (typeof arguments[0] === "number") {
				var _y5 = arguments[0];
				var H = null,
				    h = null,
				    S = null,
				    s = null,
				    e = null,
				    f = null;
				S = this._hi + _y5;
				e = S - this._hi;
				s = S - e;
				s = _y5 - e + (this._hi - s);
				f = s + this._lo;
				H = S + f;
				h = f + (S - H);
				this._hi = H + h;
				this._lo = h + (H - this._hi);
				return this;
			}
		} else if (arguments.length === 2) {
			var yhi = arguments[0],
			    ylo = arguments[1];
			var H = null,
			    h = null,
			    T = null,
			    t = null,
			    S = null,
			    s = null,
			    e = null,
			    f = null;
			S = this._hi + yhi;
			T = this._lo + ylo;
			e = S - this._hi;
			f = T - this._lo;
			s = S - e;
			t = T - f;
			s = yhi - e + (this._hi - s);
			t = ylo - f + (this._lo - t);
			e = s + T;
			H = S + e;
			h = e + (S - H);
			e = t + h;
			var zhi = H + e;
			var zlo = e + (H - zhi);
			this._hi = zhi;
			this._lo = zlo;
			return this;
		}
	},
	selfMultiply: function selfMultiply() {
		if (arguments.length === 1) {
			if (arguments[0] instanceof DD) {
				var y = arguments[0];
				return this.selfMultiply(y._hi, y._lo);
			} else if (typeof arguments[0] === "number") {
				var _y6 = arguments[0];
				return this.selfMultiply(_y6, 0.0);
			}
		} else if (arguments.length === 2) {
			var yhi = arguments[0],
			    ylo = arguments[1];
			var hx = null,
			    tx = null,
			    hy = null,
			    ty = null,
			    C = null,
			    c = null;
			C = DD.SPLIT * this._hi;
			hx = C - this._hi;
			c = DD.SPLIT * yhi;
			hx = C - hx;
			tx = this._hi - hx;
			hy = c - yhi;
			C = this._hi * yhi;
			hy = c - hy;
			ty = yhi - hy;
			c = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);
			var zhi = C + c;
			hx = C - zhi;
			var zlo = c + hx;
			this._hi = zhi;
			this._lo = zlo;
			return this;
		}
	},
	selfSqr: function selfSqr() {
		return this.selfMultiply(this);
	},
	floor: function floor() {
		if (this.isNaN()) return DD.NaN;
		var fhi = Math.floor(this._hi);
		var flo = 0.0;
		if (fhi === this._hi) {
			flo = Math.floor(this._lo);
		}
		return new DD(fhi, flo);
	},
	negate: function negate() {
		if (this.isNaN()) return this;
		return new DD(-this._hi, -this._lo);
	},
	clone: function clone() {
		try {
			return null;
		} catch (ex) {
			if (ex instanceof CloneNotSupportedException) {
				return null;
			} else throw ex;
		} finally {}
	},
	multiply: function multiply() {
		if (arguments[0] instanceof DD) {
			var y = arguments[0];
			if (y.isNaN()) return DD.createNaN();
			return DD.copy(this).selfMultiply(y);
		} else if (typeof arguments[0] === "number") {
			var _y7 = arguments[0];
			if (Double.isNaN(_y7)) return DD.createNaN();
			return DD.copy(this).selfMultiply(_y7, 0.0);
		}
	},
	isNaN: function isNaN() {
		return Double.isNaN(this._hi);
	},
	intValue: function intValue() {
		return Math.trunc(this._hi);
	},
	toString: function toString() {
		var mag = DD.magnitude(this._hi);
		if (mag >= -3 && mag <= 20) return this.toStandardNotation();
		return this.toSciNotation();
	},
	toStandardNotation: function toStandardNotation() {
		var specialStr = this.getSpecialNumberString();
		if (specialStr !== null) return specialStr;
		var magnitude = new Array(1).fill(null);
		var sigDigits = this.extractSignificantDigits(true, magnitude);
		var decimalPointPos = magnitude[0] + 1;
		var num = sigDigits;
		if (sigDigits.charAt(0) === '.') {
			num = "0" + sigDigits;
		} else if (decimalPointPos < 0) {
			num = "0." + DD.stringOfChar('0', -decimalPointPos) + sigDigits;
		} else if (sigDigits.indexOf('.') === -1) {
			var numZeroes = decimalPointPos - sigDigits.length;
			var zeroes = DD.stringOfChar('0', numZeroes);
			num = sigDigits + zeroes + ".0";
		}
		if (this.isNegative()) return "-" + num;
		return num;
	},
	reciprocal: function reciprocal() {
		var hc = null,
		    tc = null,
		    hy = null,
		    ty = null,
		    C = null,
		    c = null,
		    U = null,
		    u = null;
		C = 1.0 / this._hi;
		c = DD.SPLIT * C;
		hc = c - C;
		u = DD.SPLIT * this._hi;
		hc = c - hc;
		tc = C - hc;
		hy = u - this._hi;
		U = C * this._hi;
		hy = u - hy;
		ty = this._hi - hy;
		u = hc * hy - U + hc * ty + tc * hy + tc * ty;
		c = (1.0 - U - u - C * this._lo) / this._hi;
		var zhi = C + c;
		var zlo = C - zhi + c;
		return new DD(zhi, zlo);
	},
	toSciNotation: function toSciNotation() {
		if (this.isZero()) return DD.SCI_NOT_ZERO;
		var specialStr = this.getSpecialNumberString();
		if (specialStr !== null) return specialStr;
		var magnitude = new Array(1).fill(null);
		var digits = this.extractSignificantDigits(false, magnitude);
		var expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];
		if (digits.charAt(0) === '0') {
			throw new IllegalStateException("Found leading zero: " + digits);
		}
		var trailingDigits = "";
		if (digits.length > 1) trailingDigits = digits.substring(1);
		var digitsWithDecimal = digits.charAt(0) + "." + trailingDigits;
		if (this.isNegative()) return "-" + digitsWithDecimal + expStr;
		return digitsWithDecimal + expStr;
	},
	abs: function abs() {
		if (this.isNaN()) return DD.NaN;
		if (this.isNegative()) return this.negate();
		return new DD(this);
	},
	isPositive: function isPositive() {
		return this._hi > 0.0 || this._hi === 0.0 && this._lo > 0.0;
	},
	lt: function lt(y) {
		return this._hi < y._hi || this._hi === y._hi && this._lo < y._lo;
	},
	add: function add() {
		if (arguments[0] instanceof DD) {
			var y = arguments[0];
			return DD.copy(this).selfAdd(y);
		} else if (typeof arguments[0] === "number") {
			var _y8 = arguments[0];
			return DD.copy(this).selfAdd(_y8);
		}
	},
	init: function init() {
		if (arguments.length === 1) {
			if (typeof arguments[0] === "number") {
				var x = arguments[0];
				this._hi = x;
				this._lo = 0.0;
			} else if (arguments[0] instanceof DD) {
				var dd = arguments[0];
				this._hi = dd._hi;
				this._lo = dd._lo;
			}
		} else if (arguments.length === 2) {
			var hi = arguments[0],
			    lo = arguments[1];
			this._hi = hi;
			this._lo = lo;
		}
	},
	gt: function gt(y) {
		return this._hi > y._hi || this._hi === y._hi && this._lo > y._lo;
	},
	isNegative: function isNegative() {
		return this._hi < 0.0 || this._hi === 0.0 && this._lo < 0.0;
	},
	trunc: function trunc() {
		if (this.isNaN()) return DD.NaN;
		if (this.isPositive()) return this.floor();else return this.ceil();
	},
	signum: function signum() {
		if (this._hi > 0) return 1;
		if (this._hi < 0) return -1;
		if (this._lo > 0) return 1;
		if (this._lo < 0) return -1;
		return 0;
	},
	interfaces_: function interfaces_() {
		return [Serializable, Comparable, Clonable];
	},
	getClass: function getClass() {
		return DD;
	}
});
DD.sqr = function (x) {
	return DD.valueOf(x).selfMultiply(x);
};
DD.valueOf = function () {
	if (typeof arguments[0] === "string") {
		var str = arguments[0];
		return DD.parse(str);
	} else if (typeof arguments[0] === "number") {
		var x = arguments[0];
		return new DD(x);
	}
};
DD.sqrt = function (x) {
	return DD.valueOf(x).sqrt();
};
DD.parse = function (str) {
	var i = 0;
	var strlen = str.length;
	while (Character.isWhitespace(str.charAt(i))) {
		i++;
	}var isNegative = false;
	if (i < strlen) {
		var signCh = str.charAt(i);
		if (signCh === '-' || signCh === '+') {
			i++;
			if (signCh === '-') isNegative = true;
		}
	}
	var val = new DD();
	var numDigits = 0;
	var numBeforeDec = 0;
	var exp = 0;
	while (true) {
		if (i >= strlen) break;
		var ch = str.charAt(i);
		i++;
		if (Character.isDigit(ch)) {
			var d = ch - '0';
			val.selfMultiply(DD.TEN);
			val.selfAdd(d);
			numDigits++;
			continue;
		}
		if (ch === '.') {
			numBeforeDec = numDigits;
			continue;
		}
		if (ch === 'e' || ch === 'E') {
			var expStr = str.substring(i);
			try {
				exp = Integer.parseInt(expStr);
			} catch (ex) {
				if (ex instanceof NumberFormatException) {
					throw new NumberFormatException("Invalid exponent " + expStr + " in string " + str);
				} else throw ex;
			} finally {}
			break;
		}
		throw new NumberFormatException("Unexpected character '" + ch + "' at position " + i + " in string " + str);
	}
	var val2 = val;
	var numDecPlaces = numDigits - numBeforeDec - exp;
	if (numDecPlaces === 0) {
		val2 = val;
	} else if (numDecPlaces > 0) {
		var scale = DD.TEN.pow(numDecPlaces);
		val2 = val.divide(scale);
	} else if (numDecPlaces < 0) {
		var scale = DD.TEN.pow(-numDecPlaces);
		val2 = val.multiply(scale);
	}
	if (isNegative) {
		return val2.negate();
	}
	return val2;
};
DD.createNaN = function () {
	return new DD(Double.NaN, Double.NaN);
};
DD.copy = function (dd) {
	return new DD(dd);
};
DD.magnitude = function (x) {
	var xAbs = Math.abs(x);
	var xLog10 = Math.log(xAbs) / Math.log(10);
	var xMag = Math.trunc(Math.floor(xLog10));
	var xApprox = Math.pow(10, xMag);
	if (xApprox * 10 <= xAbs) xMag += 1;
	return xMag;
};
DD.stringOfChar = function (ch, len) {
	var buf = new StringBuffer();
	for (var i = 0; i < len; i++) {
		buf.append(ch);
	}
	return buf.toString();
};
DD.PI = new DD(3.141592653589793116e+00, 1.224646799147353207e-16);
DD.TWO_PI = new DD(6.283185307179586232e+00, 2.449293598294706414e-16);
DD.PI_2 = new DD(1.570796326794896558e+00, 6.123233995736766036e-17);
DD.E = new DD(2.718281828459045091e+00, 1.445646891729250158e-16);
DD.NaN = new DD(Double.NaN, Double.NaN);
DD.EPS = 1.23259516440783e-32;
DD.SPLIT = 134217729.0;
DD.MAX_PRINT_DIGITS = 32;
DD.TEN = DD.valueOf(10.0);
DD.ONE = DD.valueOf(1.0);
DD.SCI_NOT_EXPONENT_CHAR = "E";
DD.SCI_NOT_ZERO = "0.0E0";

function CGAlgorithmsDD() {}
extend(CGAlgorithmsDD.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return CGAlgorithmsDD;
	}
});
CGAlgorithmsDD.orientationIndex = function (p1, p2, q) {
	var index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);
	if (index <= 1) return index;
	var dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);
	var dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);
	var dx2 = DD.valueOf(q.x).selfAdd(-p2.x);
	var dy2 = DD.valueOf(q.y).selfAdd(-p2.y);
	return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();
};
CGAlgorithmsDD.signOfDet2x2 = function () {
	if (arguments[0] instanceof DD) {
		var _x = arguments[0],
		    _y = arguments[1],
		    _x2 = arguments[2],
		    _y2 = arguments[3];
		var det = _x.multiply(_y2).selfSubtract(_y.multiply(_x2));
		return det.signum();
	} else if (typeof arguments[0] === "number") {
		var dx1 = arguments[0],
		    dy1 = arguments[1],
		    dx2 = arguments[2],
		    dy2 = arguments[3];
		var x1 = DD.valueOf(dx1);
		var y1 = DD.valueOf(dy1);
		var x2 = DD.valueOf(dx2);
		var y2 = DD.valueOf(dy2);
		var det = x1.multiply(y2).selfSubtract(y1.multiply(x2));
		return det.signum();
	}
};
CGAlgorithmsDD.intersection = function (p1, p2, q1, q2) {
	var denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));
	var denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));
	var denom = denom1.subtract(denom2);
	var numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));
	var numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));
	var numx = numx1.subtract(numx2);
	var fracP = numx.selfDivide(denom).doubleValue();
	var x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();
	var numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));
	var numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));
	var numy = numy1.subtract(numy2);
	var fracQ = numy.selfDivide(denom).doubleValue();
	var y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();
	return new Coordinate(x, y);
};
CGAlgorithmsDD.orientationIndexFilter = function (pa, pb, pc) {
	var detsum = null;
	var detleft = (pa.x - pc.x) * (pb.y - pc.y);
	var detright = (pa.y - pc.y) * (pb.x - pc.x);
	var det = detleft - detright;
	if (detleft > 0.0) {
		if (detright <= 0.0) {
			return CGAlgorithmsDD.signum(det);
		} else {
			detsum = detleft + detright;
		}
	} else if (detleft < 0.0) {
		if (detright >= 0.0) {
			return CGAlgorithmsDD.signum(det);
		} else {
			detsum = -detleft - detright;
		}
	} else {
		return CGAlgorithmsDD.signum(det);
	}
	var errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;
	if (det >= errbound || -det >= errbound) {
		return CGAlgorithmsDD.signum(det);
	}
	return 2;
};
CGAlgorithmsDD.signum = function (x) {
	if (x > 0) return 1;
	if (x < 0) return -1;
	return 0;
};
CGAlgorithmsDD.DP_SAFE_EPSILON = 1e-15;

function Orientation() {}
extend(Orientation.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Orientation;
	}
});
Orientation.index = function (p1, p2, q) {
	return CGAlgorithmsDD.orientationIndex(p1, p2, q);
};
Orientation.isCCW = function (ring) {
	var nPts = ring.length - 1;
	if (nPts < 3) throw new IllegalArgumentException("Ring has fewer than 4 points, so orientation cannot be determined");
	var hiPt = ring[0];
	var hiIndex = 0;
	for (var i = 1; i <= nPts; i++) {
		var p = ring[i];
		if (p.y > hiPt.y) {
			hiPt = p;
			hiIndex = i;
		}
	}
	var iPrev = hiIndex;
	do {
		iPrev = iPrev - 1;
		if (iPrev < 0) iPrev = nPts;
	} while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);
	var iNext = hiIndex;
	do {
		iNext = (iNext + 1) % nPts;
	} while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);
	var prev = ring[iPrev];
	var next = ring[iNext];
	if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;
	var disc = Orientation.index(prev, hiPt, next);
	var isCCW = null;
	if (disc === 0) {
		isCCW = prev.x > next.x;
	} else {
		isCCW = disc > 0;
	}
	return isCCW;
};
Orientation.CLOCKWISE = -1;
Orientation.RIGHT = Orientation.CLOCKWISE;
Orientation.COUNTERCLOCKWISE = 1;
Orientation.LEFT = Orientation.COUNTERCLOCKWISE;
Orientation.COLLINEAR = 0;
Orientation.STRAIGHT = Orientation.COLLINEAR;

function System() {}

System.arraycopy = function (src, srcPos, dest, destPos, len) {
  var c = 0;
  for (var i = srcPos; i < srcPos + len; i++) {
    dest[destPos + c] = src[i];
    c++;
  }
};

System.getProperty = function (name) {
  return {
    'line.separator': '\n'
  }[name];
};

function HCoordinate() {
	this.x = null;
	this.y = null;
	this.w = null;
	if (arguments.length === 0) {
		this.x = 0.0;
		this.y = 0.0;
		this.w = 1.0;
	} else if (arguments.length === 1) {
		var p = arguments[0];
		this.x = p.x;
		this.y = p.y;
		this.w = 1.0;
	} else if (arguments.length === 2) {
		if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
			var _x = arguments[0],
			    _y = arguments[1];
			this.x = _x;
			this.y = _y;
			this.w = 1.0;
		} else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {
			var p1 = arguments[0],
			    p2 = arguments[1];
			this.x = p1.y * p2.w - p2.y * p1.w;
			this.y = p2.x * p1.w - p1.x * p2.w;
			this.w = p1.x * p2.y - p2.x * p1.y;
		} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
			var _p = arguments[0],
			    _p2 = arguments[1];
			this.x = _p.y - _p2.y;
			this.y = _p2.x - _p.x;
			this.w = _p.x * _p2.y - _p2.x * _p.y;
		}
	} else if (arguments.length === 3) {
		var _x2 = arguments[0],
		    _y2 = arguments[1],
		    _w = arguments[2];
		this.x = _x2;
		this.y = _y2;
		this.w = _w;
	} else if (arguments.length === 4) {
		var _p3 = arguments[0],
		    _p4 = arguments[1],
		    q1 = arguments[2],
		    q2 = arguments[3];
		var px = _p3.y - _p4.y;
		var py = _p4.x - _p3.x;
		var pw = _p3.x * _p4.y - _p4.x * _p3.y;
		var qx = q1.y - q2.y;
		var qy = q2.x - q1.x;
		var qw = q1.x * q2.y - q2.x * q1.y;
		this.x = py * qw - qy * pw;
		this.y = qx * pw - px * qw;
		this.w = px * qy - qx * py;
	}
}
extend(HCoordinate.prototype, {
	getY: function getY() {
		var a = this.y / this.w;
		if (Double.isNaN(a) || Double.isInfinite(a)) {
			throw new NotRepresentableException();
		}
		return a;
	},
	getX: function getX() {
		var a = this.x / this.w;
		if (Double.isNaN(a) || Double.isInfinite(a)) {
			throw new NotRepresentableException();
		}
		return a;
	},
	getCoordinate: function getCoordinate() {
		var p = new Coordinate();
		p.x = this.getX();
		p.y = this.getY();
		return p;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return HCoordinate;
	}
});
HCoordinate.intersection = function (p1, p2, q1, q2) {
	var px = p1.y - p2.y;
	var py = p2.x - p1.x;
	var pw = p1.x * p2.y - p2.x * p1.y;
	var qx = q1.y - q2.y;
	var qy = q2.x - q1.x;
	var qw = q1.x * q2.y - q2.x * q1.y;
	var x = py * qw - qy * pw;
	var y = qx * pw - px * qw;
	var w = px * qy - qx * py;
	var xInt = x / w;
	var yInt = y / w;
	if (Double.isNaN(xInt) || Double.isInfinite(xInt) || Double.isNaN(yInt) || Double.isInfinite(yInt)) {
		throw new NotRepresentableException();
	}
	return new Coordinate(xInt, yInt);
};

function MathUtil() {}
extend(MathUtil.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return MathUtil;
	}
});
MathUtil.log10 = function (x) {
	var ln = Math.log(x);
	if (Double.isInfinite(ln)) return ln;
	if (Double.isNaN(ln)) return ln;
	return ln / MathUtil.LOG_10;
};
MathUtil.min = function (v1, v2, v3, v4) {
	var min = v1;
	if (v2 < min) min = v2;
	if (v3 < min) min = v3;
	if (v4 < min) min = v4;
	return min;
};
MathUtil.clamp = function () {
	if (typeof arguments[2] === "number" && typeof arguments[0] === "number" && typeof arguments[1] === "number") {
		var x = arguments[0],
		    min = arguments[1],
		    max = arguments[2];
		if (x < min) return min;
		if (x > max) return max;
		return x;
	} else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
		var _x = arguments[0],
		    _min = arguments[1],
		    _max = arguments[2];
		if (_x < _min) return _min;
		if (_x > _max) return _max;
		return _x;
	}
};
MathUtil.wrap = function (index, max) {
	if (index < 0) {
		return max - -index % max;
	}
	return index % max;
};
MathUtil.max = function () {
	if (arguments.length === 3) {
		var v1 = arguments[0],
		    v2 = arguments[1],
		    v3 = arguments[2];
		var max = v1;
		if (v2 > max) max = v2;
		if (v3 > max) max = v3;
		return max;
	} else if (arguments.length === 4) {
		var _v = arguments[0],
		    _v2 = arguments[1],
		    _v3 = arguments[2],
		    v4 = arguments[3];
		var max = _v;
		if (_v2 > max) max = _v2;
		if (_v3 > max) max = _v3;
		if (v4 > max) max = v4;
		return max;
	}
};
MathUtil.average = function (x1, x2) {
	return (x1 + x2) / 2.0;
};
MathUtil.LOG_10 = Math.log(10);

function Distance() {}
extend(Distance.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Distance;
	}
});
Distance.segmentToSegment = function (A, B, C, D) {
	if (A.equals(B)) return Distance.pointToSegment(A, C, D);
	if (C.equals(D)) return Distance.pointToSegment(D, A, B);
	var noIntersection = false;
	if (!Envelope.intersects(A, B, C, D)) {
		noIntersection = true;
	} else {
		var denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);
		if (denom === 0) {
			noIntersection = true;
		} else {
			var r_num = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);
			var s_num = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);
			var s = s_num / denom;
			var r = r_num / denom;
			if (r < 0 || r > 1 || s < 0 || s > 1) {
				noIntersection = true;
			}
		}
	}
	if (noIntersection) {
		return MathUtil.min(Distance.pointToSegment(A, C, D), Distance.pointToSegment(B, C, D), Distance.pointToSegment(C, A, B), Distance.pointToSegment(D, A, B));
	}
	return 0.0;
};
Distance.pointToSegment = function (p, A, B) {
	if (A.x === B.x && A.y === B.y) return p.distance(A);
	var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
	var r = ((p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y)) / len2;
	if (r <= 0.0) return p.distance(A);
	if (r >= 1.0) return p.distance(B);
	var s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;
	return Math.abs(s) * Math.sqrt(len2);
};
Distance.pointToLinePerpendicular = function (p, A, B) {
	var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
	var s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;
	return Math.abs(s) * Math.sqrt(len2);
};
Distance.pointToSegmentString = function (p, line) {
	if (line.length === 0) throw new IllegalArgumentException("Line array must contain at least one vertex");
	var minDistance = p.distance(line[0]);
	for (var i = 0; i < line.length - 1; i++) {
		var dist = Distance.pointToSegment(p, line[i], line[i + 1]);
		if (dist < minDistance) {
			minDistance = dist;
		}
	}
	return minDistance;
};

function CoordinateSequence() {}
extend(CoordinateSequence.prototype, {
	setOrdinate: function setOrdinate(index, ordinateIndex, value) {},
	size: function size() {},
	getOrdinate: function getOrdinate(index, ordinateIndex) {},
	getCoordinate: function getCoordinate() {
		
	},
	getCoordinateCopy: function getCoordinateCopy(i) {},
	getDimension: function getDimension() {},
	getX: function getX(index) {},
	expandEnvelope: function expandEnvelope(env) {},
	copy: function copy() {},
	getY: function getY(index) {},
	toCoordinateArray: function toCoordinateArray() {},
	interfaces_: function interfaces_() {
		return [Clonable];
	},
	getClass: function getClass() {
		return CoordinateSequence;
	}
});
CoordinateSequence.X = 0;
CoordinateSequence.Y = 1;
CoordinateSequence.Z = 2;
CoordinateSequence.M = 3;

function CoordinateSequenceFactory() {}
extend(CoordinateSequenceFactory.prototype, {
	create: function create() {
		if (arguments.length === 1) {
			if (arguments[0] instanceof Array) {
				
			} else if (hasInterface(arguments[0], CoordinateSequence)) {
				
			}
		} else if (arguments.length === 2) {
			
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return CoordinateSequenceFactory;
	}
});

function GeometryComponentFilter() {}
extend(GeometryComponentFilter.prototype, {
	filter: function filter(geom) {},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return GeometryComponentFilter;
	}
});

function Geometry() {
	this._envelope = null;
	this._factory = null;
	this._SRID = null;
	this._userData = null;
	var factory = arguments[0];
	this._factory = factory;
	this._SRID = factory.getSRID();
}
extend(Geometry.prototype, {
	isGeometryCollection: function isGeometryCollection() {
		return this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION;
	},
	getFactory: function getFactory() {
		return this._factory;
	},
	getGeometryN: function getGeometryN(n) {
		return this;
	},
	getArea: function getArea() {
		return 0.0;
	},
	isRectangle: function isRectangle() {
		return false;
	},
	equals: function equals() {
		if (arguments[0] instanceof Geometry) {
			var _g = arguments[0];
			if (_g === null) return false;
			return this.equalsTopo(_g);
		} else if (arguments[0] instanceof Object) {
			var o = arguments[0];
			if (!(o instanceof Geometry)) return false;
			var g = o;
			return this.equalsExact(g);
		}
	},
	equalsExact: function equalsExact(other) {
		return this === other || this.equalsExact(other, 0);
	},
	geometryChanged: function geometryChanged() {
		this.apply(Geometry.geometryChangedFilter);
	},
	geometryChangedAction: function geometryChangedAction() {
		this._envelope = null;
	},
	equalsNorm: function equalsNorm(g) {
		if (g === null) return false;
		return this.norm().equalsExact(g.norm());
	},
	getLength: function getLength() {
		return 0.0;
	},
	getNumGeometries: function getNumGeometries() {
		return 1;
	},
	compareTo: function compareTo() {
		if (arguments.length === 1) {
			var o = arguments[0];
			var other = o;
			if (this.getTypeCode() !== other.getTypeCode()) {
				return this.getTypeCode() - other.getTypeCode();
			}
			if (this.isEmpty() && other.isEmpty()) {
				return 0;
			}
			if (this.isEmpty()) {
				return -1;
			}
			if (other.isEmpty()) {
				return 1;
			}
			return this.compareToSameClass(o);
		} else if (arguments.length === 2) {
			var _o = arguments[0],
			    comp = arguments[1];
			var other = _o;
			if (this.getTypeCode() !== other.getTypeCode()) {
				return this.getTypeCode() - other.getTypeCode();
			}
			if (this.isEmpty() && other.isEmpty()) {
				return 0;
			}
			if (this.isEmpty()) {
				return -1;
			}
			if (other.isEmpty()) {
				return 1;
			}
			return this.compareToSameClass(_o, comp);
		}
	},
	getUserData: function getUserData() {
		return this._userData;
	},
	getSRID: function getSRID() {
		return this._SRID;
	},
	getEnvelope: function getEnvelope() {
		return this.getFactory().toGeometry(this.getEnvelopeInternal());
	},
	checkNotGeometryCollection: function checkNotGeometryCollection(g) {
		if (g.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION) {
			throw new IllegalArgumentException("This method does not support GeometryCollection arguments");
		}
	},
	equal: function equal(a, b, tolerance) {
		if (tolerance === 0) {
			return a.equals(b);
		}
		return a.distance(b) <= tolerance;
	},
	norm: function norm() {
		var copy = this.copy();
		copy.normalize();
		return copy;
	},
	getPrecisionModel: function getPrecisionModel() {
		return this._factory.getPrecisionModel();
	},
	getEnvelopeInternal: function getEnvelopeInternal() {
		if (this._envelope === null) {
			this._envelope = this.computeEnvelopeInternal();
		}
		return new Envelope(this._envelope);
	},
	setSRID: function setSRID(SRID) {
		this._SRID = SRID;
	},
	setUserData: function setUserData(userData) {
		this._userData = userData;
	},
	compare: function compare(a, b) {
		var i = a.iterator();
		var j = b.iterator();
		while (i.hasNext() && j.hasNext()) {
			var aElement = i.next();
			var bElement = j.next();
			var comparison = aElement.compareTo(bElement);
			if (comparison !== 0) {
				return comparison;
			}
		}
		if (i.hasNext()) {
			return 1;
		}
		if (j.hasNext()) {
			return -1;
		}
		return 0;
	},
	hashCode: function hashCode() {
		return this.getEnvelopeInternal().hashCode();
	},
	isGeometryCollectionOrDerived: function isGeometryCollectionOrDerived() {
		if (this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === Geometry.TYPECODE_MULTIPOINT || this.getTypeCode() === Geometry.TYPECODE_MULTILINESTRING || this.getTypeCode() === Geometry.TYPECODE_MULTIPOLYGON) {
			return true;
		}
		return false;
	},
	interfaces_: function interfaces_() {
		return [Clonable, Comparable, Serializable];
	},
	getClass: function getClass() {
		return Geometry;
	}
});
Geometry.hasNonEmptyElements = function (geometries) {
	for (var i = 0; i < geometries.length; i++) {
		if (!geometries[i].isEmpty()) {
			return true;
		}
	}
	return false;
};
Geometry.hasNullElements = function (array) {
	for (var i = 0; i < array.length; i++) {
		if (array[i] === null) {
			return true;
		}
	}
	return false;
};
Geometry.serialVersionUID = 8763622679187376702;
Geometry.TYPECODE_POINT = 0;
Geometry.TYPECODE_MULTIPOINT = 1;
Geometry.TYPECODE_LINESTRING = 2;
Geometry.TYPECODE_LINEARRING = 3;
Geometry.TYPECODE_MULTILINESTRING = 4;
Geometry.TYPECODE_POLYGON = 5;
Geometry.TYPECODE_MULTIPOLYGON = 6;
Geometry.TYPECODE_GEOMETRYCOLLECTION = 7;
Geometry.TYPENAME_POINT = "Point";
Geometry.TYPENAME_MULTIPOINT = "MultiPoint";
Geometry.TYPENAME_LINESTRING = "LineString";
Geometry.TYPENAME_LINEARRING = "LinearRing";
Geometry.TYPENAME_MULTILINESTRING = "MultiLineString";
Geometry.TYPENAME_POLYGON = "Polygon";
Geometry.TYPENAME_MULTIPOLYGON = "MultiPolygon";
Geometry.TYPENAME_GEOMETRYCOLLECTION = "GeometryCollection";
Geometry.geometryChangedFilter = {
	interfaces_: function interfaces_() {
		return [GeometryComponentFilter];
	},
	filter: function filter(geom) {
		geom.geometryChangedAction();
	}
};

function CoordinateFilter() {}
extend(CoordinateFilter.prototype, {
	filter: function filter(coord) {},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return CoordinateFilter;
	}
});

function BoundaryNodeRule() {}
extend(BoundaryNodeRule.prototype, {
	isInBoundary: function isInBoundary(boundaryCount) {},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return BoundaryNodeRule;
	}
});
function Mod2BoundaryNodeRule() {}
extend(Mod2BoundaryNodeRule.prototype, {
	isInBoundary: function isInBoundary(boundaryCount) {
		return boundaryCount % 2 === 1;
	},
	interfaces_: function interfaces_() {
		return [BoundaryNodeRule];
	},
	getClass: function getClass() {
		return Mod2BoundaryNodeRule;
	}
});
function EndPointBoundaryNodeRule() {}
extend(EndPointBoundaryNodeRule.prototype, {
	isInBoundary: function isInBoundary(boundaryCount) {
		return boundaryCount > 0;
	},
	interfaces_: function interfaces_() {
		return [BoundaryNodeRule];
	},
	getClass: function getClass() {
		return EndPointBoundaryNodeRule;
	}
});
function MultiValentEndPointBoundaryNodeRule() {}
extend(MultiValentEndPointBoundaryNodeRule.prototype, {
	isInBoundary: function isInBoundary(boundaryCount) {
		return boundaryCount > 1;
	},
	interfaces_: function interfaces_() {
		return [BoundaryNodeRule];
	},
	getClass: function getClass() {
		return MultiValentEndPointBoundaryNodeRule;
	}
});
function MonoValentEndPointBoundaryNodeRule() {}
extend(MonoValentEndPointBoundaryNodeRule.prototype, {
	isInBoundary: function isInBoundary(boundaryCount) {
		return boundaryCount === 1;
	},
	interfaces_: function interfaces_() {
		return [BoundaryNodeRule];
	},
	getClass: function getClass() {
		return MonoValentEndPointBoundaryNodeRule;
	}
});
BoundaryNodeRule.Mod2BoundaryNodeRule = Mod2BoundaryNodeRule;
BoundaryNodeRule.EndPointBoundaryNodeRule = EndPointBoundaryNodeRule;
BoundaryNodeRule.MultiValentEndPointBoundaryNodeRule = MultiValentEndPointBoundaryNodeRule;
BoundaryNodeRule.MonoValentEndPointBoundaryNodeRule = MonoValentEndPointBoundaryNodeRule;
BoundaryNodeRule.MOD2_BOUNDARY_RULE = new Mod2BoundaryNodeRule();
BoundaryNodeRule.ENDPOINT_BOUNDARY_RULE = new EndPointBoundaryNodeRule();
BoundaryNodeRule.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new MultiValentEndPointBoundaryNodeRule();
BoundaryNodeRule.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new MonoValentEndPointBoundaryNodeRule();
BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE = BoundaryNodeRule.MOD2_BOUNDARY_RULE;

function CoordinateArrays() {}
extend(CoordinateArrays.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return CoordinateArrays;
	}
});
CoordinateArrays.isRing = function (pts) {
	if (pts.length < 4) return false;
	if (!pts[0].equals2D(pts[pts.length - 1])) return false;
	return true;
};
CoordinateArrays.ptNotInList = function (testPts, pts) {
	for (var i = 0; i < testPts.length; i++) {
		var testPt = testPts[i];
		if (CoordinateArrays.indexOf(testPt, pts) < 0) return testPt;
	}
	return null;
};
CoordinateArrays.scroll = function (coordinates, firstCoordinate) {
	var i = CoordinateArrays.indexOf(firstCoordinate, coordinates);
	if (i < 0) return null;
	var newCoordinates = new Array(coordinates.length).fill(null);
	System.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);
	System.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);
	System.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);
};
CoordinateArrays.equals = function () {
	if (arguments.length === 2) {
		var coord1 = arguments[0],
		    coord2 = arguments[1];
		if (coord1 === coord2) return true;
		if (coord1 === null || coord2 === null) return false;
		if (coord1.length !== coord2.length) return false;
		for (var i = 0; i < coord1.length; i++) {
			if (!coord1[i].equals(coord2[i])) return false;
		}
		return true;
	} else if (arguments.length === 3) {
		var _coord = arguments[0],
		    _coord2 = arguments[1],
		    coordinateComparator = arguments[2];
		if (_coord === _coord2) return true;
		if (_coord === null || _coord2 === null) return false;
		if (_coord.length !== _coord2.length) return false;
		for (var i = 0; i < _coord.length; i++) {
			if (coordinateComparator.compare(_coord[i], _coord2[i]) !== 0) return false;
		}
		return true;
	}
};
CoordinateArrays.intersection = function (coordinates, env) {
	var coordList = new CoordinateList();
	for (var i = 0; i < coordinates.length; i++) {
		if (env.intersects(coordinates[i])) coordList.add(coordinates[i], true);
	}
	return coordList.toCoordinateArray();
};
CoordinateArrays.hasRepeatedPoints = function (coord) {
	for (var i = 1; i < coord.length; i++) {
		if (coord[i - 1].equals(coord[i])) {
			return true;
		}
	}
	return false;
};
CoordinateArrays.removeRepeatedPoints = function (coord) {
	if (!CoordinateArrays.hasRepeatedPoints(coord)) return coord;
	var coordList = new CoordinateList(coord, false);
	return coordList.toCoordinateArray();
};
CoordinateArrays.reverse = function (coord) {
	var last = coord.length - 1;
	var mid = Math.trunc(last / 2);
	for (var i = 0; i <= mid; i++) {
		var tmp = coord[i];
		coord[i] = coord[last - i];
		coord[last - i] = tmp;
	}
};
CoordinateArrays.removeNull = function (coord) {
	var nonNull = 0;
	for (var i = 0; i < coord.length; i++) {
		if (coord[i] !== null) nonNull++;
	}
	var newCoord = new Array(nonNull).fill(null);
	if (nonNull === 0) return newCoord;
	var j = 0;
	for (var i = 0; i < coord.length; i++) {
		if (coord[i] !== null) newCoord[j++] = coord[i];
	}
	return newCoord;
};
CoordinateArrays.copyDeep = function () {
	if (arguments.length === 1) {
		var coordinates = arguments[0];
		var copy = new Array(coordinates.length).fill(null);
		for (var i = 0; i < coordinates.length; i++) {
			copy[i] = new Coordinate(coordinates[i]);
		}
		return copy;
	} else if (arguments.length === 5) {
		var src = arguments[0],
		    srcStart = arguments[1],
		    dest = arguments[2],
		    destStart = arguments[3],
		    length = arguments[4];
		for (var i = 0; i < length; i++) {
			dest[destStart + i] = new Coordinate(src[srcStart + i]);
		}
	}
};
CoordinateArrays.isEqualReversed = function (pts1, pts2) {
	for (var i = 0; i < pts1.length; i++) {
		var p1 = pts1[i];
		var p2 = pts2[pts1.length - i - 1];
		if (p1.compareTo(p2) !== 0) return false;
	}
	return true;
};
CoordinateArrays.envelope = function (coordinates) {
	var env = new Envelope();
	for (var i = 0; i < coordinates.length; i++) {
		env.expandToInclude(coordinates[i]);
	}
	return env;
};
CoordinateArrays.toCoordinateArray = function (coordList) {
	return coordList.toArray(CoordinateArrays.coordArrayType);
};
CoordinateArrays.atLeastNCoordinatesOrNothing = function (n, c) {
	return c.length >= n ? c : [];
};
CoordinateArrays.indexOf = function (coordinate, coordinates) {
	for (var i = 0; i < coordinates.length; i++) {
		if (coordinate.equals(coordinates[i])) {
			return i;
		}
	}
	return -1;
};
CoordinateArrays.increasingDirection = function (pts) {
	for (var i = 0; i < Math.trunc(pts.length / 2); i++) {
		var j = pts.length - 1 - i;
		var comp = pts[i].compareTo(pts[j]);
		if (comp !== 0) return comp;
	}
	return 1;
};
CoordinateArrays.compare = function (pts1, pts2) {
	var i = 0;
	while (i < pts1.length && i < pts2.length) {
		var compare = pts1[i].compareTo(pts2[i]);
		if (compare !== 0) return compare;
		i++;
	}
	if (i < pts2.length) return -1;
	if (i < pts1.length) return 1;
	return 0;
};
CoordinateArrays.minCoordinate = function (coordinates) {
	var minCoord = null;
	for (var i = 0; i < coordinates.length; i++) {
		if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {
			minCoord = coordinates[i];
		}
	}
	return minCoord;
};
CoordinateArrays.extract = function (pts, start, end) {
	start = MathUtil.clamp(start, 0, pts.length);
	end = MathUtil.clamp(end, -1, pts.length);
	var npts = end - start + 1;
	if (end < 0) npts = 0;
	if (start >= pts.length) npts = 0;
	if (end < start) npts = 0;
	var extractPts = new Array(npts).fill(null);
	if (npts === 0) return extractPts;
	var iPts = 0;
	for (var i = start; i <= end; i++) {
		extractPts[iPts++] = pts[i];
	}
	return extractPts;
};
function ForwardComparator() {}
extend(ForwardComparator.prototype, {
	compare: function compare(o1, o2) {
		var pts1 = o1;
		var pts2 = o2;
		return CoordinateArrays.compare(pts1, pts2);
	},
	interfaces_: function interfaces_() {
		return [Comparator];
	},
	getClass: function getClass() {
		return ForwardComparator;
	}
});
function BidirectionalComparator() {}
extend(BidirectionalComparator.prototype, {
	compare: function compare(o1, o2) {
		var pts1 = o1;
		var pts2 = o2;
		if (pts1.length < pts2.length) return -1;
		if (pts1.length > pts2.length) return 1;
		if (pts1.length === 0) return 0;
		var forwardComp = CoordinateArrays.compare(pts1, pts2);
		var isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);
		if (isEqualRev) return 0;
		return forwardComp;
	},
	OLDcompare: function OLDcompare(o1, o2) {
		var pts1 = o1;
		var pts2 = o2;
		if (pts1.length < pts2.length) return -1;
		if (pts1.length > pts2.length) return 1;
		if (pts1.length === 0) return 0;
		var dir1 = CoordinateArrays.increasingDirection(pts1);
		var dir2 = CoordinateArrays.increasingDirection(pts2);
		var i1 = dir1 > 0 ? 0 : pts1.length - 1;
		var i2 = dir2 > 0 ? 0 : pts1.length - 1;
		for (var i = 0; i < pts1.length; i++) {
			var comparePt = pts1[i1].compareTo(pts2[i2]);
			if (comparePt !== 0) return comparePt;
			i1 += dir1;
			i2 += dir2;
		}
		return 0;
	},
	interfaces_: function interfaces_() {
		return [Comparator];
	},
	getClass: function getClass() {
		return BidirectionalComparator;
	}
});
CoordinateArrays.ForwardComparator = ForwardComparator;
CoordinateArrays.BidirectionalComparator = BidirectionalComparator;
CoordinateArrays.coordArrayType = new Array(0).fill(null);

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html
 *
 * @constructor
 * @private
 */
function Map$1() {}

/**
 * Returns the value to which the specified key is mapped, or null if this map
 * contains no mapping for the key.
 * @param {Object} key
 * @return {Object}
 */
Map$1.prototype.get = function () {};

/**
 * Associates the specified value with the specified key in this map (optional
 * operation).
 * @param {Object} key
 * @param {Object} value
 * @return {Object}
 */
Map$1.prototype.put = function () {};

/**
 * Returns the number of key-value mappings in this map.
 * @return {number}
 */
Map$1.prototype.size = function () {};

/**
 * Returns a Collection view of the values contained in this map.
 * @return {javascript.util.Collection}
 */
Map$1.prototype.values = function () {};

/**
 * Returns a {@link Set} view of the mappings contained in this map.
 * The set is backed by the map, so changes to the map are
 * reflected in the set, and vice-versa.  If the map is modified
 * while an iteration over the set is in progress (except through
 * the iterator's own <tt>remove</tt> operation, or through the
 * <tt>setValue</tt> operation on a map entry returned by the
 * iterator) the results of the iteration are undefined.  The set
 * supports element removal, which removes the corresponding
 * mapping from the map, via the <tt>Iterator.remove</tt>,
 * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and
 * <tt>clear</tt> operations.  It does not support the
 * <tt>add</tt> or <tt>addAll</tt> operations.
 *
 * @return {Set} a set view of the mappings contained in this map
 */
Map$1.prototype.entrySet = function () {};

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html
 *
 * @extends {Map}
 * @constructor
 * @private
 */
function SortedMap() {}
SortedMap.prototype = new Map$1();

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html
 *
 * @extends {Collection}
 * @constructor
 * @private
 */
function Set() {}
Set.prototype = new Collection();

/**
 * Returns true if this set contains the specified element. More formally,
 * returns true if and only if this set contains an element e such that (o==null ?
 * e==null : o.equals(e)).
 * @param {Object} e
 * @return {boolean}
 */
Set.prototype.contains = function () {};

/**
 * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html
 *
 * @extends {javascript.util.Set}
 * @constructor
 * @private
 */
function HashSet() {
  /**
   * @type {Array}
   * @private
  */
  this.array_ = [];

  if (arguments[0] instanceof Collection) {
    this.addAll(arguments[0]);
  }
}
HashSet.prototype = new Set();

/**
 * @override
 */
HashSet.prototype.contains = function (o) {
  for (var i = 0, len = this.array_.length; i < len; i++) {
    var e = this.array_[i];
    if (e === o) {
      return true;
    }
  }
  return false;
};

/**
 * @override
 */
HashSet.prototype.add = function (o) {
  if (this.contains(o)) {
    return false;
  }

  this.array_.push(o);

  return true;
};

/**
 * @override
 */
HashSet.prototype.addAll = function (c) {
  for (var i = c.iterator(); i.hasNext();) {
    this.add(i.next());
  }
  return true;
};

/**
 * @override
 */
HashSet.prototype.remove = function (o) {
  throw new javascript.util.OperationNotSupported();
};

/**
 * @override
 */
HashSet.prototype.size = function () {
  return this.array_.length;
};

/**
 * @override
 */
HashSet.prototype.isEmpty = function () {
  return this.array_.length === 0;
};

/**
 * @override
 */
HashSet.prototype.toArray = function () {
  var array = [];

  for (var i = 0, len = this.array_.length; i < len; i++) {
    array.push(this.array_[i]);
  }

  return array;
};

/**
 * @override
 */
HashSet.prototype.iterator = function () {
  return new Iterator_$1(this);
};

/**
 * @extends {Iterator}
 * @param {HashSet} hashSet
 * @constructor
 * @private
 */
var Iterator_$1 = function Iterator_(hashSet) {
  /**
   * @type {HashSet}
   * @private
   */
  this.hashSet_ = hashSet;
  /**
   * @type {number}
   * @private
   */
  this.position_ = 0;
};

/**
 * @override
 */
Iterator_$1.prototype.next = function () {
  if (this.position_ === this.hashSet_.size()) {
    throw new NoSuchElementException();
  }
  return this.hashSet_.array_[this.position_++];
};

/**
 * @override
 */
Iterator_$1.prototype.hasNext = function () {
  if (this.position_ < this.hashSet_.size()) {
    return true;
  } else {
    return false;
  }
};

/**
 * @override
 */
Iterator_$1.prototype.remove = function () {
  throw new OperationNotSupported();
};

var BLACK = 0;
var RED = 1;
function colorOf(p) {
  return p == null ? BLACK : p.color;
}
function parentOf(p) {
  return p == null ? null : p.parent;
}
function setColor(p, c) {
  if (p !== null) p.color = c;
}
function leftOf(p) {
  return p == null ? null : p.left;
}
function rightOf(p) {
  return p == null ? null : p.right;
}

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html
 *
 * @extends {SortedMap}
 * @constructor
 * @private
 */
function TreeMap() {
  /**
   * @type {Object}
   * @private
   */
  this.root_ = null;
  /**
   * @type {number}
   * @private
  */
  this.size_ = 0;
}
TreeMap.prototype = new SortedMap();

/**
 * @override
 */
TreeMap.prototype.get = function (key) {
  var p = this.root_;
  while (p !== null) {
    var cmp = key['compareTo'](p.key);
    if (cmp < 0) {
      p = p.left;
    } else if (cmp > 0) {
      p = p.right;
    } else {
      return p.value;
    }
  }
  return null;
};

/**
 * @override
 */
TreeMap.prototype.put = function (key, value) {
  if (this.root_ === null) {
    this.root_ = {
      key: key,
      value: value,
      left: null,
      right: null,
      parent: null,
      color: BLACK,
      getValue: function getValue() {
        return this.value;
      },
      getKey: function getKey() {
        return this.key;
      }
    };
    this.size_ = 1;
    return null;
  }
  var t = this.root_,
      parent,
      cmp;
  do {
    parent = t;
    cmp = key['compareTo'](t.key);
    if (cmp < 0) {
      t = t.left;
    } else if (cmp > 0) {
      t = t.right;
    } else {
      var oldValue = t.value;
      t.value = value;
      return oldValue;
    }
  } while (t !== null);
  var e = {
    key: key,
    left: null,
    right: null,
    value: value,
    parent: parent,
    color: BLACK,
    getValue: function getValue() {
      return this.value;
    },
    getKey: function getKey() {
      return this.key;
    }
  };
  if (cmp < 0) {
    parent.left = e;
  } else {
    parent.right = e;
  }
  this.fixAfterInsertion(e);
  this.size_++;
  return null;
};

/**
 * @param {Object} x
 */
TreeMap.prototype.fixAfterInsertion = function (x) {
  x.color = RED;
  while (x != null && x != this.root_ && x.parent.color == RED) {
    if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
      var y = rightOf(parentOf(parentOf(x)));
      if (colorOf(y) == RED) {
        setColor(parentOf(x), BLACK);
        setColor(y, BLACK);
        setColor(parentOf(parentOf(x)), RED);
        x = parentOf(parentOf(x));
      } else {
        if (x == rightOf(parentOf(x))) {
          x = parentOf(x);
          this.rotateLeft(x);
        }
        setColor(parentOf(x), BLACK);
        setColor(parentOf(parentOf(x)), RED);
        this.rotateRight(parentOf(parentOf(x)));
      }
    } else {
      var y = leftOf(parentOf(parentOf(x)));
      if (colorOf(y) == RED) {
        setColor(parentOf(x), BLACK);
        setColor(y, BLACK);
        setColor(parentOf(parentOf(x)), RED);
        x = parentOf(parentOf(x));
      } else {
        if (x == leftOf(parentOf(x))) {
          x = parentOf(x);
          this.rotateRight(x);
        }
        setColor(parentOf(x), BLACK);
        setColor(parentOf(parentOf(x)), RED);
        this.rotateLeft(parentOf(parentOf(x)));
      }
    }
  }
  this.root_.color = BLACK;
};

/**
 * @override
 */
TreeMap.prototype.values = function () {
  var arrayList = new ArrayList();
  var p = this.getFirstEntry();
  if (p !== null) {
    arrayList.add(p.value);
    while ((p = TreeMap.successor(p)) !== null) {
      arrayList.add(p.value);
    }
  }
  return arrayList;
};

/**
 * @override
 */
TreeMap.prototype.entrySet = function () {
  var hashSet = new HashSet();
  var p = this.getFirstEntry();
  if (p !== null) {
    hashSet.add(p);
    while ((p = TreeMap.successor(p)) !== null) {
      hashSet.add(p);
    }
  }
  return hashSet;
};

/**
 * @param {Object} p
 */
TreeMap.prototype.rotateLeft = function (p) {
  if (p != null) {
    var r = p.right;
    p.right = r.left;
    if (r.left != null) r.left.parent = p;
    r.parent = p.parent;
    if (p.parent == null) this.root_ = r;else if (p.parent.left == p) p.parent.left = r;else p.parent.right = r;
    r.left = p;
    p.parent = r;
  }
};

/**
 * @param {Object} p
 */
TreeMap.prototype.rotateRight = function (p) {
  if (p != null) {
    var l = p.left;
    p.left = l.right;
    if (l.right != null) l.right.parent = p;
    l.parent = p.parent;
    if (p.parent == null) this.root_ = l;else if (p.parent.right == p) p.parent.right = l;else p.parent.left = l;
    l.right = p;
    p.parent = l;
  }
};

/**
 * @return {Object}
 */
TreeMap.prototype.getFirstEntry = function () {
  var p = this.root_;
  if (p != null) {
    while (p.left != null) {
      p = p.left;
    }
  }
  return p;
};

/**
 * @param {Object} t
 * @return {Object}
 * @private
 */
TreeMap.successor = function (t) {
  if (t === null) return null;else if (t.right !== null) {
    var p = t.right;
    while (p.left !== null) {
      p = p.left;
    }
    return p;
  } else {
    var p = t.parent;
    var ch = t;
    while (p !== null && ch === p.right) {
      ch = p;
      p = p.parent;
    }
    return p;
  }
};

/**
 * @override
 */
TreeMap.prototype.size = function () {
  return this.size_;
};

function Lineal() {}
extend(Lineal.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Lineal;
	}
});

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html
 *
 * @extends {Set}
 * @constructor
 * @private
 */
function SortedSet() {}
SortedSet.prototype = new Set();

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html
 *
 * @extends {SortedSet}
 * @constructor
 * @private
 */
function TreeSet() {
  /**
   * @type {Array}
   * @private
  */
  this.array_ = [];

  if (arguments[0] instanceof Collection) {
    this.addAll(arguments[0]);
  }
}
TreeSet.prototype = new SortedSet();

/**
 * @override
 */
TreeSet.prototype.contains = function (o) {
  for (var i = 0, len = this.array_.length; i < len; i++) {
    var e = this.array_[i];
    if (e['compareTo'](o) === 0) {
      return true;
    }
  }
  return false;
};

/**
 * @override
 */
TreeSet.prototype.add = function (o) {
  if (this.contains(o)) {
    return false;
  }

  for (var i = 0, len = this.array_.length; i < len; i++) {
    var e = this.array_[i];
    if (e['compareTo'](o) === 1) {
      this.array_.splice(i, 0, o);
      return true;
    }
  }

  this.array_.push(o);

  return true;
};

/**
 * @override
 */
TreeSet.prototype.addAll = function (c) {
  for (var i = c.iterator(); i.hasNext();) {
    this.add(i.next());
  }
  return true;
};

/**
 * @override
 */
TreeSet.prototype.remove = function (e) {
  throw new OperationNotSupported();
};

/**
 * @override
 */
TreeSet.prototype.size = function () {
  return this.array_.length;
};

/**
 * @override
 */
TreeSet.prototype.isEmpty = function () {
  return this.array_.length === 0;
};

/**
 * @override
 */
TreeSet.prototype.toArray = function () {
  var array = [];

  for (var i = 0, len = this.array_.length; i < len; i++) {
    array.push(this.array_[i]);
  }

  return array;
};

/**
 * @override
 */
TreeSet.prototype.iterator = function () {
  return new Iterator_$2(this);
};

/**
 * @extends {javascript.util.Iterator}
 * @param {javascript.util.TreeSet} treeSet
 * @constructor
 * @private
 */
var Iterator_$2 = function Iterator_(treeSet) {
  /**
   * @type {javascript.util.TreeSet}
   * @private
   */
  this.treeSet_ = treeSet;
  /**
   * @type {number}
   * @private
   */
  this.position_ = 0;
};

/**
 * @override
 */
Iterator_$2.prototype.next = function () {
  if (this.position_ === this.treeSet_.size()) {
    throw new NoSuchElementException();
  }
  return this.treeSet_.array_[this.position_++];
};

/**
 * @override
 */
Iterator_$2.prototype.hasNext = function () {
  if (this.position_ < this.treeSet_.size()) {
    return true;
  } else {
    return false;
  }
};

/**
 * @override
 */
Iterator_$2.prototype.remove = function () {
  throw new OperationNotSupported();
};

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html
 *
 * @constructor
 * @private
 */
function Arrays() {}

/**
 */
Arrays.sort = function () {
  var a = arguments[0],
      i,
      t,
      comparator,
      compare;
  if (arguments.length === 1) {
    compare = function compare(a, b) {
      return a.compareTo(b);
    };
    a.sort(compare);
    return;
  } else if (arguments.length === 2) {
    comparator = arguments[1];
    compare = function compare(a, b) {
      return comparator['compare'](a, b);
    };
    a.sort(compare);
  } else if (arguments.length === 3) {
    t = a.slice(arguments[1], arguments[2]);
    t.sort();
    var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
    a.splice(0, a.length);
    for (i = 0; i < r.length; i++) {
      a.push(r[i]);
    }
    return;
  } else if (arguments.length === 4) {
    t = a.slice(arguments[1], arguments[2]);
    comparator = arguments[3];
    compare = function compare(a, b) {
      return comparator['compare'](a, b);
    };
    t.sort(compare);
    r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
    a.splice(0, a.length);
    for (i = 0; i < r.length; i++) {
      a.push(r[i]);
    }
    return;
  }
};

/**
 * @param {Array} array
 * @return {ArrayList}
 */
Arrays.asList = function (array) {
  var arrayList = new ArrayList();
  for (var i = 0, len = array.length; i < len; i++) {
    arrayList.add(array[i]);
  }
  return arrayList;
};

function Dimension() {}
extend(Dimension.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Dimension;
	}
});
Dimension.toDimensionSymbol = function (dimensionValue) {
	switch (dimensionValue) {
		case Dimension.FALSE:
			return Dimension.SYM_FALSE;
		case Dimension.TRUE:
			return Dimension.SYM_TRUE;
		case Dimension.DONTCARE:
			return Dimension.SYM_DONTCARE;
		case Dimension.P:
			return Dimension.SYM_P;
		case Dimension.L:
			return Dimension.SYM_L;
		case Dimension.A:
			return Dimension.SYM_A;
	}
	throw new IllegalArgumentException("Unknown dimension value: " + dimensionValue);
};
Dimension.toDimensionValue = function (dimensionSymbol) {
	switch (Character.toUpperCase(dimensionSymbol)) {
		case Dimension.SYM_FALSE:
			return Dimension.FALSE;
		case Dimension.SYM_TRUE:
			return Dimension.TRUE;
		case Dimension.SYM_DONTCARE:
			return Dimension.DONTCARE;
		case Dimension.SYM_P:
			return Dimension.P;
		case Dimension.SYM_L:
			return Dimension.L;
		case Dimension.SYM_A:
			return Dimension.A;
	}
	throw new IllegalArgumentException("Unknown dimension symbol: " + dimensionSymbol);
};
Dimension.P = 0;
Dimension.L = 1;
Dimension.A = 2;
Dimension.FALSE = -1;
Dimension.TRUE = -2;
Dimension.DONTCARE = -3;
Dimension.SYM_FALSE = 'F';
Dimension.SYM_TRUE = 'T';
Dimension.SYM_DONTCARE = '*';
Dimension.SYM_P = '0';
Dimension.SYM_L = '1';
Dimension.SYM_A = '2';

function GeometryFilter() {}
extend(GeometryFilter.prototype, {
	filter: function filter(geom) {},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return GeometryFilter;
	}
});

function CoordinateSequenceFilter() {}
extend(CoordinateSequenceFilter.prototype, {
	filter: function filter(seq, i) {},
	isDone: function isDone() {},
	isGeometryChanged: function isGeometryChanged() {},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return CoordinateSequenceFilter;
	}
});

function GeometryCollection() {
	this._geometries = null;
	var geometries = arguments[0],
	    factory = arguments[1];
	Geometry.call(this, factory);
	if (geometries === null) {
		geometries = [];
	}
	if (Geometry.hasNullElements(geometries)) {
		throw new IllegalArgumentException("geometries must not contain null elements");
	}
	this._geometries = geometries;
}
inherits(GeometryCollection, Geometry);
extend(GeometryCollection.prototype, {
	computeEnvelopeInternal: function computeEnvelopeInternal() {
		var envelope = new Envelope();
		for (var i = 0; i < this._geometries.length; i++) {
			envelope.expandToInclude(this._geometries[i].getEnvelopeInternal());
		}
		return envelope;
	},
	getGeometryN: function getGeometryN(n) {
		return this._geometries[n];
	},
	getCoordinates: function getCoordinates() {
		var coordinates = new Array(this.getNumPoints()).fill(null);
		var k = -1;
		for (var i = 0; i < this._geometries.length; i++) {
			var childCoordinates = this._geometries[i].getCoordinates();
			for (var j = 0; j < childCoordinates.length; j++) {
				k++;
				coordinates[k] = childCoordinates[j];
			}
		}
		return coordinates;
	},
	getArea: function getArea() {
		var area = 0.0;
		for (var i = 0; i < this._geometries.length; i++) {
			area += this._geometries[i].getArea();
		}
		return area;
	},
	equalsExact: function equalsExact() {
		if (arguments.length === 2 && typeof arguments[1] === "number" && arguments[0] instanceof Geometry) {
			var other = arguments[0],
			    tolerance = arguments[1];
			if (!this.isEquivalentClass(other)) {
				return false;
			}
			var otherCollection = other;
			if (this._geometries.length !== otherCollection._geometries.length) {
				return false;
			}
			for (var i = 0; i < this._geometries.length; i++) {
				if (!this._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {
					return false;
				}
			}
			return true;
		} else return Geometry.prototype.equalsExact.apply(this, arguments);
	},
	normalize: function normalize() {
		for (var i = 0; i < this._geometries.length; i++) {
			this._geometries[i].normalize();
		}
		Arrays.sort(this._geometries);
	},
	getCoordinate: function getCoordinate() {
		if (this.isEmpty()) return null;
		return this._geometries[0].getCoordinate();
	},
	getBoundaryDimension: function getBoundaryDimension() {
		var dimension = Dimension.FALSE;
		for (var i = 0; i < this._geometries.length; i++) {
			dimension = Math.max(dimension, this._geometries[i].getBoundaryDimension());
		}
		return dimension;
	},
	getTypeCode: function getTypeCode() {
		return Geometry.TYPECODE_GEOMETRYCOLLECTION;
	},
	getDimension: function getDimension() {
		var dimension = Dimension.FALSE;
		for (var i = 0; i < this._geometries.length; i++) {
			dimension = Math.max(dimension, this._geometries[i].getDimension());
		}
		return dimension;
	},
	getLength: function getLength() {
		var sum = 0.0;
		for (var i = 0; i < this._geometries.length; i++) {
			sum += this._geometries[i].getLength();
		}
		return sum;
	},
	getNumPoints: function getNumPoints() {
		var numPoints = 0;
		for (var i = 0; i < this._geometries.length; i++) {
			numPoints += this._geometries[i].getNumPoints();
		}
		return numPoints;
	},
	getNumGeometries: function getNumGeometries() {
		return this._geometries.length;
	},
	reverse: function reverse() {
		var n = this._geometries.length;
		var revGeoms = new Array(n).fill(null);
		for (var i = 0; i < this._geometries.length; i++) {
			revGeoms[i] = this._geometries[i].reverse();
		}
		return this.getFactory().createGeometryCollection(revGeoms);
	},
	compareToSameClass: function compareToSameClass() {
		if (arguments.length === 1) {
			var o = arguments[0];
			var theseElements = new TreeSet(Arrays.asList(this._geometries));
			var otherElements = new TreeSet(Arrays.asList(o._geometries));
			return this.compare(theseElements, otherElements);
		} else if (arguments.length === 2) {
			var _o = arguments[0],
			    comp = arguments[1];
			var gc = _o;
			var n1 = this.getNumGeometries();
			var n2 = gc.getNumGeometries();
			var i = 0;
			while (i < n1 && i < n2) {
				var thisGeom = this.getGeometryN(i);
				var otherGeom = gc.getGeometryN(i);
				var holeComp = thisGeom.compareToSameClass(otherGeom, comp);
				if (holeComp !== 0) return holeComp;
				i++;
			}
			if (i < n1) return 1;
			if (i < n2) return -1;
			return 0;
		}
	},
	apply: function apply() {
		if (hasInterface(arguments[0], CoordinateFilter)) {
			var filter = arguments[0];
			for (var i = 0; i < this._geometries.length; i++) {
				this._geometries[i].apply(filter);
			}
		} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
			var _filter = arguments[0];
			if (this._geometries.length === 0) return null;
			for (var i = 0; i < this._geometries.length; i++) {
				this._geometries[i].apply(_filter);
				if (_filter.isDone()) {
					break;
				}
			}
			if (_filter.isGeometryChanged()) this.geometryChanged();
		} else if (hasInterface(arguments[0], GeometryFilter)) {
			var _filter2 = arguments[0];
			_filter2.filter(this);
			for (var i = 0; i < this._geometries.length; i++) {
				this._geometries[i].apply(_filter2);
			}
		} else if (hasInterface(arguments[0], GeometryComponentFilter)) {
			var _filter3 = arguments[0];
			_filter3.filter(this);
			for (var i = 0; i < this._geometries.length; i++) {
				this._geometries[i].apply(_filter3);
			}
		}
	},
	getBoundary: function getBoundary() {
		this.checkNotGeometryCollection(this);
		Assert.shouldNeverReachHere();
		return null;
	},
	getGeometryType: function getGeometryType() {
		return Geometry.TYPENAME_GEOMETRYCOLLECTION;
	},
	copy: function copy() {
		var geometries = new Array(this._geometries.length).fill(null);
		for (var i = 0; i < geometries.length; i++) {
			geometries[i] = this._geometries[i].copy();
		}
		return new GeometryCollection(geometries, this._factory);
	},
	isEmpty: function isEmpty() {
		for (var i = 0; i < this._geometries.length; i++) {
			if (!this._geometries[i].isEmpty()) {
				return false;
			}
		}
		return true;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return GeometryCollection;
	}
});
GeometryCollection.serialVersionUID = -5694727726395021467;

function MultiLineString() {
	var lineStrings = arguments[0],
	    factory = arguments[1];
	GeometryCollection.call(this, lineStrings, factory);
}
inherits(MultiLineString, GeometryCollection);
extend(MultiLineString.prototype, {
	equalsExact: function equalsExact() {
		if (arguments.length === 2 && typeof arguments[1] === "number" && arguments[0] instanceof Geometry) {
			var other = arguments[0],
			    tolerance = arguments[1];
			if (!this.isEquivalentClass(other)) {
				return false;
			}
			return GeometryCollection.prototype.equalsExact.call(this, other, tolerance);
		} else return GeometryCollection.prototype.equalsExact.apply(this, arguments);
	},
	getBoundaryDimension: function getBoundaryDimension() {
		if (this.isClosed()) {
			return Dimension.FALSE;
		}
		return 0;
	},
	isClosed: function isClosed() {
		if (this.isEmpty()) {
			return false;
		}
		for (var i = 0; i < this._geometries.length; i++) {
			if (!this._geometries[i].isClosed()) {
				return false;
			}
		}
		return true;
	},
	getTypeCode: function getTypeCode() {
		return Geometry.TYPECODE_MULTILINESTRING;
	},
	getDimension: function getDimension() {
		return 1;
	},
	reverse: function reverse() {
		var nLines = this._geometries.length;
		var revLines = new Array(nLines).fill(null);
		for (var i = 0; i < this._geometries.length; i++) {
			revLines[nLines - 1 - i] = this._geometries[i].reverse();
		}
		return this.getFactory().createMultiLineString(revLines);
	},
	getBoundary: function getBoundary() {
		return new BoundaryOp(this).getBoundary();
	},
	getGeometryType: function getGeometryType() {
		return Geometry.TYPENAME_MULTILINESTRING;
	},
	copy: function copy() {
		var lineStrings = new Array(this._geometries.length).fill(null);
		for (var i = 0; i < lineStrings.length; i++) {
			lineStrings[i] = this._geometries[i].copy();
		}
		return new MultiLineString(lineStrings, this._factory);
	},
	interfaces_: function interfaces_() {
		return [Lineal];
	},
	getClass: function getClass() {
		return MultiLineString;
	}
});
MultiLineString.serialVersionUID = 8166665132445433741;

function BoundaryOp() {
	this._geom = null;
	this._geomFact = null;
	this._bnRule = null;
	this._endpointMap = null;
	if (arguments.length === 1) {
		var geom = arguments[0];
		BoundaryOp.call(this, geom, BoundaryNodeRule.MOD2_BOUNDARY_RULE);
	} else if (arguments.length === 2) {
		var _geom = arguments[0],
		    bnRule = arguments[1];
		this._geom = _geom;
		this._geomFact = _geom.getFactory();
		this._bnRule = bnRule;
	}
}
extend(BoundaryOp.prototype, {
	boundaryMultiLineString: function boundaryMultiLineString(mLine) {
		if (this._geom.isEmpty()) {
			return this.getEmptyMultiPoint();
		}
		var bdyPts = this.computeBoundaryCoordinates(mLine);
		if (bdyPts.length === 1) {
			return this._geomFact.createPoint(bdyPts[0]);
		}
		return this._geomFact.createMultiPointFromCoords(bdyPts);
	},
	getBoundary: function getBoundary() {
		if (this._geom instanceof LineString) return this.boundaryLineString(this._geom);
		if (this._geom instanceof MultiLineString) return this.boundaryMultiLineString(this._geom);
		return this._geom.getBoundary();
	},
	boundaryLineString: function boundaryLineString(line) {
		if (this._geom.isEmpty()) {
			return this.getEmptyMultiPoint();
		}
		if (line.isClosed()) {
			var closedEndpointOnBoundary = this._bnRule.isInBoundary(2);
			if (closedEndpointOnBoundary) {
				return line.getStartPoint();
			} else {
				return this._geomFact.createMultiPoint();
			}
		}
		return this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()]);
	},
	getEmptyMultiPoint: function getEmptyMultiPoint() {
		return this._geomFact.createMultiPoint();
	},
	computeBoundaryCoordinates: function computeBoundaryCoordinates(mLine) {
		var bdyPts = new ArrayList();
		this._endpointMap = new TreeMap();
		for (var i = 0; i < mLine.getNumGeometries(); i++) {
			var line = mLine.getGeometryN(i);
			if (line.getNumPoints() === 0) continue;
			this.addEndpoint(line.getCoordinateN(0));
			this.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));
		}
		for (var it = this._endpointMap.entrySet().iterator(); it.hasNext();) {
			var entry = it.next();
			var counter = entry.getValue();
			var valence = counter.count;
			if (this._bnRule.isInBoundary(valence)) {
				bdyPts.add(entry.getKey());
			}
		}
		return CoordinateArrays.toCoordinateArray(bdyPts);
	},
	addEndpoint: function addEndpoint(pt) {
		var counter = this._endpointMap.get(pt);
		if (counter === null) {
			counter = new Counter();
			this._endpointMap.put(pt, counter);
		}
		counter.count++;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return BoundaryOp;
	}
});
BoundaryOp.getBoundary = function () {
	if (arguments.length === 1) {
		var g = arguments[0];
		var bop = new BoundaryOp(g);
		return bop.getBoundary();
	} else if (arguments.length === 2) {
		var _g = arguments[0],
		    bnRule = arguments[1];
		var bop = new BoundaryOp(_g, bnRule);
		return bop.getBoundary();
	}
};
function Counter() {
	this.count = null;
}
extend(Counter.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Counter;
	}
});

function Length() {}
extend(Length.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Length;
	}
});
Length.ofLine = function (pts) {
	var n = pts.size();
	if (n <= 1) return 0.0;
	var len = 0.0;
	var p = new Coordinate();
	pts.getCoordinate(0, p);
	var x0 = p.x;
	var y0 = p.y;
	for (var i = 1; i < n; i++) {
		pts.getCoordinate(i, p);
		var x1 = p.x;
		var y1 = p.y;
		var dx = x1 - x0;
		var dy = y1 - y0;
		len += Math.sqrt(dx * dx + dy * dy);
		x0 = x1;
		y0 = y1;
	}
	return len;
};

function PrintStream() {}

function StringReader() {}

function DecimalFormat() {}

function ByteArrayOutputStream() {}

function IOException() {}

function LineNumberReader() {}

function StringUtil() {}
extend(StringUtil.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return StringUtil;
	}
});
StringUtil.chars = function (c, n) {
	var ch = new Array(n).fill(null);
	for (var i = 0; i < n; i++) {
		ch[i] = c;
	}
	return new String(ch);
};
StringUtil.getStackTrace = function () {
	if (arguments.length === 1) {
		var t = arguments[0];
		var os = new ByteArrayOutputStream();
		var ps = new PrintStream(os);
		t.printStackTrace(ps);
		return os.toString();
	} else if (arguments.length === 2) {
		var _t = arguments[0],
		    depth = arguments[1];
		var stackTrace = "";
		var stringReader = new StringReader(StringUtil.getStackTrace(_t));
		var lineNumberReader = new LineNumberReader(stringReader);
		for (var i = 0; i < depth; i++) {
			try {
				stackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;
			} catch (e) {
				if (e instanceof IOException) {
					Assert.shouldNeverReachHere();
				} else throw e;
			} finally {}
		}
		return stackTrace;
	}
};
StringUtil.split = function (s, separator) {
	var separatorlen = separator.length;
	var tokenList = new ArrayList();
	var tmpString = "" + s;
	var pos = tmpString.indexOf(separator);
	while (pos >= 0) {
		var token = tmpString.substring(0, pos);
		tokenList.add(token);
		tmpString = tmpString.substring(pos + separatorlen);
		pos = tmpString.indexOf(separator);
	}
	if (tmpString.length > 0) tokenList.add(tmpString);
	var res = new Array(tokenList.size()).fill(null);
	for (var i = 0; i < res.length; i++) {
		res[i] = tokenList.get(i);
	}
	return res;
};
StringUtil.toString = function () {
	if (arguments.length === 1 && typeof arguments[0] === "number") {
		var d = arguments[0];
		return StringUtil.SIMPLE_ORDINATE_FORMAT.format(d);
	}
};
StringUtil.spaces = function (n) {
	return StringUtil.chars(' ', n);
};
StringUtil.NEWLINE = System.getProperty("line.separator");
StringUtil.SIMPLE_ORDINATE_FORMAT = new DecimalFormat("0.#");

function StringBuilder(str) {
  this.str = str;
}

StringBuilder.prototype.append = function (e) {
  this.str += e;
};

StringBuilder.prototype.setCharAt = function (i, c) {
  this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);
};

StringBuilder.prototype.toString = function (e) {
  return this.str;
};

function CoordinateSequences() {}
extend(CoordinateSequences.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return CoordinateSequences;
	}
});
CoordinateSequences.copyCoord = function (src, srcPos, dest, destPos) {
	var minDim = Math.min(src.getDimension(), dest.getDimension());
	for (var dim = 0; dim < minDim; dim++) {
		dest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));
	}
};
CoordinateSequences.isRing = function (seq) {
	var n = seq.size();
	if (n === 0) return true;
	if (n <= 3) return false;
	return seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);
};
CoordinateSequences.isEqual = function (cs1, cs2) {
	var cs1Size = cs1.size();
	var cs2Size = cs2.size();
	if (cs1Size !== cs2Size) return false;
	var dim = Math.min(cs1.getDimension(), cs2.getDimension());
	for (var i = 0; i < cs1Size; i++) {
		for (var d = 0; d < dim; d++) {
			var v1 = cs1.getOrdinate(i, d);
			var v2 = cs2.getOrdinate(i, d);
			if (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) continue;
			if (Double.isNaN(v1) && Double.isNaN(v2)) continue;
			return false;
		}
	}
	return true;
};
CoordinateSequences.extend = function (fact, seq, size) {
	var newseq = fact.create(size, seq.getDimension());
	var n = seq.size();
	CoordinateSequences.copy(seq, 0, newseq, 0, n);
	if (n > 0) {
		for (var i = n; i < size; i++) {
			CoordinateSequences.copy(seq, n - 1, newseq, i, 1);
		}
	}
	return newseq;
};
CoordinateSequences.reverse = function (seq) {
	var last = seq.size() - 1;
	var mid = Math.trunc(last / 2);
	for (var i = 0; i <= mid; i++) {
		CoordinateSequences.swap(seq, i, last - i);
	}
};
CoordinateSequences.swap = function (seq, i, j) {
	if (i === j) return null;
	for (var dim = 0; dim < seq.getDimension(); dim++) {
		var tmp = seq.getOrdinate(i, dim);
		seq.setOrdinate(i, dim, seq.getOrdinate(j, dim));
		seq.setOrdinate(j, dim, tmp);
	}
};
CoordinateSequences.copy = function (src, srcPos, dest, destPos, length) {
	for (var i = 0; i < length; i++) {
		CoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);
	}
};
CoordinateSequences.toString = function () {
	if (arguments.length === 1 && hasInterface(arguments[0], CoordinateSequence)) {
		var cs = arguments[0];
		var size = cs.size();
		if (size === 0) return "()";
		var dim = cs.getDimension();
		var builder = new StringBuilder();
		builder.append('(');
		for (var i = 0; i < size; i++) {
			if (i > 0) builder.append(" ");
			for (var d = 0; d < dim; d++) {
				if (d > 0) builder.append(",");
				builder.append(StringUtil.toString(cs.getOrdinate(i, d)));
			}
		}
		builder.append(')');
		return builder.toString();
	}
};
CoordinateSequences.ensureValidRing = function (fact, seq) {
	var n = seq.size();
	if (n === 0) return seq;
	if (n <= 3) return CoordinateSequences.createClosedRing(fact, seq, 4);
	var isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);
	if (isClosed) return seq;
	return CoordinateSequences.createClosedRing(fact, seq, n + 1);
};
CoordinateSequences.createClosedRing = function (fact, seq, size) {
	var newseq = fact.create(size, seq.getDimension());
	var n = seq.size();
	CoordinateSequences.copy(seq, 0, newseq, 0, n);
	for (var i = n; i < size; i++) {
		CoordinateSequences.copy(seq, 0, newseq, i, 1);
	}return newseq;
};

function LineString() {
	this._points = null;
	var points = arguments[0],
	    factory = arguments[1];
	Geometry.call(this, factory);
	this.init(points);
}
inherits(LineString, Geometry);
extend(LineString.prototype, {
	computeEnvelopeInternal: function computeEnvelopeInternal() {
		if (this.isEmpty()) {
			return new Envelope();
		}
		return this._points.expandEnvelope(new Envelope());
	},
	isRing: function isRing() {
		return this.isClosed() && this.isSimple();
	},
	getCoordinates: function getCoordinates() {
		return this._points.toCoordinateArray();
	},
	equalsExact: function equalsExact() {
		if (arguments.length === 2 && typeof arguments[1] === "number" && arguments[0] instanceof Geometry) {
			var other = arguments[0],
			    tolerance = arguments[1];
			if (!this.isEquivalentClass(other)) {
				return false;
			}
			var otherLineString = other;
			if (this._points.size() !== otherLineString._points.size()) {
				return false;
			}
			for (var i = 0; i < this._points.size(); i++) {
				if (!this.equal(this._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {
					return false;
				}
			}
			return true;
		} else return Geometry.prototype.equalsExact.apply(this, arguments);
	},
	normalize: function normalize() {
		for (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {
			var j = this._points.size() - 1 - i;
			if (!this._points.getCoordinate(i).equals(this._points.getCoordinate(j))) {
				if (this._points.getCoordinate(i).compareTo(this._points.getCoordinate(j)) > 0) {
					var copy = this._points.copy();
					CoordinateSequences.reverse(copy);
					this._points = copy;
				}
				return null;
			}
		}
	},
	getCoordinate: function getCoordinate() {
		if (this.isEmpty()) return null;
		return this._points.getCoordinate(0);
	},
	getBoundaryDimension: function getBoundaryDimension() {
		if (this.isClosed()) {
			return Dimension.FALSE;
		}
		return 0;
	},
	isClosed: function isClosed() {
		if (this.isEmpty()) {
			return false;
		}
		return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
	},
	getEndPoint: function getEndPoint() {
		if (this.isEmpty()) {
			return null;
		}
		return this.getPointN(this.getNumPoints() - 1);
	},
	getTypeCode: function getTypeCode() {
		return Geometry.TYPECODE_LINESTRING;
	},
	getDimension: function getDimension() {
		return 1;
	},
	getLength: function getLength() {
		return Length.ofLine(this._points);
	},
	getNumPoints: function getNumPoints() {
		return this._points.size();
	},
	reverse: function reverse() {
		var seq = this._points.copy();
		CoordinateSequences.reverse(seq);
		var revLine = this.getFactory().createLineString(seq);
		return revLine;
	},
	compareToSameClass: function compareToSameClass() {
		if (arguments.length === 1) {
			var o = arguments[0];
			var line = o;
			var i = 0;
			var j = 0;
			while (i < this._points.size() && j < line._points.size()) {
				var comparison = this._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));
				if (comparison !== 0) {
					return comparison;
				}
				i++;
				j++;
			}
			if (i < this._points.size()) {
				return 1;
			}
			if (j < line._points.size()) {
				return -1;
			}
			return 0;
		} else if (arguments.length === 2) {
			var _o = arguments[0],
			    comp = arguments[1];
			var line = _o;
			return comp.compare(this._points, line._points);
		}
	},
	apply: function apply() {
		if (hasInterface(arguments[0], CoordinateFilter)) {
			var filter = arguments[0];
			for (var i = 0; i < this._points.size(); i++) {
				filter.filter(this._points.getCoordinate(i));
			}
		} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
			var _filter = arguments[0];
			if (this._points.size() === 0) return null;
			for (var i = 0; i < this._points.size(); i++) {
				_filter.filter(this._points, i);
				if (_filter.isDone()) break;
			}
			if (_filter.isGeometryChanged()) this.geometryChanged();
		} else if (hasInterface(arguments[0], GeometryFilter)) {
			var _filter2 = arguments[0];
			_filter2.filter(this);
		} else if (hasInterface(arguments[0], GeometryComponentFilter)) {
			var _filter3 = arguments[0];
			_filter3.filter(this);
		}
	},
	getBoundary: function getBoundary() {
		return new BoundaryOp(this).getBoundary();
	},
	isEquivalentClass: function isEquivalentClass(other) {
		return other instanceof LineString;
	},
	getCoordinateN: function getCoordinateN(n) {
		return this._points.getCoordinate(n);
	},
	getGeometryType: function getGeometryType() {
		return Geometry.TYPENAME_LINESTRING;
	},
	copy: function copy() {
		return new LineString(this._points.copy(), this._factory);
	},
	getCoordinateSequence: function getCoordinateSequence() {
		return this._points;
	},
	isEmpty: function isEmpty() {
		return this._points.size() === 0;
	},
	init: function init(points) {
		if (points === null) {
			points = this.getFactory().getCoordinateSequenceFactory().create([]);
		}
		if (points.size() === 1) {
			throw new IllegalArgumentException("Invalid number of points in LineString (found " + points.size() + " - must be 0 or >= 2)");
		}
		this._points = points;
	},
	isCoordinate: function isCoordinate(pt) {
		for (var i = 0; i < this._points.size(); i++) {
			if (this._points.getCoordinate(i).equals(pt)) {
				return true;
			}
		}
		return false;
	},
	getStartPoint: function getStartPoint() {
		if (this.isEmpty()) {
			return null;
		}
		return this.getPointN(0);
	},
	getPointN: function getPointN(n) {
		return this.getFactory().createPoint(this._points.getCoordinate(n));
	},
	interfaces_: function interfaces_() {
		return [Lineal];
	},
	getClass: function getClass() {
		return LineString;
	}
});
LineString.serialVersionUID = 3110669828065365560;

function Puntal() {}
extend(Puntal.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Puntal;
	}
});

function Point() {
	this._coordinates = null;
	var coordinates = arguments[0],
	    factory = arguments[1];
	Geometry.call(this, factory);
	this.init(coordinates);
}
inherits(Point, Geometry);
extend(Point.prototype, {
	computeEnvelopeInternal: function computeEnvelopeInternal() {
		if (this.isEmpty()) {
			return new Envelope();
		}
		var env = new Envelope();
		env.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));
		return env;
	},
	getCoordinates: function getCoordinates() {
		return this.isEmpty() ? [] : [this.getCoordinate()];
	},
	equalsExact: function equalsExact() {
		if (arguments.length === 2 && typeof arguments[1] === "number" && arguments[0] instanceof Geometry) {
			var other = arguments[0],
			    tolerance = arguments[1];
			if (!this.isEquivalentClass(other)) {
				return false;
			}
			if (this.isEmpty() && other.isEmpty()) {
				return true;
			}
			if (this.isEmpty() !== other.isEmpty()) {
				return false;
			}
			return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);
		} else return Geometry.prototype.equalsExact.apply(this, arguments);
	},
	normalize: function normalize() {},
	getCoordinate: function getCoordinate() {
		return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;
	},
	getBoundaryDimension: function getBoundaryDimension() {
		return Dimension.FALSE;
	},
	getTypeCode: function getTypeCode() {
		return Geometry.TYPECODE_POINT;
	},
	getDimension: function getDimension() {
		return 0;
	},
	getNumPoints: function getNumPoints() {
		return this.isEmpty() ? 0 : 1;
	},
	reverse: function reverse() {
		return this.copy();
	},
	getX: function getX() {
		if (this.getCoordinate() === null) {
			throw new IllegalStateException("getX called on empty Point");
		}
		return this.getCoordinate().x;
	},
	compareToSameClass: function compareToSameClass() {
		if (arguments.length === 1) {
			var other = arguments[0];
			var point = other;
			return this.getCoordinate().compareTo(point.getCoordinate());
		} else if (arguments.length === 2) {
			var _other = arguments[0],
			    comp = arguments[1];
			var point = _other;
			return comp.compare(this._coordinates, point._coordinates);
		}
	},
	apply: function apply() {
		if (hasInterface(arguments[0], CoordinateFilter)) {
			var filter = arguments[0];
			if (this.isEmpty()) {
				return null;
			}
			filter.filter(this.getCoordinate());
		} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
			var _filter = arguments[0];
			if (this.isEmpty()) return null;
			_filter.filter(this._coordinates, 0);
			if (_filter.isGeometryChanged()) this.geometryChanged();
		} else if (hasInterface(arguments[0], GeometryFilter)) {
			var _filter2 = arguments[0];
			_filter2.filter(this);
		} else if (hasInterface(arguments[0], GeometryComponentFilter)) {
			var _filter3 = arguments[0];
			_filter3.filter(this);
		}
	},
	getBoundary: function getBoundary() {
		return this.getFactory().createGeometryCollection();
	},
	getGeometryType: function getGeometryType() {
		return Geometry.TYPENAME_POINT;
	},
	copy: function copy() {
		return new Point(this._coordinates.copy(), this._factory);
	},
	getCoordinateSequence: function getCoordinateSequence() {
		return this._coordinates;
	},
	getY: function getY() {
		if (this.getCoordinate() === null) {
			throw new IllegalStateException("getY called on empty Point");
		}
		return this.getCoordinate().y;
	},
	isEmpty: function isEmpty() {
		return this._coordinates.size() === 0;
	},
	init: function init(coordinates) {
		if (coordinates === null) {
			coordinates = this.getFactory().getCoordinateSequenceFactory().create([]);
		}
		Assert.isTrue(coordinates.size() <= 1);
		this._coordinates = coordinates;
	},
	isSimple: function isSimple() {
		return true;
	},
	interfaces_: function interfaces_() {
		return [Puntal];
	},
	getClass: function getClass() {
		return Point;
	}
});
Point.serialVersionUID = 4902022702746614570;

function Area() {}
extend(Area.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Area;
	}
});
Area.ofRing = function () {
	if (arguments[0] instanceof Array) {
		var ring = arguments[0];
		return Math.abs(Area.ofRingSigned(ring));
	} else if (hasInterface(arguments[0], CoordinateSequence)) {
		var _ring = arguments[0];
		return Math.abs(Area.ofRingSigned(_ring));
	}
};
Area.ofRingSigned = function () {
	if (arguments[0] instanceof Array) {
		var ring = arguments[0];
		if (ring.length < 3) return 0.0;
		var sum = 0.0;
		var x0 = ring[0].x;
		for (var i = 1; i < ring.length - 1; i++) {
			var x = ring[i].x - x0;
			var y1 = ring[i + 1].y;
			var y2 = ring[i - 1].y;
			sum += x * (y2 - y1);
		}
		return sum / 2.0;
	} else if (hasInterface(arguments[0], CoordinateSequence)) {
		var _ring2 = arguments[0];
		var n = _ring2.size();
		if (n < 3) return 0.0;
		var p0 = new Coordinate();
		var p1 = new Coordinate();
		var p2 = new Coordinate();
		_ring2.getCoordinate(0, p1);
		_ring2.getCoordinate(1, p2);
		var x0 = p1.x;
		p2.x -= x0;
		var sum = 0.0;
		for (var i = 1; i < n - 1; i++) {
			p0.y = p1.y;
			p1.x = p2.x;
			p1.y = p2.y;
			_ring2.getCoordinate(i + 1, p2);
			p2.x -= x0;
			sum += p1.x * (p0.y - p2.y);
		}
		return sum / 2.0;
	}
};

function Polygonal() {}
extend(Polygonal.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Polygonal;
	}
});

function Polygon() {
	this._shell = null;
	this._holes = null;
	var shell = arguments[0],
	    holes = arguments[1],
	    factory = arguments[2];
	Geometry.call(this, factory);
	if (shell === null) {
		shell = this.getFactory().createLinearRing();
	}
	if (holes === null) {
		holes = [];
	}
	if (Geometry.hasNullElements(holes)) {
		throw new IllegalArgumentException("holes must not contain null elements");
	}
	if (shell.isEmpty() && Geometry.hasNonEmptyElements(holes)) {
		throw new IllegalArgumentException("shell is empty but holes are not");
	}
	this._shell = shell;
	this._holes = holes;
}
inherits(Polygon, Geometry);
extend(Polygon.prototype, {
	computeEnvelopeInternal: function computeEnvelopeInternal() {
		return this._shell.getEnvelopeInternal();
	},
	getCoordinates: function getCoordinates() {
		if (this.isEmpty()) {
			return [];
		}
		var coordinates = new Array(this.getNumPoints()).fill(null);
		var k = -1;
		var shellCoordinates = this._shell.getCoordinates();
		for (var x = 0; x < shellCoordinates.length; x++) {
			k++;
			coordinates[k] = shellCoordinates[x];
		}
		for (var i = 0; i < this._holes.length; i++) {
			var childCoordinates = this._holes[i].getCoordinates();
			for (var j = 0; j < childCoordinates.length; j++) {
				k++;
				coordinates[k] = childCoordinates[j];
			}
		}
		return coordinates;
	},
	getArea: function getArea() {
		var area = 0.0;
		area += Area.ofRing(this._shell.getCoordinateSequence());
		for (var i = 0; i < this._holes.length; i++) {
			area -= Area.ofRing(this._holes[i].getCoordinateSequence());
		}
		return area;
	},
	isRectangle: function isRectangle() {
		if (this.getNumInteriorRing() !== 0) return false;
		if (this._shell === null) return false;
		if (this._shell.getNumPoints() !== 5) return false;
		var seq = this._shell.getCoordinateSequence();
		var env = this.getEnvelopeInternal();
		for (var i = 0; i < 5; i++) {
			var x = seq.getX(i);
			if (!(x === env.getMinX() || x === env.getMaxX())) return false;
			var y = seq.getY(i);
			if (!(y === env.getMinY() || y === env.getMaxY())) return false;
		}
		var prevX = seq.getX(0);
		var prevY = seq.getY(0);
		for (var i = 1; i <= 4; i++) {
			var x = seq.getX(i);
			var y = seq.getY(i);
			var xChanged = x !== prevX;
			var yChanged = y !== prevY;
			if (xChanged === yChanged) return false;
			prevX = x;
			prevY = y;
		}
		return true;
	},
	equalsExact: function equalsExact() {
		if (arguments.length === 2 && typeof arguments[1] === "number" && arguments[0] instanceof Geometry) {
			var other = arguments[0],
			    tolerance = arguments[1];
			if (!this.isEquivalentClass(other)) {
				return false;
			}
			var otherPolygon = other;
			var thisShell = this._shell;
			var otherPolygonShell = otherPolygon._shell;
			if (!thisShell.equalsExact(otherPolygonShell, tolerance)) {
				return false;
			}
			if (this._holes.length !== otherPolygon._holes.length) {
				return false;
			}
			for (var i = 0; i < this._holes.length; i++) {
				if (!this._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {
					return false;
				}
			}
			return true;
		} else return Geometry.prototype.equalsExact.apply(this, arguments);
	},
	normalize: function normalize() {
		if (arguments.length === 0) {
			this.normalize(this._shell, true);
			for (var i = 0; i < this._holes.length; i++) {
				this.normalize(this._holes[i], false);
			}
			Arrays.sort(this._holes);
		} else if (arguments.length === 2) {
			var ring = arguments[0],
			    clockwise = arguments[1];
			if (ring.isEmpty()) {
				return null;
			}
			var uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);
			System.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);
			var minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());
			CoordinateArrays.scroll(uniqueCoordinates, minCoordinate);
			System.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);
			ring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];
			if (Orientation.isCCW(ring.getCoordinates()) === clockwise) {
				CoordinateArrays.reverse(ring.getCoordinates());
			}
		}
	},
	getCoordinate: function getCoordinate() {
		return this._shell.getCoordinate();
	},
	getNumInteriorRing: function getNumInteriorRing() {
		return this._holes.length;
	},
	getBoundaryDimension: function getBoundaryDimension() {
		return 1;
	},
	getTypeCode: function getTypeCode() {
		return Geometry.TYPECODE_POLYGON;
	},
	getDimension: function getDimension() {
		return 2;
	},
	getLength: function getLength() {
		var len = 0.0;
		len += this._shell.getLength();
		for (var i = 0; i < this._holes.length; i++) {
			len += this._holes[i].getLength();
		}
		return len;
	},
	getNumPoints: function getNumPoints() {
		var numPoints = this._shell.getNumPoints();
		for (var i = 0; i < this._holes.length; i++) {
			numPoints += this._holes[i].getNumPoints();
		}
		return numPoints;
	},
	reverse: function reverse() {
		var poly = this.copy();
		poly._shell = this._shell.copy().reverse();
		poly._holes = new Array(this._holes.length).fill(null);
		for (var i = 0; i < this._holes.length; i++) {
			poly._holes[i] = this._holes[i].copy().reverse();
		}
		return poly;
	},
	convexHull: function convexHull() {
		return this.getExteriorRing().convexHull();
	},
	compareToSameClass: function compareToSameClass() {
		if (arguments.length === 1) {
			var o = arguments[0];
			var thisShell = this._shell;
			var otherShell = o._shell;
			return thisShell.compareToSameClass(otherShell);
		} else if (arguments.length === 2) {
			var _o = arguments[0],
			    comp = arguments[1];
			var poly = _o;
			var thisShell = this._shell;
			var otherShell = poly._shell;
			var shellComp = thisShell.compareToSameClass(otherShell, comp);
			if (shellComp !== 0) return shellComp;
			var nHole1 = this.getNumInteriorRing();
			var nHole2 = poly.getNumInteriorRing();
			var i = 0;
			while (i < nHole1 && i < nHole2) {
				var thisHole = this.getInteriorRingN(i);
				var otherHole = poly.getInteriorRingN(i);
				var holeComp = thisHole.compareToSameClass(otherHole, comp);
				if (holeComp !== 0) return holeComp;
				i++;
			}
			if (i < nHole1) return 1;
			if (i < nHole2) return -1;
			return 0;
		}
	},
	apply: function apply() {
		if (hasInterface(arguments[0], CoordinateFilter)) {
			var filter = arguments[0];
			this._shell.apply(filter);
			for (var i = 0; i < this._holes.length; i++) {
				this._holes[i].apply(filter);
			}
		} else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {
			var _filter = arguments[0];
			this._shell.apply(_filter);
			if (!_filter.isDone()) {
				for (var i = 0; i < this._holes.length; i++) {
					this._holes[i].apply(_filter);
					if (_filter.isDone()) break;
				}
			}
			if (_filter.isGeometryChanged()) this.geometryChanged();
		} else if (hasInterface(arguments[0], GeometryFilter)) {
			var _filter2 = arguments[0];
			_filter2.filter(this);
		} else if (hasInterface(arguments[0], GeometryComponentFilter)) {
			var _filter3 = arguments[0];
			_filter3.filter(this);
			this._shell.apply(_filter3);
			for (var i = 0; i < this._holes.length; i++) {
				this._holes[i].apply(_filter3);
			}
		}
	},
	getBoundary: function getBoundary() {
		if (this.isEmpty()) {
			return this.getFactory().createMultiLineString();
		}
		var rings = new Array(this._holes.length + 1).fill(null);
		rings[0] = this._shell;
		for (var i = 0; i < this._holes.length; i++) {
			rings[i + 1] = this._holes[i];
		}
		if (rings.length <= 1) return this.getFactory().createLinearRing(rings[0].getCoordinateSequence());
		return this.getFactory().createMultiLineString(rings);
	},
	getGeometryType: function getGeometryType() {
		return Geometry.TYPENAME_POLYGON;
	},
	copy: function copy() {
		var shellCopy = this._shell.copy();
		var holeCopies = new Array(this._holes.length).fill(null);
		for (var i = 0; i < this._holes.length; i++) {
			holeCopies[i] = this._holes[i].copy();
		}
		return new Polygon(shellCopy, holeCopies, this._factory);
	},
	getExteriorRing: function getExteriorRing() {
		return this._shell;
	},
	isEmpty: function isEmpty() {
		return this._shell.isEmpty();
	},
	getInteriorRingN: function getInteriorRingN(n) {
		return this._holes[n];
	},
	interfaces_: function interfaces_() {
		return [Polygonal];
	},
	getClass: function getClass() {
		return Polygon;
	}
});
Polygon.serialVersionUID = -3494792200821764533;

function MultiPoint() {
	var points = arguments[0],
	    factory = arguments[1];
	GeometryCollection.call(this, points, factory);
}
inherits(MultiPoint, GeometryCollection);
extend(MultiPoint.prototype, {
	isValid: function isValid() {
		return true;
	},
	equalsExact: function equalsExact() {
		if (arguments.length === 2 && typeof arguments[1] === "number" && arguments[0] instanceof Geometry) {
			var other = arguments[0],
			    tolerance = arguments[1];
			if (!this.isEquivalentClass(other)) {
				return false;
			}
			return GeometryCollection.prototype.equalsExact.call(this, other, tolerance);
		} else return GeometryCollection.prototype.equalsExact.apply(this, arguments);
	},
	getCoordinate: function getCoordinate() {
		if (arguments.length === 1 && Number.isInteger(arguments[0])) {
			var n = arguments[0];
			return this._geometries[n].getCoordinate();
		} else return GeometryCollection.prototype.getCoordinate.apply(this, arguments);
	},
	getBoundaryDimension: function getBoundaryDimension() {
		return Dimension.FALSE;
	},
	getTypeCode: function getTypeCode() {
		return Geometry.TYPECODE_MULTIPOINT;
	},
	getDimension: function getDimension() {
		return 0;
	},
	getBoundary: function getBoundary() {
		return this.getFactory().createGeometryCollection();
	},
	getGeometryType: function getGeometryType() {
		return Geometry.TYPENAME_MULTIPOINT;
	},
	copy: function copy() {
		var points = new Array(this._geometries.length).fill(null);
		for (var i = 0; i < points.length; i++) {
			points[i] = this._geometries[i].copy();
		}
		return new MultiPoint(points, this._factory);
	},
	interfaces_: function interfaces_() {
		return [Puntal];
	},
	getClass: function getClass() {
		return MultiPoint;
	}
});
MultiPoint.serialVersionUID = -8048474874175355449;

function LinearRing() {
	if (arguments[0] instanceof Array && arguments[1] instanceof GeometryFactory) {
		var points = arguments[0],
		    factory = arguments[1];
		LinearRing.call(this, factory.getCoordinateSequenceFactory().create(points), factory);
	} else if (hasInterface(arguments[0], CoordinateSequence) && arguments[1] instanceof GeometryFactory) {
		var _points = arguments[0],
		    _factory = arguments[1];
		LineString.call(this, _points, _factory);
		this.validateConstruction();
	}
}
inherits(LinearRing, LineString);
extend(LinearRing.prototype, {
	getBoundaryDimension: function getBoundaryDimension() {
		return Dimension.FALSE;
	},
	isClosed: function isClosed() {
		if (this.isEmpty()) {
			return true;
		}
		return LineString.prototype.isClosed.call(this);
	},
	getTypeCode: function getTypeCode() {
		return Geometry.TYPECODE_LINEARRING;
	},
	reverse: function reverse() {
		var seq = this._points.copy();
		CoordinateSequences.reverse(seq);
		var rev = this.getFactory().createLinearRing(seq);
		return rev;
	},
	validateConstruction: function validateConstruction() {
		if (!this.isEmpty() && !LineString.prototype.isClosed.call(this)) {
			throw new IllegalArgumentException("Points of LinearRing do not form a closed linestring");
		}
		if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {
			throw new IllegalArgumentException("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
		}
	},
	getGeometryType: function getGeometryType() {
		return Geometry.TYPENAME_LINEARRING;
	},
	copy: function copy() {
		return new LinearRing(this._points.copy(), this._factory);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LinearRing;
	}
});
LinearRing.MINIMUM_VALID_SIZE = 4;
LinearRing.serialVersionUID = -4261142084085851829;

function MultiPolygon() {
	var polygons = arguments[0],
	    factory = arguments[1];
	GeometryCollection.call(this, polygons, factory);
}
inherits(MultiPolygon, GeometryCollection);
extend(MultiPolygon.prototype, {
	equalsExact: function equalsExact() {
		if (arguments.length === 2 && typeof arguments[1] === "number" && arguments[0] instanceof Geometry) {
			var other = arguments[0],
			    tolerance = arguments[1];
			if (!this.isEquivalentClass(other)) {
				return false;
			}
			return GeometryCollection.prototype.equalsExact.call(this, other, tolerance);
		} else return GeometryCollection.prototype.equalsExact.apply(this, arguments);
	},
	getBoundaryDimension: function getBoundaryDimension() {
		return 1;
	},
	getTypeCode: function getTypeCode() {
		return Geometry.TYPECODE_MULTIPOLYGON;
	},
	getDimension: function getDimension() {
		return 2;
	},
	reverse: function reverse() {
		var n = this._geometries.length;
		var revGeoms = new Array(n).fill(null);
		for (var i = 0; i < this._geometries.length; i++) {
			revGeoms[i] = this._geometries[i].reverse();
		}
		return this.getFactory().createMultiPolygon(revGeoms);
	},
	getBoundary: function getBoundary() {
		if (this.isEmpty()) {
			return this.getFactory().createMultiLineString();
		}
		var allRings = new ArrayList();
		for (var i = 0; i < this._geometries.length; i++) {
			var polygon = this._geometries[i];
			var rings = polygon.getBoundary();
			for (var j = 0; j < rings.getNumGeometries(); j++) {
				allRings.add(rings.getGeometryN(j));
			}
		}
		var allRingsArray = new Array(allRings.size()).fill(null);
		return this.getFactory().createMultiLineString(allRings.toArray(allRingsArray));
	},
	getGeometryType: function getGeometryType() {
		return Geometry.TYPENAME_MULTIPOLYGON;
	},
	copy: function copy() {
		var polygons = new Array(this._geometries.length).fill(null);
		for (var i = 0; i < polygons.length; i++) {
			polygons[i] = this._geometries[i].copy();
		}
		return new MultiPolygon(polygons, this._factory);
	},
	interfaces_: function interfaces_() {
		return [Polygonal];
	},
	getClass: function getClass() {
		return MultiPolygon;
	}
});
MultiPolygon.serialVersionUID = -551033529766975875;

function GeometryEditor() {
	this._factory = null;
	this._isUserDataCopied = false;
	if (arguments.length === 0) {} else if (arguments.length === 1) {
		var factory = arguments[0];
		this._factory = factory;
	}
}
extend(GeometryEditor.prototype, {
	setCopyUserData: function setCopyUserData(isUserDataCopied) {
		this._isUserDataCopied = isUserDataCopied;
	},
	edit: function edit(geometry, operation) {
		if (geometry === null) return null;
		var result = this.editInternal(geometry, operation);
		if (this._isUserDataCopied) {
			result.setUserData(geometry.getUserData());
		}
		return result;
	},
	editInternal: function editInternal(geometry, operation) {
		if (this._factory === null) this._factory = geometry.getFactory();
		if (geometry instanceof GeometryCollection) {
			return this.editGeometryCollection(geometry, operation);
		}
		if (geometry instanceof Polygon) {
			return this.editPolygon(geometry, operation);
		}
		if (geometry instanceof Point) {
			return operation.edit(geometry, this._factory);
		}
		if (geometry instanceof LineString) {
			return operation.edit(geometry, this._factory);
		}
		Assert.shouldNeverReachHere("Unsupported Geometry class: " + geometry.getClass().getName());
		return null;
	},
	editGeometryCollection: function editGeometryCollection(collection, operation) {
		var collectionForType = operation.edit(collection, this._factory);
		var geometries = new ArrayList();
		for (var i = 0; i < collectionForType.getNumGeometries(); i++) {
			var geometry = this.edit(collectionForType.getGeometryN(i), operation);
			if (geometry === null || geometry.isEmpty()) {
				continue;
			}
			geometries.add(geometry);
		}
		if (collectionForType.getClass() === MultiPoint) {
			return this._factory.createMultiPoint(geometries.toArray([]));
		}
		if (collectionForType.getClass() === MultiLineString) {
			return this._factory.createMultiLineString(geometries.toArray([]));
		}
		if (collectionForType.getClass() === MultiPolygon) {
			return this._factory.createMultiPolygon(geometries.toArray([]));
		}
		return this._factory.createGeometryCollection(geometries.toArray([]));
	},
	editPolygon: function editPolygon(polygon, operation) {
		var newPolygon = operation.edit(polygon, this._factory);
		if (newPolygon === null) newPolygon = this._factory.createPolygon();
		if (newPolygon.isEmpty()) {
			return newPolygon;
		}
		var shell = this.edit(newPolygon.getExteriorRing(), operation);
		if (shell === null || shell.isEmpty()) {
			return this._factory.createPolygon();
		}
		var holes = new ArrayList();
		for (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {
			var hole = this.edit(newPolygon.getInteriorRingN(i), operation);
			if (hole === null || hole.isEmpty()) {
				continue;
			}
			holes.add(hole);
		}
		return this._factory.createPolygon(shell, holes.toArray([]));
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return GeometryEditor;
	}
});
function GeometryEditorOperation() {}
GeometryEditor.GeometryEditorOperation = GeometryEditorOperation;
function NoOpGeometryOperation() {}
extend(NoOpGeometryOperation.prototype, {
	edit: function edit(geometry, factory) {
		return geometry;
	},
	interfaces_: function interfaces_() {
		return [GeometryEditorOperation];
	},
	getClass: function getClass() {
		return NoOpGeometryOperation;
	}
});
function CoordinateOperation() {}
extend(CoordinateOperation.prototype, {
	edit: function edit(geometry, factory) {
		var coordinates = this.edit(geometry.getCoordinates(), geometry);
		if (geometry instanceof LinearRing) {
			if (coordinates === null) return factory.createLinearRing();else return factory.createLinearRing(coordinates);
		}
		if (geometry instanceof LineString) {
			if (coordinates === null) return factory.createLineString();else return factory.createLineString(coordinates);
		}
		if (geometry instanceof Point) {
			if (coordinates === null || coordinates.length === 0) return factory.createPoint();else return factory.createPoint(coordinates[0]);
		}
		return geometry;
	},
	interfaces_: function interfaces_() {
		return [GeometryEditorOperation];
	},
	getClass: function getClass() {
		return CoordinateOperation;
	}
});
function CoordinateSequenceOperation() {}
extend(CoordinateSequenceOperation.prototype, {
	edit: function edit(geometry, factory) {
		if (geometry instanceof LinearRing) {
			return factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry));
		}
		if (geometry instanceof LineString) {
			return factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry));
		}
		if (geometry instanceof Point) {
			return factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry));
		}
		return geometry;
	},
	interfaces_: function interfaces_() {
		return [GeometryEditorOperation];
	},
	getClass: function getClass() {
		return CoordinateSequenceOperation;
	}
});
GeometryEditor.NoOpGeometryOperation = NoOpGeometryOperation;
GeometryEditor.CoordinateOperation = CoordinateOperation;
GeometryEditor.CoordinateSequenceOperation = CoordinateSequenceOperation;

function CoordinateArraySequence() {
	this._dimension = 3;
	this._coordinates = null;
	if (arguments.length === 1) {
		if (arguments[0] instanceof Array) {
			var coordinates = arguments[0];
			CoordinateArraySequence.call(this, coordinates, 3);
		} else if (Number.isInteger(arguments[0])) {
			var size = arguments[0];
			this._coordinates = new Array(size).fill(null);
			for (var i = 0; i < size; i++) {
				this._coordinates[i] = new Coordinate();
			}
		} else if (hasInterface(arguments[0], CoordinateSequence)) {
			var coordSeq = arguments[0];
			if (coordSeq === null) {
				this._coordinates = new Array(0).fill(null);
				return null;
			}
			this._dimension = coordSeq.getDimension();
			this._coordinates = new Array(coordSeq.size()).fill(null);
			for (var i = 0; i < this._coordinates.length; i++) {
				this._coordinates[i] = coordSeq.getCoordinateCopy(i);
			}
		}
	} else if (arguments.length === 2) {
		if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
			var _coordinates = arguments[0],
			    dimension = arguments[1];
			this._coordinates = _coordinates;
			this._dimension = dimension;
			if (_coordinates === null) this._coordinates = new Array(0).fill(null);
		} else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
			var _size = arguments[0],
			    _dimension = arguments[1];
			this._coordinates = new Array(_size).fill(null);
			this._dimension = _dimension;
			for (var i = 0; i < _size; i++) {
				this._coordinates[i] = new Coordinate();
			}
		}
	}
}
extend(CoordinateArraySequence.prototype, {
	setOrdinate: function setOrdinate(index, ordinateIndex, value) {
		switch (ordinateIndex) {
			case CoordinateSequence.X:
				this._coordinates[index].x = value;
				break;
			case CoordinateSequence.Y:
				this._coordinates[index].y = value;
				break;
			case CoordinateSequence.Z:
				this._coordinates[index].z = value;
				break;
			default:
				throw new IllegalArgumentException("invalid ordinateIndex");
		}
	},
	size: function size() {
		return this._coordinates.length;
	},
	getOrdinate: function getOrdinate(index, ordinateIndex) {
		switch (ordinateIndex) {
			case CoordinateSequence.X:
				return this._coordinates[index].x;
			case CoordinateSequence.Y:
				return this._coordinates[index].y;
			case CoordinateSequence.Z:
				return this._coordinates[index].z;
		}
		return Double.NaN;
	},
	getCoordinate: function getCoordinate() {
		if (arguments.length === 1) {
			var i = arguments[0];
			return this._coordinates[i];
		} else if (arguments.length === 2) {
			var index = arguments[0],
			    coord = arguments[1];
			coord.x = this._coordinates[index].x;
			coord.y = this._coordinates[index].y;
			coord.z = this._coordinates[index].z;
		}
	},
	getCoordinateCopy: function getCoordinateCopy(i) {
		return new Coordinate(this._coordinates[i]);
	},
	getDimension: function getDimension() {
		return this._dimension;
	},
	getX: function getX(index) {
		return this._coordinates[index].x;
	},
	expandEnvelope: function expandEnvelope(env) {
		for (var i = 0; i < this._coordinates.length; i++) {
			env.expandToInclude(this._coordinates[i]);
		}
		return env;
	},
	copy: function copy() {
		var cloneCoordinates = new Array(this.size()).fill(null);
		for (var i = 0; i < this._coordinates.length; i++) {
			cloneCoordinates[i] = this._coordinates[i].copy();
		}
		return new CoordinateArraySequence(cloneCoordinates, this._dimension);
	},
	toString: function toString() {
		if (this._coordinates.length > 0) {
			var strBuilder = new StringBuilder(17 * this._coordinates.length);
			strBuilder.append('(');
			strBuilder.append(this._coordinates[0]);
			for (var i = 1; i < this._coordinates.length; i++) {
				strBuilder.append(", ");
				strBuilder.append(this._coordinates[i]);
			}
			strBuilder.append(')');
			return strBuilder.toString();
		} else {
			return "()";
		}
	},
	getY: function getY(index) {
		return this._coordinates[index].y;
	},
	toCoordinateArray: function toCoordinateArray() {
		return this._coordinates;
	},
	interfaces_: function interfaces_() {
		return [CoordinateSequence, Serializable];
	},
	getClass: function getClass() {
		return CoordinateArraySequence;
	}
});
CoordinateArraySequence.serialVersionUID = -915438501601840650;

function CoordinateArraySequenceFactory() {}
extend(CoordinateArraySequenceFactory.prototype, {
	readResolve: function readResolve() {
		return CoordinateArraySequenceFactory.instance();
	},
	create: function create() {
		if (arguments.length === 1) {
			if (arguments[0] instanceof Array) {
				var coordinates = arguments[0];
				return new CoordinateArraySequence(coordinates);
			} else if (hasInterface(arguments[0], CoordinateSequence)) {
				var coordSeq = arguments[0];
				return new CoordinateArraySequence(coordSeq);
			}
		} else if (arguments.length === 2) {
			var size = arguments[0],
			    dimension = arguments[1];
			if (dimension > 3) dimension = 3;
			if (dimension < 2) return new CoordinateArraySequence(size);
			return new CoordinateArraySequence(size, dimension);
		}
	},
	interfaces_: function interfaces_() {
		return [CoordinateSequenceFactory, Serializable];
	},
	getClass: function getClass() {
		return CoordinateArraySequenceFactory;
	}
});
CoordinateArraySequenceFactory.instance = function () {
	return CoordinateArraySequenceFactory.instanceObject;
};
CoordinateArraySequenceFactory.serialVersionUID = -4099577099607551657;
CoordinateArraySequenceFactory.instanceObject = new CoordinateArraySequenceFactory();

// shared pointer
var i;
// shortcuts
var defineProperty = Object.defineProperty;
function is(a, b) {
  return a === b || a !== a && b !== b;
} // eslint-disable-line

var MapPolyfill = createCollection({
  // WeakMap#delete(key:void*):boolean
  'delete': sharedDelete,
  // :was Map#get(key:void*[, d3fault:void*]):void*
  // Map#has(key:void*):boolean
  has: mapHas,
  // Map#get(key:void*):boolean
  get: sharedGet,
  // Map#set(key:void*, value:void*):void
  set: sharedSet,
  // Map#keys(void):Iterator
  keys: sharedKeys,
  // Map#values(void):Iterator
  values: sharedValues,
  // Map#entries(void):Iterator
  entries: mapEntries,
  // Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`
  forEach: sharedForEach,
  // Map#clear():
  clear: sharedClear
});

function createCollection(proto, objectOnly) {
  function Collection(a) {
    if (!this || this.constructor !== Collection) return new Collection(a);
    this._keys = [];
    this._values = [];
    this._itp = []; // iteration pointers
    this.objectOnly = objectOnly;

    // parse initial iterable argument passed
    if (a) init.call(this, a);
  }

  // define size for non object-only collections
  if (!objectOnly) {
    defineProperty(proto, 'size', {
      get: sharedSize
    });
  }

  // set prototype
  proto.constructor = Collection;
  Collection.prototype = proto;

  return Collection;
}

function init(a) {
  // init Set argument, like `[1,2,3,{}]`
  if (this.add) a.forEach(this.add, this);
  // init Map argument like `[[1,2], [{}, 4]]`
  else a.forEach(function (a) {
      this.set(a[0], a[1]);
    }, this);
}

function sharedDelete(key) {
  if (this.has(key)) {
    this._keys.splice(i, 1);
    this._values.splice(i, 1);
    // update iteration pointers
    this._itp.forEach(function (p) {
      if (i < p[0]) p[0]--;
    });
  }
  // Aurora here does it while Canary doesn't
  return i > -1;
}

function sharedGet(key) {
  return this.has(key) ? this._values[i] : undefined;
}

function has(list, key) {
  if (this.objectOnly && key !== Object(key)) throw new TypeError('Invalid value used as weak collection key');
  // NaN or 0 passed
  if (key !== key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} // eslint-disable-line
  else i = list.indexOf(key);
  return i > -1;
}

function mapHas(value) {
  return has.call(this, this._keys, value);
}

function sharedSet(key, value) {
  this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;
  return this;
}

function sharedClear() {
  (this._keys || 0).length = this._values.length = 0;
}

function sharedKeys() {
  return sharedIterator(this._itp, this._keys);
}

function sharedValues() {
  return sharedIterator(this._itp, this._values);
}

function mapEntries() {
  return sharedIterator(this._itp, this._keys, this._values);
}

function sharedIterator(itp, array, array2) {
  var p = [0];
  var done = false;
  itp.push(p);
  return {
    next: function next() {
      var v;
      var k = p[0];
      if (!done && k < array.length) {
        v = array2 ? [array[k], array2[k]] : array[k];
        p[0]++;
      } else {
        done = true;
        itp.splice(itp.indexOf(p), 1);
      }
      return { done: done, value: v };
    }
  };
}

function sharedSize() {
  return this._values.length;
}

function sharedForEach(callback, context) {
  var it = this.entries();
  for (;;) {
    var r = it.next();
    if (r.done) break;
    callback.call(context, r.value[1], r.value[0], this);
  }
}

var MapImpl = typeof Map === 'undefined' || !Map.prototype.values ? MapPolyfill : Map;

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html
 *
 * @extends {javascript.util.Map}
 * @constructor
 * @private
 */
function HashMap() {
  /**
   * @type {Object}
   * @private
  */
  this.map_ = new MapImpl();
}
HashMap.prototype = new Map$1();

/**
 * @override
 */
HashMap.prototype.get = function (key) {
  return this.map_.get(key) || null;
};

/**
 * @override
 */
HashMap.prototype.put = function (key, value) {
  this.map_.set(key, value);
  return value;
};

/**
 * @override
 */
HashMap.prototype.values = function () {
  var arrayList = new ArrayList();
  var it = this.map_.values();
  var o = it.next();
  while (!o.done) {
    arrayList.add(o.value);
    o = it.next();
  }
  return arrayList;
};

/**
 * @override
 */
HashMap.prototype.entrySet = function () {
  var hashSet = new HashSet();
  this.map_.entries().forEach(function (entry) {
    return hashSet.add(entry);
  });
  return hashSet;
};

/**
 * @override
 */
HashMap.prototype.size = function () {
  return this.map_.size();
};

function PrecisionModel() {
	this._modelType = null;
	this._scale = null;
	if (arguments.length === 0) {
		this._modelType = PrecisionModel.FLOATING;
	} else if (arguments.length === 1) {
		if (arguments[0] instanceof Type) {
			var modelType = arguments[0];
			this._modelType = modelType;
			if (modelType === PrecisionModel.FIXED) {
				this.setScale(1.0);
			}
		} else if (typeof arguments[0] === "number") {
			var scale = arguments[0];
			this._modelType = PrecisionModel.FIXED;
			this.setScale(scale);
		} else if (arguments[0] instanceof PrecisionModel) {
			var pm = arguments[0];
			this._modelType = pm._modelType;
			this._scale = pm._scale;
		}
	}
}
extend(PrecisionModel.prototype, {
	equals: function equals(other) {
		if (!(other instanceof PrecisionModel)) {
			return false;
		}
		var otherPrecisionModel = other;
		return this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale;
	},
	compareTo: function compareTo(o) {
		var other = o;
		var sigDigits = this.getMaximumSignificantDigits();
		var otherSigDigits = other.getMaximumSignificantDigits();
		return new Integer(sigDigits).compareTo(new Integer(otherSigDigits));
	},
	getScale: function getScale() {
		return this._scale;
	},
	isFloating: function isFloating() {
		return this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE;
	},
	getType: function getType() {
		return this._modelType;
	},
	toString: function toString() {
		var description = "UNKNOWN";
		if (this._modelType === PrecisionModel.FLOATING) {
			description = "Floating";
		} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
			description = "Floating-Single";
		} else if (this._modelType === PrecisionModel.FIXED) {
			description = "Fixed (Scale=" + this.getScale() + ")";
		}
		return description;
	},
	makePrecise: function makePrecise() {
		if (typeof arguments[0] === "number") {
			var val = arguments[0];
			if (Double.isNaN(val)) return val;
			if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
				var floatSingleVal = val;
				return floatSingleVal;
			}
			if (this._modelType === PrecisionModel.FIXED) {
				return Math.round(val * this._scale) / this._scale;
			}
			return val;
		} else if (arguments[0] instanceof Coordinate) {
			var coord = arguments[0];
			if (this._modelType === PrecisionModel.FLOATING) return null;
			coord.x = this.makePrecise(coord.x);
			coord.y = this.makePrecise(coord.y);
		}
	},
	getMaximumSignificantDigits: function getMaximumSignificantDigits() {
		var maxSigDigits = 16;
		if (this._modelType === PrecisionModel.FLOATING) {
			maxSigDigits = 16;
		} else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
			maxSigDigits = 6;
		} else if (this._modelType === PrecisionModel.FIXED) {
			maxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));
		}
		return maxSigDigits;
	},
	setScale: function setScale(scale) {
		this._scale = Math.abs(scale);
	},
	interfaces_: function interfaces_() {
		return [Serializable, Comparable];
	},
	getClass: function getClass() {
		return PrecisionModel;
	}
});
PrecisionModel.mostPrecise = function (pm1, pm2) {
	if (pm1.compareTo(pm2) >= 0) return pm1;
	return pm2;
};
function Type() {
	this._name = null;
	var name = arguments[0];
	this._name = name;
	Type.nameToTypeMap.put(name, this);
}
extend(Type.prototype, {
	readResolve: function readResolve() {
		return Type.nameToTypeMap.get(this._name);
	},
	toString: function toString() {
		return this._name;
	},
	interfaces_: function interfaces_() {
		return [Serializable];
	},
	getClass: function getClass() {
		return Type;
	}
});
Type.serialVersionUID = -5528602631731589822;
Type.nameToTypeMap = new HashMap();
PrecisionModel.Type = Type;
PrecisionModel.serialVersionUID = 7777263578777803835;
PrecisionModel.FIXED = new Type("FIXED");
PrecisionModel.FLOATING = new Type("FLOATING");
PrecisionModel.FLOATING_SINGLE = new Type("FLOATING SINGLE");
PrecisionModel.maximumPreciseValue = 9007199254740992.0;

function GeometryFactory() {
	this._precisionModel = null;
	this._coordinateSequenceFactory = null;
	this._SRID = null;
	if (arguments.length === 0) {
		GeometryFactory.call(this, new PrecisionModel(), 0);
	} else if (arguments.length === 1) {
		if (hasInterface(arguments[0], CoordinateSequenceFactory)) {
			var coordinateSequenceFactory = arguments[0];
			GeometryFactory.call(this, new PrecisionModel(), 0, coordinateSequenceFactory);
		} else if (arguments[0] instanceof PrecisionModel) {
			var precisionModel = arguments[0];
			GeometryFactory.call(this, precisionModel, 0, GeometryFactory.getDefaultCoordinateSequenceFactory());
		}
	} else if (arguments.length === 2) {
		var _precisionModel = arguments[0],
		    SRID = arguments[1];
		GeometryFactory.call(this, _precisionModel, SRID, GeometryFactory.getDefaultCoordinateSequenceFactory());
	} else if (arguments.length === 3) {
		var _precisionModel2 = arguments[0],
		    _SRID = arguments[1],
		    _coordinateSequenceFactory = arguments[2];
		this._precisionModel = _precisionModel2;
		this._coordinateSequenceFactory = _coordinateSequenceFactory;
		this._SRID = _SRID;
	}
}
extend(GeometryFactory.prototype, {
	toGeometry: function toGeometry(envelope) {
		if (envelope.isNull()) {
			return this.createPoint();
		}
		if (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {
			return this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()));
		}
		if (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {
			return this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())]);
		}
		return this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null);
	},
	createLineString: function createLineString() {
		if (arguments.length === 0) {
			return this.createLineString(this.getCoordinateSequenceFactory().create([]));
		} else if (arguments.length === 1) {
			if (arguments[0] instanceof Array) {
				var coordinates = arguments[0];
				return this.createLineString(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
			} else if (hasInterface(arguments[0], CoordinateSequence)) {
				var _coordinates = arguments[0];
				return new LineString(_coordinates, this);
			}
		}
	},
	createMultiLineString: function createMultiLineString() {
		if (arguments.length === 0) {
			return new MultiLineString(null, this);
		} else if (arguments.length === 1) {
			var lineStrings = arguments[0];
			return new MultiLineString(lineStrings, this);
		}
	},
	buildGeometry: function buildGeometry(geomList) {
		var geomClass = null;
		var isHeterogeneous = false;
		var hasGeometryCollection = false;
		for (var i = geomList.iterator(); i.hasNext();) {
			var geom = i.next();
			var partClass = geom.getClass();
			if (geomClass === null) {
				geomClass = partClass;
			}
			if (partClass !== geomClass) {
				isHeterogeneous = true;
			}
			if (geom instanceof GeometryCollection) hasGeometryCollection = true;
		}
		if (geomClass === null) {
			return this.createGeometryCollection();
		}
		if (isHeterogeneous || hasGeometryCollection) {
			return this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList));
		}
		var geom0 = geomList.iterator().next();
		var isCollection = geomList.size() > 1;
		if (isCollection) {
			if (geom0 instanceof Polygon) {
				return this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList));
			} else if (geom0 instanceof LineString) {
				return this.createMultiLineString(GeometryFactory.toLineStringArray(geomList));
			} else if (geom0 instanceof Point) {
				return this.createMultiPoint(GeometryFactory.toPointArray(geomList));
			}
			Assert.shouldNeverReachHere("Unhandled class: " + geom0.getClass().getName());
		}
		return geom0;
	},
	createMultiPointFromCoords: function createMultiPointFromCoords(coordinates) {
		return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
	},
	createPoint: function createPoint() {
		if (arguments.length === 0) {
			return this.createPoint(this.getCoordinateSequenceFactory().create([]));
		} else if (arguments.length === 1) {
			if (arguments[0] instanceof Coordinate) {
				var coordinate = arguments[0];
				return this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null);
			} else if (hasInterface(arguments[0], CoordinateSequence)) {
				var coordinates = arguments[0];
				return new Point(coordinates, this);
			}
		}
	},
	getCoordinateSequenceFactory: function getCoordinateSequenceFactory() {
		return this._coordinateSequenceFactory;
	},
	createPolygon: function createPolygon() {
		if (arguments.length === 0) {
			return this.createPolygon(null, null);
		} else if (arguments.length === 1) {
			if (hasInterface(arguments[0], CoordinateSequence)) {
				var shell = arguments[0];
				return this.createPolygon(this.createLinearRing(shell));
			} else if (arguments[0] instanceof Array) {
				var _shell = arguments[0];
				return this.createPolygon(this.createLinearRing(_shell));
			} else if (arguments[0] instanceof LinearRing) {
				var _shell2 = arguments[0];
				return this.createPolygon(_shell2, null);
			}
		} else if (arguments.length === 2) {
			var _shell3 = arguments[0],
			    holes = arguments[1];
			return new Polygon(_shell3, holes, this);
		}
	},
	getSRID: function getSRID() {
		return this._SRID;
	},
	createGeometryCollection: function createGeometryCollection() {
		if (arguments.length === 0) {
			return new GeometryCollection(null, this);
		} else if (arguments.length === 1) {
			var geometries = arguments[0];
			return new GeometryCollection(geometries, this);
		}
	},
	createGeometry: function createGeometry(g) {
		var editor = new GeometryEditor(this);
		return editor.edit(g, {
			edit: function edit() {
				if (arguments.length === 2 && arguments[1] instanceof Geometry && hasInterface(arguments[0], CoordinateSequence)) {
					var coordSeq = arguments[0];
					return this._coordinateSequenceFactory.create(coordSeq);
				}
			}
		});
	},
	getPrecisionModel: function getPrecisionModel() {
		return this._precisionModel;
	},
	createLinearRing: function createLinearRing() {
		if (arguments.length === 0) {
			return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
		} else if (arguments.length === 1) {
			if (arguments[0] instanceof Array) {
				var coordinates = arguments[0];
				return this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
			} else if (hasInterface(arguments[0], CoordinateSequence)) {
				var _coordinates2 = arguments[0];
				return new LinearRing(_coordinates2, this);
			}
		}
	},
	createMultiPolygon: function createMultiPolygon() {
		if (arguments.length === 0) {
			return new MultiPolygon(null, this);
		} else if (arguments.length === 1) {
			var polygons = arguments[0];
			return new MultiPolygon(polygons, this);
		}
	},
	createMultiPoint: function createMultiPoint() {
		if (arguments.length === 0) {
			return new MultiPoint(null, this);
		} else if (arguments.length === 1) {
			if (arguments[0] instanceof Array) {
				var point = arguments[0];
				return new MultiPoint(point, this);
			} else if (hasInterface(arguments[0], CoordinateSequence)) {
				var coordinates = arguments[0];
				if (coordinates === null) {
					return this.createMultiPoint(new Array(0).fill(null));
				}
				var points = new Array(coordinates.size()).fill(null);
				for (var i = 0; i < coordinates.size(); i++) {
					var ptSeq = this.getCoordinateSequenceFactory().create(1, coordinates.getDimension());
					CoordinateSequences.copy(coordinates, i, ptSeq, 0, 1);
					points[i] = this.createPoint(ptSeq);
				}
				return this.createMultiPoint(points);
			}
		}
	},
	interfaces_: function interfaces_() {
		return [Serializable];
	},
	getClass: function getClass() {
		return GeometryFactory;
	}
});
GeometryFactory.toMultiPolygonArray = function (multiPolygons) {
	var multiPolygonArray = new Array(multiPolygons.size()).fill(null);
	return multiPolygons.toArray(multiPolygonArray);
};
GeometryFactory.toGeometryArray = function (geometries) {
	if (geometries === null) return null;
	var geometryArray = new Array(geometries.size()).fill(null);
	return geometries.toArray(geometryArray);
};
GeometryFactory.getDefaultCoordinateSequenceFactory = function () {
	return CoordinateArraySequenceFactory.instance();
};
GeometryFactory.toMultiLineStringArray = function (multiLineStrings) {
	var multiLineStringArray = new Array(multiLineStrings.size()).fill(null);
	return multiLineStrings.toArray(multiLineStringArray);
};
GeometryFactory.toLineStringArray = function (lineStrings) {
	var lineStringArray = new Array(lineStrings.size()).fill(null);
	return lineStrings.toArray(lineStringArray);
};
GeometryFactory.toMultiPointArray = function (multiPoints) {
	var multiPointArray = new Array(multiPoints.size()).fill(null);
	return multiPoints.toArray(multiPointArray);
};
GeometryFactory.toLinearRingArray = function (linearRings) {
	var linearRingArray = new Array(linearRings.size()).fill(null);
	return linearRings.toArray(linearRingArray);
};
GeometryFactory.toPointArray = function (points) {
	var pointArray = new Array(points.size()).fill(null);
	return points.toArray(pointArray);
};
GeometryFactory.toPolygonArray = function (polygons) {
	var polygonArray = new Array(polygons.size()).fill(null);
	return polygons.toArray(polygonArray);
};
GeometryFactory.createPointFromInternalCoord = function (coord, exemplar) {
	exemplar.getPrecisionModel().makePrecise(coord);
	return exemplar.getFactory().createPoint(coord);
};
GeometryFactory.serialVersionUID = -6820524753094095635;

var regExes = {
  'typeStr': /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
  'emptyTypeStr': /^\s*(\w+)\s*EMPTY\s*$/,
  'spaces': /\s+/,
  'parenComma': /\)\s*,\s*\(/,
  'doubleParenComma': /\)\s*\)\s*,\s*\(\s*\(/, // can't use {2} here
  'trimParens': /^\s*\(?(.*?)\)?\s*$/

  /**
   * Class for reading and writing Well-Known Text.
   *
   * NOTE: Adapted from OpenLayers 2.11 implementation.
   */

  /** Create a new parser for WKT
   *
   * @param {GeometryFactory} geometryFactory
   * @return An instance of WKTParser.
   * @constructor
   * @private
   */
};function WKTParser(geometryFactory) {
  this.geometryFactory = geometryFactory || new GeometryFactory();
  this.precisionModel = this.geometryFactory.getPrecisionModel();
}

extend(WKTParser.prototype, {
  /**
   * Deserialize a WKT string and return a geometry. Supports WKT for POINT,
   * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,
   * and GEOMETRYCOLLECTION.
   *
   * @param {String} wkt A WKT string.
   * @return {Geometry} A geometry instance.
   * @private
   */
  read: function read(wkt) {
    var geometry, type, str;
    wkt = wkt.replace(/[\n\r]/g, ' ');
    var matches = regExes.typeStr.exec(wkt);
    if (wkt.search('EMPTY') !== -1) {
      matches = regExes.emptyTypeStr.exec(wkt);
      matches[2] = undefined;
    }
    if (matches) {
      type = matches[1].toLowerCase();
      str = matches[2];
      if (parse[type]) {
        geometry = parse[type].call(this, str);
      }
    }

    if (geometry === undefined) throw new Error('Could not parse WKT ' + wkt);

    return geometry;
  },


  /**
   * Serialize a geometry into a WKT string.
   *
   * @param {Geometry} geometry A feature or array of features.
   * @return {String} The WKT string representation of the input geometries.
   * @private
   */
  write: function write(geometry) {
    return this.extractGeometry(geometry);
  },


  /**
   * Entry point to construct the WKT for a single Geometry object.
   *
   * @param {Geometry} geometry
   * @return {String} A WKT string of representing the geometry.
   * @private
   */
  extractGeometry: function extractGeometry(geometry) {
    var type = geometry.getGeometryType().toLowerCase();
    if (!extract[type]) {
      return null;
    }
    var wktType = type.toUpperCase();
    var data;
    if (geometry.isEmpty()) {
      data = wktType + ' EMPTY';
    } else {
      data = wktType + '(' + extract[type].call(this, geometry) + ')';
    }
    return data;
  }
});

/**
 * Object with properties corresponding to the geometry types. Property values
 * are functions that do the actual data extraction.
 * @private
 */
var extract = {
  coordinate: function coordinate(_coordinate) {
    return _coordinate.x + ' ' + _coordinate.y;
  },


  /**
   * Return a space delimited string of point coordinates.
   *
   * @param {Point}
   *          point
   * @return {String} A string of coordinates representing the point.
   */
  point: function point(_point) {
    return extract.coordinate.call(this, _point._coordinates._coordinates[0]);
  },


  /**
   * Return a comma delimited string of point coordinates from a multipoint.
   *
   * @param {MultiPoint}
   *          multipoint
   * @return {String} A string of point coordinate strings representing the
   *         multipoint.
   */
  multipoint: function multipoint(_multipoint) {
    var array = [];
    for (var i = 0, len = _multipoint._geometries.length; i < len; ++i) {
      array.push('(' + extract.point.call(this, _multipoint._geometries[i]) + ')');
    }
    return array.join(',');
  },


  /**
   * Return a comma delimited string of point coordinates from a line.
   *
   * @param {LineString} linestring
   * @return {String} A string of point coordinate strings representing the linestring.
   */
  linestring: function linestring(_linestring) {
    var array = [];
    for (var i = 0, len = _linestring._points._coordinates.length; i < len; ++i) {
      array.push(extract.coordinate.call(this, _linestring._points._coordinates[i]));
    }
    return array.join(',');
  },
  linearring: function linearring(_linearring) {
    var array = [];
    for (var i = 0, len = _linearring._points._coordinates.length; i < len; ++i) {
      array.push(extract.coordinate.call(this, _linearring._points._coordinates[i]));
    }
    return array.join(',');
  },


  /**
   * Return a comma delimited string of linestring strings from a
   * multilinestring.
   *
   * @param {MultiLineString} multilinestring
   * @return {String} A string of of linestring strings representing the multilinestring.
   */
  multilinestring: function multilinestring(_multilinestring) {
    var array = [];
    for (var i = 0, len = _multilinestring._geometries.length; i < len; ++i) {
      array.push('(' + extract.linestring.call(this, _multilinestring._geometries[i]) + ')');
    }
    return array.join(',');
  },


  /**
   * Return a comma delimited string of linear ring arrays from a polygon.
   *
   * @param {Polygon} polygon
   * @return {String} An array of linear ring arrays representing the polygon.
   */
  polygon: function polygon(_polygon) {
    var array = [];
    array.push('(' + extract.linestring.call(this, _polygon._shell) + ')');
    for (var i = 0, len = _polygon._holes.length; i < len; ++i) {
      array.push('(' + extract.linestring.call(this, _polygon._holes[i]) + ')');
    }
    return array.join(',');
  },


  /**
   * Return an array of polygon arrays from a multipolygon.
   *
   * @param {MultiPolygon} multipolygon
   * @return {String} An array of polygon arrays representing the multipolygon.
   */
  multipolygon: function multipolygon(_multipolygon) {
    var array = [];
    for (var i = 0, len = _multipolygon._geometries.length; i < len; ++i) {
      array.push('(' + extract.polygon.call(this, _multipolygon._geometries[i]) + ')');
    }
    return array.join(',');
  },


  /**
   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an
   * geometrycollection.
   *
   * @param {GeometryCollection} collection
   * @return {String} internal WKT representation of the collection.
   */
  geometrycollection: function geometrycollection(collection) {
    var array = [];
    for (var i = 0, len = collection._geometries.length; i < len; ++i) {
      array.push(this.extractGeometry(collection._geometries[i]));
    }
    return array.join(',');
  }
};

/**
 * Object with properties corresponding to the geometry types. Property values
 * are functions that do the actual parsing.
 * @private
 */
var parse = {
  coord: function coord(str) {
    var coords = str.trim().split(regExes.spaces);
    var coord = new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1]));
    this.precisionModel.makePrecise(coord);
    return coord;
  },


  /**
   * Return point geometry given a point WKT fragment.
   *
   * @param {String} str A WKT fragment representing the point.
   * @return {Point} A point geometry.
   * @private
   */
  point: function point(str) {
    if (str === undefined) return this.geometryFactory.createPoint();
    return this.geometryFactory.createPoint(parse.coord.call(this, str));
  },


  /**
   * Return a multipoint geometry given a multipoint WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multipoint.
   * @return {Point} A multipoint feature.
   * @private
   */
  multipoint: function multipoint(str) {
    if (str === undefined) return this.geometryFactory.createMultiPoint();
    var point;
    var points = str.trim().split(',');
    var components = [];
    for (var i = 0, len = points.length; i < len; ++i) {
      point = points[i].replace(regExes.trimParens, '$1');
      components.push(parse.point.call(this, point));
    }
    return this.geometryFactory.createMultiPoint(components);
  },


  /**
   * Return a linestring geometry given a linestring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the linestring.
   * @return {LineString} A linestring geometry.
   * @private
   */
  linestring: function linestring(str) {
    if (str === undefined) {
      return this.geometryFactory.createLineString();
    }

    var points = str.trim().split(',');
    var components = [];
    for (var i = 0, len = points.length; i < len; ++i) {
      components.push(parse.coord.call(this, points[i]));
    }
    return this.geometryFactory.createLineString(components);
  },


  /**
   * Return a linearring geometry given a linearring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the linearring.
   * @return {LinearRing} A linearring geometry.
   * @private
   */
  linearring: function linearring(str) {
    if (str === undefined) {
      return this.geometryFactory.createLinearRing();
    }

    var points = str.trim().split(',');
    var components = [];
    for (var i = 0, len = points.length; i < len; ++i) {
      components.push(parse.coord.call(this, points[i]));
    }
    return this.geometryFactory.createLinearRing(components);
  },


  /**
   * Return a multilinestring geometry given a multilinestring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multilinestring.
   * @return {MultiLineString} A multilinestring geometry.
   * @private
   */
  multilinestring: function multilinestring(str) {
    if (str === undefined) {
      return this.geometryFactory.createMultiLineString();
    }

    var line;
    var lines = str.trim().split(regExes.parenComma);
    var components = [];
    for (var i = 0, len = lines.length; i < len; ++i) {
      line = lines[i].replace(regExes.trimParens, '$1');
      components.push(parse.linestring.call(this, line));
    }
    return this.geometryFactory.createMultiLineString(components);
  },


  /**
   * Return a polygon geometry given a polygon WKT fragment.
   *
   * @param {String} str A WKT fragment representing the polygon.
   * @return {Polygon} A polygon geometry.
   * @private
   */
  polygon: function polygon(str) {
    if (str === undefined) {
      return this.geometryFactory.createPolygon();
    }

    var ring, linestring, linearring;
    var rings = str.trim().split(regExes.parenComma);
    var shell;
    var holes = [];
    for (var i = 0, len = rings.length; i < len; ++i) {
      ring = rings[i].replace(regExes.trimParens, '$1');
      linestring = parse.linestring.call(this, ring);
      linearring = this.geometryFactory.createLinearRing(linestring._points);
      if (i === 0) {
        shell = linearring;
      } else {
        holes.push(linearring);
      }
    }
    return this.geometryFactory.createPolygon(shell, holes);
  },


  /**
   * Return a multipolygon geometry given a multipolygon WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multipolygon.
   * @return {MultiPolygon} A multipolygon geometry.
   * @private
   */
  multipolygon: function multipolygon(str) {
    if (str === undefined) {
      return this.geometryFactory.createMultiPolygon();
    }

    var polygon;
    var polygons = str.trim().split(regExes.doubleParenComma);
    var components = [];
    for (var i = 0, len = polygons.length; i < len; ++i) {
      polygon = polygons[i].replace(regExes.trimParens, '$1');
      components.push(parse.polygon.call(this, polygon));
    }
    return this.geometryFactory.createMultiPolygon(components);
  },


  /**
   * Return a geometrycollection given a geometrycollection WKT fragment.
   *
   * @param {String} str A WKT fragment representing the geometrycollection.
   * @return {GeometryCollection}
   * @private
   */
  geometrycollection: function geometrycollection(str) {
    if (str === undefined) {
      return this.geometryFactory.createGeometryCollection();
    }

    // separate components of the collection with |
    str = str.replace(/,\s*([A-Za-z])/g, '|$1');
    var wktArray = str.trim().split('|');
    var components = [];
    for (var i = 0, len = wktArray.length; i < len; ++i) {
      components.push(this.read(wktArray[i]));
    }
    return this.geometryFactory.createGeometryCollection(components);
  }
};

/**
 * @module org/locationtech/jts/io/WKTWriter
 */

/**
 * Writes the Well-Known Text representation of a {@link Geometry}. The
 * Well-Known Text format is defined in the <A
 * HREF="http://www.opengis.org/techno/specs.htm"> OGC Simple Features
 * Specification for SQL</A>.
 * <p>
 * The <code>WKTWriter</code> outputs coordinates rounded to the precision
 * model. Only the maximum number of decimal places necessary to represent the
 * ordinates to the required precision will be output.
 * <p>
 * The SFS WKT spec does not define a special tag for {@link LinearRing}s.
 * Under the spec, rings are output as <code>LINESTRING</code>s.
 */

/**
 * @param {GeometryFactory} geometryFactory
 * @constructor
 */
function WKTWriter(geometryFactory) {
  this.parser = new WKTParser(geometryFactory);
}

extend(WKTWriter.prototype, {
  /**
   * Converts a <code>Geometry</code> to its Well-known Text representation.
   *
   * @param {Geometry} geometry a <code>Geometry</code> to process.
   * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple
   *         Features Specification).
   * @memberof module:org/locationtech/jts/io/WKTWriter#
   */
  write: function write(geometry) {
    return this.parser.write(geometry);
  }
});

extend(WKTWriter, {
  /**
   * Generates the WKT for a <tt>LINESTRING</tt> specified by two
   * {@link Coordinate}s.
   *
   * @param p0 the first coordinate.
   * @param p1 the second coordinate.
   *
   * @return the WKT.
   * @private
   */
  toLineString: function toLineString(p0, p1) {
    if (arguments.length !== 2) {
      throw new Error('Not implemented');
    }

    return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )';
  }
});

function LineIntersector() {
	this._result = null;
	this._inputLines = Array(2).fill().map(function () {
		return Array(2);
	});
	this._intPt = new Array(2).fill(null);
	this._intLineIndex = null;
	this._isProper = null;
	this._pa = null;
	this._pb = null;
	this._precisionModel = null;
	this._intPt[0] = new Coordinate();
	this._intPt[1] = new Coordinate();
	this._pa = this._intPt[0];
	this._pb = this._intPt[1];
	this._result = 0;
}
extend(LineIntersector.prototype, {
	getIndexAlongSegment: function getIndexAlongSegment(segmentIndex, intIndex) {
		this.computeIntLineIndex();
		return this._intLineIndex[segmentIndex][intIndex];
	},
	getTopologySummary: function getTopologySummary() {
		var catBuilder = new StringBuilder();
		if (this.isEndPoint()) catBuilder.append(" endpoint");
		if (this._isProper) catBuilder.append(" proper");
		if (this.isCollinear()) catBuilder.append(" collinear");
		return catBuilder.toString();
	},
	computeIntersection: function computeIntersection(p1, p2, p3, p4) {
		this._inputLines[0][0] = p1;
		this._inputLines[0][1] = p2;
		this._inputLines[1][0] = p3;
		this._inputLines[1][1] = p4;
		this._result = this.computeIntersect(p1, p2, p3, p4);
	},
	getIntersectionNum: function getIntersectionNum() {
		return this._result;
	},
	computeIntLineIndex: function computeIntLineIndex() {
		if (arguments.length === 0) {
			if (this._intLineIndex === null) {
				this._intLineIndex = Array(2).fill().map(function () {
					return Array(2);
				});
				this.computeIntLineIndex(0);
				this.computeIntLineIndex(1);
			}
		} else if (arguments.length === 1) {
			var segmentIndex = arguments[0];
			var dist0 = this.getEdgeDistance(segmentIndex, 0);
			var dist1 = this.getEdgeDistance(segmentIndex, 1);
			if (dist0 > dist1) {
				this._intLineIndex[segmentIndex][0] = 0;
				this._intLineIndex[segmentIndex][1] = 1;
			} else {
				this._intLineIndex[segmentIndex][0] = 1;
				this._intLineIndex[segmentIndex][1] = 0;
			}
		}
	},
	isProper: function isProper() {
		return this.hasIntersection() && this._isProper;
	},
	setPrecisionModel: function setPrecisionModel(precisionModel) {
		this._precisionModel = precisionModel;
	},
	isInteriorIntersection: function isInteriorIntersection() {
		if (arguments.length === 0) {
			if (this.isInteriorIntersection(0)) return true;
			if (this.isInteriorIntersection(1)) return true;
			return false;
		} else if (arguments.length === 1) {
			var inputLineIndex = arguments[0];
			for (var i = 0; i < this._result; i++) {
				if (!(this._intPt[i].equals2D(this._inputLines[inputLineIndex][0]) || this._intPt[i].equals2D(this._inputLines[inputLineIndex][1]))) {
					return true;
				}
			}
			return false;
		}
	},
	getIntersection: function getIntersection(intIndex) {
		return this._intPt[intIndex];
	},
	isEndPoint: function isEndPoint() {
		return this.hasIntersection() && !this._isProper;
	},
	hasIntersection: function hasIntersection() {
		return this._result !== LineIntersector.NO_INTERSECTION;
	},
	getEdgeDistance: function getEdgeDistance(segmentIndex, intIndex) {
		var dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);
		return dist;
	},
	isCollinear: function isCollinear() {
		return this._result === LineIntersector.COLLINEAR_INTERSECTION;
	},
	toString: function toString() {
		return WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
	},
	getEndpoint: function getEndpoint(segmentIndex, ptIndex) {
		return this._inputLines[segmentIndex][ptIndex];
	},
	isIntersection: function isIntersection(pt) {
		for (var i = 0; i < this._result; i++) {
			if (this._intPt[i].equals2D(pt)) {
				return true;
			}
		}
		return false;
	},
	getIntersectionAlongSegment: function getIntersectionAlongSegment(segmentIndex, intIndex) {
		this.computeIntLineIndex();
		return this._intPt[this._intLineIndex[segmentIndex][intIndex]];
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LineIntersector;
	}
});
LineIntersector.computeEdgeDistance = function (p, p0, p1) {
	var dx = Math.abs(p1.x - p0.x);
	var dy = Math.abs(p1.y - p0.y);
	var dist = -1.0;
	if (p.equals(p0)) {
		dist = 0.0;
	} else if (p.equals(p1)) {
		if (dx > dy) dist = dx;else dist = dy;
	} else {
		var pdx = Math.abs(p.x - p0.x);
		var pdy = Math.abs(p.y - p0.y);
		if (dx > dy) dist = pdx;else dist = pdy;
		if (dist === 0.0 && !p.equals(p0)) {
			dist = Math.max(pdx, pdy);
		}
	}
	Assert.isTrue(!(dist === 0.0 && !p.equals(p0)), "Bad distance calculation");
	return dist;
};
LineIntersector.nonRobustComputeEdgeDistance = function (p, p1, p2) {
	var dx = p.x - p1.x;
	var dy = p.y - p1.y;
	var dist = Math.sqrt(dx * dx + dy * dy);
	Assert.isTrue(!(dist === 0.0 && !p.equals(p1)), "Invalid distance calculation");
	return dist;
};
LineIntersector.DONT_INTERSECT = 0;
LineIntersector.DO_INTERSECT = 1;
LineIntersector.COLLINEAR = 2;
LineIntersector.NO_INTERSECTION = 0;
LineIntersector.POINT_INTERSECTION = 1;
LineIntersector.COLLINEAR_INTERSECTION = 2;

function RobustLineIntersector() {
	LineIntersector.apply(this);
}
inherits(RobustLineIntersector, LineIntersector);
extend(RobustLineIntersector.prototype, {
	isInSegmentEnvelopes: function isInSegmentEnvelopes(intPt) {
		var env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);
		var env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);
		return env0.contains(intPt) && env1.contains(intPt);
	},
	computeIntersection: function computeIntersection() {
		if (arguments.length === 3) {
			var p = arguments[0],
			    p1 = arguments[1],
			    p2 = arguments[2];
			this._isProper = false;
			if (Envelope.intersects(p1, p2, p)) {
				if (Orientation.index(p1, p2, p) === 0 && Orientation.index(p2, p1, p) === 0) {
					this._isProper = true;
					if (p.equals(p1) || p.equals(p2)) {
						this._isProper = false;
					}
					this._result = LineIntersector.POINT_INTERSECTION;
					return null;
				}
			}
			this._result = LineIntersector.NO_INTERSECTION;
		} else return LineIntersector.prototype.computeIntersection.apply(this, arguments);
	},
	normalizeToMinimum: function normalizeToMinimum(n1, n2, n3, n4, normPt) {
		normPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);
		normPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);
		n1.x -= normPt.x;
		n1.y -= normPt.y;
		n2.x -= normPt.x;
		n2.y -= normPt.y;
		n3.x -= normPt.x;
		n3.y -= normPt.y;
		n4.x -= normPt.x;
		n4.y -= normPt.y;
	},
	safeHCoordinateIntersection: function safeHCoordinateIntersection(p1, p2, q1, q2) {
		var intPt = null;
		try {
			intPt = HCoordinate.intersection(p1, p2, q1, q2);
		} catch (e) {
			if (e instanceof NotRepresentableException) {
				intPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);
			} else throw e;
		} finally {}
		return intPt;
	},
	intersection: function intersection(p1, p2, q1, q2) {
		var intPt = this.intersectionWithNormalization(p1, p2, q1, q2);
		if (!this.isInSegmentEnvelopes(intPt)) {
			intPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));
		}
		if (this._precisionModel !== null) {
			this._precisionModel.makePrecise(intPt);
		}
		return intPt;
	},
	smallestInAbsValue: function smallestInAbsValue(x1, x2, x3, x4) {
		var x = x1;
		var xabs = Math.abs(x);
		if (Math.abs(x2) < xabs) {
			x = x2;
			xabs = Math.abs(x2);
		}
		if (Math.abs(x3) < xabs) {
			x = x3;
			xabs = Math.abs(x3);
		}
		if (Math.abs(x4) < xabs) {
			x = x4;
		}
		return x;
	},
	checkDD: function checkDD(p1, p2, q1, q2, intPt) {
		var intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);
		var isIn = this.isInSegmentEnvelopes(intPtDD);
		System.out.println("DD in env = " + isIn + "  --------------------- " + intPtDD);
		if (intPt.distance(intPtDD) > 0.0001) {
			System.out.println("Distance = " + intPt.distance(intPtDD));
		}
	},
	intersectionWithNormalization: function intersectionWithNormalization(p1, p2, q1, q2) {
		var n1 = new Coordinate(p1);
		var n2 = new Coordinate(p2);
		var n3 = new Coordinate(q1);
		var n4 = new Coordinate(q2);
		var normPt = new Coordinate();
		this.normalizeToEnvCentre(n1, n2, n3, n4, normPt);
		var intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);
		intPt.x += normPt.x;
		intPt.y += normPt.y;
		return intPt;
	},
	computeCollinearIntersection: function computeCollinearIntersection(p1, p2, q1, q2) {
		var p1q1p2 = Envelope.intersects(p1, p2, q1);
		var p1q2p2 = Envelope.intersects(p1, p2, q2);
		var q1p1q2 = Envelope.intersects(q1, q2, p1);
		var q1p2q2 = Envelope.intersects(q1, q2, p2);
		if (p1q1p2 && p1q2p2) {
			this._intPt[0] = q1;
			this._intPt[1] = q2;
			return LineIntersector.COLLINEAR_INTERSECTION;
		}
		if (q1p1q2 && q1p2q2) {
			this._intPt[0] = p1;
			this._intPt[1] = p2;
			return LineIntersector.COLLINEAR_INTERSECTION;
		}
		if (p1q1p2 && q1p1q2) {
			this._intPt[0] = q1;
			this._intPt[1] = p1;
			return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;
		}
		if (p1q1p2 && q1p2q2) {
			this._intPt[0] = q1;
			this._intPt[1] = p2;
			return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;
		}
		if (p1q2p2 && q1p1q2) {
			this._intPt[0] = q2;
			this._intPt[1] = p1;
			return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;
		}
		if (p1q2p2 && q1p2q2) {
			this._intPt[0] = q2;
			this._intPt[1] = p2;
			return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;
		}
		return LineIntersector.NO_INTERSECTION;
	},
	normalizeToEnvCentre: function normalizeToEnvCentre(n00, n01, n10, n11, normPt) {
		var minX0 = n00.x < n01.x ? n00.x : n01.x;
		var minY0 = n00.y < n01.y ? n00.y : n01.y;
		var maxX0 = n00.x > n01.x ? n00.x : n01.x;
		var maxY0 = n00.y > n01.y ? n00.y : n01.y;
		var minX1 = n10.x < n11.x ? n10.x : n11.x;
		var minY1 = n10.y < n11.y ? n10.y : n11.y;
		var maxX1 = n10.x > n11.x ? n10.x : n11.x;
		var maxY1 = n10.y > n11.y ? n10.y : n11.y;
		var intMinX = minX0 > minX1 ? minX0 : minX1;
		var intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;
		var intMinY = minY0 > minY1 ? minY0 : minY1;
		var intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;
		var intMidX = (intMinX + intMaxX) / 2.0;
		var intMidY = (intMinY + intMaxY) / 2.0;
		normPt.x = intMidX;
		normPt.y = intMidY;
		n00.x -= normPt.x;
		n00.y -= normPt.y;
		n01.x -= normPt.x;
		n01.y -= normPt.y;
		n10.x -= normPt.x;
		n10.y -= normPt.y;
		n11.x -= normPt.x;
		n11.y -= normPt.y;
	},
	computeIntersect: function computeIntersect(p1, p2, q1, q2) {
		this._isProper = false;
		if (!Envelope.intersects(p1, p2, q1, q2)) return LineIntersector.NO_INTERSECTION;
		var Pq1 = Orientation.index(p1, p2, q1);
		var Pq2 = Orientation.index(p1, p2, q2);
		if (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) {
			return LineIntersector.NO_INTERSECTION;
		}
		var Qp1 = Orientation.index(q1, q2, p1);
		var Qp2 = Orientation.index(q1, q2, p2);
		if (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) {
			return LineIntersector.NO_INTERSECTION;
		}
		var collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;
		if (collinear) {
			return this.computeCollinearIntersection(p1, p2, q1, q2);
		}
		if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {
			this._isProper = false;
			if (p1.equals2D(q1) || p1.equals2D(q2)) {
				this._intPt[0] = p1;
			} else if (p2.equals2D(q1) || p2.equals2D(q2)) {
				this._intPt[0] = p2;
			} else if (Pq1 === 0) {
				this._intPt[0] = new Coordinate(q1);
			} else if (Pq2 === 0) {
				this._intPt[0] = new Coordinate(q2);
			} else if (Qp1 === 0) {
				this._intPt[0] = new Coordinate(p1);
			} else if (Qp2 === 0) {
				this._intPt[0] = new Coordinate(p2);
			}
		} else {
			this._isProper = true;
			this._intPt[0] = this.intersection(p1, p2, q1, q2);
		}
		return LineIntersector.POINT_INTERSECTION;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return RobustLineIntersector;
	}
});
RobustLineIntersector.nearestEndpoint = function (p1, p2, q1, q2) {
	var nearestPt = p1;
	var minDist = Distance.pointToSegment(p1, q1, q2);
	var dist = Distance.pointToSegment(p2, q1, q2);
	if (dist < minDist) {
		minDist = dist;
		nearestPt = p2;
	}
	dist = Distance.pointToSegment(q1, p1, p2);
	if (dist < minDist) {
		minDist = dist;
		nearestPt = q1;
	}
	dist = Distance.pointToSegment(q2, p1, p2);
	if (dist < minDist) {
		minDist = dist;
		nearestPt = q2;
	}
	return nearestPt;
};

function LineSegment() {
	this.p0 = null;
	this.p1 = null;
	if (arguments.length === 0) {
		LineSegment.call(this, new Coordinate(), new Coordinate());
	} else if (arguments.length === 1) {
		var ls = arguments[0];
		LineSegment.call(this, ls.p0, ls.p1);
	} else if (arguments.length === 2) {
		var p0 = arguments[0],
		    p1 = arguments[1];
		this.p0 = p0;
		this.p1 = p1;
	} else if (arguments.length === 4) {
		var x0 = arguments[0],
		    y0 = arguments[1],
		    x1 = arguments[2],
		    y1 = arguments[3];
		LineSegment.call(this, new Coordinate(x0, y0), new Coordinate(x1, y1));
	}
}
extend(LineSegment.prototype, {
	minX: function minX() {
		return Math.min(this.p0.x, this.p1.x);
	},
	orientationIndex: function orientationIndex() {
		if (arguments[0] instanceof LineSegment) {
			var seg = arguments[0];
			var orient0 = Orientation.index(this.p0, this.p1, seg.p0);
			var orient1 = Orientation.index(this.p0, this.p1, seg.p1);
			if (orient0 >= 0 && orient1 >= 0) return Math.max(orient0, orient1);
			if (orient0 <= 0 && orient1 <= 0) return Math.max(orient0, orient1);
			return 0;
		} else if (arguments[0] instanceof Coordinate) {
			var p = arguments[0];
			return Orientation.index(this.p0, this.p1, p);
		}
	},
	toGeometry: function toGeometry(geomFactory) {
		return geomFactory.createLineString([this.p0, this.p1]);
	},
	isVertical: function isVertical() {
		return this.p0.x === this.p1.x;
	},
	equals: function equals(o) {
		if (!(o instanceof LineSegment)) {
			return false;
		}
		var other = o;
		return this.p0.equals(other.p0) && this.p1.equals(other.p1);
	},
	intersection: function intersection(line) {
		var li = new RobustLineIntersector();
		li.computeIntersection(this.p0, this.p1, line.p0, line.p1);
		if (li.hasIntersection()) return li.getIntersection(0);
		return null;
	},
	project: function project() {
		if (arguments[0] instanceof Coordinate) {
			var p = arguments[0];
			if (p.equals(this.p0) || p.equals(this.p1)) return new Coordinate(p);
			var r = this.projectionFactor(p);
			var coord = new Coordinate();
			coord.x = this.p0.x + r * (this.p1.x - this.p0.x);
			coord.y = this.p0.y + r * (this.p1.y - this.p0.y);
			return coord;
		} else if (arguments[0] instanceof LineSegment) {
			var seg = arguments[0];
			var pf0 = this.projectionFactor(seg.p0);
			var pf1 = this.projectionFactor(seg.p1);
			if (pf0 >= 1.0 && pf1 >= 1.0) return null;
			if (pf0 <= 0.0 && pf1 <= 0.0) return null;
			var newp0 = this.project(seg.p0);
			if (pf0 < 0.0) newp0 = this.p0;
			if (pf0 > 1.0) newp0 = this.p1;
			var newp1 = this.project(seg.p1);
			if (pf1 < 0.0) newp1 = this.p0;
			if (pf1 > 1.0) newp1 = this.p1;
			return new LineSegment(newp0, newp1);
		}
	},
	normalize: function normalize() {
		if (this.p1.compareTo(this.p0) < 0) this.reverse();
	},
	angle: function angle() {
		return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
	},
	getCoordinate: function getCoordinate(i) {
		if (i === 0) return this.p0;
		return this.p1;
	},
	distancePerpendicular: function distancePerpendicular(p) {
		return Distance.pointToLinePerpendicular(p, this.p0, this.p1);
	},
	minY: function minY() {
		return Math.min(this.p0.y, this.p1.y);
	},
	midPoint: function midPoint() {
		return LineSegment.midPoint(this.p0, this.p1);
	},
	projectionFactor: function projectionFactor(p) {
		if (p.equals(this.p0)) return 0.0;
		if (p.equals(this.p1)) return 1.0;
		var dx = this.p1.x - this.p0.x;
		var dy = this.p1.y - this.p0.y;
		var len = dx * dx + dy * dy;
		if (len <= 0.0) return Double.NaN;
		var r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;
		return r;
	},
	closestPoints: function closestPoints(line) {
		var intPt = this.intersection(line);
		if (intPt !== null) {
			return [intPt, intPt];
		}
		var closestPt = new Array(2).fill(null);
		var minDistance = Double.MAX_VALUE;
		var dist = null;
		var close00 = this.closestPoint(line.p0);
		minDistance = close00.distance(line.p0);
		closestPt[0] = close00;
		closestPt[1] = line.p0;
		var close01 = this.closestPoint(line.p1);
		dist = close01.distance(line.p1);
		if (dist < minDistance) {
			minDistance = dist;
			closestPt[0] = close01;
			closestPt[1] = line.p1;
		}
		var close10 = line.closestPoint(this.p0);
		dist = close10.distance(this.p0);
		if (dist < minDistance) {
			minDistance = dist;
			closestPt[0] = this.p0;
			closestPt[1] = close10;
		}
		var close11 = line.closestPoint(this.p1);
		dist = close11.distance(this.p1);
		if (dist < minDistance) {
			minDistance = dist;
			closestPt[0] = this.p1;
			closestPt[1] = close11;
		}
		return closestPt;
	},
	closestPoint: function closestPoint(p) {
		var factor = this.projectionFactor(p);
		if (factor > 0 && factor < 1) {
			return this.project(p);
		}
		var dist0 = this.p0.distance(p);
		var dist1 = this.p1.distance(p);
		if (dist0 < dist1) return this.p0;
		return this.p1;
	},
	maxX: function maxX() {
		return Math.max(this.p0.x, this.p1.x);
	},
	getLength: function getLength() {
		return this.p0.distance(this.p1);
	},
	compareTo: function compareTo(o) {
		var other = o;
		var comp0 = this.p0.compareTo(other.p0);
		if (comp0 !== 0) return comp0;
		return this.p1.compareTo(other.p1);
	},
	reverse: function reverse() {
		var temp = this.p0;
		this.p0 = this.p1;
		this.p1 = temp;
	},
	equalsTopo: function equalsTopo(other) {
		return this.p0.equals(other.p0) && this.p1.equals(other.p1) || this.p0.equals(other.p1) && this.p1.equals(other.p0);
	},
	lineIntersection: function lineIntersection(line) {
		try {
			var intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);
			return intPt;
		} catch (ex) {
			if (ex instanceof NotRepresentableException) {} else throw ex;
		} finally {}
		return null;
	},
	maxY: function maxY() {
		return Math.max(this.p0.y, this.p1.y);
	},
	pointAlongOffset: function pointAlongOffset(segmentLengthFraction, offsetDistance) {
		var segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
		var segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
		var dx = this.p1.x - this.p0.x;
		var dy = this.p1.y - this.p0.y;
		var len = Math.sqrt(dx * dx + dy * dy);
		var ux = 0.0;
		var uy = 0.0;
		if (offsetDistance !== 0.0) {
			if (len <= 0.0) throw new IllegalStateException("Cannot compute offset from zero-length line segment");
			ux = offsetDistance * dx / len;
			uy = offsetDistance * dy / len;
		}
		var offsetx = segx - uy;
		var offsety = segy + ux;
		var coord = new Coordinate(offsetx, offsety);
		return coord;
	},
	setCoordinates: function setCoordinates() {
		if (arguments.length === 1) {
			var ls = arguments[0];
			this.setCoordinates(ls.p0, ls.p1);
		} else if (arguments.length === 2) {
			var p0 = arguments[0],
			    p1 = arguments[1];
			this.p0.x = p0.x;
			this.p0.y = p0.y;
			this.p1.x = p1.x;
			this.p1.y = p1.y;
		}
	},
	segmentFraction: function segmentFraction(inputPt) {
		var segFrac = this.projectionFactor(inputPt);
		if (segFrac < 0.0) segFrac = 0.0;else if (segFrac > 1.0 || Double.isNaN(segFrac)) segFrac = 1.0;
		return segFrac;
	},
	toString: function toString() {
		return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
	},
	isHorizontal: function isHorizontal() {
		return this.p0.y === this.p1.y;
	},
	distance: function distance() {
		if (arguments[0] instanceof LineSegment) {
			var ls = arguments[0];
			return Distance.segmentToSegment(this.p0, this.p1, ls.p0, ls.p1);
		} else if (arguments[0] instanceof Coordinate) {
			var p = arguments[0];
			return Distance.pointToSegment(p, this.p0, this.p1);
		}
	},
	pointAlong: function pointAlong(segmentLengthFraction) {
		var coord = new Coordinate();
		coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
		coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
		return coord;
	},
	hashCode: function hashCode() {
		var bits0 = java.lang.Double.doubleToLongBits(this.p0.x);
		bits0 ^= java.lang.Double.doubleToLongBits(this.p0.y) * 31;
		var hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);
		var bits1 = java.lang.Double.doubleToLongBits(this.p1.x);
		bits1 ^= java.lang.Double.doubleToLongBits(this.p1.y) * 31;
		var hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);
		return hash0 ^ hash1;
	},
	interfaces_: function interfaces_() {
		return [Comparable, Serializable];
	},
	getClass: function getClass() {
		return LineSegment;
	}
});
LineSegment.midPoint = function (p0, p1) {
	return new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
};
LineSegment.serialVersionUID = 3252005833466256227;

function Location() {}
extend(Location.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Location;
	}
});
Location.toLocationSymbol = function (locationValue) {
	switch (locationValue) {
		case Location.EXTERIOR:
			return 'e';
		case Location.BOUNDARY:
			return 'b';
		case Location.INTERIOR:
			return 'i';
		case Location.NONE:
			return '-';
	}
	throw new IllegalArgumentException("Unknown location value: " + locationValue);
};
Location.INTERIOR = 0;
Location.BOUNDARY = 1;
Location.EXTERIOR = 2;
Location.NONE = -1;

function IntersectionMatrix() {
	this._matrix = null;
	if (arguments.length === 0) {
		this._matrix = Array(3).fill().map(function () {
			return Array(3);
		});
		this.setAll(Dimension.FALSE);
	} else if (arguments.length === 1) {
		if (typeof arguments[0] === "string") {
			var elements = arguments[0];
			IntersectionMatrix.call(this);
			this.set(elements);
		} else if (arguments[0] instanceof IntersectionMatrix) {
			var other = arguments[0];
			IntersectionMatrix.call(this);
			this._matrix[Location.INTERIOR][Location.INTERIOR] = other._matrix[Location.INTERIOR][Location.INTERIOR];
			this._matrix[Location.INTERIOR][Location.BOUNDARY] = other._matrix[Location.INTERIOR][Location.BOUNDARY];
			this._matrix[Location.INTERIOR][Location.EXTERIOR] = other._matrix[Location.INTERIOR][Location.EXTERIOR];
			this._matrix[Location.BOUNDARY][Location.INTERIOR] = other._matrix[Location.BOUNDARY][Location.INTERIOR];
			this._matrix[Location.BOUNDARY][Location.BOUNDARY] = other._matrix[Location.BOUNDARY][Location.BOUNDARY];
			this._matrix[Location.BOUNDARY][Location.EXTERIOR] = other._matrix[Location.BOUNDARY][Location.EXTERIOR];
			this._matrix[Location.EXTERIOR][Location.INTERIOR] = other._matrix[Location.EXTERIOR][Location.INTERIOR];
			this._matrix[Location.EXTERIOR][Location.BOUNDARY] = other._matrix[Location.EXTERIOR][Location.BOUNDARY];
			this._matrix[Location.EXTERIOR][Location.EXTERIOR] = other._matrix[Location.EXTERIOR][Location.EXTERIOR];
		}
	}
}
extend(IntersectionMatrix.prototype, {
	isIntersects: function isIntersects() {
		return !this.isDisjoint();
	},
	isCovers: function isCovers() {
		var hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);
		return hasPointInCommon && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;
	},
	isCoveredBy: function isCoveredBy() {
		var hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);
		return hasPointInCommon && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;
	},
	set: function set() {
		if (arguments.length === 1) {
			var dimensionSymbols = arguments[0];
			for (var i = 0; i < dimensionSymbols.length; i++) {
				var row = Math.trunc(i / 3);
				var col = i % 3;
				this._matrix[row][col] = Dimension.toDimensionValue(dimensionSymbols.charAt(i));
			}
		} else if (arguments.length === 3) {
			var _row = arguments[0],
			    column = arguments[1],
			    dimensionValue = arguments[2];
			this._matrix[_row][column] = dimensionValue;
		}
	},
	isContains: function isContains() {
		return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;
	},
	setAtLeast: function setAtLeast() {
		if (arguments.length === 1) {
			var minimumDimensionSymbols = arguments[0];
			for (var i = 0; i < minimumDimensionSymbols.length; i++) {
				var row = Math.trunc(i / 3);
				var col = i % 3;
				this.setAtLeast(row, col, Dimension.toDimensionValue(minimumDimensionSymbols.charAt(i)));
			}
		} else if (arguments.length === 3) {
			var _row2 = arguments[0],
			    column = arguments[1],
			    minimumDimensionValue = arguments[2];
			if (this._matrix[_row2][column] < minimumDimensionValue) {
				this._matrix[_row2][column] = minimumDimensionValue;
			}
		}
	},
	setAtLeastIfValid: function setAtLeastIfValid(row, column, minimumDimensionValue) {
		if (row >= 0 && column >= 0) {
			this.setAtLeast(row, column, minimumDimensionValue);
		}
	},
	isWithin: function isWithin() {
		return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;
	},
	isTouches: function isTouches(dimensionOfGeometryA, dimensionOfGeometryB) {
		if (dimensionOfGeometryA > dimensionOfGeometryB) {
			return this.isTouches(dimensionOfGeometryB, dimensionOfGeometryA);
		}
		if (dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L) {
			return this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && (IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]));
		}
		return false;
	},
	isOverlaps: function isOverlaps(dimensionOfGeometryA, dimensionOfGeometryB) {
		if (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A) {
			return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);
		}
		if (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {
			return this._matrix[Location.INTERIOR][Location.INTERIOR] === 1 && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);
		}
		return false;
	},
	isEquals: function isEquals(dimensionOfGeometryA, dimensionOfGeometryB) {
		if (dimensionOfGeometryA !== dimensionOfGeometryB) {
			return false;
		}
		return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;
	},
	toString: function toString() {
		var builder = new StringBuilder("123456789");
		for (var ai = 0; ai < 3; ai++) {
			for (var bi = 0; bi < 3; bi++) {
				builder.setCharAt(3 * ai + bi, Dimension.toDimensionSymbol(this._matrix[ai][bi]));
			}
		}
		return builder.toString();
	},
	setAll: function setAll(dimensionValue) {
		for (var ai = 0; ai < 3; ai++) {
			for (var bi = 0; bi < 3; bi++) {
				this._matrix[ai][bi] = dimensionValue;
			}
		}
	},
	get: function get(row, column) {
		return this._matrix[row][column];
	},
	transpose: function transpose() {
		var temp = this._matrix[1][0];
		this._matrix[1][0] = this._matrix[0][1];
		this._matrix[0][1] = temp;
		temp = this._matrix[2][0];
		this._matrix[2][0] = this._matrix[0][2];
		this._matrix[0][2] = temp;
		temp = this._matrix[2][1];
		this._matrix[2][1] = this._matrix[1][2];
		this._matrix[1][2] = temp;
		return this;
	},
	matches: function matches(requiredDimensionSymbols) {
		if (requiredDimensionSymbols.length !== 9) {
			throw new IllegalArgumentException("Should be length 9: " + requiredDimensionSymbols);
		}
		for (var ai = 0; ai < 3; ai++) {
			for (var bi = 0; bi < 3; bi++) {
				if (!IntersectionMatrix.matches(this._matrix[ai][bi], requiredDimensionSymbols.charAt(3 * ai + bi))) {
					return false;
				}
			}
		}
		return true;
	},
	add: function add(im) {
		for (var i = 0; i < 3; i++) {
			for (var j = 0; j < 3; j++) {
				this.setAtLeast(i, j, im.get(i, j));
			}
		}
	},
	isDisjoint: function isDisjoint() {
		return this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.INTERIOR][Location.BOUNDARY] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.BOUNDARY] === Dimension.FALSE;
	},
	isCrosses: function isCrosses(dimensionOfGeometryA, dimensionOfGeometryB) {
		if (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A) {
			return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]);
		}
		if (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.L) {
			return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);
		}
		if (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) {
			return this._matrix[Location.INTERIOR][Location.INTERIOR] === 0;
		}
		return false;
	},
	interfaces_: function interfaces_() {
		return [Clonable];
	},
	getClass: function getClass() {
		return IntersectionMatrix;
	}
});
IntersectionMatrix.matches = function () {
	if (Number.isInteger(arguments[0]) && typeof arguments[1] === "string") {
		var actualDimensionValue = arguments[0],
		    requiredDimensionSymbol = arguments[1];
		if (requiredDimensionSymbol === Dimension.SYM_DONTCARE) {
			return true;
		}
		if (requiredDimensionSymbol === Dimension.SYM_TRUE && (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE)) {
			return true;
		}
		if (requiredDimensionSymbol === Dimension.SYM_FALSE && actualDimensionValue === Dimension.FALSE) {
			return true;
		}
		if (requiredDimensionSymbol === Dimension.SYM_P && actualDimensionValue === Dimension.P) {
			return true;
		}
		if (requiredDimensionSymbol === Dimension.SYM_L && actualDimensionValue === Dimension.L) {
			return true;
		}
		if (requiredDimensionSymbol === Dimension.SYM_A && actualDimensionValue === Dimension.A) {
			return true;
		}
		return false;
	} else if (typeof arguments[0] === "string" && typeof arguments[1] === "string") {
		var actualDimensionSymbols = arguments[0],
		    requiredDimensionSymbols = arguments[1];
		var m = new IntersectionMatrix(actualDimensionSymbols);
		return m.matches(requiredDimensionSymbols);
	}
};
IntersectionMatrix.isTrue = function (actualDimensionValue) {
	if (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE) {
		return true;
	}
	return false;
};

function Angle() {}
extend(Angle.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Angle;
	}
});
Angle.toDegrees = function (radians) {
	return radians * 180 / Math.PI;
};
Angle.normalize = function (angle) {
	while (angle > Math.PI) {
		angle -= Angle.PI_TIMES_2;
	}while (angle <= -Math.PI) {
		angle += Angle.PI_TIMES_2;
	}return angle;
};
Angle.angle = function () {
	if (arguments.length === 1) {
		var p = arguments[0];
		return Math.atan2(p.y, p.x);
	} else if (arguments.length === 2) {
		var p0 = arguments[0],
		    p1 = arguments[1];
		var dx = p1.x - p0.x;
		var dy = p1.y - p0.y;
		return Math.atan2(dy, dx);
	}
};
Angle.isAcute = function (p0, p1, p2) {
	var dx0 = p0.x - p1.x;
	var dy0 = p0.y - p1.y;
	var dx1 = p2.x - p1.x;
	var dy1 = p2.y - p1.y;
	var dotprod = dx0 * dx1 + dy0 * dy1;
	return dotprod > 0;
};
Angle.isObtuse = function (p0, p1, p2) {
	var dx0 = p0.x - p1.x;
	var dy0 = p0.y - p1.y;
	var dx1 = p2.x - p1.x;
	var dy1 = p2.y - p1.y;
	var dotprod = dx0 * dx1 + dy0 * dy1;
	return dotprod < 0;
};
Angle.interiorAngle = function (p0, p1, p2) {
	var anglePrev = Angle.angle(p1, p0);
	var angleNext = Angle.angle(p1, p2);
	return Math.abs(angleNext - anglePrev);
};
Angle.normalizePositive = function (angle) {
	if (angle < 0.0) {
		while (angle < 0.0) {
			angle += Angle.PI_TIMES_2;
		}if (angle >= Angle.PI_TIMES_2) angle = 0.0;
	} else {
		while (angle >= Angle.PI_TIMES_2) {
			angle -= Angle.PI_TIMES_2;
		}if (angle < 0.0) angle = 0.0;
	}
	return angle;
};
Angle.angleBetween = function (tip1, tail, tip2) {
	var a1 = Angle.angle(tail, tip1);
	var a2 = Angle.angle(tail, tip2);
	return Angle.diff(a1, a2);
};
Angle.diff = function (ang1, ang2) {
	var delAngle = null;
	if (ang1 < ang2) {
		delAngle = ang2 - ang1;
	} else {
		delAngle = ang1 - ang2;
	}
	if (delAngle > Math.PI) {
		delAngle = 2 * Math.PI - delAngle;
	}
	return delAngle;
};
Angle.toRadians = function (angleDegrees) {
	return angleDegrees * Math.PI / 180.0;
};
Angle.getTurn = function (ang1, ang2) {
	var crossproduct = Math.sin(ang2 - ang1);
	if (crossproduct > 0) {
		return Angle.COUNTERCLOCKWISE;
	}
	if (crossproduct < 0) {
		return Angle.CLOCKWISE;
	}
	return Angle.NONE;
};
Angle.angleBetweenOriented = function (tip1, tail, tip2) {
	var a1 = Angle.angle(tail, tip1);
	var a2 = Angle.angle(tail, tip2);
	var angDel = a2 - a1;
	if (angDel <= -Math.PI) return angDel + Angle.PI_TIMES_2;
	if (angDel > Math.PI) return angDel - Angle.PI_TIMES_2;
	return angDel;
};
Angle.PI_TIMES_2 = 2.0 * Math.PI;
Angle.PI_OVER_2 = Math.PI / 2.0;
Angle.PI_OVER_4 = Math.PI / 4.0;
Angle.COUNTERCLOCKWISE = Orientation.COUNTERCLOCKWISE;
Angle.CLOCKWISE = Orientation.CLOCKWISE;
Angle.NONE = Orientation.COLLINEAR;

function Triangle() {
	this.p0 = null;
	this.p1 = null;
	this.p2 = null;
	var p0 = arguments[0],
	    p1 = arguments[1],
	    p2 = arguments[2];
	this.p0 = p0;
	this.p1 = p1;
	this.p2 = p2;
}
extend(Triangle.prototype, {
	area: function area() {
		return Triangle.area(this.p0, this.p1, this.p2);
	},
	signedArea: function signedArea() {
		return Triangle.signedArea(this.p0, this.p1, this.p2);
	},
	interpolateZ: function interpolateZ(p) {
		if (p === null) throw new IllegalArgumentException("Supplied point is null.");
		return Triangle.interpolateZ(p, this.p0, this.p1, this.p2);
	},
	longestSideLength: function longestSideLength() {
		return Triangle.longestSideLength(this.p0, this.p1, this.p2);
	},
	isAcute: function isAcute() {
		return Triangle.isAcute(this.p0, this.p1, this.p2);
	},
	circumcentre: function circumcentre() {
		return Triangle.circumcentre(this.p0, this.p1, this.p2);
	},
	area3D: function area3D() {
		return Triangle.area3D(this.p0, this.p1, this.p2);
	},
	centroid: function centroid() {
		return Triangle.centroid(this.p0, this.p1, this.p2);
	},
	inCentre: function inCentre() {
		return Triangle.inCentre(this.p0, this.p1, this.p2);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Triangle;
	}
});
Triangle.area = function (a, b, c) {
	return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2);
};
Triangle.signedArea = function (a, b, c) {
	return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2;
};
Triangle.det = function (m00, m01, m10, m11) {
	return m00 * m11 - m01 * m10;
};
Triangle.interpolateZ = function (p, v0, v1, v2) {
	var x0 = v0.x;
	var y0 = v0.y;
	var a = v1.x - x0;
	var b = v2.x - x0;
	var c = v1.y - y0;
	var d = v2.y - y0;
	var det = a * d - b * c;
	var dx = p.x - x0;
	var dy = p.y - y0;
	var t = (d * dx - b * dy) / det;
	var u = (-c * dx + a * dy) / det;
	var z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);
	return z;
};
Triangle.longestSideLength = function (a, b, c) {
	var lenAB = a.distance(b);
	var lenBC = b.distance(c);
	var lenCA = c.distance(a);
	var maxLen = lenAB;
	if (lenBC > maxLen) maxLen = lenBC;
	if (lenCA > maxLen) maxLen = lenCA;
	return maxLen;
};
Triangle.isAcute = function (a, b, c) {
	if (!Angle.isAcute(a, b, c)) return false;
	if (!Angle.isAcute(b, c, a)) return false;
	if (!Angle.isAcute(c, a, b)) return false;
	return true;
};
Triangle.circumcentre = function (a, b, c) {
	var cx = c.x;
	var cy = c.y;
	var ax = a.x - cx;
	var ay = a.y - cy;
	var bx = b.x - cx;
	var by = b.y - cy;
	var denom = 2 * Triangle.det(ax, ay, bx, by);
	var numx = Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
	var numy = Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);
	var ccx = cx - numx / denom;
	var ccy = cy + numy / denom;
	return new Coordinate(ccx, ccy);
};
Triangle.perpendicularBisector = function (a, b) {
	var dx = b.x - a.x;
	var dy = b.y - a.y;
	var l1 = new HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);
	var l2 = new HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);
	return new HCoordinate(l1, l2);
};
Triangle.angleBisector = function (a, b, c) {
	var len0 = b.distance(a);
	var len2 = b.distance(c);
	var frac = len0 / (len0 + len2);
	var dx = c.x - a.x;
	var dy = c.y - a.y;
	var splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);
	return splitPt;
};
Triangle.area3D = function (a, b, c) {
	var ux = b.x - a.x;
	var uy = b.y - a.y;
	var uz = b.z - a.z;
	var vx = c.x - a.x;
	var vy = c.y - a.y;
	var vz = c.z - a.z;
	var crossx = uy * vz - uz * vy;
	var crossy = uz * vx - ux * vz;
	var crossz = ux * vy - uy * vx;
	var absSq = crossx * crossx + crossy * crossy + crossz * crossz;
	var area3D = Math.sqrt(absSq) / 2;
	return area3D;
};
Triangle.centroid = function (a, b, c) {
	var x = (a.x + b.x + c.x) / 3;
	var y = (a.y + b.y + c.y) / 3;
	return new Coordinate(x, y);
};
Triangle.inCentre = function (a, b, c) {
	var len0 = b.distance(c);
	var len1 = a.distance(c);
	var len2 = a.distance(b);
	var circum = len0 + len1 + len2;
	var inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;
	var inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;
	return new Coordinate(inCentreX, inCentreY);
};



var geom = Object.freeze({
	Coordinate: Coordinate,
	CoordinateList: CoordinateList,
	Envelope: Envelope,
	LineSegment: LineSegment,
	GeometryFactory: GeometryFactory,
	Geometry: Geometry,
	Point: Point,
	LineString: LineString,
	LinearRing: LinearRing,
	Polygon: Polygon,
	GeometryCollection: GeometryCollection,
	MultiPoint: MultiPoint,
	MultiLineString: MultiLineString,
	MultiPolygon: MultiPolygon,
	Dimension: Dimension,
	IntersectionMatrix: IntersectionMatrix,
	PrecisionModel: PrecisionModel,
	Location: Location,
	Triangle: Triangle
});

function PointPairDistance() {
	this._pt = [new Coordinate(), new Coordinate()];
	this._distance = Double.NaN;
	this._isNull = true;
}
extend(PointPairDistance.prototype, {
	getCoordinates: function getCoordinates() {
		return this._pt;
	},
	getCoordinate: function getCoordinate(i) {
		return this._pt[i];
	},
	setMinimum: function setMinimum() {
		if (arguments.length === 1) {
			var ptDist = arguments[0];
			this.setMinimum(ptDist._pt[0], ptDist._pt[1]);
		} else if (arguments.length === 2) {
			var p0 = arguments[0],
			    p1 = arguments[1];
			if (this._isNull) {
				this.initialize(p0, p1);
				return null;
			}
			var dist = p0.distance(p1);
			if (dist < this._distance) this.initialize(p0, p1, dist);
		}
	},
	initialize: function initialize() {
		if (arguments.length === 0) {
			this._isNull = true;
		} else if (arguments.length === 2) {
			var p0 = arguments[0],
			    p1 = arguments[1];
			this._pt[0].setCoordinate(p0);
			this._pt[1].setCoordinate(p1);
			this._distance = p0.distance(p1);
			this._isNull = false;
		} else if (arguments.length === 3) {
			var _p = arguments[0],
			    _p2 = arguments[1],
			    distance = arguments[2];
			this._pt[0].setCoordinate(_p);
			this._pt[1].setCoordinate(_p2);
			this._distance = distance;
			this._isNull = false;
		}
	},
	toString: function toString() {
		return WKTWriter.toLineString(this._pt[0], this._pt[1]);
	},
	getDistance: function getDistance() {
		return this._distance;
	},
	setMaximum: function setMaximum() {
		if (arguments.length === 1) {
			var ptDist = arguments[0];
			this.setMaximum(ptDist._pt[0], ptDist._pt[1]);
		} else if (arguments.length === 2) {
			var p0 = arguments[0],
			    p1 = arguments[1];
			if (this._isNull) {
				this.initialize(p0, p1);
				return null;
			}
			var dist = p0.distance(p1);
			if (dist > this._distance) this.initialize(p0, p1, dist);
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return PointPairDistance;
	}
});

function DistanceToPoint() {}
extend(DistanceToPoint.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return DistanceToPoint;
	}
});
DistanceToPoint.computeDistance = function () {
	if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof LineString && arguments[1] instanceof Coordinate) {
		var line = arguments[0],
		    pt = arguments[1],
		    ptDist = arguments[2];
		var tempSegment = new LineSegment();
		var coords = line.getCoordinates();
		for (var i = 0; i < coords.length - 1; i++) {
			tempSegment.setCoordinates(coords[i], coords[i + 1]);
			var closestPt = tempSegment.closestPoint(pt);
			ptDist.setMinimum(closestPt, pt);
		}
	} else if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate) {
		var poly = arguments[0],
		    _pt = arguments[1],
		    _ptDist = arguments[2];
		DistanceToPoint.computeDistance(poly.getExteriorRing(), _pt, _ptDist);
		for (var i = 0; i < poly.getNumInteriorRing(); i++) {
			DistanceToPoint.computeDistance(poly.getInteriorRingN(i), _pt, _ptDist);
		}
	} else if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate) {
		var geom = arguments[0],
		    _pt2 = arguments[1],
		    _ptDist2 = arguments[2];
		if (geom instanceof LineString) {
			DistanceToPoint.computeDistance(geom, _pt2, _ptDist2);
		} else if (geom instanceof Polygon) {
			DistanceToPoint.computeDistance(geom, _pt2, _ptDist2);
		} else if (geom instanceof GeometryCollection) {
			var gc = geom;
			for (var i = 0; i < gc.getNumGeometries(); i++) {
				var g = gc.getGeometryN(i);
				DistanceToPoint.computeDistance(g, _pt2, _ptDist2);
			}
		} else {
			_ptDist2.setMinimum(geom.getCoordinate(), _pt2);
		}
	} else if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate) {
		var segment = arguments[0],
		    _pt3 = arguments[1],
		    _ptDist3 = arguments[2];
		var closestPt = segment.closestPoint(_pt3);
		_ptDist3.setMinimum(closestPt, _pt3);
	}
};

function DiscreteHausdorffDistance() {
	this._g0 = null;
	this._g1 = null;
	this._ptDist = new PointPairDistance();
	this._densifyFrac = 0.0;
	var g0 = arguments[0],
	    g1 = arguments[1];
	this._g0 = g0;
	this._g1 = g1;
}
extend(DiscreteHausdorffDistance.prototype, {
	getCoordinates: function getCoordinates() {
		return this._ptDist.getCoordinates();
	},
	setDensifyFraction: function setDensifyFraction(densifyFrac) {
		if (densifyFrac > 1.0 || densifyFrac <= 0.0) throw new IllegalArgumentException("Fraction is not in range (0.0 - 1.0]");
		this._densifyFrac = densifyFrac;
	},
	compute: function compute(g0, g1) {
		this.computeOrientedDistance(g0, g1, this._ptDist);
		this.computeOrientedDistance(g1, g0, this._ptDist);
	},
	distance: function distance() {
		this.compute(this._g0, this._g1);
		return this._ptDist.getDistance();
	},
	computeOrientedDistance: function computeOrientedDistance(discreteGeom, geom, ptDist) {
		var distFilter = new MaxPointDistanceFilter(geom);
		discreteGeom.apply(distFilter);
		ptDist.setMaximum(distFilter.getMaxPointDistance());
		if (this._densifyFrac > 0) {
			var fracFilter = new MaxDensifiedByFractionDistanceFilter(geom, this._densifyFrac);
			discreteGeom.apply(fracFilter);
			ptDist.setMaximum(fracFilter.getMaxPointDistance());
		}
	},
	orientedDistance: function orientedDistance() {
		this.computeOrientedDistance(this._g0, this._g1, this._ptDist);
		return this._ptDist.getDistance();
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return DiscreteHausdorffDistance;
	}
});
DiscreteHausdorffDistance.distance = function () {
	if (arguments.length === 2) {
		var g0 = arguments[0],
		    g1 = arguments[1];
		var dist = new DiscreteHausdorffDistance(g0, g1);
		return dist.distance();
	} else if (arguments.length === 3) {
		var _g = arguments[0],
		    _g2 = arguments[1],
		    densifyFrac = arguments[2];
		var dist = new DiscreteHausdorffDistance(_g, _g2);
		dist.setDensifyFraction(densifyFrac);
		return dist.distance();
	}
};
function MaxPointDistanceFilter() {
	this._maxPtDist = new PointPairDistance();
	this._minPtDist = new PointPairDistance();
	this._euclideanDist = new DistanceToPoint();
	this._geom = null;
	var geom = arguments[0];
	this._geom = geom;
}
extend(MaxPointDistanceFilter.prototype, {
	filter: function filter(pt) {
		this._minPtDist.initialize();
		DistanceToPoint.computeDistance(this._geom, pt, this._minPtDist);
		this._maxPtDist.setMaximum(this._minPtDist);
	},
	getMaxPointDistance: function getMaxPointDistance() {
		return this._maxPtDist;
	},
	interfaces_: function interfaces_() {
		return [CoordinateFilter];
	},
	getClass: function getClass() {
		return MaxPointDistanceFilter;
	}
});
function MaxDensifiedByFractionDistanceFilter() {
	this._maxPtDist = new PointPairDistance();
	this._minPtDist = new PointPairDistance();
	this._geom = null;
	this._numSubSegs = 0;
	var geom = arguments[0],
	    fraction = arguments[1];
	this._geom = geom;
	this._numSubSegs = Math.trunc(Math.round(1.0 / fraction));
}
extend(MaxDensifiedByFractionDistanceFilter.prototype, {
	filter: function filter(seq, index) {
		if (index === 0) return null;
		var p0 = seq.getCoordinate(index - 1);
		var p1 = seq.getCoordinate(index);
		var delx = (p1.x - p0.x) / this._numSubSegs;
		var dely = (p1.y - p0.y) / this._numSubSegs;
		for (var i = 0; i < this._numSubSegs; i++) {
			var x = p0.x + i * delx;
			var y = p0.y + i * dely;
			var pt = new Coordinate(x, y);
			this._minPtDist.initialize();
			DistanceToPoint.computeDistance(this._geom, pt, this._minPtDist);
			this._maxPtDist.setMaximum(this._minPtDist);
		}
	},
	isDone: function isDone() {
		return false;
	},
	isGeometryChanged: function isGeometryChanged() {
		return false;
	},
	getMaxPointDistance: function getMaxPointDistance() {
		return this._maxPtDist;
	},
	interfaces_: function interfaces_() {
		return [CoordinateSequenceFilter];
	},
	getClass: function getClass() {
		return MaxDensifiedByFractionDistanceFilter;
	}
});
DiscreteHausdorffDistance.MaxPointDistanceFilter = MaxPointDistanceFilter;
DiscreteHausdorffDistance.MaxDensifiedByFractionDistanceFilter = MaxDensifiedByFractionDistanceFilter;

function ItemVisitor() {}
extend(ItemVisitor.prototype, {
	visitItem: function visitItem(item) {},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return ItemVisitor;
	}
});

function PointOnGeometryLocator() {}
extend(PointOnGeometryLocator.prototype, {
	locate: function locate(p) {},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return PointOnGeometryLocator;
	}
});

function IntervalRTreeNode() {
	this._min = Double.POSITIVE_INFINITY;
	this._max = Double.NEGATIVE_INFINITY;
}
extend(IntervalRTreeNode.prototype, {
	getMin: function getMin() {
		return this._min;
	},
	intersects: function intersects(queryMin, queryMax) {
		if (this._min > queryMax || this._max < queryMin) return false;
		return true;
	},
	getMax: function getMax() {
		return this._max;
	},
	toString: function toString() {
		return WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0));
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return IntervalRTreeNode;
	}
});
function NodeComparator() {}
extend(NodeComparator.prototype, {
	compare: function compare(o1, o2) {
		var n1 = o1;
		var n2 = o2;
		var mid1 = (n1._min + n1._max) / 2;
		var mid2 = (n2._min + n2._max) / 2;
		if (mid1 < mid2) return -1;
		if (mid1 > mid2) return 1;
		return 0;
	},
	interfaces_: function interfaces_() {
		return [Comparator];
	},
	getClass: function getClass() {
		return NodeComparator;
	}
});
IntervalRTreeNode.NodeComparator = NodeComparator;

function IntervalRTreeLeafNode() {
	IntervalRTreeNode.apply(this);
	this._item = null;
	var min = arguments[0],
	    max = arguments[1],
	    item = arguments[2];
	this._min = min;
	this._max = max;
	this._item = item;
}
inherits(IntervalRTreeLeafNode, IntervalRTreeNode);
extend(IntervalRTreeLeafNode.prototype, {
	query: function query(queryMin, queryMax, visitor) {
		if (!this.intersects(queryMin, queryMax)) return null;
		visitor.visitItem(this._item);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return IntervalRTreeLeafNode;
	}
});

var Collections = {
  reverseOrder: function reverseOrder() {
    return {
      compare: function compare(a, b) {
        return b.compareTo(a);
      }
    };
  },
  min: function min(l) {
    Collections.sort(l);
    return l.get(0);
  },
  sort: function sort(l, c) {
    var a = l.toArray();
    if (c) {
      Arrays.sort(a, c);
    } else {
      Arrays.sort(a);
    }
    var i = l.iterator();
    for (var pos = 0, alen = a.length; pos < alen; pos++) {
      i.next();
      i.set(a[pos]);
    }
  },
  singletonList: function singletonList(o) {
    var arrayList = new ArrayList();
    arrayList.add(o);
    return arrayList;
  }
};

function IntervalRTreeBranchNode() {
	IntervalRTreeNode.apply(this);
	this._node1 = null;
	this._node2 = null;
	var n1 = arguments[0],
	    n2 = arguments[1];
	this._node1 = n1;
	this._node2 = n2;
	this.buildExtent(this._node1, this._node2);
}
inherits(IntervalRTreeBranchNode, IntervalRTreeNode);
extend(IntervalRTreeBranchNode.prototype, {
	buildExtent: function buildExtent(n1, n2) {
		this._min = Math.min(n1._min, n2._min);
		this._max = Math.max(n1._max, n2._max);
	},
	query: function query(queryMin, queryMax, visitor) {
		if (!this.intersects(queryMin, queryMax)) {
			return null;
		}
		if (this._node1 !== null) this._node1.query(queryMin, queryMax, visitor);
		if (this._node2 !== null) this._node2.query(queryMin, queryMax, visitor);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return IntervalRTreeBranchNode;
	}
});

function SortedPackedIntervalRTree() {
	this._leaves = new ArrayList();
	this._root = null;
	this._level = 0;
}
extend(SortedPackedIntervalRTree.prototype, {
	buildTree: function buildTree() {
		Collections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());
		var src = this._leaves;
		var temp = null;
		var dest = new ArrayList();
		while (true) {
			this.buildLevel(src, dest);
			if (dest.size() === 1) return dest.get(0);
			temp = src;
			src = dest;
			dest = temp;
		}
	},
	insert: function insert(min, max, item) {
		if (this._root !== null) throw new IllegalStateException("Index cannot be added to once it has been queried");
		this._leaves.add(new IntervalRTreeLeafNode(min, max, item));
	},
	query: function query(min, max, visitor) {
		this.init();
		this._root.query(min, max, visitor);
	},
	buildRoot: function buildRoot() {
		if (this._root !== null) return null;
		this._root = this.buildTree();
	},
	printNode: function printNode(node) {
		System.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));
	},
	init: function init() {
		if (this._root !== null) return null;
		this.buildRoot();
	},
	buildLevel: function buildLevel(src, dest) {
		this._level++;
		dest.clear();
		for (var i = 0; i < src.size(); i += 2) {
			var n1 = src.get(i);
			var n2 = i + 1 < src.size() ? src.get(i) : null;
			if (n2 === null) {
				dest.add(n1);
			} else {
				var node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));
				dest.add(node);
			}
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return SortedPackedIntervalRTree;
	}
});

function LinearComponentExtracter() {
	this._lines = null;
	this._isForcedToLineString = false;
	if (arguments.length === 1) {
		var lines = arguments[0];
		this._lines = lines;
	} else if (arguments.length === 2) {
		var _lines = arguments[0],
		    isForcedToLineString = arguments[1];
		this._lines = _lines;
		this._isForcedToLineString = isForcedToLineString;
	}
}
extend(LinearComponentExtracter.prototype, {
	filter: function filter(geom) {
		if (this._isForcedToLineString && geom instanceof LinearRing) {
			var line = geom.getFactory().createLineString(geom.getCoordinateSequence());
			this._lines.add(line);
			return null;
		}
		if (geom instanceof LineString) this._lines.add(geom);
	},
	setForceToLineString: function setForceToLineString(isForcedToLineString) {
		this._isForcedToLineString = isForcedToLineString;
	},
	interfaces_: function interfaces_() {
		return [GeometryComponentFilter];
	},
	getClass: function getClass() {
		return LinearComponentExtracter;
	}
});
LinearComponentExtracter.getGeometry = function () {
	if (arguments.length === 1) {
		var geom = arguments[0];
		return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom));
	} else if (arguments.length === 2) {
		var _geom = arguments[0],
		    forceToLineString = arguments[1];
		return _geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(_geom, forceToLineString));
	}
};
LinearComponentExtracter.getLines = function () {
	if (arguments.length === 1) {
		var geom = arguments[0];
		return LinearComponentExtracter.getLines(geom, false);
	} else if (arguments.length === 2) {
		if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {
			var geoms = arguments[0],
			    _lines2 = arguments[1];
			for (var i = geoms.iterator(); i.hasNext();) {
				var g = i.next();
				LinearComponentExtracter.getLines(g, _lines2);
			}
			return _lines2;
		} else if (arguments[0] instanceof Geometry && typeof arguments[1] === "boolean") {
			var _geom2 = arguments[0],
			    forceToLineString = arguments[1];
			var lines = new ArrayList();
			_geom2.apply(new LinearComponentExtracter(lines, forceToLineString));
			return lines;
		} else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {
			var _geom3 = arguments[0],
			    _lines3 = arguments[1];
			if (_geom3 instanceof LineString) {
				_lines3.add(_geom3);
			} else {
				_geom3.apply(new LinearComponentExtracter(_lines3));
			}
			return _lines3;
		}
	} else if (arguments.length === 3) {
		if (typeof arguments[2] === "boolean" && hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {
			var _geoms = arguments[0],
			    _lines4 = arguments[1],
			    _forceToLineString = arguments[2];
			for (var i = _geoms.iterator(); i.hasNext();) {
				var g = i.next();
				LinearComponentExtracter.getLines(g, _lines4, _forceToLineString);
			}
			return _lines4;
		} else if (typeof arguments[2] === "boolean" && arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {
			var _geom4 = arguments[0],
			    _lines5 = arguments[1],
			    _forceToLineString2 = arguments[2];
			_geom4.apply(new LinearComponentExtracter(_lines5, _forceToLineString2));
			return _lines5;
		}
	}
};

function ArrayListVisitor() {
	this._items = new ArrayList();
}
extend(ArrayListVisitor.prototype, {
	visitItem: function visitItem(item) {
		this._items.add(item);
	},
	getItems: function getItems() {
		return this._items;
	},
	interfaces_: function interfaces_() {
		return [ItemVisitor];
	},
	getClass: function getClass() {
		return ArrayListVisitor;
	}
});

function RayCrossingCounter() {
	this._p = null;
	this._crossingCount = 0;
	this._isPointOnSegment = false;
	var p = arguments[0];
	this._p = p;
}
extend(RayCrossingCounter.prototype, {
	countSegment: function countSegment(p1, p2) {
		if (p1.x < this._p.x && p2.x < this._p.x) return null;
		if (this._p.x === p2.x && this._p.y === p2.y) {
			this._isPointOnSegment = true;
			return null;
		}
		if (p1.y === this._p.y && p2.y === this._p.y) {
			var minx = p1.x;
			var maxx = p2.x;
			if (minx > maxx) {
				minx = p2.x;
				maxx = p1.x;
			}
			if (this._p.x >= minx && this._p.x <= maxx) {
				this._isPointOnSegment = true;
			}
			return null;
		}
		if (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {
			var orient = Orientation.index(p1, p2, this._p);
			if (orient === Orientation.COLLINEAR) {
				this._isPointOnSegment = true;
				return null;
			}
			if (p2.y < p1.y) {
				orient = -orient;
			}
			if (orient === Orientation.LEFT) {
				this._crossingCount++;
			}
		}
	},
	isPointInPolygon: function isPointInPolygon() {
		return this.getLocation() !== Location.EXTERIOR;
	},
	getLocation: function getLocation() {
		if (this._isPointOnSegment) return Location.BOUNDARY;
		if (this._crossingCount % 2 === 1) {
			return Location.INTERIOR;
		}
		return Location.EXTERIOR;
	},
	isOnSegment: function isOnSegment() {
		return this._isPointOnSegment;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return RayCrossingCounter;
	}
});
RayCrossingCounter.locatePointInRing = function () {
	if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {
		var p = arguments[0],
		    ring = arguments[1];
		var counter = new RayCrossingCounter(p);
		var p1 = new Coordinate();
		var p2 = new Coordinate();
		for (var i = 1; i < ring.size(); i++) {
			ring.getCoordinate(i, p1);
			ring.getCoordinate(i - 1, p2);
			counter.countSegment(p1, p2);
			if (counter.isOnSegment()) return counter.getLocation();
		}
		return counter.getLocation();
	} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {
		var _p = arguments[0],
		    _ring = arguments[1];
		var counter = new RayCrossingCounter(_p);
		for (var i = 1; i < _ring.length; i++) {
			var p1 = _ring[i];
			var p2 = _ring[i - 1];
			counter.countSegment(p1, p2);
			if (counter.isOnSegment()) return counter.getLocation();
		}
		return counter.getLocation();
	}
};

function IndexedPointInAreaLocator() {
	this._index = null;
	var g = arguments[0];
	if (!(hasInterface(g, Polygonal) || g instanceof LinearRing)) throw new IllegalArgumentException("Argument must be Polygonal or LinearRing");
	this._index = new IntervalIndexedGeometry(g);
}
extend(IndexedPointInAreaLocator.prototype, {
	locate: function locate(p) {
		var rcc = new RayCrossingCounter(p);
		var visitor = new SegmentVisitor(rcc);
		this._index.query(p.y, p.y, visitor);
		return rcc.getLocation();
	},
	interfaces_: function interfaces_() {
		return [PointOnGeometryLocator];
	},
	getClass: function getClass() {
		return IndexedPointInAreaLocator;
	}
});
function SegmentVisitor() {
	this._counter = null;
	var counter = arguments[0];
	this._counter = counter;
}
extend(SegmentVisitor.prototype, {
	visitItem: function visitItem(item) {
		var seg = item;
		this._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));
	},
	interfaces_: function interfaces_() {
		return [ItemVisitor];
	},
	getClass: function getClass() {
		return SegmentVisitor;
	}
});
function IntervalIndexedGeometry() {
	this._index = new SortedPackedIntervalRTree();
	var geom = arguments[0];
	this.init(geom);
}
extend(IntervalIndexedGeometry.prototype, {
	init: function init(geom) {
		var lines = LinearComponentExtracter.getLines(geom);
		for (var i = lines.iterator(); i.hasNext();) {
			var line = i.next();
			var pts = line.getCoordinates();
			this.addLine(pts);
		}
	},
	addLine: function addLine(pts) {
		for (var i = 1; i < pts.length; i++) {
			var seg = new LineSegment(pts[i - 1], pts[i]);
			var min = Math.min(seg.p0.y, seg.p1.y);
			var max = Math.max(seg.p0.y, seg.p1.y);
			this._index.insert(min, max, seg);
		}
	},
	query: function query() {
		if (arguments.length === 2) {
			var min = arguments[0],
			    max = arguments[1];
			var visitor = new ArrayListVisitor();
			this._index.query(min, max, visitor);
			return visitor.getItems();
		} else if (arguments.length === 3) {
			var _min = arguments[0],
			    _max = arguments[1],
			    _visitor = arguments[2];
			this._index.query(_min, _max, _visitor);
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return IntervalIndexedGeometry;
	}
});
IndexedPointInAreaLocator.SegmentVisitor = SegmentVisitor;
IndexedPointInAreaLocator.IntervalIndexedGeometry = IntervalIndexedGeometry;

function PointLocation() {}
extend(PointLocation.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return PointLocation;
	}
});
PointLocation.isOnLine = function () {
	if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {
		var p = arguments[0],
		    line = arguments[1];
		var lineIntersector = new RobustLineIntersector();
		var p0 = new Coordinate();
		var p1 = new Coordinate();
		var n = line.size();
		for (var i = 1; i < n; i++) {
			line.getCoordinate(i - 1, p0);
			line.getCoordinate(i, p1);
			lineIntersector.computeIntersection(p, p0, p1);
			if (lineIntersector.hasIntersection()) {
				return true;
			}
		}
		return false;
	} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {
		var _p = arguments[0],
		    _line = arguments[1];
		var lineIntersector = new RobustLineIntersector();
		for (var i = 1; i < _line.length; i++) {
			var p0 = _line[i - 1];
			var p1 = _line[i];
			lineIntersector.computeIntersection(_p, p0, p1);
			if (lineIntersector.hasIntersection()) {
				return true;
			}
		}
		return false;
	}
};
PointLocation.locateInRing = function (p, ring) {
	return RayCrossingCounter.locatePointInRing(p, ring);
};
PointLocation.isInRing = function (p, ring) {
	return PointLocation.locateInRing(p, ring) !== Location.EXTERIOR;
};

function GeometryCollectionIterator() {
	this._parent = null;
	this._atStart = null;
	this._max = null;
	this._index = null;
	this._subcollectionIterator = null;
	var parent = arguments[0];
	this._parent = parent;
	this._atStart = true;
	this._index = 0;
	this._max = parent.getNumGeometries();
}
extend(GeometryCollectionIterator.prototype, {
	next: function next() {
		if (this._atStart) {
			this._atStart = false;
			if (GeometryCollectionIterator.isAtomic(this._parent)) this._index++;
			return this._parent;
		}
		if (this._subcollectionIterator !== null) {
			if (this._subcollectionIterator.hasNext()) {
				return this._subcollectionIterator.next();
			} else {
				this._subcollectionIterator = null;
			}
		}
		if (this._index >= this._max) {
			throw new NoSuchElementException();
		}
		var obj = this._parent.getGeometryN(this._index++);
		if (obj instanceof GeometryCollection) {
			this._subcollectionIterator = new GeometryCollectionIterator(obj);
			return this._subcollectionIterator.next();
		}
		return obj;
	},
	remove: function remove() {
		throw new UnsupportedOperationException(this.getClass().getName());
	},
	hasNext: function hasNext() {
		if (this._atStart) {
			return true;
		}
		if (this._subcollectionIterator !== null) {
			if (this._subcollectionIterator.hasNext()) {
				return true;
			}
			this._subcollectionIterator = null;
		}
		if (this._index >= this._max) {
			return false;
		}
		return true;
	},
	interfaces_: function interfaces_() {
		return [Iterator];
	},
	getClass: function getClass() {
		return GeometryCollectionIterator;
	}
});
GeometryCollectionIterator.isAtomic = function (geom) {
	return !(geom instanceof GeometryCollection);
};

function SimplePointInAreaLocator() {
	this._geom = null;
	var geom = arguments[0];
	this._geom = geom;
}
extend(SimplePointInAreaLocator.prototype, {
	locate: function locate(p) {
		return SimplePointInAreaLocator.locate(p, this._geom);
	},
	interfaces_: function interfaces_() {
		return [PointOnGeometryLocator];
	},
	getClass: function getClass() {
		return SimplePointInAreaLocator;
	}
});
SimplePointInAreaLocator.locatePointInPolygon = function (p, poly) {
	if (poly.isEmpty()) return Location.EXTERIOR;
	var shell = poly.getExteriorRing();
	var shellLoc = SimplePointInAreaLocator.locatePointInRing(p, shell);
	if (shellLoc !== Location.INTERIOR) return shellLoc;
	for (var i = 0; i < poly.getNumInteriorRing(); i++) {
		var hole = poly.getInteriorRingN(i);
		var holeLoc = SimplePointInAreaLocator.locatePointInRing(p, hole);
		if (holeLoc === Location.BOUNDARY) return Location.BOUNDARY;
		if (holeLoc === Location.INTERIOR) return Location.EXTERIOR;
	}
	return Location.INTERIOR;
};
SimplePointInAreaLocator.locatePointInRing = function (p, ring) {
	if (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;
	return PointLocation.locateInRing(p, ring.getCoordinates());
};
SimplePointInAreaLocator.containsPointInPolygon = function (p, poly) {
	return Location.EXTERIOR !== SimplePointInAreaLocator.locatePointInPolygon(p, poly);
};
SimplePointInAreaLocator.locateInGeometry = function (p, geom) {
	if (geom instanceof Polygon) {
		return SimplePointInAreaLocator.locatePointInPolygon(p, geom);
	} else if (geom instanceof GeometryCollection) {
		var geomi = new GeometryCollectionIterator(geom);
		while (geomi.hasNext()) {
			var g2 = geomi.next();
			if (g2 !== geom) {
				var loc = SimplePointInAreaLocator.locateInGeometry(p, g2);
				if (loc !== Location.EXTERIOR) return loc;
			}
		}
	}
	return Location.EXTERIOR;
};
SimplePointInAreaLocator.locate = function (p, geom) {
	if (geom.isEmpty()) return Location.EXTERIOR;
	return SimplePointInAreaLocator.locateInGeometry(p, geom);
};

function SimilarityMeasure() {}
extend(SimilarityMeasure.prototype, {
	measure: function measure(g1, g2) {},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return SimilarityMeasure;
	}
});

function AreaSimilarityMeasure() {}
extend(AreaSimilarityMeasure.prototype, {
	measure: function measure(g1, g2) {
		var areaInt = g1.intersection(g2).getArea();
		var areaUnion = g1.union(g2).getArea();
		return areaInt / areaUnion;
	},
	interfaces_: function interfaces_() {
		return [SimilarityMeasure];
	},
	getClass: function getClass() {
		return AreaSimilarityMeasure;
	}
});

function HausdorffSimilarityMeasure() {}
extend(HausdorffSimilarityMeasure.prototype, {
	measure: function measure(g1, g2) {
		var distance = DiscreteHausdorffDistance.distance(g1, g2, HausdorffSimilarityMeasure.DENSIFY_FRACTION);
		var env = new Envelope(g1.getEnvelopeInternal());
		env.expandToInclude(g2.getEnvelopeInternal());
		var envSize = HausdorffSimilarityMeasure.diagonalSize(env);
		var measure = 1 - distance / envSize;
		return measure;
	},
	interfaces_: function interfaces_() {
		return [SimilarityMeasure];
	},
	getClass: function getClass() {
		return HausdorffSimilarityMeasure;
	}
});
HausdorffSimilarityMeasure.diagonalSize = function (env) {
	if (env.isNull()) return 0.0;
	var width = env.getWidth();
	var hgt = env.getHeight();
	return Math.sqrt(width * width + hgt * hgt);
};
HausdorffSimilarityMeasure.DENSIFY_FRACTION = 0.25;

function SimilarityMeasureCombiner() {}
extend(SimilarityMeasureCombiner.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return SimilarityMeasureCombiner;
	}
});
SimilarityMeasureCombiner.combine = function (measure1, measure2) {
	return Math.min(measure1, measure2);
};

function Centroid() {
	this._areaBasePt = null;
	this._triangleCent3 = new Coordinate();
	this._areasum2 = 0;
	this._cg3 = new Coordinate();
	this._lineCentSum = new Coordinate();
	this._totalLength = 0.0;
	this._ptCount = 0;
	this._ptCentSum = new Coordinate();
	var geom = arguments[0];
	this._areaBasePt = null;
	this.add(geom);
}
extend(Centroid.prototype, {
	setAreaBasePoint: function setAreaBasePoint(basePt) {
		this._areaBasePt = basePt;
	},
	addPoint: function addPoint(pt) {
		this._ptCount += 1;
		this._ptCentSum.x += pt.x;
		this._ptCentSum.y += pt.y;
	},
	addLineSegments: function addLineSegments(pts) {
		var lineLen = 0.0;
		for (var i = 0; i < pts.length - 1; i++) {
			var segmentLen = pts[i].distance(pts[i + 1]);
			if (segmentLen === 0.0) continue;
			lineLen += segmentLen;
			var midx = (pts[i].x + pts[i + 1].x) / 2;
			this._lineCentSum.x += segmentLen * midx;
			var midy = (pts[i].y + pts[i + 1].y) / 2;
			this._lineCentSum.y += segmentLen * midy;
		}
		this._totalLength += lineLen;
		if (lineLen === 0.0 && pts.length > 0) this.addPoint(pts[0]);
	},
	addHole: function addHole(pts) {
		var isPositiveArea = Orientation.isCCW(pts);
		for (var i = 0; i < pts.length - 1; i++) {
			this.addTriangle(this._areaBasePt, pts[i], pts[i + 1], isPositiveArea);
		}
		this.addLineSegments(pts);
	},
	getCentroid: function getCentroid() {
		var cent = new Coordinate();
		if (Math.abs(this._areasum2) > 0.0) {
			cent.x = this._cg3.x / 3 / this._areasum2;
			cent.y = this._cg3.y / 3 / this._areasum2;
		} else if (this._totalLength > 0.0) {
			cent.x = this._lineCentSum.x / this._totalLength;
			cent.y = this._lineCentSum.y / this._totalLength;
		} else if (this._ptCount > 0) {
			cent.x = this._ptCentSum.x / this._ptCount;
			cent.y = this._ptCentSum.y / this._ptCount;
		} else {
			return null;
		}
		return cent;
	},
	addShell: function addShell(pts) {
		if (pts.length > 0) this.setAreaBasePoint(pts[0]);
		var isPositiveArea = !Orientation.isCCW(pts);
		for (var i = 0; i < pts.length - 1; i++) {
			this.addTriangle(this._areaBasePt, pts[i], pts[i + 1], isPositiveArea);
		}
		this.addLineSegments(pts);
	},
	addTriangle: function addTriangle(p0, p1, p2, isPositiveArea) {
		var sign = isPositiveArea ? 1.0 : -1.0;
		Centroid.centroid3(p0, p1, p2, this._triangleCent3);
		var area2 = Centroid.area2(p0, p1, p2);
		this._cg3.x += sign * area2 * this._triangleCent3.x;
		this._cg3.y += sign * area2 * this._triangleCent3.y;
		this._areasum2 += sign * area2;
	},
	add: function add() {
		if (arguments[0] instanceof Polygon) {
			var _poly = arguments[0];
			this.addShell(_poly.getExteriorRing().getCoordinates());
			for (var i = 0; i < _poly.getNumInteriorRing(); i++) {
				this.addHole(_poly.getInteriorRingN(i).getCoordinates());
			}
		} else if (arguments[0] instanceof Geometry) {
			var geom = arguments[0];
			if (geom.isEmpty()) return null;
			if (geom instanceof Point) {
				this.addPoint(geom.getCoordinate());
			} else if (geom instanceof LineString) {
				this.addLineSegments(geom.getCoordinates());
			} else if (geom instanceof Polygon) {
				var poly = geom;
				this.add(poly);
			} else if (geom instanceof GeometryCollection) {
				var gc = geom;
				for (var i = 0; i < gc.getNumGeometries(); i++) {
					this.add(gc.getGeometryN(i));
				}
			}
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Centroid;
	}
});
Centroid.area2 = function (p1, p2, p3) {
	return (p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y);
};
Centroid.centroid3 = function (p1, p2, p3, c) {
	c.x = p1.x + p2.x + p3.x;
	c.y = p1.y + p2.y + p3.y;
	return null;
};
Centroid.getCentroid = function (geom) {
	var cent = new Centroid(geom);
	return cent.getCentroid();
};

function CGAlgorithms() {}
extend(CGAlgorithms.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return CGAlgorithms;
	}
});
CGAlgorithms.orientationIndex = function (p1, p2, q) {
	return CGAlgorithmsDD.orientationIndex(p1, p2, q);
};
CGAlgorithms.signedArea = function () {
	if (arguments[0] instanceof Array) {
		var ring = arguments[0];
		if (ring.length < 3) return 0.0;
		var sum = 0.0;
		var x0 = ring[0].x;
		for (var i = 1; i < ring.length - 1; i++) {
			var x = ring[i].x - x0;
			var y1 = ring[i + 1].y;
			var y2 = ring[i - 1].y;
			sum += x * (y2 - y1);
		}
		return sum / 2.0;
	} else if (hasInterface(arguments[0], CoordinateSequence)) {
		var _ring = arguments[0];
		var n = _ring.size();
		if (n < 3) return 0.0;
		var p0 = new Coordinate();
		var p1 = new Coordinate();
		var p2 = new Coordinate();
		_ring.getCoordinate(0, p1);
		_ring.getCoordinate(1, p2);
		var x0 = p1.x;
		p2.x -= x0;
		var sum = 0.0;
		for (var i = 1; i < n - 1; i++) {
			p0.y = p1.y;
			p1.x = p2.x;
			p1.y = p2.y;
			_ring.getCoordinate(i + 1, p2);
			p2.x -= x0;
			sum += p1.x * (p0.y - p2.y);
		}
		return sum / 2.0;
	}
};
CGAlgorithms.distanceLineLine = function (A, B, C, D) {
	if (A.equals(B)) return CGAlgorithms.distancePointLine(A, C, D);
	if (C.equals(D)) return CGAlgorithms.distancePointLine(D, A, B);
	var noIntersection = false;
	if (!Envelope.intersects(A, B, C, D)) {
		noIntersection = true;
	} else {
		var denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);
		if (denom === 0) {
			noIntersection = true;
		} else {
			var r_num = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);
			var s_num = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);
			var s = s_num / denom;
			var r = r_num / denom;
			if (r < 0 || r > 1 || s < 0 || s > 1) {
				noIntersection = true;
			}
		}
	}
	if (noIntersection) {
		return MathUtil.min(CGAlgorithms.distancePointLine(A, C, D), CGAlgorithms.distancePointLine(B, C, D), CGAlgorithms.distancePointLine(C, A, B), CGAlgorithms.distancePointLine(D, A, B));
	}
	return 0.0;
};
CGAlgorithms.isPointInRing = function (p, ring) {
	return CGAlgorithms.locatePointInRing(p, ring) !== Location.EXTERIOR;
};
CGAlgorithms.computeLength = function (pts) {
	var n = pts.size();
	if (n <= 1) return 0.0;
	var len = 0.0;
	var p = new Coordinate();
	pts.getCoordinate(0, p);
	var x0 = p.x;
	var y0 = p.y;
	for (var i = 1; i < n; i++) {
		pts.getCoordinate(i, p);
		var x1 = p.x;
		var y1 = p.y;
		var dx = x1 - x0;
		var dy = y1 - y0;
		len += Math.sqrt(dx * dx + dy * dy);
		x0 = x1;
		y0 = y1;
	}
	return len;
};
CGAlgorithms.isCCW = function (ring) {
	var nPts = ring.length - 1;
	if (nPts < 3) throw new IllegalArgumentException("Ring has fewer than 4 points, so orientation cannot be determined");
	var hiPt = ring[0];
	var hiIndex = 0;
	for (var i = 1; i <= nPts; i++) {
		var p = ring[i];
		if (p.y > hiPt.y) {
			hiPt = p;
			hiIndex = i;
		}
	}
	var iPrev = hiIndex;
	do {
		iPrev = iPrev - 1;
		if (iPrev < 0) iPrev = nPts;
	} while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);
	var iNext = hiIndex;
	do {
		iNext = (iNext + 1) % nPts;
	} while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);
	var prev = ring[iPrev];
	var next = ring[iNext];
	if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;
	var disc = CGAlgorithms.computeOrientation(prev, hiPt, next);
	var isCCW = false;
	if (disc === 0) {
		isCCW = prev.x > next.x;
	} else {
		isCCW = disc > 0;
	}
	return isCCW;
};
CGAlgorithms.locatePointInRing = function (p, ring) {
	return RayCrossingCounter.locatePointInRing(p, ring);
};
CGAlgorithms.distancePointLinePerpendicular = function (p, A, B) {
	var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
	var s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;
	return Math.abs(s) * Math.sqrt(len2);
};
CGAlgorithms.computeOrientation = function (p1, p2, q) {
	return CGAlgorithms.orientationIndex(p1, p2, q);
};
CGAlgorithms.distancePointLine = function () {
	if (arguments.length === 2) {
		var p = arguments[0],
		    line = arguments[1];
		if (line.length === 0) throw new IllegalArgumentException("Line array must contain at least one vertex");
		var minDistance = p.distance(line[0]);
		for (var i = 0; i < line.length - 1; i++) {
			var dist = CGAlgorithms.distancePointLine(p, line[i], line[i + 1]);
			if (dist < minDistance) {
				minDistance = dist;
			}
		}
		return minDistance;
	} else if (arguments.length === 3) {
		var _p = arguments[0],
		    A = arguments[1],
		    B = arguments[2];
		if (A.x === B.x && A.y === B.y) return _p.distance(A);
		var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
		var r = ((_p.x - A.x) * (B.x - A.x) + (_p.y - A.y) * (B.y - A.y)) / len2;
		if (r <= 0.0) return _p.distance(A);
		if (r >= 1.0) return _p.distance(B);
		var s = ((A.y - _p.y) * (B.x - A.x) - (A.x - _p.x) * (B.y - A.y)) / len2;
		return Math.abs(s) * Math.sqrt(len2);
	}
};
CGAlgorithms.isOnLine = function (p, pt) {
	var lineIntersector = new RobustLineIntersector();
	for (var i = 1; i < pt.length; i++) {
		var p0 = pt[i - 1];
		var p1 = pt[i];
		lineIntersector.computeIntersection(p, p0, p1);
		if (lineIntersector.hasIntersection()) {
			return true;
		}
	}
	return false;
};
CGAlgorithms.CLOCKWISE = -1;
CGAlgorithms.RIGHT = CGAlgorithms.CLOCKWISE;
CGAlgorithms.COUNTERCLOCKWISE = 1;
CGAlgorithms.LEFT = CGAlgorithms.COUNTERCLOCKWISE;
CGAlgorithms.COLLINEAR = 0;
CGAlgorithms.STRAIGHT = CGAlgorithms.COLLINEAR;

/**
 * @param {string=} message Optional message
 * @extends {Error}
 * @constructor
 * @private
 */
function EmptyStackException(message) {
  this.message = message || '';
}
EmptyStackException.prototype = new Error();

/**
 * @type {string}
 */
EmptyStackException.prototype.name = 'EmptyStackException';

/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Stack.html
 *
 * @extends {List}
 * @constructor
 * @private
 */
function Stack() {
  /**
   * @type {Array}
   * @private
   */
  this.array_ = [];
}
Stack.prototype = new List();

/**
 * @override
 */
Stack.prototype.add = function (e) {
  this.array_.push(e);
  return true;
};

/**
 * @override
 */
Stack.prototype.get = function (index) {
  if (index < 0 || index >= this.size()) {
    throw new IndexOutOfBoundsException();
  }

  return this.array_[index];
};

/**
 * Pushes an item onto the top of this stack.
 * @param {Object} e
 * @return {Object}
 */
Stack.prototype.push = function (e) {
  this.array_.push(e);
  return e;
};

/**
 * Pushes an item onto the top of this stack.
 * @param {Object} e
 * @return {Object}
 */
Stack.prototype.pop = function (e) {
  if (this.array_.length === 0) {
    throw new EmptyStackException();
  }

  return this.array_.pop();
};

/**
 * Looks at the object at the top of this stack without removing it from the
 * stack.
 * @return {Object}
 */
Stack.prototype.peek = function () {
  if (this.array_.length === 0) {
    throw new EmptyStackException();
  }

  return this.array_[this.array_.length - 1];
};

/**
 * Tests if this stack is empty.
 * @return {boolean} true if and only if this stack contains no items; false
 *         otherwise.
 */
Stack.prototype.empty = function () {
  if (this.array_.length === 0) {
    return true;
  } else {
    return false;
  }
};

/**
 * @return {boolean}
 */
Stack.prototype.isEmpty = function () {
  return this.empty();
};

/**
 * Returns the 1-based position where an object is on this stack. If the object
 * o occurs as an item in this stack, this method returns the distance from the
 * top of the stack of the occurrence nearest the top of the stack; the topmost
 * item on the stack is considered to be at distance 1. The equals method is
 * used to compare o to the items in this stack.
 *
 * NOTE: does not currently actually use equals. (=== is used)
 *
 * @param {Object} o
 * @return {number} the 1-based position from the top of the stack where the
 *         object is located; the return value -1 indicates that the object is
 *         not on the stack.
 */
Stack.prototype.search = function (o) {
  return this.array_.indexOf(o);
};

/**
 * @return {number}
 * @export
 */
Stack.prototype.size = function () {
  return this.array_.length;
};

/**
 * @return {Array}
 */
Stack.prototype.toArray = function () {
  var array = [];

  for (var i = 0, len = this.array_.length; i < len; i++) {
    array.push(this.array_[i]);
  }

  return array;
};

function UniqueCoordinateArrayFilter() {
	this.treeSet = new TreeSet();
	this.list = new ArrayList();
}
extend(UniqueCoordinateArrayFilter.prototype, {
	filter: function filter(coord) {
		if (!this.treeSet.contains(coord)) {
			this.list.add(coord);
			this.treeSet.add(coord);
		}
	},
	getCoordinates: function getCoordinates() {
		var coordinates = new Array(this.list.size()).fill(null);
		return this.list.toArray(coordinates);
	},
	interfaces_: function interfaces_() {
		return [CoordinateFilter];
	},
	getClass: function getClass() {
		return UniqueCoordinateArrayFilter;
	}
});
UniqueCoordinateArrayFilter.filterCoordinates = function (coords) {
	var filter = new UniqueCoordinateArrayFilter();
	for (var i = 0; i < coords.length; i++) {
		filter.filter(coords[i]);
	}
	return filter.getCoordinates();
};

function ConvexHull() {
	this._geomFactory = null;
	this._inputPts = null;
	if (arguments.length === 1) {
		var geometry = arguments[0];
		ConvexHull.call(this, ConvexHull.extractCoordinates(geometry), geometry.getFactory());
	} else if (arguments.length === 2) {
		var pts = arguments[0],
		    geomFactory = arguments[1];
		this._inputPts = UniqueCoordinateArrayFilter.filterCoordinates(pts);
		this._geomFactory = geomFactory;
	}
}
extend(ConvexHull.prototype, {
	preSort: function preSort(pts) {
		var t = null;
		for (var i = 1; i < pts.length; i++) {
			if (pts[i].y < pts[0].y || pts[i].y === pts[0].y && pts[i].x < pts[0].x) {
				t = pts[0];
				pts[0] = pts[i];
				pts[i] = t;
			}
		}
		Arrays.sort(pts, 1, pts.length, new RadialComparator(pts[0]));
		return pts;
	},
	computeOctRing: function computeOctRing(inputPts) {
		var octPts = this.computeOctPts(inputPts);
		var coordList = new CoordinateList();
		coordList.add(octPts, false);
		if (coordList.size() < 3) {
			return null;
		}
		coordList.closeRing();
		return coordList.toCoordinateArray();
	},
	lineOrPolygon: function lineOrPolygon(coordinates) {
		coordinates = this.cleanRing(coordinates);
		if (coordinates.length === 3) {
			return this._geomFactory.createLineString([coordinates[0], coordinates[1]]);
		}
		var linearRing = this._geomFactory.createLinearRing(coordinates);
		return this._geomFactory.createPolygon(linearRing);
	},
	cleanRing: function cleanRing(original) {
		Assert.equals(original[0], original[original.length - 1]);
		var cleanedRing = new ArrayList();
		var previousDistinctCoordinate = null;
		for (var i = 0; i <= original.length - 2; i++) {
			var currentCoordinate = original[i];
			var nextCoordinate = original[i + 1];
			if (currentCoordinate.equals(nextCoordinate)) {
				continue;
			}
			if (previousDistinctCoordinate !== null && this.isBetween(previousDistinctCoordinate, currentCoordinate, nextCoordinate)) {
				continue;
			}
			cleanedRing.add(currentCoordinate);
			previousDistinctCoordinate = currentCoordinate;
		}
		cleanedRing.add(original[original.length - 1]);
		var cleanedRingCoordinates = new Array(cleanedRing.size()).fill(null);
		return cleanedRing.toArray(cleanedRingCoordinates);
	},
	isBetween: function isBetween(c1, c2, c3) {
		if (Orientation.index(c1, c2, c3) !== 0) {
			return false;
		}
		if (c1.x !== c3.x) {
			if (c1.x <= c2.x && c2.x <= c3.x) {
				return true;
			}
			if (c3.x <= c2.x && c2.x <= c1.x) {
				return true;
			}
		}
		if (c1.y !== c3.y) {
			if (c1.y <= c2.y && c2.y <= c3.y) {
				return true;
			}
			if (c3.y <= c2.y && c2.y <= c1.y) {
				return true;
			}
		}
		return false;
	},
	reduce: function reduce(inputPts) {
		var polyPts = this.computeOctRing(inputPts);
		if (polyPts === null) return inputPts;
		var reducedSet = new TreeSet();
		for (var i = 0; i < polyPts.length; i++) {
			reducedSet.add(polyPts[i]);
		}
		for (var i = 0; i < inputPts.length; i++) {
			if (!PointLocation.isInRing(inputPts[i], polyPts)) {
				reducedSet.add(inputPts[i]);
			}
		}
		var reducedPts = CoordinateArrays.toCoordinateArray(reducedSet);
		if (reducedPts.length < 3) return this.padArray3(reducedPts);
		return reducedPts;
	},
	getConvexHull: function getConvexHull() {
		if (this._inputPts.length === 0) {
			return this._geomFactory.createGeometryCollection();
		}
		if (this._inputPts.length === 1) {
			return this._geomFactory.createPoint(this._inputPts[0]);
		}
		if (this._inputPts.length === 2) {
			return this._geomFactory.createLineString(this._inputPts);
		}
		var reducedPts = this._inputPts;
		if (this._inputPts.length > 50) {
			reducedPts = this.reduce(this._inputPts);
		}
		var sortedPts = this.preSort(reducedPts);
		var cHS = this.grahamScan(sortedPts);
		var cH = this.toCoordinateArray(cHS);
		return this.lineOrPolygon(cH);
	},
	padArray3: function padArray3(pts) {
		var pad = new Array(3).fill(null);
		for (var i = 0; i < pad.length; i++) {
			if (i < pts.length) {
				pad[i] = pts[i];
			} else pad[i] = pts[0];
		}
		return pad;
	},
	computeOctPts: function computeOctPts(inputPts) {
		var pts = new Array(8).fill(null);
		for (var j = 0; j < pts.length; j++) {
			pts[j] = inputPts[0];
		}
		for (var i = 1; i < inputPts.length; i++) {
			if (inputPts[i].x < pts[0].x) {
				pts[0] = inputPts[i];
			}
			if (inputPts[i].x - inputPts[i].y < pts[1].x - pts[1].y) {
				pts[1] = inputPts[i];
			}
			if (inputPts[i].y > pts[2].y) {
				pts[2] = inputPts[i];
			}
			if (inputPts[i].x + inputPts[i].y > pts[3].x + pts[3].y) {
				pts[3] = inputPts[i];
			}
			if (inputPts[i].x > pts[4].x) {
				pts[4] = inputPts[i];
			}
			if (inputPts[i].x - inputPts[i].y > pts[5].x - pts[5].y) {
				pts[5] = inputPts[i];
			}
			if (inputPts[i].y < pts[6].y) {
				pts[6] = inputPts[i];
			}
			if (inputPts[i].x + inputPts[i].y < pts[7].x + pts[7].y) {
				pts[7] = inputPts[i];
			}
		}
		return pts;
	},
	toCoordinateArray: function toCoordinateArray(stack) {
		var coordinates = new Array(stack.size()).fill(null);
		for (var i = 0; i < stack.size(); i++) {
			var coordinate = stack.get(i);
			coordinates[i] = coordinate;
		}
		return coordinates;
	},
	grahamScan: function grahamScan(c) {
		var p = null;
		var ps = new Stack();
		ps.push(c[0]);
		ps.push(c[1]);
		ps.push(c[2]);
		for (var i = 3; i < c.length; i++) {
			p = ps.pop();
			while (!ps.empty() && Orientation.index(ps.peek(), p, c[i]) > 0) {
				p = ps.pop();
			}
			ps.push(p);
			ps.push(c[i]);
		}
		ps.push(c[0]);
		return ps;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return ConvexHull;
	}
});
ConvexHull.extractCoordinates = function (geom) {
	var filter = new UniqueCoordinateArrayFilter();
	geom.apply(filter);
	return filter.getCoordinates();
};
function RadialComparator() {
	this._origin = null;
	var origin = arguments[0];
	this._origin = origin;
}
extend(RadialComparator.prototype, {
	compare: function compare(o1, o2) {
		var p1 = o1;
		var p2 = o2;
		return RadialComparator.polarCompare(this._origin, p1, p2);
	},
	interfaces_: function interfaces_() {
		return [Comparator];
	},
	getClass: function getClass() {
		return RadialComparator;
	}
});
RadialComparator.polarCompare = function (o, p, q) {
	var dxp = p.x - o.x;
	var dyp = p.y - o.y;
	var dxq = q.x - o.x;
	var dyq = q.y - o.y;
	var orient = Orientation.index(o, p, q);
	if (orient === Orientation.COUNTERCLOCKWISE) return 1;
	if (orient === Orientation.CLOCKWISE) return -1;
	var op = dxp * dxp + dyp * dyp;
	var oq = dxq * dxq + dyq * dyq;
	if (op < oq) {
		return -1;
	}
	if (op > oq) {
		return 1;
	}
	return 0;
};
ConvexHull.RadialComparator = RadialComparator;

function InteriorPointArea() {
	this._factory = null;
	this._interiorPoint = null;
	this._maxWidth = 0.0;
	var g = arguments[0];
	this._factory = g.getFactory();
	this.add(g);
}
extend(InteriorPointArea.prototype, {
	addPolygon: function addPolygon(geometry) {
		if (geometry.isEmpty()) return null;
		var intPt = null;
		var width = null;
		var bisector = this.horizontalBisector(geometry);
		if (bisector.getLength() === 0.0) {
			width = 0;
			intPt = bisector.getCoordinate();
		} else {
			var intersections = bisector.intersection(geometry);
			var widestIntersection = this.widestGeometry(intersections);
			width = widestIntersection.getEnvelopeInternal().getWidth();
			intPt = InteriorPointArea.centre(widestIntersection.getEnvelopeInternal());
		}
		if (this._interiorPoint === null || width > this._maxWidth) {
			this._interiorPoint = intPt;
			this._maxWidth = width;
		}
	},
	getInteriorPoint: function getInteriorPoint() {
		return this._interiorPoint;
	},
	widestGeometry: function widestGeometry() {
		if (arguments[0] instanceof GeometryCollection) {
			var gc = arguments[0];
			if (gc.isEmpty()) {
				return gc;
			}
			var widestGeometry = gc.getGeometryN(0);
			for (var i = 1; i < gc.getNumGeometries(); i++) {
				if (gc.getGeometryN(i).getEnvelopeInternal().getWidth() > widestGeometry.getEnvelopeInternal().getWidth()) {
					widestGeometry = gc.getGeometryN(i);
				}
			}
			return widestGeometry;
		} else if (arguments[0] instanceof Geometry) {
			var geometry = arguments[0];
			if (!(geometry instanceof GeometryCollection)) {
				return geometry;
			}
			return this.widestGeometry(geometry);
		}
	},
	horizontalBisector: function horizontalBisector(geometry) {
		var envelope = geometry.getEnvelopeInternal();
		var bisectY = SafeBisectorFinder.getBisectorY(geometry);
		return this._factory.createLineString([new Coordinate(envelope.getMinX(), bisectY), new Coordinate(envelope.getMaxX(), bisectY)]);
	},
	add: function add(geom) {
		if (geom instanceof Polygon) {
			this.addPolygon(geom);
		} else if (geom instanceof GeometryCollection) {
			var gc = geom;
			for (var i = 0; i < gc.getNumGeometries(); i++) {
				this.add(gc.getGeometryN(i));
			}
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return InteriorPointArea;
	}
});
InteriorPointArea.centre = function (envelope) {
	return new Coordinate(InteriorPointArea.avg(envelope.getMinX(), envelope.getMaxX()), InteriorPointArea.avg(envelope.getMinY(), envelope.getMaxY()));
};
InteriorPointArea.avg = function (a, b) {
	return (a + b) / 2.0;
};
function SafeBisectorFinder() {
	this._poly = null;
	this._centreY = null;
	this._hiY = Double.MAX_VALUE;
	this._loY = -Double.MAX_VALUE;
	var poly = arguments[0];
	this._poly = poly;
	this._hiY = poly.getEnvelopeInternal().getMaxY();
	this._loY = poly.getEnvelopeInternal().getMinY();
	this._centreY = InteriorPointArea.avg(this._loY, this._hiY);
}
extend(SafeBisectorFinder.prototype, {
	updateInterval: function updateInterval(y) {
		if (y <= this._centreY) {
			if (y > this._loY) this._loY = y;
		} else if (y > this._centreY) {
			if (y < this._hiY) {
				this._hiY = y;
			}
		}
	},
	getBisectorY: function getBisectorY() {
		this.process(this._poly.getExteriorRing());
		for (var i = 0; i < this._poly.getNumInteriorRing(); i++) {
			this.process(this._poly.getInteriorRingN(i));
		}
		var bisectY = InteriorPointArea.avg(this._hiY, this._loY);
		return bisectY;
	},
	process: function process(line) {
		var seq = line.getCoordinateSequence();
		for (var i = 0; i < seq.size(); i++) {
			var y = seq.getY(i);
			this.updateInterval(y);
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return SafeBisectorFinder;
	}
});
SafeBisectorFinder.getBisectorY = function (poly) {
	var finder = new SafeBisectorFinder(poly);
	return finder.getBisectorY();
};
InteriorPointArea.SafeBisectorFinder = SafeBisectorFinder;

function InteriorPointLine() {
	this._centroid = null;
	this._minDistance = Double.MAX_VALUE;
	this._interiorPoint = null;
	var g = arguments[0];
	this._centroid = g.getCentroid().getCoordinate();
	this.addInterior(g);
	if (this._interiorPoint === null) this.addEndpoints(g);
}
extend(InteriorPointLine.prototype, {
	addEndpoints: function addEndpoints() {
		if (arguments[0] instanceof Geometry) {
			var geom = arguments[0];
			if (geom instanceof LineString) {
				this.addEndpoints(geom.getCoordinates());
			} else if (geom instanceof GeometryCollection) {
				var gc = geom;
				for (var i = 0; i < gc.getNumGeometries(); i++) {
					this.addEndpoints(gc.getGeometryN(i));
				}
			}
		} else if (arguments[0] instanceof Array) {
			var pts = arguments[0];
			this.add(pts[0]);
			this.add(pts[pts.length - 1]);
		}
	},
	getInteriorPoint: function getInteriorPoint() {
		return this._interiorPoint;
	},
	addInterior: function addInterior() {
		if (arguments[0] instanceof Geometry) {
			var geom = arguments[0];
			if (geom instanceof LineString) {
				this.addInterior(geom.getCoordinates());
			} else if (geom instanceof GeometryCollection) {
				var gc = geom;
				for (var i = 0; i < gc.getNumGeometries(); i++) {
					this.addInterior(gc.getGeometryN(i));
				}
			}
		} else if (arguments[0] instanceof Array) {
			var pts = arguments[0];
			for (var i = 1; i < pts.length - 1; i++) {
				this.add(pts[i]);
			}
		}
	},
	add: function add(point) {
		var dist = point.distance(this._centroid);
		if (dist < this._minDistance) {
			this._interiorPoint = new Coordinate(point);
			this._minDistance = dist;
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return InteriorPointLine;
	}
});

function InteriorPointPoint() {
	this._centroid = null;
	this._minDistance = Double.MAX_VALUE;
	this._interiorPoint = null;
	var g = arguments[0];
	this._centroid = g.getCentroid().getCoordinate();
	this.add(g);
}
extend(InteriorPointPoint.prototype, {
	getInteriorPoint: function getInteriorPoint() {
		return this._interiorPoint;
	},
	add: function add() {
		if (arguments[0] instanceof Geometry) {
			var geom = arguments[0];
			if (geom instanceof Point) {
				this.add(geom.getCoordinate());
			} else if (geom instanceof GeometryCollection) {
				var gc = geom;
				for (var i = 0; i < gc.getNumGeometries(); i++) {
					this.add(gc.getGeometryN(i));
				}
			}
		} else if (arguments[0] instanceof Coordinate) {
			var point = arguments[0];
			var dist = point.distance(this._centroid);
			if (dist < this._minDistance) {
				this._interiorPoint = new Coordinate(point);
				this._minDistance = dist;
			}
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return InteriorPointPoint;
	}
});

function MonotoneChainSelectAction() {
	this.selectedSegment = new LineSegment();
}
extend(MonotoneChainSelectAction.prototype, {
	select: function select() {
		if (arguments.length === 1) {
			
		} else if (arguments.length === 2) {
			var mc = arguments[0],
			    startIndex = arguments[1];
			mc.getLineSegment(startIndex, this.selectedSegment);
			this.select(this.selectedSegment);
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return MonotoneChainSelectAction;
	}
});

function NodeBase() {
	this._items = new ArrayList();
	this._subnode = new Array(2).fill(null);
}
extend(NodeBase.prototype, {
	hasChildren: function hasChildren() {
		for (var i = 0; i < 2; i++) {
			if (this._subnode[i] !== null) return true;
		}
		return false;
	},
	isPrunable: function isPrunable() {
		return !(this.hasChildren() || this.hasItems());
	},
	addAllItems: function addAllItems(items) {
		items.addAll(this._items);
		for (var i = 0; i < 2; i++) {
			if (this._subnode[i] !== null) {
				this._subnode[i].addAllItems(items);
			}
		}
		return items;
	},
	size: function size() {
		var subSize = 0;
		for (var i = 0; i < 2; i++) {
			if (this._subnode[i] !== null) {
				subSize += this._subnode[i].size();
			}
		}
		return subSize + this._items.size();
	},
	addAllItemsFromOverlapping: function addAllItemsFromOverlapping(interval, resultItems) {
		if (interval !== null && !this.isSearchMatch(interval)) return null;
		resultItems.addAll(this._items);
		if (this._subnode[0] !== null) this._subnode[0].addAllItemsFromOverlapping(interval, resultItems);
		if (this._subnode[1] !== null) this._subnode[1].addAllItemsFromOverlapping(interval, resultItems);
	},
	hasItems: function hasItems() {
		return !this._items.isEmpty();
	},
	remove: function remove(itemInterval, item) {
		if (!this.isSearchMatch(itemInterval)) return false;
		var found = false;
		for (var i = 0; i < 2; i++) {
			if (this._subnode[i] !== null) {
				found = this._subnode[i].remove(itemInterval, item);
				if (found) {
					if (this._subnode[i].isPrunable()) this._subnode[i] = null;
					break;
				}
			}
		}
		if (found) return found;
		found = this._items.remove(item);
		return found;
	},
	getItems: function getItems() {
		return this._items;
	},
	depth: function depth() {
		var maxSubDepth = 0;
		for (var i = 0; i < 2; i++) {
			if (this._subnode[i] !== null) {
				var sqd = this._subnode[i].depth();
				if (sqd > maxSubDepth) maxSubDepth = sqd;
			}
		}
		return maxSubDepth + 1;
	},
	nodeSize: function nodeSize() {
		var subSize = 0;
		for (var i = 0; i < 2; i++) {
			if (this._subnode[i] !== null) {
				subSize += this._subnode[i].nodeSize();
			}
		}
		return subSize + 1;
	},
	add: function add(item) {
		this._items.add(item);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return NodeBase;
	}
});
NodeBase.getSubnodeIndex = function (interval, centre) {
	var subnodeIndex = -1;
	if (interval.min >= centre) subnodeIndex = 1;
	if (interval.max <= centre) subnodeIndex = 0;
	return subnodeIndex;
};

function Interval() {
	this.min = null;
	this.max = null;
	if (arguments.length === 0) {
		this.min = 0.0;
		this.max = 0.0;
	} else if (arguments.length === 1) {
		var interval = arguments[0];
		this.init(interval.min, interval.max);
	} else if (arguments.length === 2) {
		var min = arguments[0],
		    max = arguments[1];
		this.init(min, max);
	}
}
extend(Interval.prototype, {
	expandToInclude: function expandToInclude(interval) {
		if (interval.max > this.max) this.max = interval.max;
		if (interval.min < this.min) this.min = interval.min;
	},
	getWidth: function getWidth() {
		return this.max - this.min;
	},
	overlaps: function overlaps() {
		if (arguments.length === 1) {
			var interval = arguments[0];
			return this.overlaps(interval.min, interval.max);
		} else if (arguments.length === 2) {
			var min = arguments[0],
			    max = arguments[1];
			if (this.min > max || this.max < min) return false;
			return true;
		}
	},
	getMin: function getMin() {
		return this.min;
	},
	toString: function toString() {
		return "[" + this.min + ", " + this.max + "]";
	},
	contains: function contains() {
		if (arguments.length === 1) {
			if (arguments[0] instanceof Interval) {
				var interval = arguments[0];
				return this.contains(interval.min, interval.max);
			} else if (typeof arguments[0] === "number") {
				var p = arguments[0];
				return p >= this.min && p <= this.max;
			}
		} else if (arguments.length === 2) {
			var min = arguments[0],
			    max = arguments[1];
			return min >= this.min && max <= this.max;
		}
	},
	init: function init(min, max) {
		this.min = min;
		this.max = max;
		if (min > max) {
			this.min = max;
			this.max = min;
		}
	},
	getMax: function getMax() {
		return this.max;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Interval;
	}
});

function DoubleBits() {}
DoubleBits.exponent = function (d) {
  return CVTFWD(64, d) - 1023;
};
DoubleBits.powerOf2 = function (exp) {
  return Math.pow(2, exp);
};

/**
 * Calculates the exponent of the bit-pattern for a number. Uses code from:
 * http://www.merlyn.demon.co.uk/js-exact.htm
 *
 * @param {Number}
 *          NumW 32 or 64 to denote the number of bits.
 * @param {Number}
 *          Qty the number to calculate the bit pattern for.
 * @return {Number} The integer value of the exponent.
 * @private
 */
function CVTFWD(NumW, Qty) {
  var Sign;
  var Expo;
  var Mant;
  var Bin;
  var Inf = {
    32: {
      d: 0x7F,
      c: 0x80,
      b: 0,
      a: 0
    },
    64: {
      d: 0x7FF0,
      c: 0,
      b: 0,
      a: 0
    }
  };
  var ExW = {
    32: 8,
    64: 11
  }[NumW];

  if (!Bin) {
    Sign = Qty < 0 || 1 / Qty < 0; // OK for +-0
    if (!isFinite(Qty)) {
      Bin = Inf[NumW];
      if (Sign) {
        Bin.d += 1 << NumW / 4 - 1;
      }
      Expo = Math.pow(2, ExW) - 1;
      Mant = 0;
    }
  }

  if (!Bin) {
    Expo = {
      32: 127,
      64: 1023
    }[NumW];
    Mant = Math.abs(Qty);
    while (Mant >= 2) {
      Expo++;
      Mant /= 2;
    }
    while (Mant < 1 && Expo > 0) {
      Expo--;
      Mant *= 2;
    }
    if (Expo <= 0) {
      Mant /= 2;
    }
    if (NumW === 32 && Expo > 254) {
      Bin = {
        d: Sign ? 0xFF : 0x7F,
        c: 0x80,
        b: 0,
        a: 0
      };
      Expo = Math.pow(2, ExW) - 1;
      Mant = 0;
    }
  }

  return Expo;
}

function Key() {
	this._pt = 0.0;
	this._level = 0;
	this._interval = null;
	var interval = arguments[0];
	this.computeKey(interval);
}
extend(Key.prototype, {
	getInterval: function getInterval() {
		return this._interval;
	},
	getLevel: function getLevel() {
		return this._level;
	},
	computeKey: function computeKey(itemInterval) {
		this._level = Key.computeLevel(itemInterval);
		this._interval = new Interval();
		this.computeInterval(this._level, itemInterval);
		while (!this._interval.contains(itemInterval)) {
			this._level += 1;
			this.computeInterval(this._level, itemInterval);
		}
	},
	computeInterval: function computeInterval(level, itemInterval) {
		var size = DoubleBits.powerOf2(level);
		this._pt = Math.floor(itemInterval.getMin() / size) * size;
		this._interval.init(this._pt, this._pt + size);
	},
	getPoint: function getPoint() {
		return this._pt;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Key;
	}
});
Key.computeLevel = function (interval) {
	var dx = interval.getWidth();
	var level = DoubleBits.exponent(dx) + 1;
	return level;
};

function Node() {
	NodeBase.apply(this);
	this._interval = null;
	this._centre = null;
	this._level = null;
	var interval = arguments[0],
	    level = arguments[1];
	this._interval = interval;
	this._level = level;
	this._centre = (interval.getMin() + interval.getMax()) / 2;
}
inherits(Node, NodeBase);
extend(Node.prototype, {
	getInterval: function getInterval() {
		return this._interval;
	},
	find: function find(searchInterval) {
		var subnodeIndex = NodeBase.getSubnodeIndex(searchInterval, this._centre);
		if (subnodeIndex === -1) return this;
		if (this._subnode[subnodeIndex] !== null) {
			var node = this._subnode[subnodeIndex];
			return node.find(searchInterval);
		}
		return this;
	},
	insert: function insert(node) {
		Assert.isTrue(this._interval === null || this._interval.contains(node._interval));
		var index = NodeBase.getSubnodeIndex(node._interval, this._centre);
		if (node._level === this._level - 1) {
			this._subnode[index] = node;
		} else {
			var childNode = this.createSubnode(index);
			childNode.insert(node);
			this._subnode[index] = childNode;
		}
	},
	isSearchMatch: function isSearchMatch(itemInterval) {
		return itemInterval.overlaps(this._interval);
	},
	getSubnode: function getSubnode(index) {
		if (this._subnode[index] === null) {
			this._subnode[index] = this.createSubnode(index);
		}
		return this._subnode[index];
	},
	getNode: function getNode(searchInterval) {
		var subnodeIndex = NodeBase.getSubnodeIndex(searchInterval, this._centre);
		if (subnodeIndex !== -1) {
			var node = this.getSubnode(subnodeIndex);
			return node.getNode(searchInterval);
		} else {
			return this;
		}
	},
	createSubnode: function createSubnode(index) {
		var min = 0.0;
		var max = 0.0;
		switch (index) {
			case 0:
				min = this._interval.getMin();
				max = this._centre;
				break;
			case 1:
				min = this._centre;
				max = this._interval.getMax();
				break;
		}
		var subInt = new Interval(min, max);
		var node = new Node(subInt, this._level - 1);
		return node;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Node;
	}
});
Node.createNode = function (itemInterval) {
	var key = new Key(itemInterval);
	var node = new Node(key.getInterval(), key.getLevel());
	return node;
};
Node.createExpanded = function (node, addInterval) {
	var expandInt = new Interval(addInterval);
	if (node !== null) expandInt.expandToInclude(node._interval);
	var largerNode = Node.createNode(expandInt);
	if (node !== null) largerNode.insert(node);
	return largerNode;
};

function IntervalSize() {}
extend(IntervalSize.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return IntervalSize;
	}
});
IntervalSize.isZeroWidth = function (min, max) {
	var width = max - min;
	if (width === 0.0) return true;
	var maxAbs = Math.max(Math.abs(min), Math.abs(max));
	var scaledInterval = width / maxAbs;
	var level = DoubleBits.exponent(scaledInterval);
	return level <= IntervalSize.MIN_BINARY_EXPONENT;
};
IntervalSize.MIN_BINARY_EXPONENT = -50;

function Root() {
	NodeBase.apply(this);
}
inherits(Root, NodeBase);
extend(Root.prototype, {
	insert: function insert(itemInterval, item) {
		var index = NodeBase.getSubnodeIndex(itemInterval, Root.origin);
		if (index === -1) {
			this.add(item);
			return null;
		}
		var node = this._subnode[index];
		if (node === null || !node.getInterval().contains(itemInterval)) {
			var largerNode = Node.createExpanded(node, itemInterval);
			this._subnode[index] = largerNode;
		}
		this.insertContained(this._subnode[index], itemInterval, item);
	},
	isSearchMatch: function isSearchMatch(interval) {
		return true;
	},
	insertContained: function insertContained(tree, itemInterval, item) {
		Assert.isTrue(tree.getInterval().contains(itemInterval));
		var isZeroArea = IntervalSize.isZeroWidth(itemInterval.getMin(), itemInterval.getMax());
		var node = null;
		if (isZeroArea) node = tree.find(itemInterval);else node = tree.getNode(itemInterval);
		node.add(item);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Root;
	}
});
Root.origin = 0.0;

function Bintree() {
	this._root = null;
	this._minExtent = 1.0;
	this._root = new Root();
}
extend(Bintree.prototype, {
	size: function size() {
		if (this._root !== null) return this._root.size();
		return 0;
	},
	insert: function insert(itemInterval, item) {
		this.collectStats(itemInterval);
		var insertInterval = Bintree.ensureExtent(itemInterval, this._minExtent);
		this._root.insert(insertInterval, item);
	},
	query: function query() {
		if (arguments.length === 1) {
			if (typeof arguments[0] === "number") {
				var x = arguments[0];
				return this.query(new Interval(x, x));
			} else if (arguments[0] instanceof Interval) {
				var interval = arguments[0];
				var foundItems = new ArrayList();
				this.query(interval, foundItems);
				return foundItems;
			}
		} else if (arguments.length === 2) {
			var _interval = arguments[0],
			    _foundItems = arguments[1];
			this._root.addAllItemsFromOverlapping(_interval, _foundItems);
		}
	},
	iterator: function iterator() {
		var foundItems = new ArrayList();
		this._root.addAllItems(foundItems);
		return foundItems.iterator();
	},
	remove: function remove(itemInterval, item) {
		var insertInterval = Bintree.ensureExtent(itemInterval, this._minExtent);
		return this._root.remove(insertInterval, item);
	},
	collectStats: function collectStats(interval) {
		var del = interval.getWidth();
		if (del < this._minExtent && del > 0.0) this._minExtent = del;
	},
	depth: function depth() {
		if (this._root !== null) return this._root.depth();
		return 0;
	},
	nodeSize: function nodeSize() {
		if (this._root !== null) return this._root.nodeSize();
		return 0;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Bintree;
	}
});
Bintree.ensureExtent = function (itemInterval, minExtent) {
	var min = itemInterval.getMin();
	var max = itemInterval.getMax();
	if (min !== max) return itemInterval;
	if (min === max) {
		min = min - minExtent / 2.0;
		max = min + minExtent / 2.0;
	}
	return new Interval(min, max);
};

function MonotoneChain() {
	this._pts = null;
	this._start = null;
	this._end = null;
	this._env = null;
	this._context = null;
	this._id = null;
	var pts = arguments[0],
	    start = arguments[1],
	    end = arguments[2],
	    context = arguments[3];
	this._pts = pts;
	this._start = start;
	this._end = end;
	this._context = context;
}
extend(MonotoneChain.prototype, {
	getLineSegment: function getLineSegment(index, ls) {
		ls.p0 = this._pts[index];
		ls.p1 = this._pts[index + 1];
	},
	computeSelect: function computeSelect(searchEnv, start0, end0, mcs) {
		var p0 = this._pts[start0];
		var p1 = this._pts[end0];
		if (end0 - start0 === 1) {
			mcs.select(this, start0);
			return null;
		}
		if (!searchEnv.intersects(p0, p1)) return null;
		var mid = Math.trunc((start0 + end0) / 2);
		if (start0 < mid) {
			this.computeSelect(searchEnv, start0, mid, mcs);
		}
		if (mid < end0) {
			this.computeSelect(searchEnv, mid, end0, mcs);
		}
	},
	getCoordinates: function getCoordinates() {
		var coord = new Array(this._end - this._start + 1).fill(null);
		var index = 0;
		for (var i = this._start; i <= this._end; i++) {
			coord[index++] = this._pts[i];
		}
		return coord;
	},
	computeOverlaps: function computeOverlaps() {
		if (arguments.length === 2) {
			var mc = arguments[0],
			    mco = arguments[1];
			this.computeOverlaps(this._start, this._end, mc, mc._start, mc._end, mco);
		} else if (arguments.length === 6) {
			var start0 = arguments[0],
			    end0 = arguments[1],
			    _mc = arguments[2],
			    start1 = arguments[3],
			    end1 = arguments[4],
			    _mco = arguments[5];
			if (end0 - start0 === 1 && end1 - start1 === 1) {
				_mco.overlap(this, start0, _mc, start1);
				return null;
			}
			if (!this.overlaps(start0, end0, _mc, start1, end1)) return null;
			var mid0 = Math.trunc((start0 + end0) / 2);
			var mid1 = Math.trunc((start1 + end1) / 2);
			if (start0 < mid0) {
				if (start1 < mid1) this.computeOverlaps(start0, mid0, _mc, start1, mid1, _mco);
				if (mid1 < end1) this.computeOverlaps(start0, mid0, _mc, mid1, end1, _mco);
			}
			if (mid0 < end0) {
				if (start1 < mid1) this.computeOverlaps(mid0, end0, _mc, start1, mid1, _mco);
				if (mid1 < end1) this.computeOverlaps(mid0, end0, _mc, mid1, end1, _mco);
			}
		}
	},
	setId: function setId(id) {
		this._id = id;
	},
	select: function select(searchEnv, mcs) {
		this.computeSelect(searchEnv, this._start, this._end, mcs);
	},
	getEnvelope: function getEnvelope() {
		if (this._env === null) {
			var p0 = this._pts[this._start];
			var p1 = this._pts[this._end];
			this._env = new Envelope(p0, p1);
		}
		return this._env;
	},
	overlaps: function overlaps(start0, end0, mc, start1, end1) {
		return Envelope.intersects(this._pts[start0], this._pts[end0], mc._pts[start1], mc._pts[end1]);
	},
	getEndIndex: function getEndIndex() {
		return this._end;
	},
	getStartIndex: function getStartIndex() {
		return this._start;
	},
	getContext: function getContext() {
		return this._context;
	},
	getId: function getId() {
		return this._id;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return MonotoneChain;
	}
});

function Quadrant() {}
extend(Quadrant.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Quadrant;
	}
});
Quadrant.isNorthern = function (quad) {
	return quad === Quadrant.NE || quad === Quadrant.NW;
};
Quadrant.isOpposite = function (quad1, quad2) {
	if (quad1 === quad2) return false;
	var diff = (quad1 - quad2 + 4) % 4;
	if (diff === 2) return true;
	return false;
};
Quadrant.commonHalfPlane = function (quad1, quad2) {
	if (quad1 === quad2) return quad1;
	var diff = (quad1 - quad2 + 4) % 4;
	if (diff === 2) return -1;
	var min = quad1 < quad2 ? quad1 : quad2;
	var max = quad1 > quad2 ? quad1 : quad2;
	if (min === 0 && max === 3) return 3;
	return min;
};
Quadrant.isInHalfPlane = function (quad, halfPlane) {
	if (halfPlane === Quadrant.SE) {
		return quad === Quadrant.SE || quad === Quadrant.SW;
	}
	return quad === halfPlane || quad === halfPlane + 1;
};
Quadrant.quadrant = function () {
	if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
		var dx = arguments[0],
		    dy = arguments[1];
		if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException("Cannot compute the quadrant for point ( " + dx + ", " + dy + " )");
		if (dx >= 0.0) {
			if (dy >= 0.0) return Quadrant.NE;else return Quadrant.SE;
		} else {
			if (dy >= 0.0) return Quadrant.NW;else return Quadrant.SW;
		}
	} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
		var p0 = arguments[0],
		    p1 = arguments[1];
		if (p1.x === p0.x && p1.y === p0.y) throw new IllegalArgumentException("Cannot compute the quadrant for two identical points " + p0);
		if (p1.x >= p0.x) {
			if (p1.y >= p0.y) return Quadrant.NE;else return Quadrant.SE;
		} else {
			if (p1.y >= p0.y) return Quadrant.NW;else return Quadrant.SW;
		}
	}
};
Quadrant.NE = 0;
Quadrant.NW = 1;
Quadrant.SW = 2;
Quadrant.SE = 3;

function MonotoneChainBuilder() {}
extend(MonotoneChainBuilder.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return MonotoneChainBuilder;
	}
});
MonotoneChainBuilder.getChainStartIndices = function (pts) {
	var start = 0;
	var startIndexList = new ArrayList();
	startIndexList.add(new Integer(start));
	do {
		var last = MonotoneChainBuilder.findChainEnd(pts, start);
		startIndexList.add(new Integer(last));
		start = last;
	} while (start < pts.length - 1);
	var startIndex = MonotoneChainBuilder.toIntArray(startIndexList);
	return startIndex;
};
MonotoneChainBuilder.findChainEnd = function (pts, start) {
	var safeStart = start;
	while (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) {
		safeStart++;
	}
	if (safeStart >= pts.length - 1) {
		return pts.length - 1;
	}
	var chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);
	var last = start + 1;
	while (last < pts.length) {
		if (!pts[last - 1].equals2D(pts[last])) {
			var quad = Quadrant.quadrant(pts[last - 1], pts[last]);
			if (quad !== chainQuad) break;
		}
		last++;
	}
	return last - 1;
};
MonotoneChainBuilder.getChains = function () {
	if (arguments.length === 1) {
		var pts = arguments[0];
		return MonotoneChainBuilder.getChains(pts, null);
	} else if (arguments.length === 2) {
		var _pts = arguments[0],
		    context = arguments[1];
		var mcList = new ArrayList();
		var startIndex = MonotoneChainBuilder.getChainStartIndices(_pts);
		for (var i = 0; i < startIndex.length - 1; i++) {
			var mc = new MonotoneChain(_pts, startIndex[i], startIndex[i + 1], context);
			mcList.add(mc);
		}
		return mcList;
	}
};
MonotoneChainBuilder.toIntArray = function (list) {
	var array = new Array(list.size()).fill(null);
	for (var i = 0; i < array.length; i++) {
		array[i] = list.get(i).intValue();
	}
	return array;
};

function RobustDeterminant() {}
extend(RobustDeterminant.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return RobustDeterminant;
	}
});
RobustDeterminant.orientationIndex = function (p1, p2, q) {
	var dx1 = p2.x - p1.x;
	var dy1 = p2.y - p1.y;
	var dx2 = q.x - p2.x;
	var dy2 = q.y - p2.y;
	return RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2);
};
RobustDeterminant.signOfDet2x2 = function (x1, y1, x2, y2) {
	var sign = null;
	var swap = null;
	var k = null;
	sign = 1;
	if (x1 === 0.0 || y2 === 0.0) {
		if (y1 === 0.0 || x2 === 0.0) {
			return 0;
		} else if (y1 > 0) {
			if (x2 > 0) {
				return -sign;
			} else {
				return sign;
			}
		} else {
			if (x2 > 0) {
				return sign;
			} else {
				return -sign;
			}
		}
	}
	if (y1 === 0.0 || x2 === 0.0) {
		if (y2 > 0) {
			if (x1 > 0) {
				return sign;
			} else {
				return -sign;
			}
		} else {
			if (x1 > 0) {
				return -sign;
			} else {
				return sign;
			}
		}
	}
	if (0.0 < y1) {
		if (0.0 < y2) {
			if (y1 <= y2) {
				
			} else {
				sign = -sign;
				swap = x1;
				x1 = x2;
				x2 = swap;
				swap = y1;
				y1 = y2;
				y2 = swap;
			}
		} else {
			if (y1 <= -y2) {
				sign = -sign;
				x2 = -x2;
				y2 = -y2;
			} else {
				swap = x1;
				x1 = -x2;
				x2 = swap;
				swap = y1;
				y1 = -y2;
				y2 = swap;
			}
		}
	} else {
		if (0.0 < y2) {
			if (-y1 <= y2) {
				sign = -sign;
				x1 = -x1;
				y1 = -y1;
			} else {
				swap = -x1;
				x1 = x2;
				x2 = swap;
				swap = -y1;
				y1 = y2;
				y2 = swap;
			}
		} else {
			if (y1 >= y2) {
				x1 = -x1;
				y1 = -y1;
				x2 = -x2;
				y2 = -y2;
				
			} else {
				sign = -sign;
				swap = -x1;
				x1 = -x2;
				x2 = swap;
				swap = -y1;
				y1 = -y2;
				y2 = swap;
			}
		}
	}
	if (0.0 < x1) {
		if (0.0 < x2) {
			if (x1 <= x2) {
				
			} else {
				return sign;
			}
		} else {
			return sign;
		}
	} else {
		if (0.0 < x2) {
			return -sign;
		} else {
			if (x1 >= x2) {
				sign = -sign;
				x1 = -x1;
				x2 = -x2;
				
			} else {
				return -sign;
			}
		}
	}
	while (true) {
		k = Math.floor(x2 / x1);
		x2 = x2 - k * x1;
		y2 = y2 - k * y1;
		if (y2 < 0.0) {
			return -sign;
		}
		if (y2 > y1) {
			return sign;
		}
		if (x1 > x2 + x2) {
			if (y1 < y2 + y2) {
				return sign;
			}
		} else {
			if (y1 > y2 + y2) {
				return -sign;
			} else {
				x2 = x1 - x2;
				y2 = y1 - y2;
				sign = -sign;
			}
		}
		if (y2 === 0.0) {
			if (x2 === 0.0) {
				return 0;
			} else {
				return -sign;
			}
		}
		if (x2 === 0.0) {
			return sign;
		}
		k = Math.floor(x1 / x2);
		x1 = x1 - k * x2;
		y1 = y1 - k * y2;
		if (y1 < 0.0) {
			return sign;
		}
		if (y1 > y2) {
			return -sign;
		}
		if (x2 > x1 + x1) {
			if (y2 < y1 + y1) {
				return -sign;
			}
		} else {
			if (y2 > y1 + y1) {
				return sign;
			} else {
				x1 = x2 - x1;
				y1 = y2 - y1;
				sign = -sign;
			}
		}
		if (y1 === 0.0) {
			if (x1 === 0.0) {
				return 0;
			} else {
				return sign;
			}
		}
		if (x1 === 0.0) {
			return -sign;
		}
	}
};

function PointInRing() {}
extend(PointInRing.prototype, {
	isInside: function isInside(pt) {},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return PointInRing;
	}
});

function MCPointInRing() {
	this._ring = null;
	this._tree = null;
	this._crossings = 0;
	this._interval = new Interval();
	var ring = arguments[0];
	this._ring = ring;
	this.buildIndex();
}
extend(MCPointInRing.prototype, {
	testLineSegment: function testLineSegment(p, seg) {
		var xInt = null;
		var x1 = null;
		var y1 = null;
		var x2 = null;
		var y2 = null;
		var p1 = seg.p0;
		var p2 = seg.p1;
		x1 = p1.x - p.x;
		y1 = p1.y - p.y;
		x2 = p2.x - p.x;
		y2 = p2.y - p.y;
		if (y1 > 0 && y2 <= 0 || y2 > 0 && y1 <= 0) {
			xInt = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2) / (y2 - y1);
			if (0.0 < xInt) {
				this._crossings++;
			}
		}
	},
	buildIndex: function buildIndex() {
		this._tree = new Bintree();
		var pts = CoordinateArrays.removeRepeatedPoints(this._ring.getCoordinates());
		var mcList = MonotoneChainBuilder.getChains(pts);
		for (var i = 0; i < mcList.size(); i++) {
			var mc = mcList.get(i);
			var mcEnv = mc.getEnvelope();
			this._interval.min = mcEnv.getMinY();
			this._interval.max = mcEnv.getMaxY();
			this._tree.insert(this._interval, mc);
		}
	},
	testMonotoneChain: function testMonotoneChain(rayEnv, mcSelecter, mc) {
		mc.select(rayEnv, mcSelecter);
	},
	isInside: function isInside(pt) {
		this._crossings = 0;
		var rayEnv = new Envelope(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, pt.y, pt.y);
		this._interval.min = pt.y;
		this._interval.max = pt.y;
		var segs = this._tree.query(this._interval);
		var mcSelecter = new MCSelecter(this, pt);
		for (var i = segs.iterator(); i.hasNext();) {
			var mc = i.next();
			this.testMonotoneChain(rayEnv, mcSelecter, mc);
		}
		if (this._crossings % 2 === 1) {
			return true;
		}
		return false;
	},
	interfaces_: function interfaces_() {
		return [PointInRing];
	},
	getClass: function getClass() {
		return MCPointInRing;
	}
});
function MCSelecter() {
	MonotoneChainSelectAction.apply(this);
	this.mcp = null;
	this.p = null;
	var mcp = arguments[0],
	    p = arguments[1];
	this.mcp = mcp;
	this.p = p;
}
inherits(MCSelecter, MonotoneChainSelectAction);
extend(MCSelecter.prototype, {
	select: function select() {
		if (arguments.length === 1) {
			var ls = arguments[0];
			this.mcp.testLineSegment(this.p, ls);
		} else return MonotoneChainSelectAction.prototype.select.apply(this, arguments);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return MCSelecter;
	}
});
MCPointInRing.MCSelecter = MCSelecter;

function MinimumBoundingCircle() {
	this._input = null;
	this._extremalPts = null;
	this._centre = null;
	this._radius = 0.0;
	var geom = arguments[0];
	this._input = geom;
}
extend(MinimumBoundingCircle.prototype, {
	getRadius: function getRadius() {
		this.compute();
		return this._radius;
	},
	getDiameter: function getDiameter() {
		this.compute();
		switch (this._extremalPts.length) {
			case 0:
				return this._input.getFactory().createLineString();
			case 1:
				return this._input.getFactory().createPoint(this._centre);
		}
		var p0 = this._extremalPts[0];
		var p1 = this._extremalPts[1];
		return this._input.getFactory().createLineString([p0, p1]);
	},
	getExtremalPoints: function getExtremalPoints() {
		this.compute();
		return this._extremalPts;
	},
	computeCirclePoints: function computeCirclePoints() {
		if (this._input.isEmpty()) {
			this._extremalPts = new Array(0).fill(null);
			return null;
		}
		if (this._input.getNumPoints() === 1) {
			var pts = this._input.getCoordinates();
			this._extremalPts = [new Coordinate(pts[0])];
			return null;
		}
		var convexHull = this._input.convexHull();
		var hullPts = convexHull.getCoordinates();
		var pts = hullPts;
		if (hullPts[0].equals2D(hullPts[hullPts.length - 1])) {
			pts = new Array(hullPts.length - 1).fill(null);
			CoordinateArrays.copyDeep(hullPts, 0, pts, 0, hullPts.length - 1);
		}
		if (pts.length <= 2) {
			this._extremalPts = CoordinateArrays.copyDeep(pts);
			return null;
		}
		var P = MinimumBoundingCircle.lowestPoint(pts);
		var Q = MinimumBoundingCircle.pointWitMinAngleWithX(pts, P);
		for (var i = 0; i < pts.length; i++) {
			var R = MinimumBoundingCircle.pointWithMinAngleWithSegment(pts, P, Q);
			if (Angle.isObtuse(P, R, Q)) {
				this._extremalPts = [new Coordinate(P), new Coordinate(Q)];
				return null;
			}
			if (Angle.isObtuse(R, P, Q)) {
				P = R;
				continue;
			}
			if (Angle.isObtuse(R, Q, P)) {
				Q = R;
				continue;
			}
			this._extremalPts = [new Coordinate(P), new Coordinate(Q), new Coordinate(R)];
			return null;
		}
		Assert.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!");
	},
	compute: function compute() {
		if (this._extremalPts !== null) return null;
		this.computeCirclePoints();
		this.computeCentre();
		if (this._centre !== null) this._radius = this._centre.distance(this._extremalPts[0]);
	},
	getFarthestPoints: function getFarthestPoints() {
		this.compute();
		switch (this._extremalPts.length) {
			case 0:
				return this._input.getFactory().createLineString();
			case 1:
				return this._input.getFactory().createPoint(this._centre);
		}
		var p0 = this._extremalPts[0];
		var p1 = this._extremalPts[this._extremalPts.length - 1];
		return this._input.getFactory().createLineString([p0, p1]);
	},
	getCircle: function getCircle() {
		this.compute();
		if (this._centre === null) return this._input.getFactory().createPolygon();
		var centrePoint = this._input.getFactory().createPoint(this._centre);
		if (this._radius === 0.0) return centrePoint;
		return centrePoint.buffer(this._radius);
	},
	getCentre: function getCentre() {
		this.compute();
		return this._centre;
	},
	computeCentre: function computeCentre() {
		switch (this._extremalPts.length) {
			case 0:
				this._centre = null;
				break;
			case 1:
				this._centre = this._extremalPts[0];
				break;
			case 2:
				this._centre = new Coordinate((this._extremalPts[0].x + this._extremalPts[1].x) / 2.0, (this._extremalPts[0].y + this._extremalPts[1].y) / 2.0);
				break;
			case 3:
				this._centre = Triangle.circumcentre(this._extremalPts[0], this._extremalPts[1], this._extremalPts[2]);
				break;
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return MinimumBoundingCircle;
	}
});
MinimumBoundingCircle.pointWitMinAngleWithX = function (pts, P) {
	var minSin = Double.MAX_VALUE;
	var minAngPt = null;
	for (var i = 0; i < pts.length; i++) {
		var p = pts[i];
		if (p === P) continue;
		var dx = p.x - P.x;
		var dy = p.y - P.y;
		if (dy < 0) dy = -dy;
		var len = Math.sqrt(dx * dx + dy * dy);
		var sin = dy / len;
		if (sin < minSin) {
			minSin = sin;
			minAngPt = p;
		}
	}
	return minAngPt;
};
MinimumBoundingCircle.lowestPoint = function (pts) {
	var min = pts[0];
	for (var i = 1; i < pts.length; i++) {
		if (pts[i].y < min.y) min = pts[i];
	}
	return min;
};
MinimumBoundingCircle.pointWithMinAngleWithSegment = function (pts, P, Q) {
	var minAng = Double.MAX_VALUE;
	var minAngPt = null;
	for (var i = 0; i < pts.length; i++) {
		var p = pts[i];
		if (p === P) continue;
		if (p === Q) continue;
		var ang = Angle.angleBetween(P, p, Q);
		if (ang < minAng) {
			minAng = ang;
			minAngPt = p;
		}
	}
	return minAngPt;
};

function MinimumDiameter() {
	this._inputGeom = null;
	this._isConvex = null;
	this._convexHullPts = null;
	this._minBaseSeg = new LineSegment();
	this._minWidthPt = null;
	this._minPtIndex = null;
	this._minWidth = 0.0;
	if (arguments.length === 1) {
		var inputGeom = arguments[0];
		MinimumDiameter.call(this, inputGeom, false);
	} else if (arguments.length === 2) {
		var _inputGeom = arguments[0],
		    isConvex = arguments[1];
		this._inputGeom = _inputGeom;
		this._isConvex = isConvex;
	}
}
extend(MinimumDiameter.prototype, {
	getWidthCoordinate: function getWidthCoordinate() {
		this.computeMinimumDiameter();
		return this._minWidthPt;
	},
	getSupportingSegment: function getSupportingSegment() {
		this.computeMinimumDiameter();
		return this._inputGeom.getFactory().createLineString([this._minBaseSeg.p0, this._minBaseSeg.p1]);
	},
	getDiameter: function getDiameter() {
		this.computeMinimumDiameter();
		if (this._minWidthPt === null) return this._inputGeom.getFactory().createLineString();
		var basePt = this._minBaseSeg.project(this._minWidthPt);
		return this._inputGeom.getFactory().createLineString([basePt, this._minWidthPt]);
	},
	computeWidthConvex: function computeWidthConvex(convexGeom) {
		if (convexGeom instanceof Polygon) this._convexHullPts = convexGeom.getExteriorRing().getCoordinates();else this._convexHullPts = convexGeom.getCoordinates();
		if (this._convexHullPts.length === 0) {
			this._minWidth = 0.0;
			this._minWidthPt = null;
			this._minBaseSeg = null;
		} else if (this._convexHullPts.length === 1) {
			this._minWidth = 0.0;
			this._minWidthPt = this._convexHullPts[0];
			this._minBaseSeg.p0 = this._convexHullPts[0];
			this._minBaseSeg.p1 = this._convexHullPts[0];
		} else if (this._convexHullPts.length === 2 || this._convexHullPts.length === 3) {
			this._minWidth = 0.0;
			this._minWidthPt = this._convexHullPts[0];
			this._minBaseSeg.p0 = this._convexHullPts[0];
			this._minBaseSeg.p1 = this._convexHullPts[1];
		} else this.computeConvexRingMinDiameter(this._convexHullPts);
	},
	computeConvexRingMinDiameter: function computeConvexRingMinDiameter(pts) {
		this._minWidth = Double.MAX_VALUE;
		var currMaxIndex = 1;
		var seg = new LineSegment();
		for (var i = 0; i < pts.length - 1; i++) {
			seg.p0 = pts[i];
			seg.p1 = pts[i + 1];
			currMaxIndex = this.findMaxPerpDistance(pts, seg, currMaxIndex);
		}
	},
	computeMinimumDiameter: function computeMinimumDiameter() {
		if (this._minWidthPt !== null) return null;
		if (this._isConvex) this.computeWidthConvex(this._inputGeom);else {
			var convexGeom = new ConvexHull(this._inputGeom).getConvexHull();
			this.computeWidthConvex(convexGeom);
		}
	},
	getLength: function getLength() {
		this.computeMinimumDiameter();
		return this._minWidth;
	},
	findMaxPerpDistance: function findMaxPerpDistance(pts, seg, startIndex) {
		var maxPerpDistance = seg.distancePerpendicular(pts[startIndex]);
		var nextPerpDistance = maxPerpDistance;
		var maxIndex = startIndex;
		var nextIndex = maxIndex;
		while (nextPerpDistance >= maxPerpDistance) {
			maxPerpDistance = nextPerpDistance;
			maxIndex = nextIndex;
			nextIndex = MinimumDiameter.nextIndex(pts, maxIndex);
			nextPerpDistance = seg.distancePerpendicular(pts[nextIndex]);
		}
		if (maxPerpDistance < this._minWidth) {
			this._minPtIndex = maxIndex;
			this._minWidth = maxPerpDistance;
			this._minWidthPt = pts[this._minPtIndex];
			this._minBaseSeg = new LineSegment(seg);
		}
		return maxIndex;
	},
	getMinimumRectangle: function getMinimumRectangle() {
		this.computeMinimumDiameter();
		if (this._minWidth === 0.0) {
			if (this._minBaseSeg.p0.equals2D(this._minBaseSeg.p1)) {
				return this._inputGeom.getFactory().createPoint(this._minBaseSeg.p0);
			}
			return this._minBaseSeg.toGeometry(this._inputGeom.getFactory());
		}
		var dx = this._minBaseSeg.p1.x - this._minBaseSeg.p0.x;
		var dy = this._minBaseSeg.p1.y - this._minBaseSeg.p0.y;
		var minPara = Double.MAX_VALUE;
		var maxPara = -Double.MAX_VALUE;
		var minPerp = Double.MAX_VALUE;
		var maxPerp = -Double.MAX_VALUE;
		for (var i = 0; i < this._convexHullPts.length; i++) {
			var paraC = MinimumDiameter.computeC(dx, dy, this._convexHullPts[i]);
			if (paraC > maxPara) maxPara = paraC;
			if (paraC < minPara) minPara = paraC;
			var perpC = MinimumDiameter.computeC(-dy, dx, this._convexHullPts[i]);
			if (perpC > maxPerp) maxPerp = perpC;
			if (perpC < minPerp) minPerp = perpC;
		}
		var maxPerpLine = MinimumDiameter.computeSegmentForLine(-dx, -dy, maxPerp);
		var minPerpLine = MinimumDiameter.computeSegmentForLine(-dx, -dy, minPerp);
		var maxParaLine = MinimumDiameter.computeSegmentForLine(-dy, dx, maxPara);
		var minParaLine = MinimumDiameter.computeSegmentForLine(-dy, dx, minPara);
		var p0 = maxParaLine.lineIntersection(maxPerpLine);
		var p1 = minParaLine.lineIntersection(maxPerpLine);
		var p2 = minParaLine.lineIntersection(minPerpLine);
		var p3 = maxParaLine.lineIntersection(minPerpLine);
		var shell = this._inputGeom.getFactory().createLinearRing([p0, p1, p2, p3, p0]);
		return this._inputGeom.getFactory().createPolygon(shell);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return MinimumDiameter;
	}
});
MinimumDiameter.nextIndex = function (pts, index) {
	index++;
	if (index >= pts.length) index = 0;
	return index;
};
MinimumDiameter.computeC = function (a, b, p) {
	return a * p.y - b * p.x;
};
MinimumDiameter.getMinimumDiameter = function (geom) {
	return new MinimumDiameter(geom).getDiameter();
};
MinimumDiameter.getMinimumRectangle = function (geom) {
	return new MinimumDiameter(geom).getMinimumRectangle();
};
MinimumDiameter.computeSegmentForLine = function (a, b, c) {
	var p0 = null;
	var p1 = null;
	if (Math.abs(b) > Math.abs(a)) {
		p0 = new Coordinate(0.0, c / b);
		p1 = new Coordinate(1.0, c / b - a / b);
	} else {
		p0 = new Coordinate(c / a, 0.0);
		p1 = new Coordinate(c / a - b / a, 1.0);
	}
	return new LineSegment(p0, p1);
};



var algorithm = Object.freeze({
	Angle: Angle,
	Centroid: Centroid,
	CGAlgorithms: CGAlgorithms,
	ConvexHull: ConvexHull,
	Distance: Distance,
	InteriorPointArea: InteriorPointArea,
	InteriorPointLine: InteriorPointLine,
	InteriorPointPoint: InteriorPointPoint,
	RobustLineIntersector: RobustLineIntersector,
	MCPointInRing: MCPointInRing,
	MinimumBoundingCircle: MinimumBoundingCircle,
	MinimumDiameter: MinimumDiameter
});

function GeometryTransformer() {
	this._inputGeom = null;
	this._factory = null;
	this._pruneEmptyGeometry = true;
	this._preserveGeometryCollectionType = true;
	this._preserveCollections = false;
	this._preserveType = false;
}
extend(GeometryTransformer.prototype, {
	transformPoint: function transformPoint(geom, parent) {
		return this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom));
	},
	transformPolygon: function transformPolygon(geom, parent) {
		var isAllValidLinearRings = true;
		var shell = this.transformLinearRing(geom.getExteriorRing(), geom);
		if (shell === null || !(shell instanceof LinearRing) || shell.isEmpty()) isAllValidLinearRings = false;
		var holes = new ArrayList();
		for (var i = 0; i < geom.getNumInteriorRing(); i++) {
			var hole = this.transformLinearRing(geom.getInteriorRingN(i), geom);
			if (hole === null || hole.isEmpty()) {
				continue;
			}
			if (!(hole instanceof LinearRing)) isAllValidLinearRings = false;
			holes.add(hole);
		}
		if (isAllValidLinearRings) return this._factory.createPolygon(shell, holes.toArray([]));else {
			var components = new ArrayList();
			if (shell !== null) components.add(shell);
			components.addAll(holes);
			return this._factory.buildGeometry(components);
		}
	},
	createCoordinateSequence: function createCoordinateSequence(coords) {
		return this._factory.getCoordinateSequenceFactory().create(coords);
	},
	getInputGeometry: function getInputGeometry() {
		return this._inputGeom;
	},
	transformMultiLineString: function transformMultiLineString(geom, parent) {
		var transGeomList = new ArrayList();
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var transformGeom = this.transformLineString(geom.getGeometryN(i), geom);
			if (transformGeom === null) continue;
			if (transformGeom.isEmpty()) continue;
			transGeomList.add(transformGeom);
		}
		return this._factory.buildGeometry(transGeomList);
	},
	transformCoordinates: function transformCoordinates(coords, parent) {
		return this.copy(coords);
	},
	transformLineString: function transformLineString(geom, parent) {
		return this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom));
	},
	transformMultiPoint: function transformMultiPoint(geom, parent) {
		var transGeomList = new ArrayList();
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var transformGeom = this.transformPoint(geom.getGeometryN(i), geom);
			if (transformGeom === null) continue;
			if (transformGeom.isEmpty()) continue;
			transGeomList.add(transformGeom);
		}
		return this._factory.buildGeometry(transGeomList);
	},
	transformMultiPolygon: function transformMultiPolygon(geom, parent) {
		var transGeomList = new ArrayList();
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var transformGeom = this.transformPolygon(geom.getGeometryN(i), geom);
			if (transformGeom === null) continue;
			if (transformGeom.isEmpty()) continue;
			transGeomList.add(transformGeom);
		}
		return this._factory.buildGeometry(transGeomList);
	},
	copy: function copy(seq) {
		return seq.copy();
	},
	transformGeometryCollection: function transformGeometryCollection(geom, parent) {
		var transGeomList = new ArrayList();
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var transformGeom = this.transform(geom.getGeometryN(i));
			if (transformGeom === null) continue;
			if (this._pruneEmptyGeometry && transformGeom.isEmpty()) continue;
			transGeomList.add(transformGeom);
		}
		if (this._preserveGeometryCollectionType) return this._factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList));
		return this._factory.buildGeometry(transGeomList);
	},
	transform: function transform(inputGeom) {
		this._inputGeom = inputGeom;
		this._factory = inputGeom.getFactory();
		if (inputGeom instanceof Point) return this.transformPoint(inputGeom, null);
		if (inputGeom instanceof MultiPoint) return this.transformMultiPoint(inputGeom, null);
		if (inputGeom instanceof LinearRing) return this.transformLinearRing(inputGeom, null);
		if (inputGeom instanceof LineString) return this.transformLineString(inputGeom, null);
		if (inputGeom instanceof MultiLineString) return this.transformMultiLineString(inputGeom, null);
		if (inputGeom instanceof Polygon) return this.transformPolygon(inputGeom, null);
		if (inputGeom instanceof MultiPolygon) return this.transformMultiPolygon(inputGeom, null);
		if (inputGeom instanceof GeometryCollection) return this.transformGeometryCollection(inputGeom, null);
		throw new IllegalArgumentException("Unknown Geometry subtype: " + inputGeom.getClass().getName());
	},
	transformLinearRing: function transformLinearRing(geom, parent) {
		var seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);
		if (seq === null) return this._factory.createLinearRing(null);
		var seqSize = seq.size();
		if (seqSize > 0 && seqSize < 4 && !this._preserveType) return this._factory.createLineString(seq);
		return this._factory.createLinearRing(seq);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return GeometryTransformer;
	}
});

function Densifier() {
	this._inputGeom = null;
	this._distanceTolerance = null;
	var inputGeom = arguments[0];
	this._inputGeom = inputGeom;
}
extend(Densifier.prototype, {
	getResultGeometry: function getResultGeometry() {
		return new DensifyTransformer(this._distanceTolerance).transform(this._inputGeom);
	},
	setDistanceTolerance: function setDistanceTolerance(distanceTolerance) {
		if (distanceTolerance <= 0.0) throw new IllegalArgumentException("Tolerance must be positive");
		this._distanceTolerance = distanceTolerance;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Densifier;
	}
});
Densifier.densifyPoints = function (pts, distanceTolerance, precModel) {
	var seg = new LineSegment();
	var coordList = new CoordinateList();
	for (var i = 0; i < pts.length - 1; i++) {
		seg.p0 = pts[i];
		seg.p1 = pts[i + 1];
		coordList.add(seg.p0, false);
		var len = seg.getLength();
		var densifiedSegCount = Math.trunc(len / distanceTolerance) + 1;
		if (densifiedSegCount > 1) {
			var densifiedSegLen = len / densifiedSegCount;
			for (var j = 1; j < densifiedSegCount; j++) {
				var segFract = j * densifiedSegLen / len;
				var p = seg.pointAlong(segFract);
				precModel.makePrecise(p);
				coordList.add(p, false);
			}
		}
	}
	coordList.add(pts[pts.length - 1], false);
	return coordList.toCoordinateArray();
};
Densifier.densify = function (geom, distanceTolerance) {
	var densifier = new Densifier(geom);
	densifier.setDistanceTolerance(distanceTolerance);
	return densifier.getResultGeometry();
};
function DensifyTransformer() {
	GeometryTransformer.apply(this);
	this.distanceTolerance = null;
	var distanceTolerance = arguments[0];
	this.distanceTolerance = distanceTolerance;
}
inherits(DensifyTransformer, GeometryTransformer);
extend(DensifyTransformer.prototype, {
	transformMultiPolygon: function transformMultiPolygon(geom, parent) {
		var roughGeom = GeometryTransformer.prototype.transformMultiPolygon.call(this, geom, parent);
		return this.createValidArea(roughGeom);
	},
	transformPolygon: function transformPolygon(geom, parent) {
		var roughGeom = GeometryTransformer.prototype.transformPolygon.call(this, geom, parent);
		if (parent instanceof MultiPolygon) {
			return roughGeom;
		}
		return this.createValidArea(roughGeom);
	},
	transformCoordinates: function transformCoordinates(coords, parent) {
		var inputPts = coords.toCoordinateArray();
		var newPts = Densifier.densifyPoints(inputPts, this.distanceTolerance, parent.getPrecisionModel());
		if (parent instanceof LineString && newPts.length === 1) {
			newPts = new Array(0).fill(null);
		}
		return this._factory.getCoordinateSequenceFactory().create(newPts);
	},
	createValidArea: function createValidArea(roughAreaGeom) {
		return roughAreaGeom.buffer(0.0);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return DensifyTransformer;
	}
});
Densifier.DensifyTransformer = DensifyTransformer;



var densify = Object.freeze({
	Densifier: Densifier
});

function HalfEdge() {
	this._orig = null;
	this._sym = null;
	this._next = null;
	var orig = arguments[0];
	this._orig = orig;
}
extend(HalfEdge.prototype, {
	find: function find(dest) {
		var oNext = this;
		do {
			if (oNext === null) return null;
			if (oNext.dest().equals2D(dest)) return oNext;
			oNext = oNext.oNext();
		} while (oNext !== this);
		return null;
	},
	dest: function dest() {
		return this._sym._orig;
	},
	oNext: function oNext() {
		return this._sym._next;
	},
	insert: function insert(e) {
		if (this.oNext() === this) {
			this.insertAfter(e);
			return null;
		}
		var ecmp = this.compareTo(e);
		var ePrev = this;
		do {
			var oNext = ePrev.oNext();
			var cmp = oNext.compareTo(e);
			if (cmp !== ecmp || oNext === this) {
				ePrev.insertAfter(e);
				return null;
			}
			ePrev = oNext;
		} while (ePrev !== this);
		Assert.shouldNeverReachHere();
	},
	insertAfter: function insertAfter(e) {
		Assert.equals(this._orig, e.orig());
		var save = this.oNext();
		this._sym.setNext(e);
		e.sym().setNext(save);
	},
	degree: function degree() {
		var degree = 0;
		var e = this;
		do {
			degree++;
			e = e.oNext();
		} while (e !== this);
		return degree;
	},
	equals: function equals() {
		if (arguments.length === 2 && arguments[1] instanceof Coordinate && arguments[0] instanceof Coordinate) {
			var p0 = arguments[0],
			    p1 = arguments[1];
			return this._orig.equals2D(p0) && this._sym._orig.equals(p1);
		}
	},
	deltaY: function deltaY() {
		return this._sym._orig.y - this._orig.y;
	},
	sym: function sym() {
		return this._sym;
	},
	prev: function prev() {
		return this._sym.next()._sym;
	},
	compareAngularDirection: function compareAngularDirection(e) {
		var dx = this.deltaX();
		var dy = this.deltaY();
		var dx2 = e.deltaX();
		var dy2 = e.deltaY();
		if (dx === dx2 && dy === dy2) return 0;
		var quadrant = Quadrant.quadrant(dx, dy);
		var quadrant2 = Quadrant.quadrant(dx2, dy2);
		if (quadrant > quadrant2) return 1;
		if (quadrant < quadrant2) return -1;
		return Orientation.index(e._orig, e.dest(), this.dest());
	},
	prevNode: function prevNode() {
		var e = this;
		while (e.degree() === 2) {
			e = e.prev();
			if (e === this) return null;
		}
		return e;
	},
	compareTo: function compareTo(obj) {
		var e = obj;
		var comp = this.compareAngularDirection(e);
		return comp;
	},
	next: function next() {
		return this._next;
	},
	setSym: function setSym(e) {
		this._sym = e;
	},
	orig: function orig() {
		return this._orig;
	},
	toString: function toString() {
		return "HE(" + this._orig.x + " " + this._orig.y + ", " + this._sym._orig.x + " " + this._sym._orig.y + ")";
	},
	setNext: function setNext(e) {
		this._next = e;
	},
	init: function init(e) {
		this.setSym(e);
		e.setSym(this);
		this.setNext(e);
		e.setNext(this);
	},
	deltaX: function deltaX() {
		return this._sym._orig.x - this._orig.x;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return HalfEdge;
	}
});
HalfEdge.init = function (e0, e1) {
	if (e0._sym !== null || e1._sym !== null || e0._next !== null || e1._next !== null) throw new IllegalStateException("Edges are already initialized");
	e0.init(e1);
	return e0;
};
HalfEdge.create = function (p0, p1) {
	var e0 = new HalfEdge(p0);
	var e1 = new HalfEdge(p1);
	e0.init(e1);
	return e0;
};

function MarkHalfEdge() {
	this._isMarked = false;
	var orig = arguments[0];
	HalfEdge.call(this, orig);
}
inherits(MarkHalfEdge, HalfEdge);
extend(MarkHalfEdge.prototype, {
	mark: function mark() {
		this._isMarked = true;
	},
	setMark: function setMark(isMarked) {
		this._isMarked = isMarked;
	},
	isMarked: function isMarked() {
		return this._isMarked;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return MarkHalfEdge;
	}
});
MarkHalfEdge.setMarkBoth = function (e, isMarked) {
	e.setMark(isMarked);
	e.sym().setMark(isMarked);
};
MarkHalfEdge.isMarked = function (e) {
	return e.isMarked();
};
MarkHalfEdge.setMark = function (e, isMarked) {
	e.setMark(isMarked);
};
MarkHalfEdge.markBoth = function (e) {
	e.mark();
	e.sym().mark();
};
MarkHalfEdge.mark = function (e) {
	e.mark();
};

function EdgeGraph() {
	this._vertexMap = new HashMap();
}
extend(EdgeGraph.prototype, {
	insert: function insert(orig, dest, eAdj) {
		var e = this.create(orig, dest);
		if (eAdj !== null) {
			eAdj.insert(e);
		} else {
			this._vertexMap.put(orig, e);
		}
		var eAdjDest = this._vertexMap.get(dest);
		if (eAdjDest !== null) {
			eAdjDest.insert(e.sym());
		} else {
			this._vertexMap.put(dest, e.sym());
		}
		return e;
	},
	create: function create(p0, p1) {
		var e0 = this.createEdge(p0);
		var e1 = this.createEdge(p1);
		HalfEdge.init(e0, e1);
		return e0;
	},
	createEdge: function createEdge(orig) {
		return new HalfEdge(orig);
	},
	addEdge: function addEdge(orig, dest) {
		if (!EdgeGraph.isValidEdge(orig, dest)) return null;
		var eAdj = this._vertexMap.get(orig);
		var eSame = null;
		if (eAdj !== null) {
			eSame = eAdj.find(dest);
		}
		if (eSame !== null) {
			return eSame;
		}
		var e = this.insert(orig, dest, eAdj);
		return e;
	},
	getVertexEdges: function getVertexEdges() {
		return this._vertexMap.values();
	},
	findEdge: function findEdge(orig, dest) {
		var e = this._vertexMap.get(orig);
		if (e === null) return null;
		return e.find(dest);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return EdgeGraph;
	}
});
EdgeGraph.isValidEdge = function (orig, dest) {
	var cmp = dest.compareTo(orig);
	return cmp !== 0;
};

function DissolveHalfEdge() {
	this._isStart = false;
	var orig = arguments[0];
	MarkHalfEdge.call(this, orig);
}
inherits(DissolveHalfEdge, MarkHalfEdge);
extend(DissolveHalfEdge.prototype, {
	setStart: function setStart() {
		this._isStart = true;
	},
	isStart: function isStart() {
		return this._isStart;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return DissolveHalfEdge;
	}
});

function DissolveEdgeGraph() {
	EdgeGraph.apply(this);
}
inherits(DissolveEdgeGraph, EdgeGraph);
extend(DissolveEdgeGraph.prototype, {
	createEdge: function createEdge(p0) {
		return new DissolveHalfEdge(p0);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return DissolveEdgeGraph;
	}
});

function LineDissolver() {
	this._result = null;
	this._factory = null;
	this._graph = null;
	this._lines = new ArrayList();
	this._nodeEdgeStack = new Stack();
	this._ringStartEdge = null;
	this._graph = new DissolveEdgeGraph();
}
extend(LineDissolver.prototype, {
	addLine: function addLine(line) {
		this._lines.add(this._factory.createLineString(line.toCoordinateArray()));
	},
	updateRingStartEdge: function updateRingStartEdge(e) {
		if (!e.isStart()) {
			e = e.sym();
			if (!e.isStart()) return null;
		}
		if (this._ringStartEdge === null) {
			this._ringStartEdge = e;
			return null;
		}
		if (e.orig().compareTo(this._ringStartEdge.orig()) < 0) {
			this._ringStartEdge = e;
		}
	},
	getResult: function getResult() {
		if (this._result === null) this.computeResult();
		return this._result;
	},
	process: function process(e) {
		var eNode = e.prevNode();
		if (eNode === null) eNode = e;
		this.stackEdges(eNode);
		this.buildLines();
	},
	buildRing: function buildRing(eStartRing) {
		var line = new CoordinateList();
		var e = eStartRing;
		line.add(e.orig().copy(), false);
		while (e.sym().degree() === 2) {
			var eNext = e.next();
			if (eNext === eStartRing) break;
			line.add(eNext.orig().copy(), false);
			e = eNext;
		}
		line.add(e.dest().copy(), false);
		this.addLine(line);
	},
	buildLine: function buildLine(eStart) {
		var line = new CoordinateList();
		var e = eStart;
		this._ringStartEdge = null;
		MarkHalfEdge.markBoth(e);
		line.add(e.orig().copy(), false);
		while (e.sym().degree() === 2) {
			this.updateRingStartEdge(e);
			var eNext = e.next();
			if (eNext === eStart) {
				this.buildRing(this._ringStartEdge);
				return null;
			}
			line.add(eNext.orig().copy(), false);
			e = eNext;
			MarkHalfEdge.markBoth(e);
		}
		line.add(e.dest().clone(), false);
		this.stackEdges(e.sym());
		this.addLine(line);
	},
	stackEdges: function stackEdges(node) {
		var e = node;
		do {
			if (!MarkHalfEdge.isMarked(e)) this._nodeEdgeStack.add(e);
			e = e.oNext();
		} while (e !== node);
	},
	computeResult: function computeResult() {
		var edges = this._graph.getVertexEdges();
		for (var i = edges.iterator(); i.hasNext();) {
			var e = i.next();
			if (MarkHalfEdge.isMarked(e)) continue;
			this.process(e);
		}
		this._result = this._factory.buildGeometry(this._lines);
	},
	buildLines: function buildLines() {
		while (!this._nodeEdgeStack.empty()) {
			var e = this._nodeEdgeStack.pop();
			if (MarkHalfEdge.isMarked(e)) continue;
			this.buildLine(e);
		}
	},
	add: function add() {
		if (arguments[0] instanceof Geometry) {
			var _geometry = arguments[0];
			_geometry.apply({
				interfaces_: function interfaces_() {
					return [GeometryComponentFilter];
				},
				filter: function filter(component) {
					if (component instanceof LineString) {
						this.add(component);
					}
				}
			});
		} else if (hasInterface(arguments[0], Collection)) {
			var geometries = arguments[0];
			for (var i = geometries.iterator(); i.hasNext();) {
				var geometry = i.next();
				this.add(geometry);
			}
		} else if (arguments[0] instanceof LineString) {
			var lineString = arguments[0];
			if (this._factory === null) {
				this._factory = lineString.getFactory();
			}
			var seq = lineString.getCoordinateSequence();
			var doneStart = false;
			for (var i = 1; i < seq.size(); i++) {
				var e = this._graph.addEdge(seq.getCoordinate(i - 1), seq.getCoordinate(i));
				if (e === null) continue;
				if (!doneStart) {
					e.setStart();
					doneStart = true;
				}
			}
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LineDissolver;
	}
});
LineDissolver.dissolve = function (g) {
	var d = new LineDissolver();
	d.add(g);
	return d.getResult();
};



var dissolve = Object.freeze({
	LineDissolver: LineDissolver
});

function PointLocator() {
	this._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;
	this._isIn = null;
	this._numBoundaries = null;
	if (arguments.length === 0) {} else if (arguments.length === 1) {
		var boundaryRule = arguments[0];
		if (boundaryRule === null) throw new IllegalArgumentException("Rule must be non-null");
		this._boundaryRule = boundaryRule;
	}
}
extend(PointLocator.prototype, {
	locateInPolygonRing: function locateInPolygonRing(p, ring) {
		if (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;
		return PointLocation.locateInRing(p, ring.getCoordinates());
	},
	intersects: function intersects(p, geom) {
		return this.locate(p, geom) !== Location.EXTERIOR;
	},
	updateLocationInfo: function updateLocationInfo(loc) {
		if (loc === Location.INTERIOR) this._isIn = true;
		if (loc === Location.BOUNDARY) this._numBoundaries++;
	},
	computeLocation: function computeLocation(p, geom) {
		if (geom instanceof Point) {
			this.updateLocationInfo(this.locateOnPoint(p, geom));
		}
		if (geom instanceof LineString) {
			this.updateLocationInfo(this.locateOnLineString(p, geom));
		} else if (geom instanceof Polygon) {
			this.updateLocationInfo(this.locateInPolygon(p, geom));
		} else if (geom instanceof MultiLineString) {
			var ml = geom;
			for (var i = 0; i < ml.getNumGeometries(); i++) {
				var l = ml.getGeometryN(i);
				this.updateLocationInfo(this.locateOnLineString(p, l));
			}
		} else if (geom instanceof MultiPolygon) {
			var mpoly = geom;
			for (var i = 0; i < mpoly.getNumGeometries(); i++) {
				var poly = mpoly.getGeometryN(i);
				this.updateLocationInfo(this.locateInPolygon(p, poly));
			}
		} else if (geom instanceof GeometryCollection) {
			var geomi = new GeometryCollectionIterator(geom);
			while (geomi.hasNext()) {
				var g2 = geomi.next();
				if (g2 !== geom) this.computeLocation(p, g2);
			}
		}
	},
	locateOnPoint: function locateOnPoint(p, pt) {
		var ptCoord = pt.getCoordinate();
		if (ptCoord.equals2D(p)) return Location.INTERIOR;
		return Location.EXTERIOR;
	},
	locateOnLineString: function locateOnLineString(p, l) {
		if (!l.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;
		var seq = l.getCoordinateSequence();
		if (!l.isClosed()) {
			if (p.equals(seq.getCoordinate(0)) || p.equals(seq.getCoordinate(seq.size() - 1))) {
				return Location.BOUNDARY;
			}
		}
		if (PointLocation.isOnLine(p, seq)) {
			return Location.INTERIOR;
		}
		return Location.EXTERIOR;
	},
	locateInPolygon: function locateInPolygon(p, poly) {
		if (poly.isEmpty()) return Location.EXTERIOR;
		var shell = poly.getExteriorRing();
		var shellLoc = this.locateInPolygonRing(p, shell);
		if (shellLoc === Location.EXTERIOR) return Location.EXTERIOR;
		if (shellLoc === Location.BOUNDARY) return Location.BOUNDARY;
		for (var i = 0; i < poly.getNumInteriorRing(); i++) {
			var hole = poly.getInteriorRingN(i);
			var holeLoc = this.locateInPolygonRing(p, hole);
			if (holeLoc === Location.INTERIOR) return Location.EXTERIOR;
			if (holeLoc === Location.BOUNDARY) return Location.BOUNDARY;
		}
		return Location.INTERIOR;
	},
	locate: function locate(p, geom) {
		if (geom.isEmpty()) return Location.EXTERIOR;
		if (geom instanceof LineString) {
			return this.locateOnLineString(p, geom);
		} else if (geom instanceof Polygon) {
			return this.locateInPolygon(p, geom);
		}
		this._isIn = false;
		this._numBoundaries = 0;
		this.computeLocation(p, geom);
		if (this._boundaryRule.isInBoundary(this._numBoundaries)) return Location.BOUNDARY;
		if (this._numBoundaries > 0 || this._isIn) return Location.INTERIOR;
		return Location.EXTERIOR;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return PointLocator;
	}
});

function Position() {}
extend(Position.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Position;
	}
});
Position.opposite = function (position) {
	if (position === Position.LEFT) return Position.RIGHT;
	if (position === Position.RIGHT) return Position.LEFT;
	return position;
};
Position.ON = 0;
Position.LEFT = 1;
Position.RIGHT = 2;

function MonotoneChain$1() {
	this.mce = null;
	this.chainIndex = null;
	var mce = arguments[0],
	    chainIndex = arguments[1];
	this.mce = mce;
	this.chainIndex = chainIndex;
}
extend(MonotoneChain$1.prototype, {
	computeIntersections: function computeIntersections(mc, si) {
		this.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return MonotoneChain$1;
	}
});

function SweepLineEvent() {
	this._label = null;
	this._xValue = null;
	this._eventType = null;
	this._insertEvent = null;
	this._deleteEventIndex = null;
	this._obj = null;
	if (arguments.length === 2) {
		var x = arguments[0],
		    insertEvent = arguments[1];
		this._eventType = SweepLineEvent.DELETE;
		this._xValue = x;
		this._insertEvent = insertEvent;
	} else if (arguments.length === 3) {
		var label = arguments[0],
		    _x = arguments[1],
		    obj = arguments[2];
		this._eventType = SweepLineEvent.INSERT;
		this._label = label;
		this._xValue = _x;
		this._obj = obj;
	}
}
extend(SweepLineEvent.prototype, {
	isDelete: function isDelete() {
		return this._eventType === SweepLineEvent.DELETE;
	},
	setDeleteEventIndex: function setDeleteEventIndex(deleteEventIndex) {
		this._deleteEventIndex = deleteEventIndex;
	},
	getObject: function getObject() {
		return this._obj;
	},
	compareTo: function compareTo(o) {
		var pe = o;
		if (this._xValue < pe._xValue) return -1;
		if (this._xValue > pe._xValue) return 1;
		if (this._eventType < pe._eventType) return -1;
		if (this._eventType > pe._eventType) return 1;
		return 0;
	},
	getInsertEvent: function getInsertEvent() {
		return this._insertEvent;
	},
	isInsert: function isInsert() {
		return this._eventType === SweepLineEvent.INSERT;
	},
	isSameLabel: function isSameLabel(ev) {
		if (this._label === null) return false;
		return this._label === ev._label;
	},
	getDeleteEventIndex: function getDeleteEventIndex() {
		return this._deleteEventIndex;
	},
	interfaces_: function interfaces_() {
		return [Comparable];
	},
	getClass: function getClass() {
		return SweepLineEvent;
	}
});
SweepLineEvent.INSERT = 1;
SweepLineEvent.DELETE = 2;

function EdgeSetIntersector() {}
extend(EdgeSetIntersector.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return EdgeSetIntersector;
	}
});

function SegmentIntersector() {
	this._hasIntersection = false;
	this._hasProper = false;
	this._hasProperInterior = false;
	this._properIntersectionPoint = null;
	this._li = null;
	this._includeProper = null;
	this._recordIsolated = null;
	this._isSelfIntersection = null;
	this._numIntersections = 0;
	this.numTests = 0;
	this._bdyNodes = null;
	this._isDone = false;
	this._isDoneWhenProperInt = false;
	var li = arguments[0],
	    includeProper = arguments[1],
	    recordIsolated = arguments[2];
	this._li = li;
	this._includeProper = includeProper;
	this._recordIsolated = recordIsolated;
}
extend(SegmentIntersector.prototype, {
	isTrivialIntersection: function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {
		if (e0 === e1) {
			if (this._li.getIntersectionNum() === 1) {
				if (SegmentIntersector.isAdjacentSegments(segIndex0, segIndex1)) return true;
				if (e0.isClosed()) {
					var maxSegIndex = e0.getNumPoints() - 1;
					if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {
						return true;
					}
				}
			}
		}
		return false;
	},
	getProperIntersectionPoint: function getProperIntersectionPoint() {
		return this._properIntersectionPoint;
	},
	setIsDoneIfProperInt: function setIsDoneIfProperInt(isDoneWhenProperInt) {
		this._isDoneWhenProperInt = isDoneWhenProperInt;
	},
	hasProperInteriorIntersection: function hasProperInteriorIntersection() {
		return this._hasProperInterior;
	},
	isBoundaryPointInternal: function isBoundaryPointInternal(li, bdyNodes) {
		for (var i = bdyNodes.iterator(); i.hasNext();) {
			var node = i.next();
			var pt = node.getCoordinate();
			if (li.isIntersection(pt)) return true;
		}
		return false;
	},
	hasProperIntersection: function hasProperIntersection() {
		return this._hasProper;
	},
	hasIntersection: function hasIntersection() {
		return this._hasIntersection;
	},
	isDone: function isDone() {
		return this._isDone;
	},
	isBoundaryPoint: function isBoundaryPoint(li, bdyNodes) {
		if (bdyNodes === null) return false;
		if (this.isBoundaryPointInternal(li, bdyNodes[0])) return true;
		if (this.isBoundaryPointInternal(li, bdyNodes[1])) return true;
		return false;
	},
	setBoundaryNodes: function setBoundaryNodes(bdyNodes0, bdyNodes1) {
		this._bdyNodes = new Array(2).fill(null);
		this._bdyNodes[0] = bdyNodes0;
		this._bdyNodes[1] = bdyNodes1;
	},
	addIntersections: function addIntersections(e0, segIndex0, e1, segIndex1) {
		if (e0 === e1 && segIndex0 === segIndex1) return null;
		this.numTests++;
		var p00 = e0.getCoordinates()[segIndex0];
		var p01 = e0.getCoordinates()[segIndex0 + 1];
		var p10 = e1.getCoordinates()[segIndex1];
		var p11 = e1.getCoordinates()[segIndex1 + 1];
		this._li.computeIntersection(p00, p01, p10, p11);
		if (this._li.hasIntersection()) {
			if (this._recordIsolated) {
				e0.setIsolated(false);
				e1.setIsolated(false);
			}
			this._numIntersections++;
			if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
				this._hasIntersection = true;
				if (this._includeProper || !this._li.isProper()) {
					e0.addIntersections(this._li, segIndex0, 0);
					e1.addIntersections(this._li, segIndex1, 1);
				}
				if (this._li.isProper()) {
					this._properIntersectionPoint = this._li.getIntersection(0).copy();
					this._hasProper = true;
					if (this._isDoneWhenProperInt) {
						this._isDone = true;
					}
					if (!this.isBoundaryPoint(this._li, this._bdyNodes)) this._hasProperInterior = true;
				}
			}
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return SegmentIntersector;
	}
});
SegmentIntersector.isAdjacentSegments = function (i1, i2) {
	return Math.abs(i1 - i2) === 1;
};

function SimpleMCSweepLineIntersector() {
	EdgeSetIntersector.apply(this);
	this.events = new ArrayList();
	this.nOverlaps = null;
}
inherits(SimpleMCSweepLineIntersector, EdgeSetIntersector);
extend(SimpleMCSweepLineIntersector.prototype, {
	prepareEvents: function prepareEvents() {
		Collections.sort(this.events);
		for (var i = 0; i < this.events.size(); i++) {
			var ev = this.events.get(i);
			if (ev.isDelete()) {
				ev.getInsertEvent().setDeleteEventIndex(i);
			}
		}
	},
	computeIntersections: function computeIntersections() {
		if (arguments.length === 1) {
			var si = arguments[0];
			this.nOverlaps = 0;
			this.prepareEvents();
			for (var i = 0; i < this.events.size(); i++) {
				var ev = this.events.get(i);
				if (ev.isInsert()) {
					this.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);
				}
				if (si.isDone()) {
					break;
				}
			}
		} else if (arguments.length === 3) {
			if (arguments[2] instanceof SegmentIntersector && hasInterface(arguments[0], List) && hasInterface(arguments[1], List)) {
				var edges0 = arguments[0],
				    edges1 = arguments[1],
				    _si = arguments[2];
				this.addEdges(edges0, edges0);
				this.addEdges(edges1, edges1);
				this.computeIntersections(_si);
			} else if (typeof arguments[2] === "boolean" && hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector) {
				var edges = arguments[0],
				    _si2 = arguments[1],
				    testAllSegments = arguments[2];
				if (testAllSegments) this.addEdges(edges, null);else this.addEdges(edges);
				this.computeIntersections(_si2);
			}
		}
	},
	addEdge: function addEdge(edge, edgeSet) {
		var mce = edge.getMonotoneChainEdge();
		var startIndex = mce.getStartIndexes();
		for (var i = 0; i < startIndex.length - 1; i++) {
			var mc = new MonotoneChain$1(mce, i);
			var insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);
			this.events.add(insertEvent);
			this.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));
		}
	},
	processOverlaps: function processOverlaps(start, end, ev0, si) {
		var mc0 = ev0.getObject();
		for (var i = start; i < end; i++) {
			var ev1 = this.events.get(i);
			if (ev1.isInsert()) {
				var mc1 = ev1.getObject();
				if (!ev0.isSameLabel(ev1)) {
					mc0.computeIntersections(mc1, si);
					this.nOverlaps++;
				}
			}
		}
	},
	addEdges: function addEdges() {
		if (arguments.length === 1) {
			var edges = arguments[0];
			for (var i = edges.iterator(); i.hasNext();) {
				var edge = i.next();
				this.addEdge(edge, edge);
			}
		} else if (arguments.length === 2) {
			var _edges = arguments[0],
			    edgeSet = arguments[1];
			for (var i = _edges.iterator(); i.hasNext();) {
				var edge = i.next();
				this.addEdge(edge, edgeSet);
			}
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return SimpleMCSweepLineIntersector;
	}
});

function TopologyLocation() {
	this.location = null;
	if (arguments.length === 1) {
		if (arguments[0] instanceof Array) {
			var location = arguments[0];
			this.init(location.length);
		} else if (Number.isInteger(arguments[0])) {
			var on = arguments[0];
			this.init(1);
			this.location[Position.ON] = on;
		} else if (arguments[0] instanceof TopologyLocation) {
			var gl = arguments[0];
			this.init(gl.location.length);
			if (gl !== null) {
				for (var i = 0; i < this.location.length; i++) {
					this.location[i] = gl.location[i];
				}
			}
		}
	} else if (arguments.length === 3) {
		var _on = arguments[0],
		    left = arguments[1],
		    right = arguments[2];
		this.init(3);
		this.location[Position.ON] = _on;
		this.location[Position.LEFT] = left;
		this.location[Position.RIGHT] = right;
	}
}
extend(TopologyLocation.prototype, {
	setAllLocations: function setAllLocations(locValue) {
		for (var i = 0; i < this.location.length; i++) {
			this.location[i] = locValue;
		}
	},
	isNull: function isNull() {
		for (var i = 0; i < this.location.length; i++) {
			if (this.location[i] !== Location.NONE) return false;
		}
		return true;
	},
	setAllLocationsIfNull: function setAllLocationsIfNull(locValue) {
		for (var i = 0; i < this.location.length; i++) {
			if (this.location[i] === Location.NONE) this.location[i] = locValue;
		}
	},
	isLine: function isLine() {
		return this.location.length === 1;
	},
	merge: function merge(gl) {
		if (gl.location.length > this.location.length) {
			var newLoc = new Array(3).fill(null);
			newLoc[Position.ON] = this.location[Position.ON];
			newLoc[Position.LEFT] = Location.NONE;
			newLoc[Position.RIGHT] = Location.NONE;
			this.location = newLoc;
		}
		for (var i = 0; i < this.location.length; i++) {
			if (this.location[i] === Location.NONE && i < gl.location.length) this.location[i] = gl.location[i];
		}
	},
	getLocations: function getLocations() {
		return this.location;
	},
	flip: function flip() {
		if (this.location.length <= 1) return null;
		var temp = this.location[Position.LEFT];
		this.location[Position.LEFT] = this.location[Position.RIGHT];
		this.location[Position.RIGHT] = temp;
	},
	toString: function toString() {
		var buf = new StringBuffer();
		if (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.LEFT]));
		buf.append(Location.toLocationSymbol(this.location[Position.ON]));
		if (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]));
		return buf.toString();
	},
	setLocations: function setLocations(on, left, right) {
		this.location[Position.ON] = on;
		this.location[Position.LEFT] = left;
		this.location[Position.RIGHT] = right;
	},
	get: function get(posIndex) {
		if (posIndex < this.location.length) return this.location[posIndex];
		return Location.NONE;
	},
	isArea: function isArea() {
		return this.location.length > 1;
	},
	isAnyNull: function isAnyNull() {
		for (var i = 0; i < this.location.length; i++) {
			if (this.location[i] === Location.NONE) return true;
		}
		return false;
	},
	setLocation: function setLocation() {
		if (arguments.length === 1) {
			var locValue = arguments[0];
			this.setLocation(Position.ON, locValue);
		} else if (arguments.length === 2) {
			var locIndex = arguments[0],
			    _locValue = arguments[1];
			this.location[locIndex] = _locValue;
		}
	},
	init: function init(size) {
		this.location = new Array(size).fill(null);
		this.setAllLocations(Location.NONE);
	},
	isEqualOnSide: function isEqualOnSide(le, locIndex) {
		return this.location[locIndex] === le.location[locIndex];
	},
	allPositionsEqual: function allPositionsEqual(loc) {
		for (var i = 0; i < this.location.length; i++) {
			if (this.location[i] !== loc) return false;
		}
		return true;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return TopologyLocation;
	}
});

function Label() {
	this.elt = new Array(2).fill(null);
	if (arguments.length === 1) {
		if (Number.isInteger(arguments[0])) {
			var onLoc = arguments[0];
			this.elt[0] = new TopologyLocation(onLoc);
			this.elt[1] = new TopologyLocation(onLoc);
		} else if (arguments[0] instanceof Label) {
			var lbl = arguments[0];
			this.elt[0] = new TopologyLocation(lbl.elt[0]);
			this.elt[1] = new TopologyLocation(lbl.elt[1]);
		}
	} else if (arguments.length === 2) {
		var geomIndex = arguments[0],
		    _onLoc = arguments[1];
		this.elt[0] = new TopologyLocation(Location.NONE);
		this.elt[1] = new TopologyLocation(Location.NONE);
		this.elt[geomIndex].setLocation(_onLoc);
	} else if (arguments.length === 3) {
		var _onLoc2 = arguments[0],
		    leftLoc = arguments[1],
		    rightLoc = arguments[2];
		this.elt[0] = new TopologyLocation(_onLoc2, leftLoc, rightLoc);
		this.elt[1] = new TopologyLocation(_onLoc2, leftLoc, rightLoc);
	} else if (arguments.length === 4) {
		var _geomIndex = arguments[0],
		    _onLoc3 = arguments[1],
		    _leftLoc = arguments[2],
		    _rightLoc = arguments[3];
		this.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);
		this.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);
		this.elt[_geomIndex].setLocations(_onLoc3, _leftLoc, _rightLoc);
	}
}
extend(Label.prototype, {
	getGeometryCount: function getGeometryCount() {
		var count = 0;
		if (!this.elt[0].isNull()) count++;
		if (!this.elt[1].isNull()) count++;
		return count;
	},
	setAllLocations: function setAllLocations(geomIndex, location) {
		this.elt[geomIndex].setAllLocations(location);
	},
	isNull: function isNull(geomIndex) {
		return this.elt[geomIndex].isNull();
	},
	setAllLocationsIfNull: function setAllLocationsIfNull() {
		if (arguments.length === 1) {
			var location = arguments[0];
			this.setAllLocationsIfNull(0, location);
			this.setAllLocationsIfNull(1, location);
		} else if (arguments.length === 2) {
			var geomIndex = arguments[0],
			    _location = arguments[1];
			this.elt[geomIndex].setAllLocationsIfNull(_location);
		}
	},
	isLine: function isLine(geomIndex) {
		return this.elt[geomIndex].isLine();
	},
	merge: function merge(lbl) {
		for (var i = 0; i < 2; i++) {
			if (this.elt[i] === null && lbl.elt[i] !== null) {
				this.elt[i] = new TopologyLocation(lbl.elt[i]);
			} else {
				this.elt[i].merge(lbl.elt[i]);
			}
		}
	},
	flip: function flip() {
		this.elt[0].flip();
		this.elt[1].flip();
	},
	getLocation: function getLocation() {
		if (arguments.length === 1) {
			var geomIndex = arguments[0];
			return this.elt[geomIndex].get(Position.ON);
		} else if (arguments.length === 2) {
			var _geomIndex2 = arguments[0],
			    posIndex = arguments[1];
			return this.elt[_geomIndex2].get(posIndex);
		}
	},
	toString: function toString() {
		var buf = new StringBuffer();
		if (this.elt[0] !== null) {
			buf.append("A:");
			buf.append(this.elt[0].toString());
		}
		if (this.elt[1] !== null) {
			buf.append(" B:");
			buf.append(this.elt[1].toString());
		}
		return buf.toString();
	},
	isArea: function isArea() {
		if (arguments.length === 0) {
			return this.elt[0].isArea() || this.elt[1].isArea();
		} else if (arguments.length === 1) {
			var geomIndex = arguments[0];
			return this.elt[geomIndex].isArea();
		}
	},
	isAnyNull: function isAnyNull(geomIndex) {
		return this.elt[geomIndex].isAnyNull();
	},
	setLocation: function setLocation() {
		if (arguments.length === 2) {
			var geomIndex = arguments[0],
			    location = arguments[1];
			this.elt[geomIndex].setLocation(Position.ON, location);
		} else if (arguments.length === 3) {
			var _geomIndex3 = arguments[0],
			    posIndex = arguments[1],
			    _location2 = arguments[2];
			this.elt[_geomIndex3].setLocation(posIndex, _location2);
		}
	},
	isEqualOnSide: function isEqualOnSide(lbl, side) {
		return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side);
	},
	allPositionsEqual: function allPositionsEqual(geomIndex, loc) {
		return this.elt[geomIndex].allPositionsEqual(loc);
	},
	toLine: function toLine(geomIndex) {
		if (this.elt[geomIndex].isArea()) this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Label;
	}
});
Label.toLineLabel = function (label) {
	var lineLabel = new Label(Location.NONE);
	for (var i = 0; i < 2; i++) {
		lineLabel.setLocation(i, label.getLocation(i));
	}
	return lineLabel;
};

function EdgeIntersection() {
	this.coord = null;
	this.segmentIndex = null;
	this.dist = null;
	var coord = arguments[0],
	    segmentIndex = arguments[1],
	    dist = arguments[2];
	this.coord = new Coordinate(coord);
	this.segmentIndex = segmentIndex;
	this.dist = dist;
}
extend(EdgeIntersection.prototype, {
	getSegmentIndex: function getSegmentIndex() {
		return this.segmentIndex;
	},
	getCoordinate: function getCoordinate() {
		return this.coord;
	},
	print: function print(out) {
		out.print(this.coord);
		out.print(" seg # = " + this.segmentIndex);
		out.println(" dist = " + this.dist);
	},
	compareTo: function compareTo(obj) {
		var other = obj;
		return this.compare(other.segmentIndex, other.dist);
	},
	isEndPoint: function isEndPoint(maxSegmentIndex) {
		if (this.segmentIndex === 0 && this.dist === 0.0) return true;
		if (this.segmentIndex === maxSegmentIndex) return true;
		return false;
	},
	toString: function toString() {
		return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
	},
	getDistance: function getDistance() {
		return this.dist;
	},
	compare: function compare(segmentIndex, dist) {
		if (this.segmentIndex < segmentIndex) return -1;
		if (this.segmentIndex > segmentIndex) return 1;
		if (this.dist < dist) return -1;
		if (this.dist > dist) return 1;
		return 0;
	},
	interfaces_: function interfaces_() {
		return [Comparable];
	},
	getClass: function getClass() {
		return EdgeIntersection;
	}
});

function EdgeIntersectionList() {
	this._nodeMap = new TreeMap();
	this.edge = null;
	var edge = arguments[0];
	this.edge = edge;
}
extend(EdgeIntersectionList.prototype, {
	print: function print(out) {
		out.println("Intersections:");
		for (var it = this.iterator(); it.hasNext();) {
			var ei = it.next();
			ei.print(out);
		}
	},
	iterator: function iterator() {
		return this._nodeMap.values().iterator();
	},
	addSplitEdges: function addSplitEdges(edgeList) {
		this.addEndpoints();
		var it = this.iterator();
		var eiPrev = it.next();
		while (it.hasNext()) {
			var ei = it.next();
			var newEdge = this.createSplitEdge(eiPrev, ei);
			edgeList.add(newEdge);
			eiPrev = ei;
		}
	},
	addEndpoints: function addEndpoints() {
		var maxSegIndex = this.edge.pts.length - 1;
		this.add(this.edge.pts[0], 0, 0.0);
		this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);
	},
	createSplitEdge: function createSplitEdge(ei0, ei1) {
		var npts = ei1.segmentIndex - ei0.segmentIndex + 2;
		var lastSegStartPt = this.edge.pts[ei1.segmentIndex];
		var useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);
		if (!useIntPt1) {
			npts--;
		}
		var pts = new Array(npts).fill(null);
		var ipt = 0;
		pts[ipt++] = new Coordinate(ei0.coord);
		for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
			pts[ipt++] = this.edge.pts[i];
		}
		if (useIntPt1) pts[ipt] = ei1.coord;
		return new Edge(pts, new Label(this.edge._label));
	},
	add: function add(intPt, segmentIndex, dist) {
		var eiNew = new EdgeIntersection(intPt, segmentIndex, dist);
		var ei = this._nodeMap.get(eiNew);
		if (ei !== null) {
			return ei;
		}
		this._nodeMap.put(eiNew, eiNew);
		return eiNew;
	},
	isIntersection: function isIntersection(pt) {
		for (var it = this.iterator(); it.hasNext();) {
			var ei = it.next();
			if (ei.coord.equals(pt)) return true;
		}
		return false;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return EdgeIntersectionList;
	}
});

function MonotoneChainIndexer() {}
extend(MonotoneChainIndexer.prototype, {
	getChainStartIndices: function getChainStartIndices(pts) {
		var start = 0;
		var startIndexList = new ArrayList();
		startIndexList.add(new Integer(start));
		do {
			var last = this.findChainEnd(pts, start);
			startIndexList.add(new Integer(last));
			start = last;
		} while (start < pts.length - 1);
		var startIndex = MonotoneChainIndexer.toIntArray(startIndexList);
		return startIndex;
	},
	findChainEnd: function findChainEnd(pts, start) {
		var chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);
		var last = start + 1;
		while (last < pts.length) {
			var quad = Quadrant.quadrant(pts[last - 1], pts[last]);
			if (quad !== chainQuad) break;
			last++;
		}
		return last - 1;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return MonotoneChainIndexer;
	}
});
MonotoneChainIndexer.toIntArray = function (list) {
	var array = new Array(list.size()).fill(null);
	for (var i = 0; i < array.length; i++) {
		array[i] = list.get(i).intValue();
	}
	return array;
};

function MonotoneChainEdge() {
	this.e = null;
	this.pts = null;
	this.startIndex = null;
	var e = arguments[0];
	this.e = e;
	this.pts = e.getCoordinates();
	var mcb = new MonotoneChainIndexer();
	this.startIndex = mcb.getChainStartIndices(this.pts);
}
extend(MonotoneChainEdge.prototype, {
	getCoordinates: function getCoordinates() {
		return this.pts;
	},
	getMaxX: function getMaxX(chainIndex) {
		var x1 = this.pts[this.startIndex[chainIndex]].x;
		var x2 = this.pts[this.startIndex[chainIndex + 1]].x;
		return x1 > x2 ? x1 : x2;
	},
	getMinX: function getMinX(chainIndex) {
		var x1 = this.pts[this.startIndex[chainIndex]].x;
		var x2 = this.pts[this.startIndex[chainIndex + 1]].x;
		return x1 < x2 ? x1 : x2;
	},
	computeIntersectsForChain: function computeIntersectsForChain() {
		if (arguments.length === 4) {
			var chainIndex0 = arguments[0],
			    mce = arguments[1],
			    chainIndex1 = arguments[2],
			    si = arguments[3];
			this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);
		} else if (arguments.length === 6) {
			var start0 = arguments[0],
			    end0 = arguments[1],
			    _mce = arguments[2],
			    start1 = arguments[3],
			    end1 = arguments[4],
			    ei = arguments[5];
			if (end0 - start0 === 1 && end1 - start1 === 1) {
				ei.addIntersections(this.e, start0, _mce.e, start1);
				return null;
			}
			if (!this.overlaps(start0, end0, _mce, start1, end1)) return null;
			var mid0 = Math.trunc((start0 + end0) / 2);
			var mid1 = Math.trunc((start1 + end1) / 2);
			if (start0 < mid0) {
				if (start1 < mid1) this.computeIntersectsForChain(start0, mid0, _mce, start1, mid1, ei);
				if (mid1 < end1) this.computeIntersectsForChain(start0, mid0, _mce, mid1, end1, ei);
			}
			if (mid0 < end0) {
				if (start1 < mid1) this.computeIntersectsForChain(mid0, end0, _mce, start1, mid1, ei);
				if (mid1 < end1) this.computeIntersectsForChain(mid0, end0, _mce, mid1, end1, ei);
			}
		}
	},
	overlaps: function overlaps(start0, end0, mce, start1, end1) {
		return Envelope.intersects(this.pts[start0], this.pts[end0], mce.pts[start1], mce.pts[end1]);
	},
	getStartIndexes: function getStartIndexes() {
		return this.startIndex;
	},
	computeIntersects: function computeIntersects(mce, si) {
		for (var i = 0; i < this.startIndex.length - 1; i++) {
			for (var j = 0; j < mce.startIndex.length - 1; j++) {
				this.computeIntersectsForChain(i, mce, j, si);
			}
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return MonotoneChainEdge;
	}
});

function Depth() {
	this._depth = Array(2).fill().map(function () {
		return Array(3);
	});
	for (var i = 0; i < 2; i++) {
		for (var j = 0; j < 3; j++) {
			this._depth[i][j] = Depth.NULL_VALUE;
		}
	}
}
extend(Depth.prototype, {
	getDepth: function getDepth(geomIndex, posIndex) {
		return this._depth[geomIndex][posIndex];
	},
	setDepth: function setDepth(geomIndex, posIndex, depthValue) {
		this._depth[geomIndex][posIndex] = depthValue;
	},
	isNull: function isNull() {
		if (arguments.length === 0) {
			for (var i = 0; i < 2; i++) {
				for (var j = 0; j < 3; j++) {
					if (this._depth[i][j] !== Depth.NULL_VALUE) return false;
				}
			}
			return true;
		} else if (arguments.length === 1) {
			var geomIndex = arguments[0];
			return this._depth[geomIndex][1] === Depth.NULL_VALUE;
		} else if (arguments.length === 2) {
			var _geomIndex = arguments[0],
			    posIndex = arguments[1];
			return this._depth[_geomIndex][posIndex] === Depth.NULL_VALUE;
		}
	},
	normalize: function normalize() {
		for (var i = 0; i < 2; i++) {
			if (!this.isNull(i)) {
				var minDepth = this._depth[i][1];
				if (this._depth[i][2] < minDepth) minDepth = this._depth[i][2];
				if (minDepth < 0) minDepth = 0;
				for (var j = 1; j < 3; j++) {
					var newValue = 0;
					if (this._depth[i][j] > minDepth) newValue = 1;
					this._depth[i][j] = newValue;
				}
			}
		}
	},
	getDelta: function getDelta(geomIndex) {
		return this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT];
	},
	getLocation: function getLocation(geomIndex, posIndex) {
		if (this._depth[geomIndex][posIndex] <= 0) return Location.EXTERIOR;
		return Location.INTERIOR;
	},
	toString: function toString() {
		return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
	},
	add: function add() {
		if (arguments.length === 1) {
			var lbl = arguments[0];
			for (var i = 0; i < 2; i++) {
				for (var j = 1; j < 3; j++) {
					var loc = lbl.getLocation(i, j);
					if (loc === Location.EXTERIOR || loc === Location.INTERIOR) {
						if (this.isNull(i, j)) {
							this._depth[i][j] = Depth.depthAtLocation(loc);
						} else this._depth[i][j] += Depth.depthAtLocation(loc);
					}
				}
			}
		} else if (arguments.length === 3) {
			var geomIndex = arguments[0],
			    posIndex = arguments[1],
			    location = arguments[2];
			if (location === Location.INTERIOR) this._depth[geomIndex][posIndex]++;
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Depth;
	}
});
Depth.depthAtLocation = function (location) {
	if (location === Location.EXTERIOR) return 0;
	if (location === Location.INTERIOR) return 1;
	return Depth.NULL_VALUE;
};
Depth.NULL_VALUE = -1;

function GraphComponent() {
	this._label = null;
	this._isInResult = false;
	this._isCovered = false;
	this._isCoveredSet = false;
	this._isVisited = false;
	if (arguments.length === 0) {} else if (arguments.length === 1) {
		var label = arguments[0];
		this._label = label;
	}
}
extend(GraphComponent.prototype, {
	setVisited: function setVisited(isVisited) {
		this._isVisited = isVisited;
	},
	setInResult: function setInResult(isInResult) {
		this._isInResult = isInResult;
	},
	isCovered: function isCovered() {
		return this._isCovered;
	},
	isCoveredSet: function isCoveredSet() {
		return this._isCoveredSet;
	},
	setLabel: function setLabel(label) {
		this._label = label;
	},
	getLabel: function getLabel() {
		return this._label;
	},
	setCovered: function setCovered(isCovered) {
		this._isCovered = isCovered;
		this._isCoveredSet = true;
	},
	updateIM: function updateIM(im) {
		Assert.isTrue(this._label.getGeometryCount() >= 2, "found partial label");
		this.computeIM(im);
	},
	isInResult: function isInResult() {
		return this._isInResult;
	},
	isVisited: function isVisited() {
		return this._isVisited;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return GraphComponent;
	}
});

function Edge() {
	GraphComponent.apply(this);
	this.pts = null;
	this._env = null;
	this.eiList = new EdgeIntersectionList(this);
	this._name = null;
	this._mce = null;
	this._isIsolated = true;
	this._depth = new Depth();
	this._depthDelta = 0;
	if (arguments.length === 1) {
		var pts = arguments[0];
		Edge.call(this, pts, null);
	} else if (arguments.length === 2) {
		var _pts = arguments[0],
		    label = arguments[1];
		this.pts = _pts;
		this._label = label;
	}
}
inherits(Edge, GraphComponent);
extend(Edge.prototype, {
	getDepth: function getDepth() {
		return this._depth;
	},
	getCollapsedEdge: function getCollapsedEdge() {
		var newPts = new Array(2).fill(null);
		newPts[0] = this.pts[0];
		newPts[1] = this.pts[1];
		var newe = new Edge(newPts, Label.toLineLabel(this._label));
		return newe;
	},
	isIsolated: function isIsolated() {
		return this._isIsolated;
	},
	getCoordinates: function getCoordinates() {
		return this.pts;
	},
	setIsolated: function setIsolated(isIsolated) {
		this._isIsolated = isIsolated;
	},
	setName: function setName(name) {
		this._name = name;
	},
	equals: function equals(o) {
		if (!(o instanceof Edge)) return false;
		var e = o;
		if (this.pts.length !== e.pts.length) return false;
		var isEqualForward = true;
		var isEqualReverse = true;
		var iRev = this.pts.length;
		for (var i = 0; i < this.pts.length; i++) {
			if (!this.pts[i].equals2D(e.pts[i])) {
				isEqualForward = false;
			}
			if (!this.pts[i].equals2D(e.pts[--iRev])) {
				isEqualReverse = false;
			}
			if (!isEqualForward && !isEqualReverse) return false;
		}
		return true;
	},
	getCoordinate: function getCoordinate() {
		if (arguments.length === 0) {
			if (this.pts.length > 0) return this.pts[0];
			return null;
		} else if (arguments.length === 1) {
			var i = arguments[0];
			return this.pts[i];
		}
	},
	print: function print(out) {
		out.print("edge " + this._name + ": ");
		out.print("LINESTRING (");
		for (var i = 0; i < this.pts.length; i++) {
			if (i > 0) out.print(",");
			out.print(this.pts[i].x + " " + this.pts[i].y);
		}
		out.print(")  " + this._label + " " + this._depthDelta);
	},
	computeIM: function computeIM(im) {
		Edge.updateIM(this._label, im);
	},
	isCollapsed: function isCollapsed() {
		if (!this._label.isArea()) return false;
		if (this.pts.length !== 3) return false;
		if (this.pts[0].equals(this.pts[2])) return true;
		return false;
	},
	isClosed: function isClosed() {
		return this.pts[0].equals(this.pts[this.pts.length - 1]);
	},
	getMaximumSegmentIndex: function getMaximumSegmentIndex() {
		return this.pts.length - 1;
	},
	getDepthDelta: function getDepthDelta() {
		return this._depthDelta;
	},
	getNumPoints: function getNumPoints() {
		return this.pts.length;
	},
	printReverse: function printReverse(out) {
		out.print("edge " + this._name + ": ");
		for (var i = this.pts.length - 1; i >= 0; i--) {
			out.print(this.pts[i] + " ");
		}
		out.println("");
	},
	getMonotoneChainEdge: function getMonotoneChainEdge() {
		if (this._mce === null) this._mce = new MonotoneChainEdge(this);
		return this._mce;
	},
	getEnvelope: function getEnvelope() {
		if (this._env === null) {
			this._env = new Envelope();
			for (var i = 0; i < this.pts.length; i++) {
				this._env.expandToInclude(this.pts[i]);
			}
		}
		return this._env;
	},
	addIntersection: function addIntersection(li, segmentIndex, geomIndex, intIndex) {
		var intPt = new Coordinate(li.getIntersection(intIndex));
		var normalizedSegmentIndex = segmentIndex;
		var dist = li.getEdgeDistance(geomIndex, intIndex);
		var nextSegIndex = normalizedSegmentIndex + 1;
		if (nextSegIndex < this.pts.length) {
			var nextPt = this.pts[nextSegIndex];
			if (intPt.equals2D(nextPt)) {
				normalizedSegmentIndex = nextSegIndex;
				dist = 0.0;
			}
		}
		var ei = this.eiList.add(intPt, normalizedSegmentIndex, dist);
	},
	toString: function toString() {
		var builder = new StringBuilder();
		builder.append("edge " + this._name + ": ");
		builder.append("LINESTRING (");
		for (var i = 0; i < this.pts.length; i++) {
			if (i > 0) builder.append(",");
			builder.append(this.pts[i].x + " " + this.pts[i].y);
		}
		builder.append(")  " + this._label + " " + this._depthDelta);
		return builder.toString();
	},
	isPointwiseEqual: function isPointwiseEqual(e) {
		if (this.pts.length !== e.pts.length) return false;
		for (var i = 0; i < this.pts.length; i++) {
			if (!this.pts[i].equals2D(e.pts[i])) {
				return false;
			}
		}
		return true;
	},
	setDepthDelta: function setDepthDelta(depthDelta) {
		this._depthDelta = depthDelta;
	},
	getEdgeIntersectionList: function getEdgeIntersectionList() {
		return this.eiList;
	},
	addIntersections: function addIntersections(li, segmentIndex, geomIndex) {
		for (var i = 0; i < li.getIntersectionNum(); i++) {
			this.addIntersection(li, segmentIndex, geomIndex, i);
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Edge;
	}
});
Edge.updateIM = function () {
	if (arguments.length === 2 && arguments[1] instanceof IntersectionMatrix && arguments[0] instanceof Label) {
		var label = arguments[0],
		    im = arguments[1];
		im.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);
		if (label.isArea()) {
			im.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);
			im.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);
		}
	} else return GraphComponent.prototype.updateIM.apply(this, arguments);
};

function Node$1() {
	GraphComponent.apply(this);
	this._coord = null;
	this._edges = null;
	var coord = arguments[0],
	    edges = arguments[1];
	this._coord = coord;
	this._edges = edges;
	this._label = new Label(0, Location.NONE);
}
inherits(Node$1, GraphComponent);
extend(Node$1.prototype, {
	isIncidentEdgeInResult: function isIncidentEdgeInResult() {
		for (var it = this.getEdges().getEdges().iterator(); it.hasNext();) {
			var de = it.next();
			if (de.getEdge().isInResult()) return true;
		}
		return false;
	},
	isIsolated: function isIsolated() {
		return this._label.getGeometryCount() === 1;
	},
	getCoordinate: function getCoordinate() {
		return this._coord;
	},
	print: function print(out) {
		out.println("node " + this._coord + " lbl: " + this._label);
	},
	computeIM: function computeIM(im) {},
	computeMergedLocation: function computeMergedLocation(label2, eltIndex) {
		var loc = Location.NONE;
		loc = this._label.getLocation(eltIndex);
		if (!label2.isNull(eltIndex)) {
			var nLoc = label2.getLocation(eltIndex);
			if (loc !== Location.BOUNDARY) loc = nLoc;
		}
		return loc;
	},
	setLabel: function setLabel() {
		if (arguments.length === 2 && Number.isInteger(arguments[1]) && Number.isInteger(arguments[0])) {
			var argIndex = arguments[0],
			    onLocation = arguments[1];
			if (this._label === null) {
				this._label = new Label(argIndex, onLocation);
			} else this._label.setLocation(argIndex, onLocation);
		} else return GraphComponent.prototype.setLabel.apply(this, arguments);
	},
	getEdges: function getEdges() {
		return this._edges;
	},
	mergeLabel: function mergeLabel() {
		if (arguments[0] instanceof Node$1) {
			var n = arguments[0];
			this.mergeLabel(n._label);
		} else if (arguments[0] instanceof Label) {
			var label2 = arguments[0];
			for (var i = 0; i < 2; i++) {
				var loc = this.computeMergedLocation(label2, i);
				var thisLoc = this._label.getLocation(i);
				if (thisLoc === Location.NONE) this._label.setLocation(i, loc);
			}
		}
	},
	add: function add(e) {
		this._edges.insert(e);
		e.setNode(this);
	},
	setLabelBoundary: function setLabelBoundary(argIndex) {
		if (this._label === null) return null;
		var loc = Location.NONE;
		if (this._label !== null) loc = this._label.getLocation(argIndex);
		var newLoc = null;
		switch (loc) {
			case Location.BOUNDARY:
				newLoc = Location.INTERIOR;
				break;
			case Location.INTERIOR:
				newLoc = Location.BOUNDARY;
				break;
			default:
				newLoc = Location.BOUNDARY;
				break;
		}
		this._label.setLocation(argIndex, newLoc);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Node$1;
	}
});

function NodeMap() {
	this.nodeMap = new TreeMap();
	this.nodeFact = null;
	var nodeFact = arguments[0];
	this.nodeFact = nodeFact;
}
extend(NodeMap.prototype, {
	find: function find(coord) {
		return this.nodeMap.get(coord);
	},
	addNode: function addNode() {
		if (arguments[0] instanceof Coordinate) {
			var coord = arguments[0];
			var node = this.nodeMap.get(coord);
			if (node === null) {
				node = this.nodeFact.createNode(coord);
				this.nodeMap.put(coord, node);
			}
			return node;
		} else if (arguments[0] instanceof Node$1) {
			var n = arguments[0];
			var node = this.nodeMap.get(n.getCoordinate());
			if (node === null) {
				this.nodeMap.put(n.getCoordinate(), n);
				return n;
			}
			node.mergeLabel(n);
			return node;
		}
	},
	print: function print(out) {
		for (var it = this.iterator(); it.hasNext();) {
			var n = it.next();
			n.print(out);
		}
	},
	iterator: function iterator() {
		return this.nodeMap.values().iterator();
	},
	values: function values() {
		return this.nodeMap.values();
	},
	getBoundaryNodes: function getBoundaryNodes(geomIndex) {
		var bdyNodes = new ArrayList();
		for (var i = this.iterator(); i.hasNext();) {
			var node = i.next();
			if (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) bdyNodes.add(node);
		}
		return bdyNodes;
	},
	add: function add(e) {
		var p = e.getCoordinate();
		var n = this.addNode(p);
		n.add(e);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return NodeMap;
	}
});

function EdgeEnd() {
	this._edge = null;
	this._label = null;
	this._node = null;
	this._p0 = null;
	this._p1 = null;
	this._dx = null;
	this._dy = null;
	this._quadrant = null;
	if (arguments.length === 1) {
		var edge = arguments[0];
		this._edge = edge;
	} else if (arguments.length === 3) {
		var _edge = arguments[0],
		    p0 = arguments[1],
		    p1 = arguments[2];
		EdgeEnd.call(this, _edge, p0, p1, null);
	} else if (arguments.length === 4) {
		var _edge2 = arguments[0],
		    _p = arguments[1],
		    _p2 = arguments[2],
		    label = arguments[3];
		EdgeEnd.call(this, _edge2);
		this.init(_p, _p2);
		this._label = label;
	}
}
extend(EdgeEnd.prototype, {
	compareDirection: function compareDirection(e) {
		if (this._dx === e._dx && this._dy === e._dy) return 0;
		if (this._quadrant > e._quadrant) return 1;
		if (this._quadrant < e._quadrant) return -1;
		return Orientation.index(e._p0, e._p1, this._p1);
	},
	getDy: function getDy() {
		return this._dy;
	},
	getCoordinate: function getCoordinate() {
		return this._p0;
	},
	setNode: function setNode(node) {
		this._node = node;
	},
	print: function print(out) {
		var angle = Math.atan2(this._dy, this._dx);
		var className = this.getClass().getName();
		var lastDotPos = className.lastIndexOf('.');
		var name = className.substring(lastDotPos + 1);
		out.print("  " + name + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + angle + "   " + this._label);
	},
	compareTo: function compareTo(obj) {
		var e = obj;
		return this.compareDirection(e);
	},
	getDirectedCoordinate: function getDirectedCoordinate() {
		return this._p1;
	},
	getDx: function getDx() {
		return this._dx;
	},
	getLabel: function getLabel() {
		return this._label;
	},
	getEdge: function getEdge() {
		return this._edge;
	},
	getQuadrant: function getQuadrant() {
		return this._quadrant;
	},
	getNode: function getNode() {
		return this._node;
	},
	toString: function toString() {
		var angle = Math.atan2(this._dy, this._dx);
		var className = this.getClass().getName();
		var lastDotPos = className.lastIndexOf('.');
		var name = className.substring(lastDotPos + 1);
		return "  " + name + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + angle + "   " + this._label;
	},
	computeLabel: function computeLabel(boundaryNodeRule) {},
	init: function init(p0, p1) {
		this._p0 = p0;
		this._p1 = p1;
		this._dx = p1.x - p0.x;
		this._dy = p1.y - p0.y;
		this._quadrant = Quadrant.quadrant(this._dx, this._dy);
		Assert.isTrue(!(this._dx === 0 && this._dy === 0), "EdgeEnd with identical endpoints found");
	},
	interfaces_: function interfaces_() {
		return [Comparable];
	},
	getClass: function getClass() {
		return EdgeEnd;
	}
});

function TopologyException() {
	this.pt = null;
	if (arguments.length === 1) {
		var msg = arguments[0];
		RuntimeException.call(this, msg);
	} else if (arguments.length === 2) {
		var _msg = arguments[0],
		    pt = arguments[1];
		RuntimeException.call(this, TopologyException.msgWithCoord(_msg, pt));
		this.name = 'TopologyException';
		this.pt = new Coordinate(pt);
	}
}
inherits(TopologyException, RuntimeException);
extend(TopologyException.prototype, {
	getCoordinate: function getCoordinate() {
		return this.pt;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return TopologyException;
	}
});
TopologyException.msgWithCoord = function (msg, pt) {
	if (pt !== null) return msg + " [ " + pt + " ]";
	return msg;
};

function DirectedEdge() {
	this._isForward = null;
	this._isInResult = false;
	this._isVisited = false;
	this._sym = null;
	this._next = null;
	this._nextMin = null;
	this._edgeRing = null;
	this._minEdgeRing = null;
	this._depth = [0, -999, -999];
	var edge = arguments[0],
	    isForward = arguments[1];
	EdgeEnd.call(this, edge);
	this._isForward = isForward;
	if (isForward) {
		this.init(edge.getCoordinate(0), edge.getCoordinate(1));
	} else {
		var n = edge.getNumPoints() - 1;
		this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));
	}
	this.computeDirectedLabel();
}
inherits(DirectedEdge, EdgeEnd);
extend(DirectedEdge.prototype, {
	getNextMin: function getNextMin() {
		return this._nextMin;
	},
	getDepth: function getDepth(position) {
		return this._depth[position];
	},
	setVisited: function setVisited(isVisited) {
		this._isVisited = isVisited;
	},
	computeDirectedLabel: function computeDirectedLabel() {
		this._label = new Label(this._edge.getLabel());
		if (!this._isForward) this._label.flip();
	},
	getNext: function getNext() {
		return this._next;
	},
	setDepth: function setDepth(position, depthVal) {
		if (this._depth[position] !== -999) {
			if (this._depth[position] !== depthVal) throw new TopologyException("assigned depths do not match", this.getCoordinate());
		}
		this._depth[position] = depthVal;
	},
	isInteriorAreaEdge: function isInteriorAreaEdge() {
		var isInteriorAreaEdge = true;
		for (var i = 0; i < 2; i++) {
			if (!(this._label.isArea(i) && this._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {
				isInteriorAreaEdge = false;
			}
		}
		return isInteriorAreaEdge;
	},
	setNextMin: function setNextMin(nextMin) {
		this._nextMin = nextMin;
	},
	print: function print(out) {
		EdgeEnd.prototype.print.call(this, out);
		out.print(" " + this._depth[Position.LEFT] + "/" + this._depth[Position.RIGHT]);
		out.print(" (" + this.getDepthDelta() + ")");
		if (this._isInResult) out.print(" inResult");
	},
	setMinEdgeRing: function setMinEdgeRing(minEdgeRing) {
		this._minEdgeRing = minEdgeRing;
	},
	isLineEdge: function isLineEdge() {
		var isLine = this._label.isLine(0) || this._label.isLine(1);
		var isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);
		var isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);
		return isLine && isExteriorIfArea0 && isExteriorIfArea1;
	},
	setEdgeRing: function setEdgeRing(edgeRing) {
		this._edgeRing = edgeRing;
	},
	getMinEdgeRing: function getMinEdgeRing() {
		return this._minEdgeRing;
	},
	getDepthDelta: function getDepthDelta() {
		var depthDelta = this._edge.getDepthDelta();
		if (!this._isForward) depthDelta = -depthDelta;
		return depthDelta;
	},
	setInResult: function setInResult(isInResult) {
		this._isInResult = isInResult;
	},
	getSym: function getSym() {
		return this._sym;
	},
	isForward: function isForward() {
		return this._isForward;
	},
	getEdge: function getEdge() {
		return this._edge;
	},
	printEdge: function printEdge(out) {
		this.print(out);
		out.print(" ");
		if (this._isForward) this._edge.print(out);else this._edge.printReverse(out);
	},
	setSym: function setSym(de) {
		this._sym = de;
	},
	setVisitedEdge: function setVisitedEdge(isVisited) {
		this.setVisited(isVisited);
		this._sym.setVisited(isVisited);
	},
	setEdgeDepths: function setEdgeDepths(position, depth) {
		var depthDelta = this.getEdge().getDepthDelta();
		if (!this._isForward) depthDelta = -depthDelta;
		var directionFactor = 1;
		if (position === Position.LEFT) directionFactor = -1;
		var oppositePos = Position.opposite(position);
		var delta = depthDelta * directionFactor;
		var oppositeDepth = depth + delta;
		this.setDepth(position, depth);
		this.setDepth(oppositePos, oppositeDepth);
	},
	getEdgeRing: function getEdgeRing() {
		return this._edgeRing;
	},
	isInResult: function isInResult() {
		return this._isInResult;
	},
	setNext: function setNext(next) {
		this._next = next;
	},
	isVisited: function isVisited() {
		return this._isVisited;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return DirectedEdge;
	}
});
DirectedEdge.depthFactor = function (currLocation, nextLocation) {
	if (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) return 1;else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) return -1;
	return 0;
};

function NodeFactory() {}
extend(NodeFactory.prototype, {
	createNode: function createNode(coord) {
		return new Node$1(coord, null);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return NodeFactory;
	}
});

function PlanarGraph() {
	this._edges = new ArrayList();
	this._nodes = null;
	this._edgeEndList = new ArrayList();
	if (arguments.length === 0) {
		this._nodes = new NodeMap(new NodeFactory());
	} else if (arguments.length === 1) {
		var nodeFact = arguments[0];
		this._nodes = new NodeMap(nodeFact);
	}
}
extend(PlanarGraph.prototype, {
	printEdges: function printEdges(out) {
		out.println("Edges:");
		for (var i = 0; i < this._edges.size(); i++) {
			out.println("edge " + i + ":");
			var e = this._edges.get(i);
			e.print(out);
			e.eiList.print(out);
		}
	},
	find: function find(coord) {
		return this._nodes.find(coord);
	},
	addNode: function addNode() {
		if (arguments[0] instanceof Node$1) {
			var node = arguments[0];
			return this._nodes.addNode(node);
		} else if (arguments[0] instanceof Coordinate) {
			var coord = arguments[0];
			return this._nodes.addNode(coord);
		}
	},
	getNodeIterator: function getNodeIterator() {
		return this._nodes.iterator();
	},
	linkResultDirectedEdges: function linkResultDirectedEdges() {
		for (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {
			var node = nodeit.next();
			node.getEdges().linkResultDirectedEdges();
		}
	},
	debugPrintln: function debugPrintln(o) {
		System.out.println(o);
	},
	isBoundaryNode: function isBoundaryNode(geomIndex, coord) {
		var node = this._nodes.find(coord);
		if (node === null) return false;
		var label = node.getLabel();
		if (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) return true;
		return false;
	},
	linkAllDirectedEdges: function linkAllDirectedEdges() {
		for (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {
			var node = nodeit.next();
			node.getEdges().linkAllDirectedEdges();
		}
	},
	matchInSameDirection: function matchInSameDirection(p0, p1, ep0, ep1) {
		if (!p0.equals(ep0)) return false;
		if (Orientation.index(p0, p1, ep1) === Orientation.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) return true;
		return false;
	},
	getEdgeEnds: function getEdgeEnds() {
		return this._edgeEndList;
	},
	debugPrint: function debugPrint(o) {
		System.out.print(o);
	},
	getEdgeIterator: function getEdgeIterator() {
		return this._edges.iterator();
	},
	findEdgeInSameDirection: function findEdgeInSameDirection(p0, p1) {
		for (var i = 0; i < this._edges.size(); i++) {
			var e = this._edges.get(i);
			var eCoord = e.getCoordinates();
			if (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) return e;
			if (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) return e;
		}
		return null;
	},
	insertEdge: function insertEdge(e) {
		this._edges.add(e);
	},
	findEdgeEnd: function findEdgeEnd(e) {
		for (var i = this.getEdgeEnds().iterator(); i.hasNext();) {
			var ee = i.next();
			if (ee.getEdge() === e) return ee;
		}
		return null;
	},
	addEdges: function addEdges(edgesToAdd) {
		for (var it = edgesToAdd.iterator(); it.hasNext();) {
			var e = it.next();
			this._edges.add(e);
			var de1 = new DirectedEdge(e, true);
			var de2 = new DirectedEdge(e, false);
			de1.setSym(de2);
			de2.setSym(de1);
			this.add(de1);
			this.add(de2);
		}
	},
	add: function add(e) {
		this._nodes.add(e);
		this._edgeEndList.add(e);
	},
	getNodes: function getNodes() {
		return this._nodes.values();
	},
	findEdge: function findEdge(p0, p1) {
		for (var i = 0; i < this._edges.size(); i++) {
			var e = this._edges.get(i);
			var eCoord = e.getCoordinates();
			if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) return e;
		}
		return null;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return PlanarGraph;
	}
});
PlanarGraph.linkResultDirectedEdges = function (nodes) {
	for (var nodeit = nodes.iterator(); nodeit.hasNext();) {
		var node = nodeit.next();
		node.getEdges().linkResultDirectedEdges();
	}
};

function GeometryGraph() {
	PlanarGraph.apply(this);
	this._parentGeom = null;
	this._lineEdgeMap = new HashMap();
	this._boundaryNodeRule = null;
	this._useBoundaryDeterminationRule = true;
	this._argIndex = null;
	this._boundaryNodes = null;
	this._hasTooFewPoints = false;
	this._invalidPoint = null;
	this._areaPtLocator = null;
	this._ptLocator = new PointLocator();
	if (arguments.length === 2) {
		var argIndex = arguments[0],
		    parentGeom = arguments[1];
		GeometryGraph.call(this, argIndex, parentGeom, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);
	} else if (arguments.length === 3) {
		var _argIndex = arguments[0],
		    _parentGeom = arguments[1],
		    boundaryNodeRule = arguments[2];
		this._argIndex = _argIndex;
		this._parentGeom = _parentGeom;
		this._boundaryNodeRule = boundaryNodeRule;
		if (_parentGeom !== null) {
			this.add(_parentGeom);
		}
	}
}
inherits(GeometryGraph, PlanarGraph);
extend(GeometryGraph.prototype, {
	insertBoundaryPoint: function insertBoundaryPoint(argIndex, coord) {
		var n = this._nodes.addNode(coord);
		var lbl = n.getLabel();
		var boundaryCount = 1;
		var loc = Location.NONE;
		loc = lbl.getLocation(argIndex, Position.ON);
		if (loc === Location.BOUNDARY) boundaryCount++;
		var newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);
		lbl.setLocation(argIndex, newLoc);
	},
	computeSelfNodes: function computeSelfNodes() {
		if (arguments.length === 2) {
			var li = arguments[0],
			    computeRingSelfNodes = arguments[1];
			return this.computeSelfNodes(li, computeRingSelfNodes, false);
		} else if (arguments.length === 3) {
			var _li = arguments[0],
			    _computeRingSelfNodes = arguments[1],
			    isDoneIfProperInt = arguments[2];
			var si = new SegmentIntersector(_li, true, false);
			si.setIsDoneIfProperInt(isDoneIfProperInt);
			var esi = this.createEdgeSetIntersector();
			var isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;
			var computeAllSegments = _computeRingSelfNodes || !isRings;
			esi.computeIntersections(this._edges, si, computeAllSegments);
			this.addSelfIntersectionNodes(this._argIndex);
			return si;
		}
	},
	computeSplitEdges: function computeSplitEdges(edgelist) {
		for (var i = this._edges.iterator(); i.hasNext();) {
			var e = i.next();
			e.eiList.addSplitEdges(edgelist);
		}
	},
	computeEdgeIntersections: function computeEdgeIntersections(g, li, includeProper) {
		var si = new SegmentIntersector(li, includeProper, true);
		si.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());
		var esi = this.createEdgeSetIntersector();
		esi.computeIntersections(this._edges, g._edges, si);
		return si;
	},
	getGeometry: function getGeometry() {
		return this._parentGeom;
	},
	getBoundaryNodeRule: function getBoundaryNodeRule() {
		return this._boundaryNodeRule;
	},
	hasTooFewPoints: function hasTooFewPoints() {
		return this._hasTooFewPoints;
	},
	addPoint: function addPoint() {
		if (arguments[0] instanceof Point) {
			var p = arguments[0];
			var coord = p.getCoordinate();
			this.insertPoint(this._argIndex, coord, Location.INTERIOR);
		} else if (arguments[0] instanceof Coordinate) {
			var pt = arguments[0];
			this.insertPoint(this._argIndex, pt, Location.INTERIOR);
		}
	},
	addPolygon: function addPolygon(p) {
		this.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);
		for (var i = 0; i < p.getNumInteriorRing(); i++) {
			var hole = p.getInteriorRingN(i);
			this.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);
		}
	},
	addEdge: function addEdge(e) {
		this.insertEdge(e);
		var coord = e.getCoordinates();
		this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);
		this.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);
	},
	addLineString: function addLineString(line) {
		var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());
		if (coord.length < 2) {
			this._hasTooFewPoints = true;
			this._invalidPoint = coord[0];
			return null;
		}
		var e = new Edge(coord, new Label(this._argIndex, Location.INTERIOR));
		this._lineEdgeMap.put(line, e);
		this.insertEdge(e);
		Assert.isTrue(coord.length >= 2, "found LineString with single point");
		this.insertBoundaryPoint(this._argIndex, coord[0]);
		this.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);
	},
	getInvalidPoint: function getInvalidPoint() {
		return this._invalidPoint;
	},
	getBoundaryPoints: function getBoundaryPoints() {
		var coll = this.getBoundaryNodes();
		var pts = new Array(coll.size()).fill(null);
		var i = 0;
		for (var it = coll.iterator(); it.hasNext();) {
			var node = it.next();
			pts[i++] = node.getCoordinate().copy();
		}
		return pts;
	},
	getBoundaryNodes: function getBoundaryNodes() {
		if (this._boundaryNodes === null) this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex);
		return this._boundaryNodes;
	},
	addSelfIntersectionNode: function addSelfIntersectionNode(argIndex, coord, loc) {
		if (this.isBoundaryNode(argIndex, coord)) return null;
		if (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) this.insertBoundaryPoint(argIndex, coord);else this.insertPoint(argIndex, coord, loc);
	},
	addPolygonRing: function addPolygonRing(lr, cwLeft, cwRight) {
		if (lr.isEmpty()) return null;
		var coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());
		if (coord.length < 4) {
			this._hasTooFewPoints = true;
			this._invalidPoint = coord[0];
			return null;
		}
		var left = cwLeft;
		var right = cwRight;
		if (Orientation.isCCW(coord)) {
			left = cwRight;
			right = cwLeft;
		}
		var e = new Edge(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));
		this._lineEdgeMap.put(lr, e);
		this.insertEdge(e);
		this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);
	},
	insertPoint: function insertPoint(argIndex, coord, onLocation) {
		var n = this._nodes.addNode(coord);
		var lbl = n.getLabel();
		if (lbl === null) {
			n._label = new Label(argIndex, onLocation);
		} else lbl.setLocation(argIndex, onLocation);
	},
	createEdgeSetIntersector: function createEdgeSetIntersector() {
		return new SimpleMCSweepLineIntersector();
	},
	addSelfIntersectionNodes: function addSelfIntersectionNodes(argIndex) {
		for (var i = this._edges.iterator(); i.hasNext();) {
			var e = i.next();
			var eLoc = e.getLabel().getLocation(argIndex);
			for (var eiIt = e.eiList.iterator(); eiIt.hasNext();) {
				var ei = eiIt.next();
				this.addSelfIntersectionNode(argIndex, ei.coord, eLoc);
			}
		}
	},
	add: function add() {
		if (arguments.length === 1 && arguments[0] instanceof Geometry) {
			var g = arguments[0];
			if (g.isEmpty()) return null;
			if (g instanceof MultiPolygon) this._useBoundaryDeterminationRule = false;
			if (g instanceof Polygon) this.addPolygon(g);else if (g instanceof LineString) this.addLineString(g);else if (g instanceof Point) this.addPoint(g);else if (g instanceof MultiPoint) this.addCollection(g);else if (g instanceof MultiLineString) this.addCollection(g);else if (g instanceof MultiPolygon) this.addCollection(g);else if (g instanceof GeometryCollection) this.addCollection(g);else throw new UnsupportedOperationException(g.getClass().getName());
		} else return PlanarGraph.prototype.add.apply(this, arguments);
	},
	addCollection: function addCollection(gc) {
		for (var i = 0; i < gc.getNumGeometries(); i++) {
			var g = gc.getGeometryN(i);
			this.add(g);
		}
	},
	locate: function locate(pt) {
		if (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {
			if (this._areaPtLocator === null) {
				this._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);
			}
			return this._areaPtLocator.locate(pt);
		}
		return this._ptLocator.locate(pt, this._parentGeom);
	},
	findEdge: function findEdge() {
		if (arguments.length === 1 && arguments[0] instanceof LineString) {
			var line = arguments[0];
			return this._lineEdgeMap.get(line);
		} else return PlanarGraph.prototype.findEdge.apply(this, arguments);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return GeometryGraph;
	}
});
GeometryGraph.determineBoundary = function (boundaryNodeRule, boundaryCount) {
	return boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR;
};



var geomgraph = Object.freeze({
	GeometryGraph: GeometryGraph
});

function KdNodeVisitor() {}
extend(KdNodeVisitor.prototype, {
	visit: function visit(node) {},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return KdNodeVisitor;
	}
});

function KdNode() {
	this._p = null;
	this._data = null;
	this._left = null;
	this._right = null;
	this._count = null;
	if (arguments.length === 2) {
		var p = arguments[0],
		    data = arguments[1];
		this._p = new Coordinate(p);
		this._left = null;
		this._right = null;
		this._count = 1;
		this._data = data;
	} else if (arguments.length === 3) {
		var _x = arguments[0],
		    _y = arguments[1],
		    _data = arguments[2];
		this._p = new Coordinate(_x, _y);
		this._left = null;
		this._right = null;
		this._count = 1;
		this._data = _data;
	}
}
extend(KdNode.prototype, {
	isRepeated: function isRepeated() {
		return this._count > 1;
	},
	getRight: function getRight() {
		return this._right;
	},
	getCoordinate: function getCoordinate() {
		return this._p;
	},
	setLeft: function setLeft(_left) {
		this._left = _left;
	},
	getX: function getX() {
		return this._p.x;
	},
	getData: function getData() {
		return this._data;
	},
	getCount: function getCount() {
		return this._count;
	},
	getLeft: function getLeft() {
		return this._left;
	},
	getY: function getY() {
		return this._p.y;
	},
	increment: function increment() {
		this._count = this._count + 1;
	},
	setRight: function setRight(_right) {
		this._right = _right;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return KdNode;
	}
});

function KdTree() {
	this._root = null;
	this._numberOfNodes = null;
	this._tolerance = null;
	if (arguments.length === 0) {
		KdTree.call(this, 0.0);
	} else if (arguments.length === 1) {
		var tolerance = arguments[0];
		this._tolerance = tolerance;
	}
}
extend(KdTree.prototype, {
	insert: function insert() {
		if (arguments.length === 1) {
			var p = arguments[0];
			return this.insert(p, null);
		} else if (arguments.length === 2) {
			var _p = arguments[0],
			    data = arguments[1];
			if (this._root === null) {
				this._root = new KdNode(_p, data);
				return this._root;
			}
			if (this._tolerance > 0) {
				var matchNode = this.findBestMatchNode(_p);
				if (matchNode !== null) {
					matchNode.increment();
					return matchNode;
				}
			}
			return this.insertExact(_p, data);
		}
	},
	query: function query() {
		if (arguments.length === 1) {
			var queryEnv = arguments[0];
			var result = new ArrayList();
			this.query(queryEnv, result);
			return result;
		} else if (arguments.length === 2) {
			if (arguments[0] instanceof Envelope && hasInterface(arguments[1], List)) {
				var _queryEnv = arguments[0],
				    _result = arguments[1];
				this.queryNode(this._root, _queryEnv, true, {
					interfaces_: function interfaces_() {
						return [KdNodeVisitor];
					},
					visit: function visit(node) {
						_result.add(node);
					}
				});
			} else if (arguments[0] instanceof Envelope && hasInterface(arguments[1], KdNodeVisitor)) {
				var _queryEnv2 = arguments[0],
				    visitor = arguments[1];
				this.queryNode(this._root, _queryEnv2, true, visitor);
			}
		}
	},
	queryNode: function queryNode(currentNode, queryEnv, odd, visitor) {
		if (currentNode === null) return null;
		var min = null;
		var max = null;
		var discriminant = null;
		if (odd) {
			min = queryEnv.getMinX();
			max = queryEnv.getMaxX();
			discriminant = currentNode.getX();
		} else {
			min = queryEnv.getMinY();
			max = queryEnv.getMaxY();
			discriminant = currentNode.getY();
		}
		var searchLeft = min < discriminant;
		var searchRight = discriminant <= max;
		if (searchLeft) {
			this.queryNode(currentNode.getLeft(), queryEnv, !odd, visitor);
		}
		if (queryEnv.contains(currentNode.getCoordinate())) {
			visitor.visit(currentNode);
		}
		if (searchRight) {
			this.queryNode(currentNode.getRight(), queryEnv, !odd, visitor);
		}
	},
	findBestMatchNode: function findBestMatchNode(p) {
		var visitor = new BestMatchVisitor(p, this._tolerance);
		this.query(visitor.queryEnvelope(), visitor);
		return visitor.getNode();
	},
	isEmpty: function isEmpty() {
		if (this._root === null) return true;
		return false;
	},
	insertExact: function insertExact(p, data) {
		var currentNode = this._root;
		var leafNode = this._root;
		var isOddLevel = true;
		var isLessThan = true;
		while (currentNode !== null) {
			if (currentNode !== null) {
				var isInTolerance = p.distance(currentNode.getCoordinate()) <= this._tolerance;
				if (isInTolerance) {
					currentNode.increment();
					return currentNode;
				}
			}
			if (isOddLevel) {
				isLessThan = p.x < currentNode.getX();
			} else {
				isLessThan = p.y < currentNode.getY();
			}
			leafNode = currentNode;
			if (isLessThan) {
				currentNode = currentNode.getLeft();
			} else {
				currentNode = currentNode.getRight();
			}
			isOddLevel = !isOddLevel;
		}
		this._numberOfNodes = this._numberOfNodes + 1;
		var node = new KdNode(p, data);
		if (isLessThan) {
			leafNode.setLeft(node);
		} else {
			leafNode.setRight(node);
		}
		return node;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return KdTree;
	}
});
KdTree.toCoordinates = function () {
	if (arguments.length === 1) {
		var kdnodes = arguments[0];
		return KdTree.toCoordinates(kdnodes, false);
	} else if (arguments.length === 2) {
		var _kdnodes = arguments[0],
		    includeRepeated = arguments[1];
		var coord = new CoordinateList();
		for (var it = _kdnodes.iterator(); it.hasNext();) {
			var node = it.next();
			var count = includeRepeated ? node.getCount() : 1;
			for (var i = 0; i < count; i++) {
				coord.add(node.getCoordinate(), true);
			}
		}
		return coord.toCoordinateArray();
	}
};
function BestMatchVisitor() {
	this._tolerance = null;
	this._matchNode = null;
	this._matchDist = 0.0;
	this._p = null;
	var p = arguments[0],
	    tolerance = arguments[1];
	this._p = p;
	this._tolerance = tolerance;
}
extend(BestMatchVisitor.prototype, {
	visit: function visit(node) {
		var dist = this._p.distance(node.getCoordinate());
		var isInTolerance = dist <= this._tolerance;
		if (!isInTolerance) return null;
		var update = false;
		if (this._matchNode === null || dist < this._matchDist || this._matchNode !== null && dist === this._matchDist && node.getCoordinate().compareTo(this._matchNode.getCoordinate()) < 1) update = true;
		if (update) {
			this._matchNode = node;
			this._matchDist = dist;
		}
	},
	queryEnvelope: function queryEnvelope() {
		var queryEnv = new Envelope(this._p);
		queryEnv.expandBy(this._tolerance);
		return queryEnv;
	},
	getNode: function getNode() {
		return this._matchNode;
	},
	interfaces_: function interfaces_() {
		return [KdNodeVisitor];
	},
	getClass: function getClass() {
		return BestMatchVisitor;
	}
});
KdTree.BestMatchVisitor = BestMatchVisitor;



var kdtree = Object.freeze({
	KdTree: KdTree
});

function NodeBase$1() {
	this._items = new ArrayList();
	this._subnode = new Array(4).fill(null);
}
extend(NodeBase$1.prototype, {
	hasChildren: function hasChildren() {
		for (var i = 0; i < 4; i++) {
			if (this._subnode[i] !== null) return true;
		}
		return false;
	},
	isPrunable: function isPrunable() {
		return !(this.hasChildren() || this.hasItems());
	},
	addAllItems: function addAllItems(resultItems) {
		resultItems.addAll(this._items);
		for (var i = 0; i < 4; i++) {
			if (this._subnode[i] !== null) {
				this._subnode[i].addAllItems(resultItems);
			}
		}
		return resultItems;
	},
	getNodeCount: function getNodeCount() {
		var subSize = 0;
		for (var i = 0; i < 4; i++) {
			if (this._subnode[i] !== null) {
				subSize += this._subnode[i].size();
			}
		}
		return subSize + 1;
	},
	size: function size() {
		var subSize = 0;
		for (var i = 0; i < 4; i++) {
			if (this._subnode[i] !== null) {
				subSize += this._subnode[i].size();
			}
		}
		return subSize + this._items.size();
	},
	addAllItemsFromOverlapping: function addAllItemsFromOverlapping(searchEnv, resultItems) {
		if (!this.isSearchMatch(searchEnv)) return null;
		resultItems.addAll(this._items);
		for (var i = 0; i < 4; i++) {
			if (this._subnode[i] !== null) {
				this._subnode[i].addAllItemsFromOverlapping(searchEnv, resultItems);
			}
		}
	},
	visitItems: function visitItems(searchEnv, visitor) {
		for (var i = this._items.iterator(); i.hasNext();) {
			visitor.visitItem(i.next());
		}
	},
	hasItems: function hasItems() {
		return !this._items.isEmpty();
	},
	remove: function remove(itemEnv, item) {
		if (!this.isSearchMatch(itemEnv)) return false;
		var found = false;
		for (var i = 0; i < 4; i++) {
			if (this._subnode[i] !== null) {
				found = this._subnode[i].remove(itemEnv, item);
				if (found) {
					if (this._subnode[i].isPrunable()) this._subnode[i] = null;
					break;
				}
			}
		}
		if (found) return found;
		found = this._items.remove(item);
		return found;
	},
	visit: function visit(searchEnv, visitor) {
		if (!this.isSearchMatch(searchEnv)) return null;
		this.visitItems(searchEnv, visitor);
		for (var i = 0; i < 4; i++) {
			if (this._subnode[i] !== null) {
				this._subnode[i].visit(searchEnv, visitor);
			}
		}
	},
	getItems: function getItems() {
		return this._items;
	},
	depth: function depth() {
		var maxSubDepth = 0;
		for (var i = 0; i < 4; i++) {
			if (this._subnode[i] !== null) {
				var sqd = this._subnode[i].depth();
				if (sqd > maxSubDepth) maxSubDepth = sqd;
			}
		}
		return maxSubDepth + 1;
	},
	isEmpty: function isEmpty() {
		var isEmpty = true;
		if (!this._items.isEmpty()) isEmpty = false;else {
			for (var i = 0; i < 4; i++) {
				if (this._subnode[i] !== null) {
					if (!this._subnode[i].isEmpty()) {
						isEmpty = false;
						break;
					}
				}
			}
		}
		return isEmpty;
	},
	add: function add(item) {
		this._items.add(item);
	},
	interfaces_: function interfaces_() {
		return [Serializable];
	},
	getClass: function getClass() {
		return NodeBase$1;
	}
});
NodeBase$1.getSubnodeIndex = function (env, centrex, centrey) {
	var subnodeIndex = -1;
	if (env.getMinX() >= centrex) {
		if (env.getMinY() >= centrey) subnodeIndex = 3;
		if (env.getMaxY() <= centrey) subnodeIndex = 1;
	}
	if (env.getMaxX() <= centrex) {
		if (env.getMinY() >= centrey) subnodeIndex = 2;
		if (env.getMaxY() <= centrey) subnodeIndex = 0;
	}
	return subnodeIndex;
};

function Key$1() {
	this._pt = new Coordinate();
	this._level = 0;
	this._env = null;
	var itemEnv = arguments[0];
	this.computeKey(itemEnv);
}
extend(Key$1.prototype, {
	getLevel: function getLevel() {
		return this._level;
	},
	computeKey: function computeKey() {
		if (arguments.length === 1) {
			var itemEnv = arguments[0];
			this._level = Key$1.computeQuadLevel(itemEnv);
			this._env = new Envelope();
			this.computeKey(this._level, itemEnv);
			while (!this._env.contains(itemEnv)) {
				this._level += 1;
				this.computeKey(this._level, itemEnv);
			}
		} else if (arguments.length === 2) {
			var level = arguments[0],
			    _itemEnv = arguments[1];
			var quadSize = DoubleBits.powerOf2(level);
			this._pt.x = Math.floor(_itemEnv.getMinX() / quadSize) * quadSize;
			this._pt.y = Math.floor(_itemEnv.getMinY() / quadSize) * quadSize;
			this._env.init(this._pt.x, this._pt.x + quadSize, this._pt.y, this._pt.y + quadSize);
		}
	},
	getEnvelope: function getEnvelope() {
		return this._env;
	},
	getCentre: function getCentre() {
		return new Coordinate((this._env.getMinX() + this._env.getMaxX()) / 2, (this._env.getMinY() + this._env.getMaxY()) / 2);
	},
	getPoint: function getPoint() {
		return this._pt;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Key$1;
	}
});
Key$1.computeQuadLevel = function (env) {
	var dx = env.getWidth();
	var dy = env.getHeight();
	var dMax = dx > dy ? dx : dy;
	var level = DoubleBits.exponent(dMax) + 1;
	return level;
};

function Node$2() {
	NodeBase$1.apply(this);
	this._env = null;
	this._centrex = null;
	this._centrey = null;
	this._level = null;
	var env = arguments[0],
	    level = arguments[1];
	this._env = env;
	this._level = level;
	this._centrex = (env.getMinX() + env.getMaxX()) / 2;
	this._centrey = (env.getMinY() + env.getMaxY()) / 2;
}
inherits(Node$2, NodeBase$1);
extend(Node$2.prototype, {
	find: function find(searchEnv) {
		var subnodeIndex = NodeBase$1.getSubnodeIndex(searchEnv, this._centrex, this._centrey);
		if (subnodeIndex === -1) return this;
		if (this._subnode[subnodeIndex] !== null) {
			var node = this._subnode[subnodeIndex];
			return node.find(searchEnv);
		}
		return this;
	},
	isSearchMatch: function isSearchMatch(searchEnv) {
		if (searchEnv === null) return false;
		return this._env.intersects(searchEnv);
	},
	getSubnode: function getSubnode(index) {
		if (this._subnode[index] === null) {
			this._subnode[index] = this.createSubnode(index);
		}
		return this._subnode[index];
	},
	getEnvelope: function getEnvelope() {
		return this._env;
	},
	getNode: function getNode(searchEnv) {
		var subnodeIndex = NodeBase$1.getSubnodeIndex(searchEnv, this._centrex, this._centrey);
		if (subnodeIndex !== -1) {
			var node = this.getSubnode(subnodeIndex);
			return node.getNode(searchEnv);
		} else {
			return this;
		}
	},
	createSubnode: function createSubnode(index) {
		var minx = 0.0;
		var maxx = 0.0;
		var miny = 0.0;
		var maxy = 0.0;
		switch (index) {
			case 0:
				minx = this._env.getMinX();
				maxx = this._centrex;
				miny = this._env.getMinY();
				maxy = this._centrey;
				break;
			case 1:
				minx = this._centrex;
				maxx = this._env.getMaxX();
				miny = this._env.getMinY();
				maxy = this._centrey;
				break;
			case 2:
				minx = this._env.getMinX();
				maxx = this._centrex;
				miny = this._centrey;
				maxy = this._env.getMaxY();
				break;
			case 3:
				minx = this._centrex;
				maxx = this._env.getMaxX();
				miny = this._centrey;
				maxy = this._env.getMaxY();
				break;
		}
		var sqEnv = new Envelope(minx, maxx, miny, maxy);
		var node = new Node$2(sqEnv, this._level - 1);
		return node;
	},
	insertNode: function insertNode(node) {
		Assert.isTrue(this._env === null || this._env.contains(node._env));
		var index = NodeBase$1.getSubnodeIndex(node._env, this._centrex, this._centrey);
		if (node._level === this._level - 1) {
			this._subnode[index] = node;
		} else {
			var childNode = this.createSubnode(index);
			childNode.insertNode(node);
			this._subnode[index] = childNode;
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Node$2;
	}
});
Node$2.createNode = function (env) {
	var key = new Key$1(env);
	var node = new Node$2(key.getEnvelope(), key.getLevel());
	return node;
};
Node$2.createExpanded = function (node, addEnv) {
	var expandEnv = new Envelope(addEnv);
	if (node !== null) expandEnv.expandToInclude(node._env);
	var largerNode = Node$2.createNode(expandEnv);
	if (node !== null) largerNode.insertNode(node);
	return largerNode;
};

function Root$1() {
	NodeBase$1.apply(this);
}
inherits(Root$1, NodeBase$1);
extend(Root$1.prototype, {
	insert: function insert(itemEnv, item) {
		var index = NodeBase$1.getSubnodeIndex(itemEnv, Root$1.origin.x, Root$1.origin.y);
		if (index === -1) {
			this.add(item);
			return null;
		}
		var node = this._subnode[index];
		if (node === null || !node.getEnvelope().contains(itemEnv)) {
			var largerNode = Node$2.createExpanded(node, itemEnv);
			this._subnode[index] = largerNode;
		}
		this.insertContained(this._subnode[index], itemEnv, item);
	},
	isSearchMatch: function isSearchMatch(searchEnv) {
		return true;
	},
	insertContained: function insertContained(tree, itemEnv, item) {
		Assert.isTrue(tree.getEnvelope().contains(itemEnv));
		var isZeroX = IntervalSize.isZeroWidth(itemEnv.getMinX(), itemEnv.getMaxX());
		var isZeroY = IntervalSize.isZeroWidth(itemEnv.getMinY(), itemEnv.getMaxY());
		var node = null;
		if (isZeroX || isZeroY) node = tree.find(itemEnv);else node = tree.getNode(itemEnv);
		node.add(item);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Root$1;
	}
});
Root$1.origin = new Coordinate(0.0, 0.0);

function SpatialIndex() {}
extend(SpatialIndex.prototype, {
	insert: function insert(itemEnv, item) {},
	remove: function remove(itemEnv, item) {},
	query: function query() {
		
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return SpatialIndex;
	}
});

function Quadtree() {
	this._root = null;
	this._minExtent = 1.0;
	this._root = new Root$1();
}
extend(Quadtree.prototype, {
	size: function size() {
		if (this._root !== null) return this._root.size();
		return 0;
	},
	insert: function insert(itemEnv, item) {
		this.collectStats(itemEnv);
		var insertEnv = Quadtree.ensureExtent(itemEnv, this._minExtent);
		this._root.insert(insertEnv, item);
	},
	query: function query() {
		if (arguments.length === 1) {
			var searchEnv = arguments[0];
			var visitor = new ArrayListVisitor();
			this.query(searchEnv, visitor);
			return visitor.getItems();
		} else if (arguments.length === 2) {
			var _searchEnv = arguments[0],
			    _visitor = arguments[1];
			this._root.visit(_searchEnv, _visitor);
		}
	},
	queryAll: function queryAll() {
		var foundItems = new ArrayList();
		this._root.addAllItems(foundItems);
		return foundItems;
	},
	remove: function remove(itemEnv, item) {
		var posEnv = Quadtree.ensureExtent(itemEnv, this._minExtent);
		return this._root.remove(posEnv, item);
	},
	collectStats: function collectStats(itemEnv) {
		var delX = itemEnv.getWidth();
		if (delX < this._minExtent && delX > 0.0) this._minExtent = delX;
		var delY = itemEnv.getHeight();
		if (delY < this._minExtent && delY > 0.0) this._minExtent = delY;
	},
	depth: function depth() {
		if (this._root !== null) return this._root.depth();
		return 0;
	},
	isEmpty: function isEmpty() {
		if (this._root === null) return true;
		return this._root.isEmpty();
	},
	interfaces_: function interfaces_() {
		return [SpatialIndex, Serializable];
	},
	getClass: function getClass() {
		return Quadtree;
	}
});
Quadtree.ensureExtent = function (itemEnv, minExtent) {
	var minx = itemEnv.getMinX();
	var maxx = itemEnv.getMaxX();
	var miny = itemEnv.getMinY();
	var maxy = itemEnv.getMaxY();
	if (minx !== maxx && miny !== maxy) return itemEnv;
	if (minx === maxx) {
		minx = minx - minExtent / 2.0;
		maxx = minx + minExtent / 2.0;
	}
	if (miny === maxy) {
		miny = miny - minExtent / 2.0;
		maxy = miny + minExtent / 2.0;
	}
	return new Envelope(minx, maxx, miny, maxy);
};
Quadtree.serialVersionUID = -7461163625812743604;



var quadtree = Object.freeze({
	Quadtree: Quadtree
});

function Boundable() {}
extend(Boundable.prototype, {
	getBounds: function getBounds() {},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Boundable;
	}
});

function ItemBoundable() {
	this._bounds = null;
	this._item = null;
	var bounds = arguments[0],
	    item = arguments[1];
	this._bounds = bounds;
	this._item = item;
}
extend(ItemBoundable.prototype, {
	getItem: function getItem() {
		return this._item;
	},
	getBounds: function getBounds() {
		return this._bounds;
	},
	interfaces_: function interfaces_() {
		return [Boundable, Serializable];
	},
	getClass: function getClass() {
		return ItemBoundable;
	}
});

function PriorityQueue() {
	this._size = null;
	this._items = null;
	this._size = 0;
	this._items = new ArrayList();
	this._items.add(null);
}
extend(PriorityQueue.prototype, {
	poll: function poll() {
		if (this.isEmpty()) return null;
		var minItem = this._items.get(1);
		this._items.set(1, this._items.get(this._size));
		this._size -= 1;
		this.reorder(1);
		return minItem;
	},
	size: function size() {
		return this._size;
	},
	reorder: function reorder(hole) {
		var child = null;
		var tmp = this._items.get(hole);
		for (; hole * 2 <= this._size; hole = child) {
			child = hole * 2;
			if (child !== this._size && this._items.get(child + 1).compareTo(this._items.get(child)) < 0) child++;
			if (this._items.get(child).compareTo(tmp) < 0) this._items.set(hole, this._items.get(child));else break;
		}
		this._items.set(hole, tmp);
	},
	clear: function clear() {
		this._size = 0;
		this._items.clear();
	},
	isEmpty: function isEmpty() {
		return this._size === 0;
	},
	add: function add(x) {
		this._items.add(null);
		this._size += 1;
		var hole = this._size;
		this._items.set(0, x);
		for (; x.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) {
			this._items.set(hole, this._items.get(Math.trunc(hole / 2)));
		}
		this._items.set(hole, x);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return PriorityQueue;
	}
});

function BoundablePairDistanceComparator() {
	this.normalOrder = null;
	var normalOrder = arguments[0];
	this.normalOrder = normalOrder;
}
extend(BoundablePairDistanceComparator.prototype, {
	compare: function compare(p1, p2) {
		var distance1 = p1.getDistance();
		var distance2 = p2.getDistance();
		if (this.normalOrder) {
			if (distance1 > distance2) {
				return 1;
			} else if (distance1 === distance2) {
				return 0;
			}
			return -1;
		} else {
			if (distance1 > distance2) {
				return -1;
			} else if (distance1 === distance2) {
				return 0;
			}
			return 1;
		}
	},
	interfaces_: function interfaces_() {
		return [Comparator, Serializable];
	},
	getClass: function getClass() {
		return BoundablePairDistanceComparator;
	}
});

function AbstractNode() {
	this._childBoundables = new ArrayList();
	this._bounds = null;
	this._level = null;
	if (arguments.length === 0) {} else if (arguments.length === 1) {
		var level = arguments[0];
		this._level = level;
	}
}
extend(AbstractNode.prototype, {
	getLevel: function getLevel() {
		return this._level;
	},
	size: function size() {
		return this._childBoundables.size();
	},
	getChildBoundables: function getChildBoundables() {
		return this._childBoundables;
	},
	addChildBoundable: function addChildBoundable(childBoundable) {
		Assert.isTrue(this._bounds === null);
		this._childBoundables.add(childBoundable);
	},
	isEmpty: function isEmpty() {
		return this._childBoundables.isEmpty();
	},
	getBounds: function getBounds() {
		if (this._bounds === null) {
			this._bounds = this.computeBounds();
		}
		return this._bounds;
	},
	interfaces_: function interfaces_() {
		return [Boundable, Serializable];
	},
	getClass: function getClass() {
		return AbstractNode;
	}
});
AbstractNode.serialVersionUID = 6493722185909573708;

function BoundablePair() {
	this._boundable1 = null;
	this._boundable2 = null;
	this._distance = null;
	this._itemDistance = null;
	var boundable1 = arguments[0],
	    boundable2 = arguments[1],
	    itemDistance = arguments[2];
	this._boundable1 = boundable1;
	this._boundable2 = boundable2;
	this._itemDistance = itemDistance;
	this._distance = this.distance();
}
extend(BoundablePair.prototype, {
	expandToQueue: function expandToQueue(priQ, minDistance) {
		var isComp1 = BoundablePair.isComposite(this._boundable1);
		var isComp2 = BoundablePair.isComposite(this._boundable2);
		if (isComp1 && isComp2) {
			if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {
				this.expand(this._boundable1, this._boundable2, priQ, minDistance);
				return null;
			} else {
				this.expand(this._boundable2, this._boundable1, priQ, minDistance);
				return null;
			}
		} else if (isComp1) {
			this.expand(this._boundable1, this._boundable2, priQ, minDistance);
			return null;
		} else if (isComp2) {
			this.expand(this._boundable2, this._boundable1, priQ, minDistance);
			return null;
		}
		throw new IllegalArgumentException("neither boundable is composite");
	},
	isLeaves: function isLeaves() {
		return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2));
	},
	compareTo: function compareTo(o) {
		var nd = o;
		if (this._distance < nd._distance) return -1;
		if (this._distance > nd._distance) return 1;
		return 0;
	},
	expand: function expand(bndComposite, bndOther, priQ, minDistance) {
		var children = bndComposite.getChildBoundables();
		for (var i = children.iterator(); i.hasNext();) {
			var child = i.next();
			var bp = new BoundablePair(child, bndOther, this._itemDistance);
			if (bp.getDistance() < minDistance) {
				priQ.add(bp);
			}
		}
	},
	getBoundable: function getBoundable(i) {
		if (i === 0) return this._boundable1;
		return this._boundable2;
	},
	getDistance: function getDistance() {
		return this._distance;
	},
	distance: function distance() {
		if (this.isLeaves()) {
			return this._itemDistance.distance(this._boundable1, this._boundable2);
		}
		return this._boundable1.getBounds().distance(this._boundable2.getBounds());
	},
	interfaces_: function interfaces_() {
		return [Comparable];
	},
	getClass: function getClass() {
		return BoundablePair;
	}
});
BoundablePair.area = function (b) {
	return b.getBounds().getArea();
};
BoundablePair.isComposite = function (item) {
	return item instanceof AbstractNode;
};

function AbstractSTRtree() {
	this._root = null;
	this._built = false;
	this._itemBoundables = new ArrayList();
	this._nodeCapacity = null;
	if (arguments.length === 0) {
		AbstractSTRtree.call(this, AbstractSTRtree.DEFAULT_NODE_CAPACITY);
	} else if (arguments.length === 1) {
		var nodeCapacity = arguments[0];
		Assert.isTrue(nodeCapacity > 1, "Node capacity must be greater than 1");
		this._nodeCapacity = nodeCapacity;
	}
}
extend(AbstractSTRtree.prototype, {
	queryInternal: function queryInternal() {
		if (hasInterface(arguments[2], ItemVisitor) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {
			var searchBounds = arguments[0],
			    node = arguments[1],
			    visitor = arguments[2];
			var childBoundables = node.getChildBoundables();
			for (var i = 0; i < childBoundables.size(); i++) {
				var childBoundable = childBoundables.get(i);
				if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) {
					continue;
				}
				if (childBoundable instanceof AbstractNode) {
					this.queryInternal(searchBounds, childBoundable, visitor);
				} else if (childBoundable instanceof ItemBoundable) {
					visitor.visitItem(childBoundable.getItem());
				} else {
					Assert.shouldNeverReachHere();
				}
			}
		} else if (hasInterface(arguments[2], List) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {
			var _searchBounds = arguments[0],
			    _node = arguments[1],
			    matches = arguments[2];
			var childBoundables = _node.getChildBoundables();
			for (var i = 0; i < childBoundables.size(); i++) {
				var childBoundable = childBoundables.get(i);
				if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), _searchBounds)) {
					continue;
				}
				if (childBoundable instanceof AbstractNode) {
					this.queryInternal(_searchBounds, childBoundable, matches);
				} else if (childBoundable instanceof ItemBoundable) {
					matches.add(childBoundable.getItem());
				} else {
					Assert.shouldNeverReachHere();
				}
			}
		}
	},
	getNodeCapacity: function getNodeCapacity() {
		return this._nodeCapacity;
	},
	lastNode: function lastNode(nodes) {
		return nodes.get(nodes.size() - 1);
	},
	size: function size() {
		if (arguments.length === 0) {
			if (this.isEmpty()) {
				return 0;
			}
			this.build();
			return this.size(this._root);
		} else if (arguments.length === 1) {
			var node = arguments[0];
			var size = 0;
			for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
				var childBoundable = i.next();
				if (childBoundable instanceof AbstractNode) {
					size += this.size(childBoundable);
				} else if (childBoundable instanceof ItemBoundable) {
					size += 1;
				}
			}
			return size;
		}
	},
	removeItem: function removeItem(node, item) {
		var childToRemove = null;
		for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
			var childBoundable = i.next();
			if (childBoundable instanceof ItemBoundable) {
				if (childBoundable.getItem() === item) childToRemove = childBoundable;
			}
		}
		if (childToRemove !== null) {
			node.getChildBoundables().remove(childToRemove);
			return true;
		}
		return false;
	},
	itemsTree: function itemsTree() {
		if (arguments.length === 0) {
			this.build();
			var valuesTree = this.itemsTree(this._root);
			if (valuesTree === null) return new ArrayList();
			return valuesTree;
		} else if (arguments.length === 1) {
			var node = arguments[0];
			var valuesTreeForNode = new ArrayList();
			for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
				var childBoundable = i.next();
				if (childBoundable instanceof AbstractNode) {
					var valuesTreeForChild = this.itemsTree(childBoundable);
					if (valuesTreeForChild !== null) valuesTreeForNode.add(valuesTreeForChild);
				} else if (childBoundable instanceof ItemBoundable) {
					valuesTreeForNode.add(childBoundable.getItem());
				} else {
					Assert.shouldNeverReachHere();
				}
			}
			if (valuesTreeForNode.size() <= 0) return null;
			return valuesTreeForNode;
		}
	},
	insert: function insert(bounds, item) {
		Assert.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built.");
		this._itemBoundables.add(new ItemBoundable(bounds, item));
	},
	boundablesAtLevel: function boundablesAtLevel() {
		if (arguments.length === 1) {
			var level = arguments[0];
			var boundables = new ArrayList();
			this.boundablesAtLevel(level, this._root, boundables);
			return boundables;
		} else if (arguments.length === 3) {
			var _level = arguments[0],
			    top = arguments[1],
			    _boundables = arguments[2];
			Assert.isTrue(_level > -2);
			if (top.getLevel() === _level) {
				_boundables.add(top);
				return null;
			}
			for (var i = top.getChildBoundables().iterator(); i.hasNext();) {
				var boundable = i.next();
				if (boundable instanceof AbstractNode) {
					this.boundablesAtLevel(_level, boundable, _boundables);
				} else {
					Assert.isTrue(boundable instanceof ItemBoundable);
					if (_level === -1) {
						_boundables.add(boundable);
					}
				}
			}
			return null;
		}
	},
	query: function query() {
		if (arguments.length === 1) {
			var searchBounds = arguments[0];
			this.build();
			var matches = new ArrayList();
			if (this.isEmpty()) {
				return matches;
			}
			if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
				this.queryInternal(searchBounds, this._root, matches);
			}
			return matches;
		} else if (arguments.length === 2) {
			var _searchBounds2 = arguments[0],
			    visitor = arguments[1];
			this.build();
			if (this.isEmpty()) {
				return null;
			}
			if (this.getIntersectsOp().intersects(this._root.getBounds(), _searchBounds2)) {
				this.queryInternal(_searchBounds2, this._root, visitor);
			}
		}
	},
	build: function build() {
		if (this._built) return null;
		this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);
		this._itemBoundables = null;
		this._built = true;
	},
	getRoot: function getRoot() {
		this.build();
		return this._root;
	},
	remove: function remove() {
		if (arguments.length === 2) {
			var searchBounds = arguments[0],
			    item = arguments[1];
			this.build();
			if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {
				return this.remove(searchBounds, this._root, item);
			}
			return false;
		} else if (arguments.length === 3) {
			var _searchBounds3 = arguments[0],
			    node = arguments[1],
			    _item = arguments[2];
			var found = this.removeItem(node, _item);
			if (found) return true;
			var childToPrune = null;
			for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
				var childBoundable = i.next();
				if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), _searchBounds3)) {
					continue;
				}
				if (childBoundable instanceof AbstractNode) {
					found = this.remove(_searchBounds3, childBoundable, _item);
					if (found) {
						childToPrune = childBoundable;
						break;
					}
				}
			}
			if (childToPrune !== null) {
				if (childToPrune.getChildBoundables().isEmpty()) {
					node.getChildBoundables().remove(childToPrune);
				}
			}
			return found;
		}
	},
	createHigherLevels: function createHigherLevels(boundablesOfALevel, level) {
		Assert.isTrue(!boundablesOfALevel.isEmpty());
		var parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);
		if (parentBoundables.size() === 1) {
			return parentBoundables.get(0);
		}
		return this.createHigherLevels(parentBoundables, level + 1);
	},
	depth: function depth() {
		if (arguments.length === 0) {
			if (this.isEmpty()) {
				return 0;
			}
			this.build();
			return this.depth(this._root);
		} else if (arguments.length === 1) {
			var node = arguments[0];
			var maxChildDepth = 0;
			for (var i = node.getChildBoundables().iterator(); i.hasNext();) {
				var childBoundable = i.next();
				if (childBoundable instanceof AbstractNode) {
					var childDepth = this.depth(childBoundable);
					if (childDepth > maxChildDepth) maxChildDepth = childDepth;
				}
			}
			return maxChildDepth + 1;
		}
	},
	createParentBoundables: function createParentBoundables(childBoundables, newLevel) {
		Assert.isTrue(!childBoundables.isEmpty());
		var parentBoundables = new ArrayList();
		parentBoundables.add(this.createNode(newLevel));
		var sortedChildBoundables = new ArrayList(childBoundables);
		Collections.sort(sortedChildBoundables, this.getComparator());
		for (var i = sortedChildBoundables.iterator(); i.hasNext();) {
			var childBoundable = i.next();
			if (this.lastNode(parentBoundables).getChildBoundables().size() === this.getNodeCapacity()) {
				parentBoundables.add(this.createNode(newLevel));
			}
			this.lastNode(parentBoundables).addChildBoundable(childBoundable);
		}
		return parentBoundables;
	},
	isEmpty: function isEmpty() {
		if (!this._built) return this._itemBoundables.isEmpty();
		return this._root.isEmpty();
	},
	interfaces_: function interfaces_() {
		return [Serializable];
	},
	getClass: function getClass() {
		return AbstractSTRtree;
	}
});
AbstractSTRtree.compareDoubles = function (a, b) {
	return a > b ? 1 : a < b ? -1 : 0;
};
function IntersectsOp$1() {}
AbstractSTRtree.IntersectsOp = IntersectsOp$1;
AbstractSTRtree.serialVersionUID = -3886435814360241337;
AbstractSTRtree.DEFAULT_NODE_CAPACITY = 10;

function ItemDistance() {}
extend(ItemDistance.prototype, {
	distance: function distance(item1, item2) {},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return ItemDistance;
	}
});

function STRtree() {
	if (arguments.length === 0) {
		STRtree.call(this, STRtree.DEFAULT_NODE_CAPACITY);
	} else if (arguments.length === 1) {
		var nodeCapacity = arguments[0];
		AbstractSTRtree.call(this, nodeCapacity);
	}
}
inherits(STRtree, AbstractSTRtree);
extend(STRtree.prototype, {
	createParentBoundablesFromVerticalSlices: function createParentBoundablesFromVerticalSlices(verticalSlices, newLevel) {
		Assert.isTrue(verticalSlices.length > 0);
		var parentBoundables = new ArrayList();
		for (var i = 0; i < verticalSlices.length; i++) {
			parentBoundables.addAll(this.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));
		}
		return parentBoundables;
	},
	createNode: function createNode(level) {
		return new STRtreeNode(level);
	},
	size: function size() {
		if (arguments.length === 0) {
			return AbstractSTRtree.prototype.size.call(this);
		} else return AbstractSTRtree.prototype.size.apply(this, arguments);
	},
	insert: function insert() {
		if (arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof Envelope) {
			var itemEnv = arguments[0],
			    item = arguments[1];
			if (itemEnv.isNull()) {
				return null;
			}
			AbstractSTRtree.prototype.insert.call(this, itemEnv, item);
		} else return AbstractSTRtree.prototype.insert.apply(this, arguments);
	},
	getIntersectsOp: function getIntersectsOp() {
		return STRtree.intersectsOp;
	},
	verticalSlices: function verticalSlices(childBoundables, sliceCount) {
		var sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));
		var slices = new Array(sliceCount).fill(null);
		var i = childBoundables.iterator();
		for (var j = 0; j < sliceCount; j++) {
			slices[j] = new ArrayList();
			var boundablesAddedToSlice = 0;
			while (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {
				var childBoundable = i.next();
				slices[j].add(childBoundable);
				boundablesAddedToSlice++;
			}
		}
		return slices;
	},
	query: function query() {
		if (arguments.length === 1) {
			var searchEnv = arguments[0];
			return AbstractSTRtree.prototype.query.call(this, searchEnv);
		} else if (arguments.length === 2) {
			var _searchEnv = arguments[0],
			    visitor = arguments[1];
			AbstractSTRtree.prototype.query.call(this, _searchEnv, visitor);
		}
	},
	getComparator: function getComparator() {
		return STRtree.yComparator;
	},
	createParentBoundablesFromVerticalSlice: function createParentBoundablesFromVerticalSlice(childBoundables, newLevel) {
		return AbstractSTRtree.prototype.createParentBoundables.call(this, childBoundables, newLevel);
	},
	remove: function remove() {
		if (arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof Envelope) {
			var itemEnv = arguments[0],
			    item = arguments[1];
			return AbstractSTRtree.prototype.remove.call(this, itemEnv, item);
		} else return AbstractSTRtree.prototype.remove.apply(this, arguments);
	},
	depth: function depth() {
		if (arguments.length === 0) {
			return AbstractSTRtree.prototype.depth.call(this);
		} else return AbstractSTRtree.prototype.depth.apply(this, arguments);
	},
	createParentBoundables: function createParentBoundables(childBoundables, newLevel) {
		Assert.isTrue(!childBoundables.isEmpty());
		var minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));
		var sortedChildBoundables = new ArrayList(childBoundables);
		Collections.sort(sortedChildBoundables, STRtree.xComparator);
		var verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));
		return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel);
	},
	nearestNeighbour: function nearestNeighbour() {
		if (arguments.length === 1) {
			if (hasInterface(arguments[0], ItemDistance)) {
				var itemDist = arguments[0];
				var bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);
				return this.nearestNeighbour(bp);
			} else if (arguments[0] instanceof BoundablePair) {
				var initBndPair = arguments[0];
				return this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY);
			}
		} else if (arguments.length === 2) {
			if (arguments[0] instanceof STRtree && hasInterface(arguments[1], ItemDistance)) {
				var tree = arguments[0],
				    _itemDist = arguments[1];
				var bp = new BoundablePair(this.getRoot(), tree.getRoot(), _itemDist);
				return this.nearestNeighbour(bp);
			} else if (arguments[0] instanceof BoundablePair && typeof arguments[1] === "number") {
				var _initBndPair = arguments[0],
				    maxDistance = arguments[1];
				var distanceLowerBound = maxDistance;
				var minPair = null;
				var priQ = new PriorityQueue();
				priQ.add(_initBndPair);
				while (!priQ.isEmpty() && distanceLowerBound > 0.0) {
					var bndPair = priQ.poll();
					var currentDistance = bndPair.getDistance();
					if (currentDistance >= distanceLowerBound) break;
					if (bndPair.isLeaves()) {
						distanceLowerBound = currentDistance;
						minPair = bndPair;
					} else {
						bndPair.expandToQueue(priQ, distanceLowerBound);
					}
				}
				return [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()];
			} else if (arguments[0] instanceof BoundablePair && Number.isInteger(arguments[1])) {
				var _initBndPair2 = arguments[0],
				    k = arguments[1];
				return this.nearestNeighbour(_initBndPair2, Double.POSITIVE_INFINITY, k);
			}
		} else if (arguments.length === 3) {
			if (hasInterface(arguments[2], ItemDistance) && arguments[0] instanceof Envelope && arguments[1] instanceof Object) {
				var env = arguments[0],
				    item = arguments[1],
				    _itemDist2 = arguments[2];
				var bnd = new ItemBoundable(env, item);
				var bp = new BoundablePair(this.getRoot(), bnd, _itemDist2);
				return this.nearestNeighbour(bp)[0];
			} else if (Number.isInteger(arguments[2]) && arguments[0] instanceof BoundablePair && typeof arguments[1] === "number") {
				var _initBndPair3 = arguments[0],
				    _maxDistance = arguments[1],
				    _k = arguments[2];
				var distanceLowerBound = _maxDistance;
				var priQ = new PriorityQueue();
				priQ.add(_initBndPair3);
				var kNearestNeighbors = new java.util.PriorityQueue() < BoundablePair > (new BoundablePairDistanceComparator(false));
				while (!priQ.isEmpty() && distanceLowerBound >= 0.0) {
					var bndPair = priQ.poll();
					var currentDistance = bndPair.getDistance();
					if (currentDistance >= distanceLowerBound) {
						break;
					}
					if (bndPair.isLeaves()) {
						if (kNearestNeighbors.size() < _k) {
							kNearestNeighbors.add(bndPair);
						} else {
							if (kNearestNeighbors.peek().getDistance() > currentDistance) {
								kNearestNeighbors.poll();
								kNearestNeighbors.add(bndPair);
							}
							distanceLowerBound = kNearestNeighbors.peek().getDistance();
						}
					} else {
						bndPair.expandToQueue(priQ, distanceLowerBound);
					}
				}
				return STRtree.getItems(kNearestNeighbors);
			}
		} else if (arguments.length === 4) {
			var _env = arguments[0],
			    _item = arguments[1],
			    _itemDist3 = arguments[2],
			    _k2 = arguments[3];
			var bnd = new ItemBoundable(_env, _item);
			var bp = new BoundablePair(this.getRoot(), bnd, _itemDist3);
			return this.nearestNeighbour(bp, _k2);
		}
	},
	interfaces_: function interfaces_() {
		return [SpatialIndex, Serializable];
	},
	getClass: function getClass() {
		return STRtree;
	}
});
STRtree.centreX = function (e) {
	return STRtree.avg(e.getMinX(), e.getMaxX());
};
STRtree.avg = function (a, b) {
	return (a + b) / 2;
};
STRtree.getItems = function (kNearestNeighbors) {
	var items = new Array(kNearestNeighbors.size()).fill(null);
	var resultIterator = kNearestNeighbors.iterator();
	var count = 0;
	while (resultIterator.hasNext()) {
		items[count] = resultIterator.next().getBoundable(0).getItem();
		count++;
	}
	return items;
};
STRtree.centreY = function (e) {
	return STRtree.avg(e.getMinY(), e.getMaxY());
};
function STRtreeNode() {
	var level = arguments[0];
	AbstractNode.call(this, level);
}
inherits(STRtreeNode, AbstractNode);
extend(STRtreeNode.prototype, {
	computeBounds: function computeBounds() {
		var bounds = null;
		for (var i = this.getChildBoundables().iterator(); i.hasNext();) {
			var childBoundable = i.next();
			if (bounds === null) {
				bounds = new Envelope(childBoundable.getBounds());
			} else {
				bounds.expandToInclude(childBoundable.getBounds());
			}
		}
		return bounds;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return STRtreeNode;
	}
});
STRtree.STRtreeNode = STRtreeNode;
STRtree.serialVersionUID = 259274702368956900;
STRtree.xComparator = {
	interfaces_: function interfaces_() {
		return [Comparator];
	},
	compare: function compare(o1, o2) {
		return AbstractSTRtree.compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()));
	}
};
STRtree.yComparator = {
	interfaces_: function interfaces_() {
		return [Comparator];
	},
	compare: function compare(o1, o2) {
		return AbstractSTRtree.compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()));
	}
};
STRtree.intersectsOp = {
	interfaces_: function interfaces_() {
		return [IntersectsOp];
	},
	intersects: function intersects(aBounds, bBounds) {
		return aBounds.intersects(bBounds);
	}
};
STRtree.DEFAULT_NODE_CAPACITY = 10;



var strtree = Object.freeze({
	STRtree: STRtree
});



var index = Object.freeze({
	kdtree: kdtree,
	quadtree: quadtree,
	strtree: strtree
});

var geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];

/**
 * Class for reading and writing Well-Known Text.Create a new parser for GeoJSON
 * NOTE: Adapted from OpenLayers 2.11 implementation.
 */

/**
 * Create a new parser for GeoJSON
 *
 * @param {GeometryFactory} geometryFactory
 * @return An instance of GeoJsonParser.
 * @constructor
 * @private
 */
function GeoJSONParser(geometryFactory) {
  this.geometryFactory = geometryFactory || new GeometryFactory();
}

extend(GeoJSONParser.prototype, {
  /**
   * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries
   *
   * @param {}
   *          A GeoJSON object.
   * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.
   * @private
   */
  read: function read(json) {
    var obj = void 0;
    if (typeof json === 'string') obj = JSON.parse(json);else obj = json;

    var type = obj.type;

    if (!parse$1[type]) throw new Error('Unknown GeoJSON type: ' + obj.type);

    if (geometryTypes.indexOf(type) !== -1) return parse$1[type].call(this, obj.coordinates);else if (type === 'GeometryCollection') return parse$1[type].call(this, obj.geometries);

    // feature or feature collection
    return parse$1[type].call(this, obj);
  },


  /**
   * Serialize a Geometry object into GeoJSON
   *
   * @param {Geometry}
   *          geometry A Geometry or array of Geometries.
   * @return {Object} A GeoJSON object represting the input Geometry/Geometries.
   * @private
   */
  write: function write(geometry) {
    var type = geometry.getGeometryType();

    if (!extract$1[type]) throw new Error('Geometry is not supported');

    return extract$1[type].call(this, geometry);
  }
});

var parse$1 = {
  /**
   * Parse a GeoJSON Feature object
   *
   * @param {Object}
   *          obj Object to parse.
   *
   * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.
   */
  Feature: function Feature(obj) {
    var feature = {};

    for (var key in obj) {
      feature[key] = obj[key];
    }if (obj.geometry) {
      var type = obj.geometry.type;
      if (!parse$1[type]) throw new Error('Unknown GeoJSON type: ' + obj.type);
      feature.geometry = this.read(obj.geometry);
    }

    if (obj.bbox) feature.bbox = parse$1.bbox.call(this, obj.bbox);

    return feature;
  },

  /**
   * Parse a GeoJSON FeatureCollection object
   *
   * @param {Object}
   *          obj Object to parse.
   *
   * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.
   */
  FeatureCollection: function FeatureCollection(obj) {
    var featureCollection = {};

    if (obj.features) {
      featureCollection.features = [];

      for (var i = 0; i < obj.features.length; ++i) {
        featureCollection.features.push(this.read(obj.features[i]));
      }
    }

    if (obj.bbox) featureCollection.bbox = this.parse.bbox.call(this, obj.bbox);

    return featureCollection;
  },

  /**
   * Convert the ordinates in an array to an array of Coordinates
   *
   * @param {Array}
   *          array Array with {Number}s.
   *
   * @return {Array} Array with Coordinates.
   */
  coordinates: function coordinates(array) {
    var coordinates = [];
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i];
      coordinates.push(new Coordinate(sub[0], sub[1]));
    }
    return coordinates;
  },

  /**
   * Convert the bbox to a LinearRing
   *
   * @param {Array}
   *          array Array with [xMin, yMin, xMax, yMax].
   *
   * @return {Array} Array with Coordinates.
   */
  bbox: function bbox(array) {
    return this.geometryFactory.createLinearRing([new Coordinate(array[0], array[1]), new Coordinate(array[2], array[1]), new Coordinate(array[2], array[3]), new Coordinate(array[0], array[3]), new Coordinate(array[0], array[1])]);
  },

  /**
   * Convert an Array with ordinates to a Point
   *
   * @param {Array}
   *          array Array with ordinates.
   *
   * @return {Point} Point.
   */
  Point: function Point(array) {
    var coordinate = new Coordinate(array[0], array[1]);
    return this.geometryFactory.createPoint(coordinate);
  },

  /**
   * Convert an Array with coordinates to a MultiPoint
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {MultiPoint} MultiPoint.
   */
  MultiPoint: function MultiPoint(array) {
    var points = [];
    for (var i = 0; i < array.length; ++i) {
      points.push(parse$1.Point.call(this, array[i]));
    }return this.geometryFactory.createMultiPoint(points);
  },

  /**
   * Convert an Array with coordinates to a LineString
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {LineString} LineString.
   */
  LineString: function LineString(array) {
    var coordinates = parse$1.coordinates.call(this, array);
    return this.geometryFactory.createLineString(coordinates);
  },

  /**
   * Convert an Array with coordinates to a MultiLineString
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {MultiLineString} MultiLineString.
   */
  MultiLineString: function MultiLineString(array) {
    var lineStrings = [];
    for (var i = 0; i < array.length; ++i) {
      lineStrings.push(parse$1.LineString.call(this, array[i]));
    }return this.geometryFactory.createMultiLineString(lineStrings);
  },

  /**
   * Convert an Array to a Polygon
   *
   * @param {Array}
   *          array Array with shell and holes.
   *
   * @return {Polygon} Polygon.
   */
  Polygon: function Polygon(array) {
    var shellCoordinates = parse$1.coordinates.call(this, array[0]);
    var shell = this.geometryFactory.createLinearRing(shellCoordinates);
    var holes = [];
    for (var i = 1; i < array.length; ++i) {
      var hole = array[i];
      var coordinates = parse$1.coordinates.call(this, hole);
      var linearRing = this.geometryFactory.createLinearRing(coordinates);
      holes.push(linearRing);
    }
    return this.geometryFactory.createPolygon(shell, holes);
  },

  /**
   * Convert an Array to a MultiPolygon
   *
   * @param {Array}
   *          array Array of arrays with shell and rings.
   *
   * @return {MultiPolygon} MultiPolygon.
   */
  MultiPolygon: function MultiPolygon(array) {
    var polygons = [];
    for (var i = 0; i < array.length; ++i) {
      var polygon = array[i];
      polygons.push(parse$1.Polygon.call(this, polygon));
    }
    return this.geometryFactory.createMultiPolygon(polygons);
  },

  /**
   * Convert an Array to a GeometryCollection
   *
   * @param {Array}
   *          array Array of GeoJSON geometries.
   *
   * @return {GeometryCollection} GeometryCollection.
   */
  GeometryCollection: function GeometryCollection(array) {
    var geometries = [];
    for (var i = 0; i < array.length; ++i) {
      var geometry = array[i];
      geometries.push(this.read(geometry));
    }
    return this.geometryFactory.createGeometryCollection(geometries);
  }
};

var extract$1 = {
  /**
   * Convert a Coordinate to an Array
   *
   * @param {Coordinate}
   *          coordinate Coordinate to convert.
   *
   * @return {Array} Array of ordinates.
   */
  coordinate: function coordinate(_coordinate) {
    return [_coordinate.x, _coordinate.y];
  },

  /**
   * Convert a Point to a GeoJSON object
   *
   * @param {Point}
   *          point Point to convert.
   *
   * @return {Array} Array of 2 ordinates (paired to a coordinate).
   */
  Point: function Point(point) {
    var array = extract$1.coordinate.call(this, point.getCoordinate());
    return {
      type: 'Point',
      coordinates: array
    };
  },

  /**
   * Convert a MultiPoint to a GeoJSON object
   *
   * @param {MultiPoint}
   *          multipoint MultiPoint to convert.
   *
   * @return {Array} Array of coordinates.
   */
  MultiPoint: function MultiPoint(multipoint) {
    var array = [];
    for (var i = 0; i < multipoint._geometries.length; ++i) {
      var point = multipoint._geometries[i];
      var geoJson = extract$1.Point.call(this, point);
      array.push(geoJson.coordinates);
    }
    return {
      type: 'MultiPoint',
      coordinates: array
    };
  },

  /**
   * Convert a LineString to a GeoJSON object
   *
   * @param {LineString}
   *          linestring LineString to convert.
   *
   * @return {Array} Array of coordinates.
   */
  LineString: function LineString(linestring) {
    var array = [];
    var coordinates = linestring.getCoordinates();
    for (var i = 0; i < coordinates.length; ++i) {
      var coordinate = coordinates[i];
      array.push(extract$1.coordinate.call(this, coordinate));
    }
    return {
      type: 'LineString',
      coordinates: array
    };
  },

  /**
   * Convert a MultiLineString to a GeoJSON object
   *
   * @param {MultiLineString}
   *          multilinestring MultiLineString to convert.
   *
   * @return {Array} Array of Array of coordinates.
   */
  MultiLineString: function MultiLineString(multilinestring) {
    var array = [];
    for (var i = 0; i < multilinestring._geometries.length; ++i) {
      var linestring = multilinestring._geometries[i];
      var geoJson = extract$1.LineString.call(this, linestring);
      array.push(geoJson.coordinates);
    }
    return {
      type: 'MultiLineString',
      coordinates: array
    };
  },

  /**
   * Convert a Polygon to a GeoJSON object
   *
   * @param {Polygon}
   *          polygon Polygon to convert.
   *
   * @return {Array} Array with shell, holes.
   */
  Polygon: function Polygon(polygon) {
    var array = [];
    var shellGeoJson = extract$1.LineString.call(this, polygon._shell);
    array.push(shellGeoJson.coordinates);
    for (var i = 0; i < polygon._holes.length; ++i) {
      var hole = polygon._holes[i];
      var holeGeoJson = extract$1.LineString.call(this, hole);
      array.push(holeGeoJson.coordinates);
    }
    return {
      type: 'Polygon',
      coordinates: array
    };
  },

  /**
   * Convert a MultiPolygon to a GeoJSON object
   *
   * @param {MultiPolygon}
   *          multipolygon MultiPolygon to convert.
   *
   * @return {Array} Array of polygons.
   */
  MultiPolygon: function MultiPolygon(multipolygon) {
    var array = [];
    for (var i = 0; i < multipolygon._geometries.length; ++i) {
      var polygon = multipolygon._geometries[i];
      var geoJson = extract$1.Polygon.call(this, polygon);
      array.push(geoJson.coordinates);
    }
    return {
      type: 'MultiPolygon',
      coordinates: array
    };
  },

  /**
   * Convert a GeometryCollection to a GeoJSON object
   *
   * @param {GeometryCollection}
   *          collection GeometryCollection to convert.
   *
   * @return {Array} Array of geometries.
   */
  GeometryCollection: function GeometryCollection(collection) {
    var array = [];
    for (var i = 0; i < collection._geometries.length; ++i) {
      var geometry = collection._geometries[i];
      var type = geometry.getGeometryType();
      array.push(extract$1[type].call(this, geometry));
    }
    return {
      type: 'GeometryCollection',
      geometries: array
    };
  }
};

/**
 * @module org/locationtech/jts/io/GeoJSONReader
 */

/**
 * Converts a geometry in GeoJSON to a {@link Geometry}.
 */

/**
 * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,
 * to allow it to create <code>Geometry</code> objects of the appropriate
 * implementation. In particular, the <code>GeometryFactory</code> determines
 * the <code>PrecisionModel</code> and <code>SRID</code> that is used.
 *
 * @param {GeometryFactory} geometryFactory
 * @constructor
 */
function GeoJSONReader(geometryFactory) {
  this.parser = new GeoJSONParser(geometryFactory || new GeometryFactory());
}

extend(GeoJSONReader.prototype, {
  /**
   * Reads a GeoJSON representation of a {@link Geometry}
   *
   * Will also parse GeoJSON Features/FeatureCollections as custom objects.
   *
   * @param {Object|String} geoJson a GeoJSON Object or String.
   * @return {Geometry|Object} a <code>Geometry or Feature/FeatureCollection representation.</code>
   * @memberof module:org/locationtech/jts/io/GeoJSONReader#
   */
  read: function read(geoJson) {
    var geometry = this.parser.read(geoJson);
    return geometry;
  }
});

/**
 * @module org/locationtech/jts/io/GeoJSONWriter
 */

/**
 * Writes the GeoJSON representation of a {@link Geometry}. The
 * The GeoJSON format is defined <A
 * HREF="http://geojson.org/geojson-spec.html">here</A>.
 */

/**
 * The <code>GeoJSONWriter</code> outputs coordinates rounded to the precision
 * model. Only the maximum number of decimal places necessary to represent the
 * ordinates to the required precision will be output.
 *
 * @param {GeometryFactory} geometryFactory
 * @constructor
 */
function GeoJSONWriter() {
  this.parser = new GeoJSONParser(this.geometryFactory);
}

extend(GeoJSONWriter.prototype, {
  /**
   * Converts a <code>Geometry</code> to its GeoJSON representation.
   *
   * @param {Geometry}
   *          geometry a <code>Geometry</code> to process.
   * @return {Object} The GeoJSON representation of the Geometry.
   * @memberof module:org/locationtech/jts/io/GeoJSONWriter#
   */
  write: function write(geometry) {
    return this.parser.write(geometry);
  }
});

/**
 * @module org/locationtech/jts/io/WKTReader
 */

/**
 * Converts a geometry in Well-Known Text format to a {@link Geometry}.
 * <p>
 * <code>WKTReader</code> supports extracting <code>Geometry</code> objects
 * from either {@link Reader}s or {@link String}s. This allows it to function
 * as a parser to read <code>Geometry</code> objects from text blocks embedded
 * in other data formats (e.g. XML).
 */

/**
 * A <code>WKTReader</code> is parameterized by a <code>GeometryFactory</code>,
 * to allow it to create <code>Geometry</code> objects of the appropriate
 * implementation. In particular, the <code>GeometryFactory</code> determines
 * the <code>PrecisionModel</code> and <code>SRID</code> that is used.
 * @param {GeometryFactory} geometryFactory
 * @constructor
 */
function WKTReader(geometryFactory) {
  this.parser = new WKTParser(geometryFactory || new GeometryFactory());
}

extend(WKTReader.prototype, {
  /**
   * Reads a Well-Known Text representation of a {@link Geometry}
   *
   * @param {string}
   *          wkt a <Geometry Tagged Text> string (see the OpenGIS Simple Features
   *          Specification).
   * @return {Geometry} a <code>Geometry</code> read from
   *         <code>string.</code>
   * @memberof module:org/locationtech/jts/io/WKTReader#
   */
  read: function read(wkt) {
    var geometry = this.parser.read(wkt);
    return geometry;
  }
});

/*eslint-disable no-undef */

/**
 * @module org/locationtech/jts/io/OL3Parser
 */

function p2c(p) {
  return [p.x, p.y];
}

/**
 * OpenLayers Geometry parser and writer
 * @param {GeometryFactory} geometryFactory
 * @param {ol} olReference 
 * @constructor
 */
function OL3Parser(geometryFactory, olReference) {
  this.geometryFactory = geometryFactory || new GeometryFactory();
  this.ol = olReference || typeof ol !== 'undefined' && ol;
}

extend(OL3Parser.prototype, {

  /**
   * Inject OpenLayers geom classes
   */
  inject: function inject(Point, LineString, LinearRing, Polygon, MultiPoint, MultiLineString, MultiPolygon, GeometryCollection) {
    this.ol = {
      geom: {
        Point: Point, LineString: LineString, LinearRing: LinearRing, Polygon: Polygon, MultiPoint: MultiPoint, MultiLineString: MultiLineString, MultiPolygon: MultiPolygon, GeometryCollection: GeometryCollection
      }
    };
  },


  /**
   * @param geometry {ol.geom.Geometry}
   * @return {Geometry}
   * @memberof module:org/locationtech/jts/io/OL3Parser#
   */
  read: function read(geometry) {
    var ol = this.ol;
    if (geometry instanceof ol.geom.Point) {
      return this.convertFromPoint(geometry);
    } else if (geometry instanceof ol.geom.LineString) {
      return this.convertFromLineString(geometry);
    } else if (geometry instanceof ol.geom.LinearRing) {
      return this.convertFromLinearRing(geometry);
    } else if (geometry instanceof ol.geom.Polygon) {
      return this.convertFromPolygon(geometry);
    } else if (geometry instanceof ol.geom.MultiPoint) {
      return this.convertFromMultiPoint(geometry);
    } else if (geometry instanceof ol.geom.MultiLineString) {
      return this.convertFromMultiLineString(geometry);
    } else if (geometry instanceof ol.geom.MultiPolygon) {
      return this.convertFromMultiPolygon(geometry);
    } else if (geometry instanceof ol.geom.GeometryCollection) {
      return this.convertFromCollection(geometry);
    }
  },
  convertFromPoint: function convertFromPoint(point) {
    var coordinates = point.getCoordinates();
    return this.geometryFactory.createPoint(new Coordinate(coordinates[0], coordinates[1]));
  },
  convertFromLineString: function convertFromLineString(lineString) {
    return this.geometryFactory.createLineString(lineString.getCoordinates().map(function (coordinates) {
      return new Coordinate(coordinates[0], coordinates[1]);
    }));
  },
  convertFromLinearRing: function convertFromLinearRing(linearRing) {
    return this.geometryFactory.createLinearRing(linearRing.getCoordinates().map(function (coordinates) {
      return new Coordinate(coordinates[0], coordinates[1]);
    }));
  },
  convertFromPolygon: function convertFromPolygon(polygon) {
    var linearRings = polygon.getLinearRings();
    var shell = null;
    var holes = [];
    for (var i = 0; i < linearRings.length; i++) {
      var linearRing = this.convertFromLinearRing(linearRings[i]);
      if (i === 0) {
        shell = linearRing;
      } else {
        holes.push(linearRing);
      }
    }
    return this.geometryFactory.createPolygon(shell, holes);
  },
  convertFromMultiPoint: function convertFromMultiPoint(multiPoint) {
    var points = multiPoint.getPoints().map(function (point) {
      return this.convertFromPoint(point);
    }, this);
    return this.geometryFactory.createMultiPoint(points);
  },
  convertFromMultiLineString: function convertFromMultiLineString(multiLineString) {
    var lineStrings = multiLineString.getLineStrings().map(function (lineString) {
      return this.convertFromLineString(lineString);
    }, this);
    return this.geometryFactory.createMultiLineString(lineStrings);
  },
  convertFromMultiPolygon: function convertFromMultiPolygon(multiPolygon) {
    var polygons = multiPolygon.getPolygons().map(function (polygon) {
      return this.convertFromPolygon(polygon);
    }, this);
    return this.geometryFactory.createMultiPolygon(polygons);
  },
  convertFromCollection: function convertFromCollection(collection) {
    var geometries = collection.getGeometries().map(function (geometry) {
      return this.read(geometry);
    }, this);
    return this.geometryFactory.createGeometryCollection(geometries);
  },


  /**
   * @param geometry
   *          {Geometry}
   * @return {ol.geom.Geometry}
   * @memberof module:org/locationtech/jts/io/OL3Parser#
   */
  write: function write(geometry) {
    if (geometry.getGeometryType() === 'Point') {
      return this.convertToPoint(geometry.getCoordinate());
    } else if (geometry.getGeometryType() === 'LineString') {
      return this.convertToLineString(geometry);
    } else if (geometry.getGeometryType() === 'LinearRing') {
      return this.convertToLinearRing(geometry);
    } else if (geometry.getGeometryType() === 'Polygon') {
      return this.convertToPolygon(geometry);
    } else if (geometry.getGeometryType() === 'MultiPoint') {
      return this.convertToMultiPoint(geometry);
    } else if (geometry.getGeometryType() === 'MultiLineString') {
      return this.convertToMultiLineString(geometry);
    } else if (geometry.getGeometryType() === 'MultiPolygon') {
      return this.convertToMultiPolygon(geometry);
    } else if (geometry.getGeometryType() === 'GeometryCollection') {
      return this.convertToCollection(geometry);
    }
  },
  convertToPoint: function convertToPoint(coordinate) {
    return new this.ol.geom.Point([coordinate.x, coordinate.y]);
  },
  convertToLineString: function convertToLineString(lineString) {
    var points = lineString._points._coordinates.map(p2c);
    return new this.ol.geom.LineString(points);
  },
  convertToLinearRing: function convertToLinearRing(linearRing) {
    var points = linearRing._points._coordinates.map(p2c);
    return new this.ol.geom.LinearRing(points);
  },
  convertToPolygon: function convertToPolygon(polygon) {
    var rings = [polygon._shell._points._coordinates.map(p2c)];
    for (var i = 0; i < polygon._holes.length; i++) {
      rings.push(polygon._holes[i]._points._coordinates.map(p2c));
    }
    return new this.ol.geom.Polygon(rings);
  },
  convertToMultiPoint: function convertToMultiPoint(multiPoint) {
    return new this.ol.geom.MultiPoint(multiPoint.getCoordinates().map(p2c));
  },
  convertToMultiLineString: function convertToMultiLineString(multiLineString) {
    var lineStrings = [];
    for (var i = 0; i < multiLineString._geometries.length; i++) {
      lineStrings.push(this.convertToLineString(multiLineString._geometries[i]).getCoordinates());
    }
    return new this.ol.geom.MultiLineString(lineStrings);
  },
  convertToMultiPolygon: function convertToMultiPolygon(multiPolygon) {
    var polygons = [];
    for (var i = 0; i < multiPolygon._geometries.length; i++) {
      polygons.push(this.convertToPolygon(multiPolygon._geometries[i]).getCoordinates());
    }
    return new this.ol.geom.MultiPolygon(polygons);
  },
  convertToCollection: function convertToCollection(geometryCollection) {
    var geometries = [];
    for (var i = 0; i < geometryCollection._geometries.length; i++) {
      var geometry = geometryCollection._geometries[i];
      geometries.push(this.write(geometry));
    }
    return new this.ol.geom.GeometryCollection(geometries);
  }
});



var io = Object.freeze({
	GeoJSONReader: GeoJSONReader,
	GeoJSONWriter: GeoJSONWriter,
	OL3Parser: OL3Parser,
	WKTReader: WKTReader,
	WKTWriter: WKTWriter
});

function SegmentPointComparator() {}
extend(SegmentPointComparator.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return SegmentPointComparator;
	}
});
SegmentPointComparator.relativeSign = function (x0, x1) {
	if (x0 < x1) return -1;
	if (x0 > x1) return 1;
	return 0;
};
SegmentPointComparator.compare = function (octant, p0, p1) {
	if (p0.equals2D(p1)) return 0;
	var xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);
	var ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);
	switch (octant) {
		case 0:
			return SegmentPointComparator.compareValue(xSign, ySign);
		case 1:
			return SegmentPointComparator.compareValue(ySign, xSign);
		case 2:
			return SegmentPointComparator.compareValue(ySign, -xSign);
		case 3:
			return SegmentPointComparator.compareValue(-xSign, ySign);
		case 4:
			return SegmentPointComparator.compareValue(-xSign, -ySign);
		case 5:
			return SegmentPointComparator.compareValue(-ySign, -xSign);
		case 6:
			return SegmentPointComparator.compareValue(-ySign, xSign);
		case 7:
			return SegmentPointComparator.compareValue(xSign, -ySign);
	}
	Assert.shouldNeverReachHere("invalid octant value");
	return 0;
};
SegmentPointComparator.compareValue = function (compareSign0, compareSign1) {
	if (compareSign0 < 0) return -1;
	if (compareSign0 > 0) return 1;
	if (compareSign1 < 0) return -1;
	if (compareSign1 > 0) return 1;
	return 0;
};

function SegmentNode() {
	this._segString = null;
	this.coord = null;
	this.segmentIndex = null;
	this._segmentOctant = null;
	this._isInterior = null;
	var segString = arguments[0],
	    coord = arguments[1],
	    segmentIndex = arguments[2],
	    segmentOctant = arguments[3];
	this._segString = segString;
	this.coord = new Coordinate(coord);
	this.segmentIndex = segmentIndex;
	this._segmentOctant = segmentOctant;
	this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));
}
extend(SegmentNode.prototype, {
	getCoordinate: function getCoordinate() {
		return this.coord;
	},
	print: function print(out) {
		out.print(this.coord);
		out.print(" seg # = " + this.segmentIndex);
	},
	compareTo: function compareTo(obj) {
		var other = obj;
		if (this.segmentIndex < other.segmentIndex) return -1;
		if (this.segmentIndex > other.segmentIndex) return 1;
		if (this.coord.equals2D(other.coord)) return 0;
		return SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord);
	},
	isEndPoint: function isEndPoint(maxSegmentIndex) {
		if (this.segmentIndex === 0 && !this._isInterior) return true;
		if (this.segmentIndex === maxSegmentIndex) return true;
		return false;
	},
	isInterior: function isInterior() {
		return this._isInterior;
	},
	interfaces_: function interfaces_() {
		return [Comparable];
	},
	getClass: function getClass() {
		return SegmentNode;
	}
});

function SegmentNodeList() {
	this._nodeMap = new TreeMap();
	this._edge = null;
	var edge = arguments[0];
	this._edge = edge;
}
extend(SegmentNodeList.prototype, {
	getSplitCoordinates: function getSplitCoordinates() {
		var coordList = new CoordinateList();
		this.addEndpoints();
		var it = this.iterator();
		var eiPrev = it.next();
		while (it.hasNext()) {
			var ei = it.next();
			this.addEdgeCoordinates(eiPrev, ei, coordList);
			eiPrev = ei;
		}
		return coordList.toCoordinateArray();
	},
	addCollapsedNodes: function addCollapsedNodes() {
		var collapsedVertexIndexes = new ArrayList();
		this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);
		this.findCollapsesFromExistingVertices(collapsedVertexIndexes);
		for (var it = collapsedVertexIndexes.iterator(); it.hasNext();) {
			var vertexIndex = it.next().intValue();
			this.add(this._edge.getCoordinate(vertexIndex), vertexIndex);
		}
	},
	print: function print(out) {
		out.println("Intersections:");
		for (var it = this.iterator(); it.hasNext();) {
			var ei = it.next();
			ei.print(out);
		}
	},
	findCollapsesFromExistingVertices: function findCollapsesFromExistingVertices(collapsedVertexIndexes) {
		for (var i = 0; i < this._edge.size() - 2; i++) {
			var p0 = this._edge.getCoordinate(i);
			var p1 = this._edge.getCoordinate(i + 1);
			var p2 = this._edge.getCoordinate(i + 2);
			if (p0.equals2D(p2)) {
				collapsedVertexIndexes.add(new Integer(i + 1));
			}
		}
	},
	addEdgeCoordinates: function addEdgeCoordinates(ei0, ei1, coordList) {
		var npts = ei1.segmentIndex - ei0.segmentIndex + 2;
		var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
		var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
		if (!useIntPt1) {
			npts--;
		}
		coordList.add(new Coordinate(ei0.coord), false);
		for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
			coordList.add(this._edge.getCoordinate(i));
		}
		if (useIntPt1) {
			coordList.add(new Coordinate(ei1.coord));
		}
	},
	iterator: function iterator() {
		return this._nodeMap.values().iterator();
	},
	addSplitEdges: function addSplitEdges(edgeList) {
		this.addEndpoints();
		this.addCollapsedNodes();
		var it = this.iterator();
		var eiPrev = it.next();
		while (it.hasNext()) {
			var ei = it.next();
			var newEdge = this.createSplitEdge(eiPrev, ei);
			edgeList.add(newEdge);
			eiPrev = ei;
		}
	},
	findCollapseIndex: function findCollapseIndex(ei0, ei1, collapsedVertexIndex) {
		if (!ei0.coord.equals2D(ei1.coord)) return false;
		var numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;
		if (!ei1.isInterior()) {
			numVerticesBetween--;
		}
		if (numVerticesBetween === 1) {
			collapsedVertexIndex[0] = ei0.segmentIndex + 1;
			return true;
		}
		return false;
	},
	findCollapsesFromInsertedNodes: function findCollapsesFromInsertedNodes(collapsedVertexIndexes) {
		var collapsedVertexIndex = new Array(1).fill(null);
		var it = this.iterator();
		var eiPrev = it.next();
		while (it.hasNext()) {
			var ei = it.next();
			var isCollapsed = this.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);
			if (isCollapsed) collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0]));
			eiPrev = ei;
		}
	},
	getEdge: function getEdge() {
		return this._edge;
	},
	addEndpoints: function addEndpoints() {
		var maxSegIndex = this._edge.size() - 1;
		this.add(this._edge.getCoordinate(0), 0);
		this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);
	},
	createSplitEdge: function createSplitEdge(ei0, ei1) {
		var npts = ei1.segmentIndex - ei0.segmentIndex + 2;
		var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
		var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
		if (!useIntPt1) {
			npts--;
		}
		var pts = new Array(npts).fill(null);
		var ipt = 0;
		pts[ipt++] = new Coordinate(ei0.coord);
		for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {
			pts[ipt++] = this._edge.getCoordinate(i);
		}
		if (useIntPt1) pts[ipt] = new Coordinate(ei1.coord);
		return new NodedSegmentString(pts, this._edge.getData());
	},
	add: function add(intPt, segmentIndex) {
		var eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));
		var ei = this._nodeMap.get(eiNew);
		if (ei !== null) {
			Assert.isTrue(ei.coord.equals2D(intPt), "Found equal nodes with different coordinates");
			return ei;
		}
		this._nodeMap.put(eiNew, eiNew);
		return eiNew;
	},
	checkSplitEdgesCorrectness: function checkSplitEdgesCorrectness(splitEdges) {
		var edgePts = this._edge.getCoordinates();
		var split0 = splitEdges.get(0);
		var pt0 = split0.getCoordinate(0);
		if (!pt0.equals2D(edgePts[0])) throw new RuntimeException("bad split edge start point at " + pt0);
		var splitn = splitEdges.get(splitEdges.size() - 1);
		var splitnPts = splitn.getCoordinates();
		var ptn = splitnPts[splitnPts.length - 1];
		if (!ptn.equals2D(edgePts[edgePts.length - 1])) throw new RuntimeException("bad split edge end point at " + ptn);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return SegmentNodeList;
	}
});
function NodeVertexIterator() {
	this._nodeList = null;
	this._edge = null;
	this._nodeIt = null;
	this._currNode = null;
	this._nextNode = null;
	this._currSegIndex = 0;
	var nodeList = arguments[0];
	this._nodeList = nodeList;
	this._edge = nodeList.getEdge();
	this._nodeIt = nodeList.iterator();
	this.readNextNode();
}
extend(NodeVertexIterator.prototype, {
	next: function next() {
		if (this._currNode === null) {
			this._currNode = this._nextNode;
			this._currSegIndex = this._currNode.segmentIndex;
			this.readNextNode();
			return this._currNode;
		}
		if (this._nextNode === null) return null;
		if (this._nextNode.segmentIndex === this._currNode.segmentIndex) {
			this._currNode = this._nextNode;
			this._currSegIndex = this._currNode.segmentIndex;
			this.readNextNode();
			return this._currNode;
		}
		if (this._nextNode.segmentIndex > this._currNode.segmentIndex) {}
		return null;
	},
	remove: function remove() {
		throw new UnsupportedOperationException(this.getClass().getName());
	},
	hasNext: function hasNext() {
		if (this._nextNode === null) return false;
		return true;
	},
	readNextNode: function readNextNode() {
		if (this._nodeIt.hasNext()) this._nextNode = this._nodeIt.next();else this._nextNode = null;
	},
	interfaces_: function interfaces_() {
		return [Iterator];
	},
	getClass: function getClass() {
		return NodeVertexIterator;
	}
});

function Octant() {}
extend(Octant.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Octant;
	}
});
Octant.octant = function () {
	if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
		var _dx = arguments[0],
		    _dy = arguments[1];
		if (_dx === 0.0 && _dy === 0.0) throw new IllegalArgumentException("Cannot compute the octant for point ( " + _dx + ", " + _dy + " )");
		var adx = Math.abs(_dx);
		var ady = Math.abs(_dy);
		if (_dx >= 0) {
			if (_dy >= 0) {
				if (adx >= ady) return 0;else return 1;
			} else {
				if (adx >= ady) return 7;else return 6;
			}
		} else {
			if (_dy >= 0) {
				if (adx >= ady) return 3;else return 2;
			} else {
				if (adx >= ady) return 4;else return 5;
			}
		}
	} else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {
		var p0 = arguments[0],
		    p1 = arguments[1];
		var dx = p1.x - p0.x;
		var dy = p1.y - p0.y;
		if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException("Cannot compute the octant for two identical points " + p0);
		return Octant.octant(dx, dy);
	}
};

function SegmentString() {}
extend(SegmentString.prototype, {
	getCoordinates: function getCoordinates() {},
	size: function size() {},
	getCoordinate: function getCoordinate(i) {},
	isClosed: function isClosed() {},
	setData: function setData(data) {},
	getData: function getData() {},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return SegmentString;
	}
});

function NodableSegmentString() {}
extend(NodableSegmentString.prototype, {
	addIntersection: function addIntersection(intPt, segmentIndex) {},
	interfaces_: function interfaces_() {
		return [SegmentString];
	},
	getClass: function getClass() {
		return NodableSegmentString;
	}
});

function NodedSegmentString() {
	this._nodeList = new SegmentNodeList(this);
	this._pts = null;
	this._data = null;
	var pts = arguments[0],
	    data = arguments[1];
	this._pts = pts;
	this._data = data;
}
extend(NodedSegmentString.prototype, {
	getCoordinates: function getCoordinates() {
		return this._pts;
	},
	size: function size() {
		return this._pts.length;
	},
	getCoordinate: function getCoordinate(i) {
		return this._pts[i];
	},
	isClosed: function isClosed() {
		return this._pts[0].equals(this._pts[this._pts.length - 1]);
	},
	getSegmentOctant: function getSegmentOctant(index) {
		if (index === this._pts.length - 1) return -1;
		return this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1));
	},
	setData: function setData(data) {
		this._data = data;
	},
	safeOctant: function safeOctant(p0, p1) {
		if (p0.equals2D(p1)) return 0;
		return Octant.octant(p0, p1);
	},
	getData: function getData() {
		return this._data;
	},
	addIntersection: function addIntersection() {
		if (arguments.length === 2) {
			var _intPt = arguments[0],
			    segmentIndex = arguments[1];
			this.addIntersectionNode(_intPt, segmentIndex);
		} else if (arguments.length === 4) {
			var li = arguments[0],
			    _segmentIndex = arguments[1],
			    geomIndex = arguments[2],
			    intIndex = arguments[3];
			var intPt = new Coordinate(li.getIntersection(intIndex));
			this.addIntersection(intPt, _segmentIndex);
		}
	},
	toString: function toString() {
		return WKTWriter.toLineString(new CoordinateArraySequence(this._pts));
	},
	getNodeList: function getNodeList() {
		return this._nodeList;
	},
	addIntersectionNode: function addIntersectionNode(intPt, segmentIndex) {
		var normalizedSegmentIndex = segmentIndex;
		var nextSegIndex = normalizedSegmentIndex + 1;
		if (nextSegIndex < this._pts.length) {
			var nextPt = this._pts[nextSegIndex];
			if (intPt.equals2D(nextPt)) {
				normalizedSegmentIndex = nextSegIndex;
			}
		}
		var ei = this._nodeList.add(intPt, normalizedSegmentIndex);
		return ei;
	},
	addIntersections: function addIntersections(li, segmentIndex, geomIndex) {
		for (var i = 0; i < li.getIntersectionNum(); i++) {
			this.addIntersection(li, segmentIndex, geomIndex, i);
		}
	},
	interfaces_: function interfaces_() {
		return [NodableSegmentString];
	},
	getClass: function getClass() {
		return NodedSegmentString;
	}
});
NodedSegmentString.getNodedSubstrings = function () {
	if (arguments.length === 1) {
		var segStrings = arguments[0];
		var resultEdgelist = new ArrayList();
		NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);
		return resultEdgelist;
	} else if (arguments.length === 2) {
		var _segStrings = arguments[0],
		    _resultEdgelist = arguments[1];
		for (var i = _segStrings.iterator(); i.hasNext();) {
			var ss = i.next();
			ss.getNodeList().addSplitEdges(_resultEdgelist);
		}
	}
};

function MonotoneChainOverlapAction() {
	this._overlapSeg1 = new LineSegment();
	this._overlapSeg2 = new LineSegment();
}
extend(MonotoneChainOverlapAction.prototype, {
	overlap: function overlap() {
		if (arguments.length === 2) {
			
		} else if (arguments.length === 4) {
			var mc1 = arguments[0],
			    start1 = arguments[1],
			    mc2 = arguments[2],
			    start2 = arguments[3];
			mc1.getLineSegment(start1, this._overlapSeg1);
			mc2.getLineSegment(start2, this._overlapSeg2);
			this.overlap(this._overlapSeg1, this._overlapSeg2);
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return MonotoneChainOverlapAction;
	}
});

function Noder() {}
extend(Noder.prototype, {
	computeNodes: function computeNodes(segStrings) {},
	getNodedSubstrings: function getNodedSubstrings() {},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Noder;
	}
});

function SinglePassNoder() {
	this._segInt = null;
	if (arguments.length === 0) {} else if (arguments.length === 1) {
		var segInt = arguments[0];
		this.setSegmentIntersector(segInt);
	}
}
extend(SinglePassNoder.prototype, {
	setSegmentIntersector: function setSegmentIntersector(segInt) {
		this._segInt = segInt;
	},
	interfaces_: function interfaces_() {
		return [Noder];
	},
	getClass: function getClass() {
		return SinglePassNoder;
	}
});

function MCIndexNoder() {
	this._monoChains = new ArrayList();
	this._index = new STRtree();
	this._idCounter = 0;
	this._nodedSegStrings = null;
	this._nOverlaps = 0;
	if (arguments.length === 0) {} else if (arguments.length === 1) {
		var si = arguments[0];
		SinglePassNoder.call(this, si);
	}
}
inherits(MCIndexNoder, SinglePassNoder);
extend(MCIndexNoder.prototype, {
	getMonotoneChains: function getMonotoneChains() {
		return this._monoChains;
	},
	getNodedSubstrings: function getNodedSubstrings() {
		return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);
	},
	getIndex: function getIndex() {
		return this._index;
	},
	add: function add(segStr) {
		var segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);
		for (var i = segChains.iterator(); i.hasNext();) {
			var mc = i.next();
			mc.setId(this._idCounter++);
			this._index.insert(mc.getEnvelope(), mc);
			this._monoChains.add(mc);
		}
	},
	computeNodes: function computeNodes(inputSegStrings) {
		this._nodedSegStrings = inputSegStrings;
		for (var i = inputSegStrings.iterator(); i.hasNext();) {
			this.add(i.next());
		}
		this.intersectChains();
	},
	intersectChains: function intersectChains() {
		var overlapAction = new SegmentOverlapAction(this._segInt);
		for (var i = this._monoChains.iterator(); i.hasNext();) {
			var queryChain = i.next();
			var overlapChains = this._index.query(queryChain.getEnvelope());
			for (var j = overlapChains.iterator(); j.hasNext();) {
				var testChain = j.next();
				if (testChain.getId() > queryChain.getId()) {
					queryChain.computeOverlaps(testChain, overlapAction);
					this._nOverlaps++;
				}
				if (this._segInt.isDone()) return null;
			}
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return MCIndexNoder;
	}
});
function SegmentOverlapAction() {
	MonotoneChainOverlapAction.apply(this);
	this._si = null;
	var si = arguments[0];
	this._si = si;
}
inherits(SegmentOverlapAction, MonotoneChainOverlapAction);
extend(SegmentOverlapAction.prototype, {
	overlap: function overlap() {
		if (arguments.length === 4) {
			var mc1 = arguments[0],
			    start1 = arguments[1],
			    mc2 = arguments[2],
			    start2 = arguments[3];
			var ss1 = mc1.getContext();
			var ss2 = mc2.getContext();
			this._si.processIntersections(ss1, start1, ss2, start2);
		} else return MonotoneChainOverlapAction.prototype.overlap.apply(this, arguments);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return SegmentOverlapAction;
	}
});
MCIndexNoder.SegmentOverlapAction = SegmentOverlapAction;

function ScaledNoder() {
	this._noder = null;
	this._scaleFactor = null;
	this._offsetX = null;
	this._offsetY = null;
	this._isScaled = false;
	if (arguments.length === 2) {
		var noder = arguments[0],
		    scaleFactor = arguments[1];
		ScaledNoder.call(this, noder, scaleFactor, 0, 0);
	} else if (arguments.length === 4) {
		var _noder = arguments[0],
		    _scaleFactor = arguments[1];
		this._noder = _noder;
		this._scaleFactor = _scaleFactor;
		this._isScaled = !this.isIntegerPrecision();
	}
}
extend(ScaledNoder.prototype, {
	rescale: function rescale() {
		if (hasInterface(arguments[0], Collection)) {
			var segStrings = arguments[0];
			for (var i = segStrings.iterator(); i.hasNext();) {
				var ss = i.next();
				this.rescale(ss.getCoordinates());
			}
		} else if (arguments[0] instanceof Array) {
			var pts = arguments[0];
			var p0 = null;
			var p1 = null;
			if (pts.length === 2) {
				p0 = new Coordinate(pts[0]);
				p1 = new Coordinate(pts[1]);
			}
			for (var i = 0; i < pts.length; i++) {
				pts[i].x = pts[i].x / this._scaleFactor + this._offsetX;
				pts[i].y = pts[i].y / this._scaleFactor + this._offsetY;
			}
			if (pts.length === 2 && pts[0].equals2D(pts[1])) {
				System.out.println(pts);
			}
		}
	},
	scale: function scale() {
		if (hasInterface(arguments[0], Collection)) {
			var segStrings = arguments[0];
			var nodedSegmentStrings = new ArrayList(segStrings.size());
			for (var i = segStrings.iterator(); i.hasNext();) {
				var ss = i.next();
				nodedSegmentStrings.add(new NodedSegmentString(this.scale(ss.getCoordinates()), ss.getData()));
			}
			return nodedSegmentStrings;
		} else if (arguments[0] instanceof Array) {
			var pts = arguments[0];
			var roundPts = new Array(pts.length).fill(null);
			for (var i = 0; i < pts.length; i++) {
				roundPts[i] = new Coordinate(Math.round((pts[i].x - this._offsetX) * this._scaleFactor), Math.round((pts[i].y - this._offsetY) * this._scaleFactor), pts[i].z);
			}
			var roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);
			return roundPtsNoDup;
		}
	},
	isIntegerPrecision: function isIntegerPrecision() {
		return this._scaleFactor === 1.0;
	},
	getNodedSubstrings: function getNodedSubstrings() {
		var splitSS = this._noder.getNodedSubstrings();
		if (this._isScaled) this.rescale(splitSS);
		return splitSS;
	},
	computeNodes: function computeNodes(inputSegStrings) {
		var intSegStrings = inputSegStrings;
		if (this._isScaled) intSegStrings = this.scale(inputSegStrings);
		this._noder.computeNodes(intSegStrings);
	},
	interfaces_: function interfaces_() {
		return [Noder];
	},
	getClass: function getClass() {
		return ScaledNoder;
	}
});



var noding = Object.freeze({
	MCIndexNoder: MCIndexNoder,
	ScaledNoder: ScaledNoder,
	SegmentString: SegmentString
});

function IsSimpleOp() {
	this._inputGeom = null;
	this._isClosedEndpointsInInterior = true;
	this._nonSimpleLocation = null;
	if (arguments.length === 1) {
		var geom = arguments[0];
		this._inputGeom = geom;
	} else if (arguments.length === 2) {
		var _geom = arguments[0],
		    boundaryNodeRule = arguments[1];
		this._inputGeom = _geom;
		this._isClosedEndpointsInInterior = !boundaryNodeRule.isInBoundary(2);
	}
}
extend(IsSimpleOp.prototype, {
	isSimpleMultiPoint: function isSimpleMultiPoint(mp) {
		if (mp.isEmpty()) return true;
		var points = new TreeSet();
		for (var i = 0; i < mp.getNumGeometries(); i++) {
			var pt = mp.getGeometryN(i);
			var p = pt.getCoordinate();
			if (points.contains(p)) {
				this._nonSimpleLocation = p;
				return false;
			}
			points.add(p);
		}
		return true;
	},
	isSimplePolygonal: function isSimplePolygonal(geom) {
		var rings = LinearComponentExtracter.getLines(geom);
		for (var i = rings.iterator(); i.hasNext();) {
			var ring = i.next();
			if (!this.isSimpleLinearGeometry(ring)) return false;
		}
		return true;
	},
	hasClosedEndpointIntersection: function hasClosedEndpointIntersection(graph) {
		var endPoints = new TreeMap();
		for (var i = graph.getEdgeIterator(); i.hasNext();) {
			var e = i.next();
			var maxSegmentIndex = e.getMaximumSegmentIndex();
			var isClosed = e.isClosed();
			var p0 = e.getCoordinate(0);
			this.addEndpoint(endPoints, p0, isClosed);
			var p1 = e.getCoordinate(e.getNumPoints() - 1);
			this.addEndpoint(endPoints, p1, isClosed);
		}
		for (var i = endPoints.values().iterator(); i.hasNext();) {
			var eiInfo = i.next();
			if (eiInfo.isClosed && eiInfo.degree !== 2) {
				this._nonSimpleLocation = eiInfo.getCoordinate();
				return true;
			}
		}
		return false;
	},
	getNonSimpleLocation: function getNonSimpleLocation() {
		return this._nonSimpleLocation;
	},
	isSimpleLinearGeometry: function isSimpleLinearGeometry(geom) {
		if (geom.isEmpty()) return true;
		var graph = new GeometryGraph(0, geom);
		var li = new RobustLineIntersector();
		var si = graph.computeSelfNodes(li, true);
		if (!si.hasIntersection()) return true;
		if (si.hasProperIntersection()) {
			this._nonSimpleLocation = si.getProperIntersectionPoint();
			return false;
		}
		if (this.hasNonEndpointIntersection(graph)) return false;
		if (this._isClosedEndpointsInInterior) {
			if (this.hasClosedEndpointIntersection(graph)) return false;
		}
		return true;
	},
	hasNonEndpointIntersection: function hasNonEndpointIntersection(graph) {
		for (var i = graph.getEdgeIterator(); i.hasNext();) {
			var e = i.next();
			var maxSegmentIndex = e.getMaximumSegmentIndex();
			for (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {
				var ei = eiIt.next();
				if (!ei.isEndPoint(maxSegmentIndex)) {
					this._nonSimpleLocation = ei.getCoordinate();
					return true;
				}
			}
		}
		return false;
	},
	addEndpoint: function addEndpoint(endPoints, p, isClosed) {
		var eiInfo = endPoints.get(p);
		if (eiInfo === null) {
			eiInfo = new EndpointInfo(p);
			endPoints.put(p, eiInfo);
		}
		eiInfo.addEndpoint(isClosed);
	},
	computeSimple: function computeSimple(geom) {
		this._nonSimpleLocation = null;
		if (geom.isEmpty()) return true;
		if (geom instanceof LineString) return this.isSimpleLinearGeometry(geom);
		if (geom instanceof MultiLineString) return this.isSimpleLinearGeometry(geom);
		if (geom instanceof MultiPoint) return this.isSimpleMultiPoint(geom);
		if (hasInterface(geom, Polygonal)) return this.isSimplePolygonal(geom);
		if (geom instanceof GeometryCollection) return this.isSimpleGeometryCollection(geom);
		return true;
	},
	isSimple: function isSimple() {
		this._nonSimpleLocation = null;
		return this.computeSimple(this._inputGeom);
	},
	isSimpleGeometryCollection: function isSimpleGeometryCollection(geom) {
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var comp = geom.getGeometryN(i);
			if (!this.computeSimple(comp)) return false;
		}
		return true;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return IsSimpleOp;
	}
});
IsSimpleOp.isSimple = function () {
	if (arguments.length === 1) {
		var geom = arguments[0];
		var op = new IsSimpleOp(geom);
		return op.isSimple();
	} else if (arguments.length === 2) {
		var _geom2 = arguments[0],
		    boundaryNodeRule = arguments[1];
		var op = new IsSimpleOp(_geom2, boundaryNodeRule);
		return op.isSimple();
	}
};
function EndpointInfo() {
	this.pt = null;
	this.isClosed = null;
	this.degree = null;
	var pt = arguments[0];
	this.pt = pt;
	this.isClosed = false;
	this.degree = 0;
}
extend(EndpointInfo.prototype, {
	addEndpoint: function addEndpoint(isClosed) {
		this.degree++;
		this.isClosed |= isClosed;
	},
	getCoordinate: function getCoordinate() {
		return this.pt;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return EndpointInfo;
	}
});
IsSimpleOp.EndpointInfo = EndpointInfo;

function BufferParameters() {
	this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
	this._endCapStyle = BufferParameters.CAP_ROUND;
	this._joinStyle = BufferParameters.JOIN_ROUND;
	this._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;
	this._isSingleSided = false;
	this._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;
	if (arguments.length === 0) {} else if (arguments.length === 1) {
		var quadrantSegments = arguments[0];
		this.setQuadrantSegments(quadrantSegments);
	} else if (arguments.length === 2) {
		var _quadrantSegments = arguments[0],
		    endCapStyle = arguments[1];
		this.setQuadrantSegments(_quadrantSegments);
		this.setEndCapStyle(endCapStyle);
	} else if (arguments.length === 4) {
		var _quadrantSegments2 = arguments[0],
		    _endCapStyle = arguments[1],
		    joinStyle = arguments[2],
		    mitreLimit = arguments[3];
		this.setQuadrantSegments(_quadrantSegments2);
		this.setEndCapStyle(_endCapStyle);
		this.setJoinStyle(joinStyle);
		this.setMitreLimit(mitreLimit);
	}
}
extend(BufferParameters.prototype, {
	getEndCapStyle: function getEndCapStyle() {
		return this._endCapStyle;
	},
	isSingleSided: function isSingleSided() {
		return this._isSingleSided;
	},
	setQuadrantSegments: function setQuadrantSegments(quadSegs) {
		this._quadrantSegments = quadSegs;
		if (this._quadrantSegments === 0) this._joinStyle = BufferParameters.JOIN_BEVEL;
		if (this._quadrantSegments < 0) {
			this._joinStyle = BufferParameters.JOIN_MITRE;
			this._mitreLimit = Math.abs(this._quadrantSegments);
		}
		if (quadSegs <= 0) {
			this._quadrantSegments = 1;
		}
		if (this._joinStyle !== BufferParameters.JOIN_ROUND) {
			this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
		}
	},
	getJoinStyle: function getJoinStyle() {
		return this._joinStyle;
	},
	setJoinStyle: function setJoinStyle(joinStyle) {
		this._joinStyle = joinStyle;
	},
	setSimplifyFactor: function setSimplifyFactor(simplifyFactor) {
		this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;
	},
	getSimplifyFactor: function getSimplifyFactor() {
		return this._simplifyFactor;
	},
	getQuadrantSegments: function getQuadrantSegments() {
		return this._quadrantSegments;
	},
	setEndCapStyle: function setEndCapStyle(endCapStyle) {
		this._endCapStyle = endCapStyle;
	},
	getMitreLimit: function getMitreLimit() {
		return this._mitreLimit;
	},
	setMitreLimit: function setMitreLimit(mitreLimit) {
		this._mitreLimit = mitreLimit;
	},
	setSingleSided: function setSingleSided(isSingleSided) {
		this._isSingleSided = isSingleSided;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return BufferParameters;
	}
});
BufferParameters.bufferDistanceError = function (quadSegs) {
	var alpha = Math.PI / 2.0 / quadSegs;
	return 1 - Math.cos(alpha / 2.0);
};
BufferParameters.CAP_ROUND = 1;
BufferParameters.CAP_FLAT = 2;
BufferParameters.CAP_SQUARE = 3;
BufferParameters.JOIN_ROUND = 1;
BufferParameters.JOIN_MITRE = 2;
BufferParameters.JOIN_BEVEL = 3;
BufferParameters.DEFAULT_QUADRANT_SEGMENTS = 8;
BufferParameters.DEFAULT_MITRE_LIMIT = 5.0;
BufferParameters.DEFAULT_SIMPLIFY_FACTOR = 0.01;

function RightmostEdgeFinder() {
	this._minIndex = -1;
	this._minCoord = null;
	this._minDe = null;
	this._orientedDe = null;
}
extend(RightmostEdgeFinder.prototype, {
	getCoordinate: function getCoordinate() {
		return this._minCoord;
	},
	getRightmostSide: function getRightmostSide(de, index) {
		var side = this.getRightmostSideOfSegment(de, index);
		if (side < 0) side = this.getRightmostSideOfSegment(de, index - 1);
		if (side < 0) {
			this._minCoord = null;
			this.checkForRightmostCoordinate(de);
		}
		return side;
	},
	findRightmostEdgeAtVertex: function findRightmostEdgeAtVertex() {
		var pts = this._minDe.getEdge().getCoordinates();
		Assert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, "rightmost point expected to be interior vertex of edge");
		var pPrev = pts[this._minIndex - 1];
		var pNext = pts[this._minIndex + 1];
		var orientation = Orientation.index(this._minCoord, pNext, pPrev);
		var usePrev = false;
		if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === Orientation.COUNTERCLOCKWISE) {
			usePrev = true;
		} else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === Orientation.CLOCKWISE) {
			usePrev = true;
		}
		if (usePrev) {
			this._minIndex = this._minIndex - 1;
		}
	},
	getRightmostSideOfSegment: function getRightmostSideOfSegment(de, i) {
		var e = de.getEdge();
		var coord = e.getCoordinates();
		if (i < 0 || i + 1 >= coord.length) return -1;
		if (coord[i].y === coord[i + 1].y) return -1;
		var pos = Position.LEFT;
		if (coord[i].y < coord[i + 1].y) pos = Position.RIGHT;
		return pos;
	},
	getEdge: function getEdge() {
		return this._orientedDe;
	},
	checkForRightmostCoordinate: function checkForRightmostCoordinate(de) {
		var coord = de.getEdge().getCoordinates();
		for (var i = 0; i < coord.length - 1; i++) {
			if (this._minCoord === null || coord[i].x > this._minCoord.x) {
				this._minDe = de;
				this._minIndex = i;
				this._minCoord = coord[i];
			}
		}
	},
	findRightmostEdgeAtNode: function findRightmostEdgeAtNode() {
		var node = this._minDe.getNode();
		var star = node.getEdges();
		this._minDe = star.getRightmostEdge();
		if (!this._minDe.isForward()) {
			this._minDe = this._minDe.getSym();
			this._minIndex = this._minDe.getEdge().getCoordinates().length - 1;
		}
	},
	findEdge: function findEdge(dirEdgeList) {
		for (var i = dirEdgeList.iterator(); i.hasNext();) {
			var de = i.next();
			if (!de.isForward()) continue;
			this.checkForRightmostCoordinate(de);
		}
		Assert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing");
		if (this._minIndex === 0) {
			this.findRightmostEdgeAtNode();
		} else {
			this.findRightmostEdgeAtVertex();
		}
		this._orientedDe = this._minDe;
		var rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);
		if (rightmostSide === Position.LEFT) {
			this._orientedDe = this._minDe.getSym();
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return RightmostEdgeFinder;
	}
});

function LinkedList() {
  this.array_ = [];
}
LinkedList.prototype.addLast = function (e) {
  this.array_.push(e);
};
LinkedList.prototype.removeFirst = function () {
  return this.array_.shift();
};
LinkedList.prototype.isEmpty = function () {
  return this.array_.length === 0;
};

function BufferSubgraph() {
	this._finder = null;
	this._dirEdgeList = new ArrayList();
	this._nodes = new ArrayList();
	this._rightMostCoord = null;
	this._env = null;
	this._finder = new RightmostEdgeFinder();
}
extend(BufferSubgraph.prototype, {
	clearVisitedEdges: function clearVisitedEdges() {
		for (var it = this._dirEdgeList.iterator(); it.hasNext();) {
			var de = it.next();
			de.setVisited(false);
		}
	},
	getRightmostCoordinate: function getRightmostCoordinate() {
		return this._rightMostCoord;
	},
	computeNodeDepth: function computeNodeDepth(n) {
		var startEdge = null;
		for (var i = n.getEdges().iterator(); i.hasNext();) {
			var de = i.next();
			if (de.isVisited() || de.getSym().isVisited()) {
				startEdge = de;
				break;
			}
		}
		if (startEdge === null) throw new TopologyException("unable to find edge to compute depths at " + n.getCoordinate());
		n.getEdges().computeDepths(startEdge);
		for (var i = n.getEdges().iterator(); i.hasNext();) {
			var de = i.next();
			de.setVisited(true);
			this.copySymDepths(de);
		}
	},
	computeDepth: function computeDepth(outsideDepth) {
		this.clearVisitedEdges();
		var de = this._finder.getEdge();
		var n = de.getNode();
		var label = de.getLabel();
		de.setEdgeDepths(Position.RIGHT, outsideDepth);
		this.copySymDepths(de);
		this.computeDepths(de);
	},
	create: function create(node) {
		this.addReachable(node);
		this._finder.findEdge(this._dirEdgeList);
		this._rightMostCoord = this._finder.getCoordinate();
	},
	findResultEdges: function findResultEdges() {
		for (var it = this._dirEdgeList.iterator(); it.hasNext();) {
			var de = it.next();
			if (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) {
				de.setInResult(true);
			}
		}
	},
	computeDepths: function computeDepths(startEdge) {
		var nodesVisited = new HashSet();
		var nodeQueue = new LinkedList();
		var startNode = startEdge.getNode();
		nodeQueue.addLast(startNode);
		nodesVisited.add(startNode);
		startEdge.setVisited(true);
		while (!nodeQueue.isEmpty()) {
			var n = nodeQueue.removeFirst();
			nodesVisited.add(n);
			this.computeNodeDepth(n);
			for (var i = n.getEdges().iterator(); i.hasNext();) {
				var de = i.next();
				var sym = de.getSym();
				if (sym.isVisited()) continue;
				var adjNode = sym.getNode();
				if (!nodesVisited.contains(adjNode)) {
					nodeQueue.addLast(adjNode);
					nodesVisited.add(adjNode);
				}
			}
		}
	},
	compareTo: function compareTo(o) {
		var graph = o;
		if (this._rightMostCoord.x < graph._rightMostCoord.x) {
			return -1;
		}
		if (this._rightMostCoord.x > graph._rightMostCoord.x) {
			return 1;
		}
		return 0;
	},
	getEnvelope: function getEnvelope() {
		if (this._env === null) {
			var edgeEnv = new Envelope();
			for (var it = this._dirEdgeList.iterator(); it.hasNext();) {
				var dirEdge = it.next();
				var pts = dirEdge.getEdge().getCoordinates();
				for (var i = 0; i < pts.length - 1; i++) {
					edgeEnv.expandToInclude(pts[i]);
				}
			}
			this._env = edgeEnv;
		}
		return this._env;
	},
	addReachable: function addReachable(startNode) {
		var nodeStack = new Stack();
		nodeStack.add(startNode);
		while (!nodeStack.empty()) {
			var node = nodeStack.pop();
			this.add(node, nodeStack);
		}
	},
	copySymDepths: function copySymDepths(de) {
		var sym = de.getSym();
		sym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT));
		sym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT));
	},
	add: function add(node, nodeStack) {
		node.setVisited(true);
		this._nodes.add(node);
		for (var i = node.getEdges().iterator(); i.hasNext();) {
			var de = i.next();
			this._dirEdgeList.add(de);
			var sym = de.getSym();
			var symNode = sym.getNode();
			if (!symNode.isVisited()) nodeStack.push(symNode);
		}
	},
	getNodes: function getNodes() {
		return this._nodes;
	},
	getDirectedEdges: function getDirectedEdges() {
		return this._dirEdgeList;
	},
	interfaces_: function interfaces_() {
		return [Comparable];
	},
	getClass: function getClass() {
		return BufferSubgraph;
	}
});

function EdgeRing() {
	this._startDe = null;
	this._maxNodeDegree = -1;
	this._edges = new ArrayList();
	this._pts = new ArrayList();
	this._label = new Label(Location.NONE);
	this._ring = null;
	this._isHole = null;
	this._shell = null;
	this._holes = new ArrayList();
	this._geometryFactory = null;
	var start = arguments[0],
	    geometryFactory = arguments[1];
	this._geometryFactory = geometryFactory;
	this.computePoints(start);
	this.computeRing();
}
extend(EdgeRing.prototype, {
	computeRing: function computeRing() {
		if (this._ring !== null) return null;
		var coord = new Array(this._pts.size()).fill(null);
		for (var i = 0; i < this._pts.size(); i++) {
			coord[i] = this._pts.get(i);
		}
		this._ring = this._geometryFactory.createLinearRing(coord);
		this._isHole = Orientation.isCCW(this._ring.getCoordinates());
	},
	isIsolated: function isIsolated() {
		return this._label.getGeometryCount() === 1;
	},
	computePoints: function computePoints(start) {
		this._startDe = start;
		var de = start;
		var isFirstEdge = true;
		do {
			if (de === null) throw new TopologyException("Found null DirectedEdge");
			if (de.getEdgeRing() === this) throw new TopologyException("Directed Edge visited twice during ring-building at " + de.getCoordinate());
			this._edges.add(de);
			var label = de.getLabel();
			Assert.isTrue(label.isArea());
			this.mergeLabel(label);
			this.addPoints(de.getEdge(), de.isForward(), isFirstEdge);
			isFirstEdge = false;
			this.setEdgeRing(de, this);
			de = this.getNext(de);
		} while (de !== this._startDe);
	},
	getLinearRing: function getLinearRing() {
		return this._ring;
	},
	getCoordinate: function getCoordinate(i) {
		return this._pts.get(i);
	},
	computeMaxNodeDegree: function computeMaxNodeDegree() {
		this._maxNodeDegree = 0;
		var de = this._startDe;
		do {
			var node = de.getNode();
			var degree = node.getEdges().getOutgoingDegree(this);
			if (degree > this._maxNodeDegree) this._maxNodeDegree = degree;
			de = this.getNext(de);
		} while (de !== this._startDe);
		this._maxNodeDegree *= 2;
	},
	addPoints: function addPoints(edge, isForward, isFirstEdge) {
		var edgePts = edge.getCoordinates();
		if (isForward) {
			var startIndex = 1;
			if (isFirstEdge) startIndex = 0;
			for (var i = startIndex; i < edgePts.length; i++) {
				this._pts.add(edgePts[i]);
			}
		} else {
			var startIndex = edgePts.length - 2;
			if (isFirstEdge) startIndex = edgePts.length - 1;
			for (var i = startIndex; i >= 0; i--) {
				this._pts.add(edgePts[i]);
			}
		}
	},
	isHole: function isHole() {
		return this._isHole;
	},
	setInResult: function setInResult() {
		var de = this._startDe;
		do {
			de.getEdge().setInResult(true);
			de = de.getNext();
		} while (de !== this._startDe);
	},
	containsPoint: function containsPoint(p) {
		var shell = this.getLinearRing();
		var env = shell.getEnvelopeInternal();
		if (!env.contains(p)) return false;
		if (!PointLocation.isInRing(p, shell.getCoordinates())) return false;
		for (var i = this._holes.iterator(); i.hasNext();) {
			var hole = i.next();
			if (hole.containsPoint(p)) return false;
		}
		return true;
	},
	addHole: function addHole(ring) {
		this._holes.add(ring);
	},
	isShell: function isShell() {
		return this._shell === null;
	},
	getLabel: function getLabel() {
		return this._label;
	},
	getEdges: function getEdges() {
		return this._edges;
	},
	getMaxNodeDegree: function getMaxNodeDegree() {
		if (this._maxNodeDegree < 0) this.computeMaxNodeDegree();
		return this._maxNodeDegree;
	},
	getShell: function getShell() {
		return this._shell;
	},
	mergeLabel: function mergeLabel() {
		if (arguments.length === 1) {
			var deLabel = arguments[0];
			this.mergeLabel(deLabel, 0);
			this.mergeLabel(deLabel, 1);
		} else if (arguments.length === 2) {
			var _deLabel = arguments[0],
			    geomIndex = arguments[1];
			var loc = _deLabel.getLocation(geomIndex, Position.RIGHT);
			if (loc === Location.NONE) return null;
			if (this._label.getLocation(geomIndex) === Location.NONE) {
				this._label.setLocation(geomIndex, loc);
				return null;
			}
		}
	},
	setShell: function setShell(shell) {
		this._shell = shell;
		if (shell !== null) shell.addHole(this);
	},
	toPolygon: function toPolygon(geometryFactory) {
		var holeLR = new Array(this._holes.size()).fill(null);
		for (var i = 0; i < this._holes.size(); i++) {
			holeLR[i] = this._holes.get(i).getLinearRing();
		}
		var poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);
		return poly;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return EdgeRing;
	}
});

function MinimalEdgeRing() {
	var start = arguments[0],
	    geometryFactory = arguments[1];
	EdgeRing.call(this, start, geometryFactory);
}
inherits(MinimalEdgeRing, EdgeRing);
extend(MinimalEdgeRing.prototype, {
	setEdgeRing: function setEdgeRing(de, er) {
		de.setMinEdgeRing(er);
	},
	getNext: function getNext(de) {
		return de.getNextMin();
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return MinimalEdgeRing;
	}
});

function MaximalEdgeRing() {
	var start = arguments[0],
	    geometryFactory = arguments[1];
	EdgeRing.call(this, start, geometryFactory);
}
inherits(MaximalEdgeRing, EdgeRing);
extend(MaximalEdgeRing.prototype, {
	buildMinimalRings: function buildMinimalRings() {
		var minEdgeRings = new ArrayList();
		var de = this._startDe;
		do {
			if (de.getMinEdgeRing() === null) {
				var minEr = new MinimalEdgeRing(de, this._geometryFactory);
				minEdgeRings.add(minEr);
			}
			de = de.getNext();
		} while (de !== this._startDe);
		return minEdgeRings;
	},
	setEdgeRing: function setEdgeRing(de, er) {
		de.setEdgeRing(er);
	},
	linkDirectedEdgesForMinimalEdgeRings: function linkDirectedEdgesForMinimalEdgeRings() {
		var de = this._startDe;
		do {
			var node = de.getNode();
			node.getEdges().linkMinimalDirectedEdges(this);
			de = de.getNext();
		} while (de !== this._startDe);
	},
	getNext: function getNext(de) {
		return de.getNext();
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return MaximalEdgeRing;
	}
});

function PolygonBuilder() {
	this._geometryFactory = null;
	this._shellList = new ArrayList();
	var geometryFactory = arguments[0];
	this._geometryFactory = geometryFactory;
}
extend(PolygonBuilder.prototype, {
	sortShellsAndHoles: function sortShellsAndHoles(edgeRings, shellList, freeHoleList) {
		for (var it = edgeRings.iterator(); it.hasNext();) {
			var er = it.next();
			if (er.isHole()) {
				freeHoleList.add(er);
			} else {
				shellList.add(er);
			}
		}
	},
	computePolygons: function computePolygons(shellList) {
		var resultPolyList = new ArrayList();
		for (var it = shellList.iterator(); it.hasNext();) {
			var er = it.next();
			var poly = er.toPolygon(this._geometryFactory);
			resultPolyList.add(poly);
		}
		return resultPolyList;
	},
	placeFreeHoles: function placeFreeHoles(shellList, freeHoleList) {
		for (var it = freeHoleList.iterator(); it.hasNext();) {
			var hole = it.next();
			if (hole.getShell() === null) {
				var shell = this.findEdgeRingContaining(hole, shellList);
				if (shell === null) throw new TopologyException("unable to assign hole to a shell", hole.getCoordinate(0));
				hole.setShell(shell);
			}
		}
	},
	buildMinimalEdgeRings: function buildMinimalEdgeRings(maxEdgeRings, shellList, freeHoleList) {
		var edgeRings = new ArrayList();
		for (var it = maxEdgeRings.iterator(); it.hasNext();) {
			var er = it.next();
			if (er.getMaxNodeDegree() > 2) {
				er.linkDirectedEdgesForMinimalEdgeRings();
				var minEdgeRings = er.buildMinimalRings();
				var shell = this.findShell(minEdgeRings);
				if (shell !== null) {
					this.placePolygonHoles(shell, minEdgeRings);
					shellList.add(shell);
				} else {
					freeHoleList.addAll(minEdgeRings);
				}
			} else {
				edgeRings.add(er);
			}
		}
		return edgeRings;
	},
	containsPoint: function containsPoint(p) {
		for (var it = this._shellList.iterator(); it.hasNext();) {
			var er = it.next();
			if (er.containsPoint(p)) return true;
		}
		return false;
	},
	buildMaximalEdgeRings: function buildMaximalEdgeRings(dirEdges) {
		var maxEdgeRings = new ArrayList();
		for (var it = dirEdges.iterator(); it.hasNext();) {
			var de = it.next();
			if (de.isInResult() && de.getLabel().isArea()) {
				if (de.getEdgeRing() === null) {
					var er = new MaximalEdgeRing(de, this._geometryFactory);
					maxEdgeRings.add(er);
					er.setInResult();
				}
			}
		}
		return maxEdgeRings;
	},
	placePolygonHoles: function placePolygonHoles(shell, minEdgeRings) {
		for (var it = minEdgeRings.iterator(); it.hasNext();) {
			var er = it.next();
			if (er.isHole()) {
				er.setShell(shell);
			}
		}
	},
	getPolygons: function getPolygons() {
		var resultPolyList = this.computePolygons(this._shellList);
		return resultPolyList;
	},
	findEdgeRingContaining: function findEdgeRingContaining(testEr, shellList) {
		var testRing = testEr.getLinearRing();
		var testEnv = testRing.getEnvelopeInternal();
		var testPt = testRing.getCoordinateN(0);
		var minShell = null;
		var minEnv = null;
		for (var it = shellList.iterator(); it.hasNext();) {
			var tryShell = it.next();
			var tryRing = tryShell.getLinearRing();
			var tryEnv = tryRing.getEnvelopeInternal();
			if (minShell !== null) minEnv = minShell.getLinearRing().getEnvelopeInternal();
			var isContained = false;
			if (tryEnv.contains(testEnv) && PointLocation.isInRing(testPt, tryRing.getCoordinates())) isContained = true;
			if (isContained) {
				if (minShell === null || minEnv.contains(tryEnv)) {
					minShell = tryShell;
				}
			}
		}
		return minShell;
	},
	findShell: function findShell(minEdgeRings) {
		var shellCount = 0;
		var shell = null;
		for (var it = minEdgeRings.iterator(); it.hasNext();) {
			var er = it.next();
			if (!er.isHole()) {
				shell = er;
				shellCount++;
			}
		}
		Assert.isTrue(shellCount <= 1, "found two shells in MinimalEdgeRing list");
		return shell;
	},
	add: function add() {
		if (arguments.length === 1) {
			var graph = arguments[0];
			this.add(graph.getEdgeEnds(), graph.getNodes());
		} else if (arguments.length === 2) {
			var dirEdges = arguments[0],
			    nodes = arguments[1];
			PlanarGraph.linkResultDirectedEdges(nodes);
			var maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);
			var freeHoleList = new ArrayList();
			var edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);
			this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);
			this.placeFreeHoles(this._shellList, freeHoleList);
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return PolygonBuilder;
	}
});

function BufferInputLineSimplifier() {
	this._inputLine = null;
	this._distanceTol = null;
	this._isDeleted = null;
	this._angleOrientation = Orientation.COUNTERCLOCKWISE;
	var inputLine = arguments[0];
	this._inputLine = inputLine;
}
extend(BufferInputLineSimplifier.prototype, {
	isDeletable: function isDeletable(i0, i1, i2, distanceTol) {
		var p0 = this._inputLine[i0];
		var p1 = this._inputLine[i1];
		var p2 = this._inputLine[i2];
		if (!this.isConcave(p0, p1, p2)) return false;
		if (!this.isShallow(p0, p1, p2, distanceTol)) return false;
		return this.isShallowSampled(p0, p1, i0, i2, distanceTol);
	},
	deleteShallowConcavities: function deleteShallowConcavities() {
		var index = 1;
		var maxIndex = this._inputLine.length - 1;
		var midIndex = this.findNextNonDeletedIndex(index);
		var lastIndex = this.findNextNonDeletedIndex(midIndex);
		var isChanged = false;
		while (lastIndex < this._inputLine.length) {
			var isMiddleVertexDeleted = false;
			if (this.isDeletable(index, midIndex, lastIndex, this._distanceTol)) {
				this._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;
				isMiddleVertexDeleted = true;
				isChanged = true;
			}
			if (isMiddleVertexDeleted) index = lastIndex;else index = midIndex;
			midIndex = this.findNextNonDeletedIndex(index);
			lastIndex = this.findNextNonDeletedIndex(midIndex);
		}
		return isChanged;
	},
	isShallowConcavity: function isShallowConcavity(p0, p1, p2, distanceTol) {
		var orientation = Orientation.index(p0, p1, p2);
		var isAngleToSimplify = orientation === this._angleOrientation;
		if (!isAngleToSimplify) return false;
		var dist = Distance.pointToSegment(p1, p0, p2);
		return dist < distanceTol;
	},
	isShallowSampled: function isShallowSampled(p0, p2, i0, i2, distanceTol) {
		var inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);
		if (inc <= 0) inc = 1;
		for (var i = i0; i < i2; i += inc) {
			if (!this.isShallow(p0, p2, this._inputLine[i], distanceTol)) return false;
		}
		return true;
	},
	isConcave: function isConcave(p0, p1, p2) {
		var orientation = Orientation.index(p0, p1, p2);
		var isConcave = orientation === this._angleOrientation;
		return isConcave;
	},
	simplify: function simplify(distanceTol) {
		this._distanceTol = Math.abs(distanceTol);
		if (distanceTol < 0) this._angleOrientation = Orientation.CLOCKWISE;
		this._isDeleted = new Array(this._inputLine.length).fill(null);
		var isChanged = false;
		do {
			isChanged = this.deleteShallowConcavities();
		} while (isChanged);
		return this.collapseLine();
	},
	findNextNonDeletedIndex: function findNextNonDeletedIndex(index) {
		var next = index + 1;
		while (next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE) {
			next++;
		}return next;
	},
	isShallow: function isShallow(p0, p1, p2, distanceTol) {
		var dist = Distance.pointToSegment(p1, p0, p2);
		return dist < distanceTol;
	},
	collapseLine: function collapseLine() {
		var coordList = new CoordinateList();
		for (var i = 0; i < this._inputLine.length; i++) {
			if (this._isDeleted[i] !== BufferInputLineSimplifier.DELETE) coordList.add(this._inputLine[i]);
		}
		return coordList.toCoordinateArray();
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return BufferInputLineSimplifier;
	}
});
BufferInputLineSimplifier.simplify = function (inputLine, distanceTol) {
	var simp = new BufferInputLineSimplifier(inputLine);
	return simp.simplify(distanceTol);
};
BufferInputLineSimplifier.INIT = 0;
BufferInputLineSimplifier.DELETE = 1;
BufferInputLineSimplifier.KEEP = 1;
BufferInputLineSimplifier.NUM_PTS_TO_CHECK = 10;

function OffsetSegmentString() {
	this._ptList = null;
	this._precisionModel = null;
	this._minimimVertexDistance = 0.0;
	this._ptList = new ArrayList();
}
extend(OffsetSegmentString.prototype, {
	getCoordinates: function getCoordinates() {
		var coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);
		return coord;
	},
	setPrecisionModel: function setPrecisionModel(precisionModel) {
		this._precisionModel = precisionModel;
	},
	addPt: function addPt(pt) {
		var bufPt = new Coordinate(pt);
		this._precisionModel.makePrecise(bufPt);
		if (this.isRedundant(bufPt)) return null;
		this._ptList.add(bufPt);
	},
	reverse: function reverse() {},
	addPts: function addPts(pt, isForward) {
		if (isForward) {
			for (var i = 0; i < pt.length; i++) {
				this.addPt(pt[i]);
			}
		} else {
			for (var i = pt.length - 1; i >= 0; i--) {
				this.addPt(pt[i]);
			}
		}
	},
	isRedundant: function isRedundant(pt) {
		if (this._ptList.size() < 1) return false;
		var lastPt = this._ptList.get(this._ptList.size() - 1);
		var ptDist = pt.distance(lastPt);
		if (ptDist < this._minimimVertexDistance) return true;
		return false;
	},
	toString: function toString() {
		var fact = new GeometryFactory();
		var line = fact.createLineString(this.getCoordinates());
		return line.toString();
	},
	closeRing: function closeRing() {
		if (this._ptList.size() < 1) return null;
		var startPt = new Coordinate(this._ptList.get(0));
		var lastPt = this._ptList.get(this._ptList.size() - 1);
		var last2Pt = null;
		if (this._ptList.size() >= 2) last2Pt = this._ptList.get(this._ptList.size() - 2);
		if (startPt.equals(lastPt)) return null;
		this._ptList.add(startPt);
	},
	setMinimumVertexDistance: function setMinimumVertexDistance(minimimVertexDistance) {
		this._minimimVertexDistance = minimimVertexDistance;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return OffsetSegmentString;
	}
});
OffsetSegmentString.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);

function OffsetSegmentGenerator() {
	this._maxCurveSegmentError = 0.0;
	this._filletAngleQuantum = null;
	this._closingSegLengthFactor = 1;
	this._segList = null;
	this._distance = 0.0;
	this._precisionModel = null;
	this._bufParams = null;
	this._li = null;
	this._s0 = null;
	this._s1 = null;
	this._s2 = null;
	this._seg0 = new LineSegment();
	this._seg1 = new LineSegment();
	this._offset0 = new LineSegment();
	this._offset1 = new LineSegment();
	this._side = 0;
	this._hasNarrowConcaveAngle = false;
	var precisionModel = arguments[0],
	    bufParams = arguments[1],
	    distance = arguments[2];
	this._precisionModel = precisionModel;
	this._bufParams = bufParams;
	this._li = new RobustLineIntersector();
	this._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();
	if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR;
	this.init(distance);
}
extend(OffsetSegmentGenerator.prototype, {
	addNextSegment: function addNextSegment(p, addStartPoint) {
		this._s0 = this._s1;
		this._s1 = this._s2;
		this._s2 = p;
		this._seg0.setCoordinates(this._s0, this._s1);
		this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);
		this._seg1.setCoordinates(this._s1, this._s2);
		this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);
		if (this._s1.equals(this._s2)) return null;
		var orientation = Orientation.index(this._s0, this._s1, this._s2);
		var outsideTurn = orientation === Orientation.CLOCKWISE && this._side === Position.LEFT || orientation === Orientation.COUNTERCLOCKWISE && this._side === Position.RIGHT;
		if (orientation === 0) {
			this.addCollinear(addStartPoint);
		} else if (outsideTurn) {
			this.addOutsideTurn(orientation, addStartPoint);
		} else {
			this.addInsideTurn(orientation, addStartPoint);
		}
	},
	addLineEndCap: function addLineEndCap(p0, p1) {
		var seg = new LineSegment(p0, p1);
		var offsetL = new LineSegment();
		this.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL);
		var offsetR = new LineSegment();
		this.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR);
		var dx = p1.x - p0.x;
		var dy = p1.y - p0.y;
		var angle = Math.atan2(dy, dx);
		switch (this._bufParams.getEndCapStyle()) {
			case BufferParameters.CAP_ROUND:
				this._segList.addPt(offsetL.p1);
				this.addDirectedFillet(p1, angle + Math.PI / 2, angle - Math.PI / 2, Orientation.CLOCKWISE, this._distance);
				this._segList.addPt(offsetR.p1);
				break;
			case BufferParameters.CAP_FLAT:
				this._segList.addPt(offsetL.p1);
				this._segList.addPt(offsetR.p1);
				break;
			case BufferParameters.CAP_SQUARE:
				var squareCapSideOffset = new Coordinate();
				squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);
				squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);
				var squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);
				var squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);
				this._segList.addPt(squareCapLOffset);
				this._segList.addPt(squareCapROffset);
				break;
		}
	},
	getCoordinates: function getCoordinates() {
		var pts = this._segList.getCoordinates();
		return pts;
	},
	addMitreJoin: function addMitreJoin(p, offset0, offset1, distance) {
		var isMitreWithinLimit = true;
		var intPt = null;
		try {
			intPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);
			var mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);
			if (mitreRatio > this._bufParams.getMitreLimit()) isMitreWithinLimit = false;
		} catch (ex) {
			if (ex instanceof NotRepresentableException) {
				intPt = new Coordinate(0, 0);
				isMitreWithinLimit = false;
			} else throw ex;
		} finally {}
		if (isMitreWithinLimit) {
			this._segList.addPt(intPt);
		} else {
			this.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());
		}
	},
	addOutsideTurn: function addOutsideTurn(orientation, addStartPoint) {
		if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {
			this._segList.addPt(this._offset0.p1);
			return null;
		}
		if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {
			this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);
		} else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {
			this.addBevelJoin(this._offset0, this._offset1);
		} else {
			if (addStartPoint) this._segList.addPt(this._offset0.p1);
			this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);
			this._segList.addPt(this._offset1.p0);
		}
	},
	createSquare: function createSquare(p) {
		this._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance));
		this._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance));
		this._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance));
		this._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance));
		this._segList.closeRing();
	},
	addSegments: function addSegments(pt, isForward) {
		this._segList.addPts(pt, isForward);
	},
	addFirstSegment: function addFirstSegment() {
		this._segList.addPt(this._offset1.p0);
	},
	addCornerFillet: function addCornerFillet(p, p0, p1, direction, radius) {
		var dx0 = p0.x - p.x;
		var dy0 = p0.y - p.y;
		var startAngle = Math.atan2(dy0, dx0);
		var dx1 = p1.x - p.x;
		var dy1 = p1.y - p.y;
		var endAngle = Math.atan2(dy1, dx1);
		if (direction === Orientation.CLOCKWISE) {
			if (startAngle <= endAngle) startAngle += 2.0 * Math.PI;
		} else {
			if (startAngle >= endAngle) startAngle -= 2.0 * Math.PI;
		}
		this._segList.addPt(p0);
		this.addDirectedFillet(p, startAngle, endAngle, direction, radius);
		this._segList.addPt(p1);
	},
	addLastSegment: function addLastSegment() {
		this._segList.addPt(this._offset1.p1);
	},
	initSideSegments: function initSideSegments(s1, s2, side) {
		this._s1 = s1;
		this._s2 = s2;
		this._side = side;
		this._seg1.setCoordinates(s1, s2);
		this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);
	},
	addLimitedMitreJoin: function addLimitedMitreJoin(offset0, offset1, distance, mitreLimit) {
		var basePt = this._seg0.p1;
		var ang0 = Angle.angle(basePt, this._seg0.p0);
		var ang1 = Angle.angle(basePt, this._seg1.p1);
		var angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);
		var angDiffHalf = angDiff / 2;
		var midAng = Angle.normalize(ang0 + angDiffHalf);
		var mitreMidAng = Angle.normalize(midAng + Math.PI);
		var mitreDist = mitreLimit * distance;
		var bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));
		var bevelHalfLen = distance - bevelDelta;
		var bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);
		var bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);
		var bevelMidPt = new Coordinate(bevelMidX, bevelMidY);
		var mitreMidLine = new LineSegment(basePt, bevelMidPt);
		var bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);
		var bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);
		if (this._side === Position.LEFT) {
			this._segList.addPt(bevelEndLeft);
			this._segList.addPt(bevelEndRight);
		} else {
			this._segList.addPt(bevelEndRight);
			this._segList.addPt(bevelEndLeft);
		}
	},
	addDirectedFillet: function addDirectedFillet(p, startAngle, endAngle, direction, radius) {
		var directionFactor = direction === Orientation.CLOCKWISE ? -1 : 1;
		var totalAngle = Math.abs(startAngle - endAngle);
		var nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);
		if (nSegs < 1) return null;
		var initAngle = null,
		    currAngleInc = null;
		initAngle = 0.0;
		currAngleInc = totalAngle / nSegs;
		var currAngle = initAngle;
		var pt = new Coordinate();
		while (currAngle < totalAngle) {
			var angle = startAngle + directionFactor * currAngle;
			pt.x = p.x + radius * Math.cos(angle);
			pt.y = p.y + radius * Math.sin(angle);
			this._segList.addPt(pt);
			currAngle += currAngleInc;
		}
	},
	computeOffsetSegment: function computeOffsetSegment(seg, side, distance, offset) {
		var sideSign = side === Position.LEFT ? 1 : -1;
		var dx = seg.p1.x - seg.p0.x;
		var dy = seg.p1.y - seg.p0.y;
		var len = Math.sqrt(dx * dx + dy * dy);
		var ux = sideSign * distance * dx / len;
		var uy = sideSign * distance * dy / len;
		offset.p0.x = seg.p0.x - uy;
		offset.p0.y = seg.p0.y + ux;
		offset.p1.x = seg.p1.x - uy;
		offset.p1.y = seg.p1.y + ux;
	},
	addInsideTurn: function addInsideTurn(orientation, addStartPoint) {
		this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);
		if (this._li.hasIntersection()) {
			this._segList.addPt(this._li.getIntersection(0));
		} else {
			this._hasNarrowConcaveAngle = true;
			if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {
				this._segList.addPt(this._offset0.p1);
			} else {
				this._segList.addPt(this._offset0.p1);
				if (this._closingSegLengthFactor > 0) {
					var mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
					this._segList.addPt(mid0);
					var mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
					this._segList.addPt(mid1);
				} else {
					this._segList.addPt(this._s1);
				}
				this._segList.addPt(this._offset1.p0);
			}
		}
	},
	createCircle: function createCircle(p) {
		var pt = new Coordinate(p.x + this._distance, p.y);
		this._segList.addPt(pt);
		this.addDirectedFillet(p, 0.0, 2.0 * Math.PI, -1, this._distance);
		this._segList.closeRing();
	},
	addBevelJoin: function addBevelJoin(offset0, offset1) {
		this._segList.addPt(offset0.p1);
		this._segList.addPt(offset1.p0);
	},
	init: function init(distance) {
		this._distance = distance;
		this._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0));
		this._segList = new OffsetSegmentString();
		this._segList.setPrecisionModel(this._precisionModel);
		this._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
	},
	addCollinear: function addCollinear(addStartPoint) {
		this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
		var numInt = this._li.getIntersectionNum();
		if (numInt >= 2) {
			if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {
				if (addStartPoint) this._segList.addPt(this._offset0.p1);
				this._segList.addPt(this._offset1.p0);
			} else {
				this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, Orientation.CLOCKWISE, this._distance);
			}
		}
	},
	closeRing: function closeRing() {
		this._segList.closeRing();
	},
	hasNarrowConcaveAngle: function hasNarrowConcaveAngle() {
		return this._hasNarrowConcaveAngle;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return OffsetSegmentGenerator;
	}
});
OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR = 1.0E-3;
OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-3;
OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-6;
OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR = 80;

function OffsetCurveBuilder() {
	this._distance = 0.0;
	this._precisionModel = null;
	this._bufParams = null;
	var precisionModel = arguments[0],
	    bufParams = arguments[1];
	this._precisionModel = precisionModel;
	this._bufParams = bufParams;
}
extend(OffsetCurveBuilder.prototype, {
	getOffsetCurve: function getOffsetCurve(inputPts, distance) {
		this._distance = distance;
		if (distance === 0.0) return null;
		var isRightSide = distance < 0.0;
		var posDistance = Math.abs(distance);
		var segGen = this.getSegGen(posDistance);
		if (inputPts.length <= 1) {
			this.computePointCurve(inputPts[0], segGen);
		} else {
			this.computeOffsetCurve(inputPts, isRightSide, segGen);
		}
		var curvePts = segGen.getCoordinates();
		if (isRightSide) CoordinateArrays.reverse(curvePts);
		return curvePts;
	},
	computeSingleSidedBufferCurve: function computeSingleSidedBufferCurve(inputPts, isRightSide, segGen) {
		var distTol = this.simplifyTolerance(this._distance);
		if (isRightSide) {
			segGen.addSegments(inputPts, true);
			var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
			var n2 = simp2.length - 1;
			segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
			segGen.addFirstSegment();
			for (var i = n2 - 2; i >= 0; i--) {
				segGen.addNextSegment(simp2[i], true);
			}
		} else {
			segGen.addSegments(inputPts, false);
			var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
			var n1 = simp1.length - 1;
			segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
			segGen.addFirstSegment();
			for (var i = 2; i <= n1; i++) {
				segGen.addNextSegment(simp1[i], true);
			}
		}
		segGen.addLastSegment();
		segGen.closeRing();
	},
	computeRingBufferCurve: function computeRingBufferCurve(inputPts, side, segGen) {
		var distTol = this.simplifyTolerance(this._distance);
		if (side === Position.RIGHT) distTol = -distTol;
		var simp = BufferInputLineSimplifier.simplify(inputPts, distTol);
		var n = simp.length - 1;
		segGen.initSideSegments(simp[n - 1], simp[0], side);
		for (var i = 1; i <= n; i++) {
			var addStartPoint = i !== 1;
			segGen.addNextSegment(simp[i], addStartPoint);
		}
		segGen.closeRing();
	},
	computeLineBufferCurve: function computeLineBufferCurve(inputPts, segGen) {
		var distTol = this.simplifyTolerance(this._distance);
		var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
		var n1 = simp1.length - 1;
		segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
		for (var i = 2; i <= n1; i++) {
			segGen.addNextSegment(simp1[i], true);
		}
		segGen.addLastSegment();
		segGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);
		var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
		var n2 = simp2.length - 1;
		segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
		for (var i = n2 - 2; i >= 0; i--) {
			segGen.addNextSegment(simp2[i], true);
		}
		segGen.addLastSegment();
		segGen.addLineEndCap(simp2[1], simp2[0]);
		segGen.closeRing();
	},
	computePointCurve: function computePointCurve(pt, segGen) {
		switch (this._bufParams.getEndCapStyle()) {
			case BufferParameters.CAP_ROUND:
				segGen.createCircle(pt);
				break;
			case BufferParameters.CAP_SQUARE:
				segGen.createSquare(pt);
				break;
		}
	},
	getLineCurve: function getLineCurve(inputPts, distance) {
		this._distance = distance;
		if (distance < 0.0 && !this._bufParams.isSingleSided()) return null;
		if (distance === 0.0) return null;
		var posDistance = Math.abs(distance);
		var segGen = this.getSegGen(posDistance);
		if (inputPts.length <= 1) {
			this.computePointCurve(inputPts[0], segGen);
		} else {
			if (this._bufParams.isSingleSided()) {
				var isRightSide = distance < 0.0;
				this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);
			} else this.computeLineBufferCurve(inputPts, segGen);
		}
		var lineCoord = segGen.getCoordinates();
		return lineCoord;
	},
	getBufferParameters: function getBufferParameters() {
		return this._bufParams;
	},
	simplifyTolerance: function simplifyTolerance(bufDistance) {
		return bufDistance * this._bufParams.getSimplifyFactor();
	},
	getRingCurve: function getRingCurve(inputPts, side, distance) {
		this._distance = distance;
		if (inputPts.length <= 2) return this.getLineCurve(inputPts, distance);
		if (distance === 0.0) {
			return OffsetCurveBuilder.copyCoordinates(inputPts);
		}
		var segGen = this.getSegGen(distance);
		this.computeRingBufferCurve(inputPts, side, segGen);
		return segGen.getCoordinates();
	},
	computeOffsetCurve: function computeOffsetCurve(inputPts, isRightSide, segGen) {
		var distTol = this.simplifyTolerance(this._distance);
		if (isRightSide) {
			var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);
			var n2 = simp2.length - 1;
			segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);
			segGen.addFirstSegment();
			for (var i = n2 - 2; i >= 0; i--) {
				segGen.addNextSegment(simp2[i], true);
			}
		} else {
			var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);
			var n1 = simp1.length - 1;
			segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);
			segGen.addFirstSegment();
			for (var i = 2; i <= n1; i++) {
				segGen.addNextSegment(simp1[i], true);
			}
		}
		segGen.addLastSegment();
	},
	getSegGen: function getSegGen(distance) {
		return new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return OffsetCurveBuilder;
	}
});
OffsetCurveBuilder.copyCoordinates = function (pts) {
	var copy = new Array(pts.length).fill(null);
	for (var i = 0; i < copy.length; i++) {
		copy[i] = new Coordinate(pts[i]);
	}
	return copy;
};

function SubgraphDepthLocater() {
	this._subgraphs = null;
	this._seg = new LineSegment();
	var subgraphs = arguments[0];
	this._subgraphs = subgraphs;
}
extend(SubgraphDepthLocater.prototype, {
	findStabbedSegments: function findStabbedSegments() {
		if (arguments.length === 1) {
			var stabbingRayLeftPt = arguments[0];
			var stabbedSegments = new ArrayList();
			for (var i = this._subgraphs.iterator(); i.hasNext();) {
				var bsg = i.next();
				var env = bsg.getEnvelope();
				if (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) continue;
				this.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);
			}
			return stabbedSegments;
		} else if (arguments.length === 3) {
			if (hasInterface(arguments[2], List) && arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge) {
				var _stabbingRayLeftPt = arguments[0],
				    dirEdge = arguments[1],
				    _stabbedSegments = arguments[2];
				var pts = dirEdge.getEdge().getCoordinates();
				for (var i = 0; i < pts.length - 1; i++) {
					this._seg.p0 = pts[i];
					this._seg.p1 = pts[i + 1];
					if (this._seg.p0.y > this._seg.p1.y) this._seg.reverse();
					var maxx = Math.max(this._seg.p0.x, this._seg.p1.x);
					if (maxx < _stabbingRayLeftPt.x) continue;
					if (this._seg.isHorizontal()) continue;
					if (_stabbingRayLeftPt.y < this._seg.p0.y || _stabbingRayLeftPt.y > this._seg.p1.y) continue;
					if (Orientation.index(this._seg.p0, this._seg.p1, _stabbingRayLeftPt) === Orientation.RIGHT) continue;
					var depth = dirEdge.getDepth(Position.LEFT);
					if (!this._seg.p0.equals(pts[i])) depth = dirEdge.getDepth(Position.RIGHT);
					var ds = new DepthSegment(this._seg, depth);
					_stabbedSegments.add(ds);
				}
			} else if (hasInterface(arguments[2], List) && arguments[0] instanceof Coordinate && hasInterface(arguments[1], List)) {
				var _stabbingRayLeftPt2 = arguments[0],
				    dirEdges = arguments[1],
				    _stabbedSegments2 = arguments[2];
				for (var i = dirEdges.iterator(); i.hasNext();) {
					var de = i.next();
					if (!de.isForward()) continue;
					this.findStabbedSegments(_stabbingRayLeftPt2, de, _stabbedSegments2);
				}
			}
		}
	},
	getDepth: function getDepth(p) {
		var stabbedSegments = this.findStabbedSegments(p);
		if (stabbedSegments.size() === 0) return 0;
		var ds = Collections.min(stabbedSegments);
		return ds._leftDepth;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return SubgraphDepthLocater;
	}
});
function DepthSegment() {
	this._upwardSeg = null;
	this._leftDepth = null;
	var seg = arguments[0],
	    depth = arguments[1];
	this._upwardSeg = new LineSegment(seg);
	this._leftDepth = depth;
}
extend(DepthSegment.prototype, {
	compareTo: function compareTo(obj) {
		var other = obj;
		if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) return 1;
		if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) return -1;
		var orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);
		if (orientIndex !== 0) return orientIndex;
		orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);
		if (orientIndex !== 0) return orientIndex;
		return this._upwardSeg.compareTo(other._upwardSeg);
	},
	compareX: function compareX(seg0, seg1) {
		var compare0 = seg0.p0.compareTo(seg1.p0);
		if (compare0 !== 0) return compare0;
		return seg0.p1.compareTo(seg1.p1);
	},
	toString: function toString() {
		return this._upwardSeg.toString();
	},
	interfaces_: function interfaces_() {
		return [Comparable];
	},
	getClass: function getClass() {
		return DepthSegment;
	}
});
SubgraphDepthLocater.DepthSegment = DepthSegment;

function OffsetCurveSetBuilder() {
	this._inputGeom = null;
	this._distance = null;
	this._curveBuilder = null;
	this._curveList = new ArrayList();
	var inputGeom = arguments[0],
	    distance = arguments[1],
	    curveBuilder = arguments[2];
	this._inputGeom = inputGeom;
	this._distance = distance;
	this._curveBuilder = curveBuilder;
}
extend(OffsetCurveSetBuilder.prototype, {
	addPoint: function addPoint(p) {
		if (this._distance <= 0.0) return null;
		var coord = p.getCoordinates();
		var curve = this._curveBuilder.getLineCurve(coord, this._distance);
		this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);
	},
	addPolygon: function addPolygon(p) {
		var offsetDistance = this._distance;
		var offsetSide = Position.LEFT;
		if (this._distance < 0.0) {
			offsetDistance = -this._distance;
			offsetSide = Position.RIGHT;
		}
		var shell = p.getExteriorRing();
		var shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());
		if (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) return null;
		if (this._distance <= 0.0 && shellCoord.length < 3) return null;
		this.addPolygonRing(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);
		for (var i = 0; i < p.getNumInteriorRing(); i++) {
			var hole = p.getInteriorRingN(i);
			var holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());
			if (this._distance > 0.0 && this.isErodedCompletely(hole, -this._distance)) continue;
			this.addPolygonRing(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);
		}
	},
	isTriangleErodedCompletely: function isTriangleErodedCompletely(triangleCoord, bufferDistance) {
		var tri = new Triangle(triangleCoord[0], triangleCoord[1], triangleCoord[2]);
		var inCentre = tri.inCentre();
		var distToCentre = Distance.pointToSegment(inCentre, tri.p0, tri.p1);
		return distToCentre < Math.abs(bufferDistance);
	},
	addLineString: function addLineString(line) {
		if (this._distance <= 0.0 && !this._curveBuilder.getBufferParameters().isSingleSided()) return null;
		var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());
		var curve = this._curveBuilder.getLineCurve(coord, this._distance);
		this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);
	},
	addCurve: function addCurve(coord, leftLoc, rightLoc) {
		if (coord === null || coord.length < 2) return null;
		var e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc));
		this._curveList.add(e);
	},
	getCurves: function getCurves() {
		this.add(this._inputGeom);
		return this._curveList;
	},
	addPolygonRing: function addPolygonRing(coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {
		if (offsetDistance === 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) return null;
		var leftLoc = cwLeftLoc;
		var rightLoc = cwRightLoc;
		if (coord.length >= LinearRing.MINIMUM_VALID_SIZE && Orientation.isCCW(coord)) {
			leftLoc = cwRightLoc;
			rightLoc = cwLeftLoc;
			side = Position.opposite(side);
		}
		var curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);
		this.addCurve(curve, leftLoc, rightLoc);
	},
	add: function add(g) {
		if (g.isEmpty()) return null;
		if (g instanceof Polygon) this.addPolygon(g);else if (g instanceof LineString) this.addLineString(g);else if (g instanceof Point) this.addPoint(g);else if (g instanceof MultiPoint) this.addCollection(g);else if (g instanceof MultiLineString) this.addCollection(g);else if (g instanceof MultiPolygon) this.addCollection(g);else if (g instanceof GeometryCollection) this.addCollection(g);else throw new UnsupportedOperationException(g.getClass().getName());
	},
	isErodedCompletely: function isErodedCompletely(ring, bufferDistance) {
		var ringCoord = ring.getCoordinates();
		if (ringCoord.length < 4) return bufferDistance < 0;
		if (ringCoord.length === 4) return this.isTriangleErodedCompletely(ringCoord, bufferDistance);
		var env = ring.getEnvelopeInternal();
		var envMinDimension = Math.min(env.getHeight(), env.getWidth());
		if (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) return true;
		return false;
	},
	addCollection: function addCollection(gc) {
		for (var i = 0; i < gc.getNumGeometries(); i++) {
			var g = gc.getGeometryN(i);
			this.add(g);
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return OffsetCurveSetBuilder;
	}
});

function EdgeEndStar() {
	this._edgeMap = new TreeMap();
	this._edgeList = null;
	this._ptInAreaLocation = [Location.NONE, Location.NONE];
}
extend(EdgeEndStar.prototype, {
	getNextCW: function getNextCW(ee) {
		this.getEdges();
		var i = this._edgeList.indexOf(ee);
		var iNextCW = i - 1;
		if (i === 0) iNextCW = this._edgeList.size() - 1;
		return this._edgeList.get(iNextCW);
	},
	propagateSideLabels: function propagateSideLabels(geomIndex) {
		var startLoc = Location.NONE;
		for (var it = this.iterator(); it.hasNext();) {
			var e = it.next();
			var label = e.getLabel();
			if (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) startLoc = label.getLocation(geomIndex, Position.LEFT);
		}
		if (startLoc === Location.NONE) return null;
		var currLoc = startLoc;
		for (var it = this.iterator(); it.hasNext();) {
			var e = it.next();
			var label = e.getLabel();
			if (label.getLocation(geomIndex, Position.ON) === Location.NONE) label.setLocation(geomIndex, Position.ON, currLoc);
			if (label.isArea(geomIndex)) {
				var leftLoc = label.getLocation(geomIndex, Position.LEFT);
				var rightLoc = label.getLocation(geomIndex, Position.RIGHT);
				if (rightLoc !== Location.NONE) {
					if (rightLoc !== currLoc) throw new TopologyException("side location conflict", e.getCoordinate());
					if (leftLoc === Location.NONE) {
						Assert.shouldNeverReachHere("found single null side (at " + e.getCoordinate() + ")");
					}
					currLoc = leftLoc;
				} else {
					Assert.isTrue(label.getLocation(geomIndex, Position.LEFT) === Location.NONE, "found single null side");
					label.setLocation(geomIndex, Position.RIGHT, currLoc);
					label.setLocation(geomIndex, Position.LEFT, currLoc);
				}
			}
		}
	},
	getCoordinate: function getCoordinate() {
		var it = this.iterator();
		if (!it.hasNext()) return null;
		var e = it.next();
		return e.getCoordinate();
	},
	print: function print(out) {
		System.out.println("EdgeEndStar:   " + this.getCoordinate());
		for (var it = this.iterator(); it.hasNext();) {
			var e = it.next();
			e.print(out);
		}
	},
	isAreaLabelsConsistent: function isAreaLabelsConsistent(geomGraph) {
		this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());
		return this.checkAreaLabelsConsistent(0);
	},
	checkAreaLabelsConsistent: function checkAreaLabelsConsistent(geomIndex) {
		var edges = this.getEdges();
		if (edges.size() <= 0) return true;
		var lastEdgeIndex = edges.size() - 1;
		var startLabel = edges.get(lastEdgeIndex).getLabel();
		var startLoc = startLabel.getLocation(geomIndex, Position.LEFT);
		Assert.isTrue(startLoc !== Location.NONE, "Found unlabelled area edge");
		var currLoc = startLoc;
		for (var it = this.iterator(); it.hasNext();) {
			var e = it.next();
			var label = e.getLabel();
			Assert.isTrue(label.isArea(geomIndex), "Found non-area edge");
			var leftLoc = label.getLocation(geomIndex, Position.LEFT);
			var rightLoc = label.getLocation(geomIndex, Position.RIGHT);
			if (leftLoc === rightLoc) {
				return false;
			}
			if (rightLoc !== currLoc) {
				return false;
			}
			currLoc = leftLoc;
		}
		return true;
	},
	findIndex: function findIndex(eSearch) {
		this.iterator();
		for (var i = 0; i < this._edgeList.size(); i++) {
			var e = this._edgeList.get(i);
			if (e === eSearch) return i;
		}
		return -1;
	},
	iterator: function iterator() {
		return this.getEdges().iterator();
	},
	getEdges: function getEdges() {
		if (this._edgeList === null) {
			this._edgeList = new ArrayList(this._edgeMap.values());
		}
		return this._edgeList;
	},
	getLocation: function getLocation(geomIndex, p, geom) {
		if (this._ptInAreaLocation[geomIndex] === Location.NONE) {
			this._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());
		}
		return this._ptInAreaLocation[geomIndex];
	},
	toString: function toString() {
		var buf = new StringBuffer();
		buf.append("EdgeEndStar:   " + this.getCoordinate());
		buf.append("\n");
		for (var it = this.iterator(); it.hasNext();) {
			var e = it.next();
			buf.append(e);
			buf.append("\n");
		}
		return buf.toString();
	},
	computeEdgeEndLabels: function computeEdgeEndLabels(boundaryNodeRule) {
		for (var it = this.iterator(); it.hasNext();) {
			var ee = it.next();
			ee.computeLabel(boundaryNodeRule);
		}
	},
	computeLabelling: function computeLabelling(geomGraph) {
		this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());
		this.propagateSideLabels(0);
		this.propagateSideLabels(1);
		var hasDimensionalCollapseEdge = [false, false];
		for (var it = this.iterator(); it.hasNext();) {
			var e = it.next();
			var label = e.getLabel();
			for (var geomi = 0; geomi < 2; geomi++) {
				if (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) hasDimensionalCollapseEdge[geomi] = true;
			}
		}
		for (var it = this.iterator(); it.hasNext();) {
			var e = it.next();
			var label = e.getLabel();
			for (var geomi = 0; geomi < 2; geomi++) {
				if (label.isAnyNull(geomi)) {
					var loc = Location.NONE;
					if (hasDimensionalCollapseEdge[geomi]) {
						loc = Location.EXTERIOR;
					} else {
						var p = e.getCoordinate();
						loc = this.getLocation(geomi, p, geomGraph);
					}
					label.setAllLocationsIfNull(geomi, loc);
				}
			}
		}
	},
	getDegree: function getDegree() {
		return this._edgeMap.size();
	},
	insertEdgeEnd: function insertEdgeEnd(e, obj) {
		this._edgeMap.put(e, obj);
		this._edgeList = null;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return EdgeEndStar;
	}
});

function DirectedEdgeStar() {
	EdgeEndStar.apply(this);
	this._resultAreaEdgeList = null;
	this._label = null;
	this._SCANNING_FOR_INCOMING = 1;
	this._LINKING_TO_OUTGOING = 2;
}
inherits(DirectedEdgeStar, EdgeEndStar);
extend(DirectedEdgeStar.prototype, {
	linkResultDirectedEdges: function linkResultDirectedEdges() {
		this.getResultAreaEdges();
		var firstOut = null;
		var incoming = null;
		var state = this._SCANNING_FOR_INCOMING;
		for (var i = 0; i < this._resultAreaEdgeList.size(); i++) {
			var nextOut = this._resultAreaEdgeList.get(i);
			var nextIn = nextOut.getSym();
			if (!nextOut.getLabel().isArea()) continue;
			if (firstOut === null && nextOut.isInResult()) firstOut = nextOut;
			switch (state) {
				case this._SCANNING_FOR_INCOMING:
					if (!nextIn.isInResult()) continue;
					incoming = nextIn;
					state = this._LINKING_TO_OUTGOING;
					break;
				case this._LINKING_TO_OUTGOING:
					if (!nextOut.isInResult()) continue;
					incoming.setNext(nextOut);
					state = this._SCANNING_FOR_INCOMING;
					break;
			}
		}
		if (state === this._LINKING_TO_OUTGOING) {
			if (firstOut === null) throw new TopologyException("no outgoing dirEdge found", this.getCoordinate());
			Assert.isTrue(firstOut.isInResult(), "unable to link last incoming dirEdge");
			incoming.setNext(firstOut);
		}
	},
	insert: function insert(ee) {
		var de = ee;
		this.insertEdgeEnd(de, de);
	},
	getRightmostEdge: function getRightmostEdge() {
		var edges = this.getEdges();
		var size = edges.size();
		if (size < 1) return null;
		var de0 = edges.get(0);
		if (size === 1) return de0;
		var deLast = edges.get(size - 1);
		var quad0 = de0.getQuadrant();
		var quad1 = deLast.getQuadrant();
		if (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) return de0;else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) return deLast;else {
			if (de0.getDy() !== 0) return de0;else if (deLast.getDy() !== 0) return deLast;
		}
		Assert.shouldNeverReachHere("found two horizontal edges incident on node");
		return null;
	},
	print: function print(out) {
		System.out.println("DirectedEdgeStar: " + this.getCoordinate());
		for (var it = this.iterator(); it.hasNext();) {
			var de = it.next();
			out.print("out ");
			de.print(out);
			out.println();
			out.print("in ");
			de.getSym().print(out);
			out.println();
		}
	},
	getResultAreaEdges: function getResultAreaEdges() {
		if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList;
		this._resultAreaEdgeList = new ArrayList();
		for (var it = this.iterator(); it.hasNext();) {
			var de = it.next();
			if (de.isInResult() || de.getSym().isInResult()) this._resultAreaEdgeList.add(de);
		}
		return this._resultAreaEdgeList;
	},
	updateLabelling: function updateLabelling(nodeLabel) {
		for (var it = this.iterator(); it.hasNext();) {
			var de = it.next();
			var label = de.getLabel();
			label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));
			label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));
		}
	},
	linkAllDirectedEdges: function linkAllDirectedEdges() {
		this.getEdges();
		var prevOut = null;
		var firstIn = null;
		for (var i = this._edgeList.size() - 1; i >= 0; i--) {
			var nextOut = this._edgeList.get(i);
			var nextIn = nextOut.getSym();
			if (firstIn === null) firstIn = nextIn;
			if (prevOut !== null) nextIn.setNext(prevOut);
			prevOut = nextOut;
		}
		firstIn.setNext(prevOut);
	},
	computeDepths: function computeDepths() {
		if (arguments.length === 1) {
			var de = arguments[0];
			var edgeIndex = this.findIndex(de);
			var label = de.getLabel();
			var startDepth = de.getDepth(Position.LEFT);
			var targetLastDepth = de.getDepth(Position.RIGHT);
			var nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);
			var lastDepth = this.computeDepths(0, edgeIndex, nextDepth);
			if (lastDepth !== targetLastDepth) throw new TopologyException("depth mismatch at " + de.getCoordinate());
		} else if (arguments.length === 3) {
			var startIndex = arguments[0],
			    endIndex = arguments[1],
			    _startDepth = arguments[2];
			var currDepth = _startDepth;
			for (var i = startIndex; i < endIndex; i++) {
				var nextDe = this._edgeList.get(i);
				var label = nextDe.getLabel();
				nextDe.setEdgeDepths(Position.RIGHT, currDepth);
				currDepth = nextDe.getDepth(Position.LEFT);
			}
			return currDepth;
		}
	},
	mergeSymLabels: function mergeSymLabels() {
		for (var it = this.iterator(); it.hasNext();) {
			var de = it.next();
			var label = de.getLabel();
			label.merge(de.getSym().getLabel());
		}
	},
	linkMinimalDirectedEdges: function linkMinimalDirectedEdges(er) {
		var firstOut = null;
		var incoming = null;
		var state = this._SCANNING_FOR_INCOMING;
		for (var i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {
			var nextOut = this._resultAreaEdgeList.get(i);
			var nextIn = nextOut.getSym();
			if (firstOut === null && nextOut.getEdgeRing() === er) firstOut = nextOut;
			switch (state) {
				case this._SCANNING_FOR_INCOMING:
					if (nextIn.getEdgeRing() !== er) continue;
					incoming = nextIn;
					state = this._LINKING_TO_OUTGOING;
					break;
				case this._LINKING_TO_OUTGOING:
					if (nextOut.getEdgeRing() !== er) continue;
					incoming.setNextMin(nextOut);
					state = this._SCANNING_FOR_INCOMING;
					break;
			}
		}
		if (state === this._LINKING_TO_OUTGOING) {
			Assert.isTrue(firstOut !== null, "found null for first outgoing dirEdge");
			Assert.isTrue(firstOut.getEdgeRing() === er, "unable to link last incoming dirEdge");
			incoming.setNextMin(firstOut);
		}
	},
	getOutgoingDegree: function getOutgoingDegree() {
		if (arguments.length === 0) {
			var degree = 0;
			for (var it = this.iterator(); it.hasNext();) {
				var de = it.next();
				if (de.isInResult()) degree++;
			}
			return degree;
		} else if (arguments.length === 1) {
			var er = arguments[0];
			var degree = 0;
			for (var it = this.iterator(); it.hasNext();) {
				var de = it.next();
				if (de.getEdgeRing() === er) degree++;
			}
			return degree;
		}
	},
	getLabel: function getLabel() {
		return this._label;
	},
	findCoveredLineEdges: function findCoveredLineEdges() {
		var startLoc = Location.NONE;
		for (var it = this.iterator(); it.hasNext();) {
			var nextOut = it.next();
			var nextIn = nextOut.getSym();
			if (!nextOut.isLineEdge()) {
				if (nextOut.isInResult()) {
					startLoc = Location.INTERIOR;
					break;
				}
				if (nextIn.isInResult()) {
					startLoc = Location.EXTERIOR;
					break;
				}
			}
		}
		if (startLoc === Location.NONE) return null;
		var currLoc = startLoc;
		for (var it = this.iterator(); it.hasNext();) {
			var nextOut = it.next();
			var nextIn = nextOut.getSym();
			if (nextOut.isLineEdge()) {
				nextOut.getEdge().setCovered(currLoc === Location.INTERIOR);
			} else {
				if (nextOut.isInResult()) currLoc = Location.EXTERIOR;
				if (nextIn.isInResult()) currLoc = Location.INTERIOR;
			}
		}
	},
	computeLabelling: function computeLabelling(geom) {
		EdgeEndStar.prototype.computeLabelling.call(this, geom);
		this._label = new Label(Location.NONE);
		for (var it = this.iterator(); it.hasNext();) {
			var ee = it.next();
			var e = ee.getEdge();
			var eLabel = e.getLabel();
			for (var i = 0; i < 2; i++) {
				var eLoc = eLabel.getLocation(i);
				if (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) this._label.setLocation(i, Location.INTERIOR);
			}
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return DirectedEdgeStar;
	}
});

function OverlayNodeFactory() {
	NodeFactory.apply(this);
}
inherits(OverlayNodeFactory, NodeFactory);
extend(OverlayNodeFactory.prototype, {
	createNode: function createNode(coord) {
		return new Node$1(coord, new DirectedEdgeStar());
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return OverlayNodeFactory;
	}
});

function OrientedCoordinateArray() {
	this._pts = null;
	this._orientation = null;
	var pts = arguments[0];
	this._pts = pts;
	this._orientation = OrientedCoordinateArray.orientation(pts);
}
extend(OrientedCoordinateArray.prototype, {
	compareTo: function compareTo(o1) {
		var oca = o1;
		var comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);
		return comp;
	},
	interfaces_: function interfaces_() {
		return [Comparable];
	},
	getClass: function getClass() {
		return OrientedCoordinateArray;
	}
});
OrientedCoordinateArray.orientation = function (pts) {
	return CoordinateArrays.increasingDirection(pts) === 1;
};
OrientedCoordinateArray.compareOriented = function (pts1, orientation1, pts2, orientation2) {
	var dir1 = orientation1 ? 1 : -1;
	var dir2 = orientation2 ? 1 : -1;
	var limit1 = orientation1 ? pts1.length : -1;
	var limit2 = orientation2 ? pts2.length : -1;
	var i1 = orientation1 ? 0 : pts1.length - 1;
	var i2 = orientation2 ? 0 : pts2.length - 1;
	while (true) {
		var compPt = pts1[i1].compareTo(pts2[i2]);
		if (compPt !== 0) return compPt;
		i1 += dir1;
		i2 += dir2;
		var done1 = i1 === limit1;
		var done2 = i2 === limit2;
		if (done1 && !done2) return -1;
		if (!done1 && done2) return 1;
		if (done1 && done2) return 0;
	}
};

function EdgeList() {
	this._edges = new ArrayList();
	this._ocaMap = new TreeMap();
}
extend(EdgeList.prototype, {
	print: function print(out) {
		out.print("MULTILINESTRING ( ");
		for (var j = 0; j < this._edges.size(); j++) {
			var e = this._edges.get(j);
			if (j > 0) out.print(",");
			out.print("(");
			var pts = e.getCoordinates();
			for (var i = 0; i < pts.length; i++) {
				if (i > 0) out.print(",");
				out.print(pts[i].x + " " + pts[i].y);
			}
			out.println(")");
		}
		out.print(")  ");
	},
	addAll: function addAll(edgeColl) {
		for (var i = edgeColl.iterator(); i.hasNext();) {
			this.add(i.next());
		}
	},
	findEdgeIndex: function findEdgeIndex(e) {
		for (var i = 0; i < this._edges.size(); i++) {
			if (this._edges.get(i).equals(e)) return i;
		}
		return -1;
	},
	iterator: function iterator() {
		return this._edges.iterator();
	},
	getEdges: function getEdges() {
		return this._edges;
	},
	get: function get(i) {
		return this._edges.get(i);
	},
	findEqualEdge: function findEqualEdge(e) {
		var oca = new OrientedCoordinateArray(e.getCoordinates());
		var matchEdge = this._ocaMap.get(oca);
		return matchEdge;
	},
	add: function add(e) {
		this._edges.add(e);
		var oca = new OrientedCoordinateArray(e.getCoordinates());
		this._ocaMap.put(oca, e);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return EdgeList;
	}
});

function SegmentIntersector$1() {}
extend(SegmentIntersector$1.prototype, {
	processIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {},
	isDone: function isDone() {},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return SegmentIntersector$1;
	}
});

function IntersectionAdder() {
	this._hasIntersection = false;
	this._hasProper = false;
	this._hasProperInterior = false;
	this._hasInterior = false;
	this._properIntersectionPoint = null;
	this._li = null;
	this._isSelfIntersection = null;
	this.numIntersections = 0;
	this.numInteriorIntersections = 0;
	this.numProperIntersections = 0;
	this.numTests = 0;
	var li = arguments[0];
	this._li = li;
}
extend(IntersectionAdder.prototype, {
	isTrivialIntersection: function isTrivialIntersection(e0, segIndex0, e1, segIndex1) {
		if (e0 === e1) {
			if (this._li.getIntersectionNum() === 1) {
				if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) return true;
				if (e0.isClosed()) {
					var maxSegIndex = e0.size() - 1;
					if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) {
						return true;
					}
				}
			}
		}
		return false;
	},
	getProperIntersectionPoint: function getProperIntersectionPoint() {
		return this._properIntersectionPoint;
	},
	hasProperInteriorIntersection: function hasProperInteriorIntersection() {
		return this._hasProperInterior;
	},
	getLineIntersector: function getLineIntersector() {
		return this._li;
	},
	hasProperIntersection: function hasProperIntersection() {
		return this._hasProper;
	},
	processIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {
		if (e0 === e1 && segIndex0 === segIndex1) return null;
		this.numTests++;
		var p00 = e0.getCoordinates()[segIndex0];
		var p01 = e0.getCoordinates()[segIndex0 + 1];
		var p10 = e1.getCoordinates()[segIndex1];
		var p11 = e1.getCoordinates()[segIndex1 + 1];
		this._li.computeIntersection(p00, p01, p10, p11);
		if (this._li.hasIntersection()) {
			this.numIntersections++;
			if (this._li.isInteriorIntersection()) {
				this.numInteriorIntersections++;
				this._hasInterior = true;
			}
			if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
				this._hasIntersection = true;
				e0.addIntersections(this._li, segIndex0, 0);
				e1.addIntersections(this._li, segIndex1, 1);
				if (this._li.isProper()) {
					this.numProperIntersections++;
					this._hasProper = true;
					this._hasProperInterior = true;
				}
			}
		}
	},
	hasIntersection: function hasIntersection() {
		return this._hasIntersection;
	},
	isDone: function isDone() {
		return false;
	},
	hasInteriorIntersection: function hasInteriorIntersection() {
		return this._hasInterior;
	},
	interfaces_: function interfaces_() {
		return [SegmentIntersector$1];
	},
	getClass: function getClass() {
		return IntersectionAdder;
	}
});
IntersectionAdder.isAdjacentSegments = function (i1, i2) {
	return Math.abs(i1 - i2) === 1;
};

function BufferBuilder() {
	this._bufParams = null;
	this._workingPrecisionModel = null;
	this._workingNoder = null;
	this._geomFact = null;
	this._graph = null;
	this._edgeList = new EdgeList();
	var bufParams = arguments[0];
	this._bufParams = bufParams;
}
extend(BufferBuilder.prototype, {
	setWorkingPrecisionModel: function setWorkingPrecisionModel(pm) {
		this._workingPrecisionModel = pm;
	},
	insertUniqueEdge: function insertUniqueEdge(e) {
		var existingEdge = this._edgeList.findEqualEdge(e);
		if (existingEdge !== null) {
			var existingLabel = existingEdge.getLabel();
			var labelToMerge = e.getLabel();
			if (!existingEdge.isPointwiseEqual(e)) {
				labelToMerge = new Label(e.getLabel());
				labelToMerge.flip();
			}
			existingLabel.merge(labelToMerge);
			var mergeDelta = BufferBuilder.depthDelta(labelToMerge);
			var existingDelta = existingEdge.getDepthDelta();
			var newDelta = existingDelta + mergeDelta;
			existingEdge.setDepthDelta(newDelta);
		} else {
			this._edgeList.add(e);
			e.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));
		}
	},
	buildSubgraphs: function buildSubgraphs(subgraphList, polyBuilder) {
		var processedGraphs = new ArrayList();
		for (var i = subgraphList.iterator(); i.hasNext();) {
			var subgraph = i.next();
			var p = subgraph.getRightmostCoordinate();
			var locater = new SubgraphDepthLocater(processedGraphs);
			var outsideDepth = locater.getDepth(p);
			subgraph.computeDepth(outsideDepth);
			subgraph.findResultEdges();
			processedGraphs.add(subgraph);
			polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());
		}
	},
	createSubgraphs: function createSubgraphs(graph) {
		var subgraphList = new ArrayList();
		for (var i = graph.getNodes().iterator(); i.hasNext();) {
			var node = i.next();
			if (!node.isVisited()) {
				var subgraph = new BufferSubgraph();
				subgraph.create(node);
				subgraphList.add(subgraph);
			}
		}
		Collections.sort(subgraphList, Collections.reverseOrder());
		return subgraphList;
	},
	createEmptyResultGeometry: function createEmptyResultGeometry() {
		var emptyGeom = this._geomFact.createPolygon();
		return emptyGeom;
	},
	getNoder: function getNoder(precisionModel) {
		if (this._workingNoder !== null) return this._workingNoder;
		var noder = new MCIndexNoder();
		var li = new RobustLineIntersector();
		li.setPrecisionModel(precisionModel);
		noder.setSegmentIntersector(new IntersectionAdder(li));
		return noder;
	},
	buffer: function buffer(g, distance) {
		var precisionModel = this._workingPrecisionModel;
		if (precisionModel === null) precisionModel = g.getPrecisionModel();
		this._geomFact = g.getFactory();
		var curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams);
		var curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder);
		var bufferSegStrList = curveSetBuilder.getCurves();
		if (bufferSegStrList.size() <= 0) {
			return this.createEmptyResultGeometry();
		}
		this.computeNodedEdges(bufferSegStrList, precisionModel);
		this._graph = new PlanarGraph(new OverlayNodeFactory());
		this._graph.addEdges(this._edgeList.getEdges());
		var subgraphList = this.createSubgraphs(this._graph);
		var polyBuilder = new PolygonBuilder(this._geomFact);
		this.buildSubgraphs(subgraphList, polyBuilder);
		var resultPolyList = polyBuilder.getPolygons();
		if (resultPolyList.size() <= 0) {
			return this.createEmptyResultGeometry();
		}
		var resultGeom = this._geomFact.buildGeometry(resultPolyList);
		return resultGeom;
	},
	computeNodedEdges: function computeNodedEdges(bufferSegStrList, precisionModel) {
		var noder = this.getNoder(precisionModel);
		noder.computeNodes(bufferSegStrList);
		var nodedSegStrings = noder.getNodedSubstrings();
		for (var i = nodedSegStrings.iterator(); i.hasNext();) {
			var segStr = i.next();
			var pts = segStr.getCoordinates();
			if (pts.length === 2 && pts[0].equals2D(pts[1])) continue;
			var oldLabel = segStr.getData();
			var edge = new Edge(segStr.getCoordinates(), new Label(oldLabel));
			this.insertUniqueEdge(edge);
		}
	},
	setNoder: function setNoder(noder) {
		this._workingNoder = noder;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return BufferBuilder;
	}
});
BufferBuilder.depthDelta = function (label) {
	var lLoc = label.getLocation(0, Position.LEFT);
	var rLoc = label.getLocation(0, Position.RIGHT);
	if (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) return 1;else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) return -1;
	return 0;
};
BufferBuilder.convertSegStrings = function (it) {
	var fact = new GeometryFactory();
	var lines = new ArrayList();
	while (it.hasNext()) {
		var ss = it.next();
		var line = fact.createLineString(ss.getCoordinates());
		lines.add(line);
	}
	return fact.buildGeometry(lines);
};

function NodingValidator() {
	this._li = new RobustLineIntersector();
	this._segStrings = null;
	var segStrings = arguments[0];
	this._segStrings = segStrings;
}
extend(NodingValidator.prototype, {
	checkEndPtVertexIntersections: function checkEndPtVertexIntersections() {
		if (arguments.length === 0) {
			for (var i = this._segStrings.iterator(); i.hasNext();) {
				var ss = i.next();
				var pts = ss.getCoordinates();
				this.checkEndPtVertexIntersections(pts[0], this._segStrings);
				this.checkEndPtVertexIntersections(pts[pts.length - 1], this._segStrings);
			}
		} else if (arguments.length === 2) {
			var testPt = arguments[0],
			    segStrings = arguments[1];
			for (var i = segStrings.iterator(); i.hasNext();) {
				var ss = i.next();
				var pts = ss.getCoordinates();
				for (var j = 1; j < pts.length - 1; j++) {
					if (pts[j].equals(testPt)) throw new RuntimeException("found endpt/interior pt intersection at index " + j + " :pt " + testPt);
				}
			}
		}
	},
	checkInteriorIntersections: function checkInteriorIntersections() {
		if (arguments.length === 0) {
			for (var i = this._segStrings.iterator(); i.hasNext();) {
				var ss0 = i.next();
				for (var j = this._segStrings.iterator(); j.hasNext();) {
					var ss1 = j.next();
					this.checkInteriorIntersections(ss0, ss1);
				}
			}
		} else if (arguments.length === 2) {
			var _ss = arguments[0],
			    _ss2 = arguments[1];
			var pts0 = _ss.getCoordinates();
			var pts1 = _ss2.getCoordinates();
			for (var i0 = 0; i0 < pts0.length - 1; i0++) {
				for (var i1 = 0; i1 < pts1.length - 1; i1++) {
					this.checkInteriorIntersections(_ss, i0, _ss2, i1);
				}
			}
		} else if (arguments.length === 4) {
			var e0 = arguments[0],
			    segIndex0 = arguments[1],
			    e1 = arguments[2],
			    segIndex1 = arguments[3];
			if (e0 === e1 && segIndex0 === segIndex1) return null;
			var p00 = e0.getCoordinates()[segIndex0];
			var p01 = e0.getCoordinates()[segIndex0 + 1];
			var p10 = e1.getCoordinates()[segIndex1];
			var p11 = e1.getCoordinates()[segIndex1 + 1];
			this._li.computeIntersection(p00, p01, p10, p11);
			if (this._li.hasIntersection()) {
				if (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) {
					throw new RuntimeException("found non-noded intersection at " + p00 + "-" + p01 + " and " + p10 + "-" + p11);
				}
			}
		}
	},
	checkValid: function checkValid() {
		this.checkEndPtVertexIntersections();
		this.checkInteriorIntersections();
		this.checkCollapses();
	},
	checkCollapses: function checkCollapses() {
		if (arguments.length === 0) {
			for (var i = this._segStrings.iterator(); i.hasNext();) {
				var ss = i.next();
				this.checkCollapses(ss);
			}
		} else if (arguments.length === 1) {
			var _ss3 = arguments[0];
			var pts = _ss3.getCoordinates();
			for (var i = 0; i < pts.length - 2; i++) {
				this.checkCollapse(pts[i], pts[i + 1], pts[i + 2]);
			}
		}
	},
	hasInteriorIntersection: function hasInteriorIntersection(li, p0, p1) {
		for (var i = 0; i < li.getIntersectionNum(); i++) {
			var intPt = li.getIntersection(i);
			if (!(intPt.equals(p0) || intPt.equals(p1))) return true;
		}
		return false;
	},
	checkCollapse: function checkCollapse(p0, p1, p2) {
		if (p0.equals(p2)) throw new RuntimeException("found non-noded collapse at " + NodingValidator.fact.createLineString([p0, p1, p2]));
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return NodingValidator;
	}
});
NodingValidator.fact = new GeometryFactory();

function HotPixel() {
	this._li = null;
	this._pt = null;
	this._originalPt = null;
	this._ptScaled = null;
	this._p0Scaled = null;
	this._p1Scaled = null;
	this._scaleFactor = null;
	this._minx = null;
	this._maxx = null;
	this._miny = null;
	this._maxy = null;
	this._corner = new Array(4).fill(null);
	this._safeEnv = null;
	var pt = arguments[0],
	    scaleFactor = arguments[1],
	    li = arguments[2];
	this._originalPt = pt;
	this._pt = pt;
	this._scaleFactor = scaleFactor;
	this._li = li;
	if (scaleFactor <= 0) throw new IllegalArgumentException("Scale factor must be non-zero");
	if (scaleFactor !== 1.0) {
		this._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));
		this._p0Scaled = new Coordinate();
		this._p1Scaled = new Coordinate();
	}
	this.initCorners(this._pt);
}
extend(HotPixel.prototype, {
	intersectsScaled: function intersectsScaled(p0, p1) {
		var segMinx = Math.min(p0.x, p1.x);
		var segMaxx = Math.max(p0.x, p1.x);
		var segMiny = Math.min(p0.y, p1.y);
		var segMaxy = Math.max(p0.y, p1.y);
		var isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;
		if (isOutsidePixelEnv) return false;
		var intersects = this.intersectsToleranceSquare(p0, p1);
		Assert.isTrue(!(isOutsidePixelEnv && intersects), "Found bad envelope test");
		return intersects;
	},
	initCorners: function initCorners(pt) {
		var tolerance = 0.5;
		this._minx = pt.x - tolerance;
		this._maxx = pt.x + tolerance;
		this._miny = pt.y - tolerance;
		this._maxy = pt.y + tolerance;
		this._corner[0] = new Coordinate(this._maxx, this._maxy);
		this._corner[1] = new Coordinate(this._minx, this._maxy);
		this._corner[2] = new Coordinate(this._minx, this._miny);
		this._corner[3] = new Coordinate(this._maxx, this._miny);
	},
	intersects: function intersects(p0, p1) {
		if (this._scaleFactor === 1.0) return this.intersectsScaled(p0, p1);
		this.copyScaled(p0, this._p0Scaled);
		this.copyScaled(p1, this._p1Scaled);
		return this.intersectsScaled(this._p0Scaled, this._p1Scaled);
	},
	scale: function scale(val) {
		return Math.round(val * this._scaleFactor);
	},
	getCoordinate: function getCoordinate() {
		return this._originalPt;
	},
	copyScaled: function copyScaled(p, pScaled) {
		pScaled.x = this.scale(p.x);
		pScaled.y = this.scale(p.y);
	},
	getSafeEnvelope: function getSafeEnvelope() {
		if (this._safeEnv === null) {
			var safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
			this._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);
		}
		return this._safeEnv;
	},
	intersectsPixelClosure: function intersectsPixelClosure(p0, p1) {
		this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
		if (this._li.hasIntersection()) return true;
		this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
		if (this._li.hasIntersection()) return true;
		this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
		if (this._li.hasIntersection()) return true;
		this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
		if (this._li.hasIntersection()) return true;
		return false;
	},
	intersectsToleranceSquare: function intersectsToleranceSquare(p0, p1) {
		var intersectsLeft = false;
		var intersectsBottom = false;
		this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
		if (this._li.isProper()) return true;
		this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
		if (this._li.isProper()) return true;
		if (this._li.hasIntersection()) intersectsLeft = true;
		this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
		if (this._li.isProper()) return true;
		if (this._li.hasIntersection()) intersectsBottom = true;
		this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
		if (this._li.isProper()) return true;
		if (intersectsLeft && intersectsBottom) return true;
		if (p0.equals(this._pt)) return true;
		if (p1.equals(this._pt)) return true;
		return false;
	},
	addSnappedNode: function addSnappedNode(segStr, segIndex) {
		var p0 = segStr.getCoordinate(segIndex);
		var p1 = segStr.getCoordinate(segIndex + 1);
		if (this.intersects(p0, p1)) {
			segStr.addIntersection(this.getCoordinate(), segIndex);
			return true;
		}
		return false;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return HotPixel;
	}
});
HotPixel.SAFE_ENV_EXPANSION_FACTOR = 0.75;

function MCIndexPointSnapper() {
	this._index = null;
	var index = arguments[0];
	this._index = index;
}
extend(MCIndexPointSnapper.prototype, {
	snap: function snap() {
		if (arguments.length === 1) {
			var hotPixel = arguments[0];
			return this.snap(hotPixel, null, -1);
		} else if (arguments.length === 3) {
			var _hotPixel = arguments[0],
			    parentEdge = arguments[1],
			    hotPixelVertexIndex = arguments[2];
			var pixelEnv = _hotPixel.getSafeEnvelope();
			var hotPixelSnapAction = new HotPixelSnapAction(_hotPixel, parentEdge, hotPixelVertexIndex);
			this._index.query(pixelEnv, {
				interfaces_: function interfaces_() {
					return [ItemVisitor];
				},
				visitItem: function visitItem(item) {
					var testChain = item;
					testChain.select(pixelEnv, hotPixelSnapAction);
				}
			});
			return hotPixelSnapAction.isNodeAdded();
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return MCIndexPointSnapper;
	}
});
function HotPixelSnapAction() {
	MonotoneChainSelectAction.apply(this);
	this._hotPixel = null;
	this._parentEdge = null;
	this._hotPixelVertexIndex = null;
	this._isNodeAdded = false;
	var hotPixel = arguments[0],
	    parentEdge = arguments[1],
	    hotPixelVertexIndex = arguments[2];
	this._hotPixel = hotPixel;
	this._parentEdge = parentEdge;
	this._hotPixelVertexIndex = hotPixelVertexIndex;
}
inherits(HotPixelSnapAction, MonotoneChainSelectAction);
extend(HotPixelSnapAction.prototype, {
	isNodeAdded: function isNodeAdded() {
		return this._isNodeAdded;
	},
	select: function select() {
		if (arguments.length === 2 && Number.isInteger(arguments[1]) && arguments[0] instanceof MonotoneChain) {
			var mc = arguments[0],
			    startIndex = arguments[1];
			var ss = mc.getContext();
			if (this._parentEdge !== null) {
				if (ss === this._parentEdge && startIndex === this._hotPixelVertexIndex) return null;
			}
			this._isNodeAdded = this._hotPixel.addSnappedNode(ss, startIndex);
		} else return MonotoneChainSelectAction.prototype.select.apply(this, arguments);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return HotPixelSnapAction;
	}
});
MCIndexPointSnapper.HotPixelSnapAction = HotPixelSnapAction;

function InteriorIntersectionFinderAdder() {
	this._li = null;
	this._interiorIntersections = null;
	var li = arguments[0];
	this._li = li;
	this._interiorIntersections = new ArrayList();
}
extend(InteriorIntersectionFinderAdder.prototype, {
	processIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {
		if (e0 === e1 && segIndex0 === segIndex1) return null;
		var p00 = e0.getCoordinates()[segIndex0];
		var p01 = e0.getCoordinates()[segIndex0 + 1];
		var p10 = e1.getCoordinates()[segIndex1];
		var p11 = e1.getCoordinates()[segIndex1 + 1];
		this._li.computeIntersection(p00, p01, p10, p11);
		if (this._li.hasIntersection()) {
			if (this._li.isInteriorIntersection()) {
				for (var intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) {
					this._interiorIntersections.add(this._li.getIntersection(intIndex));
				}
				e0.addIntersections(this._li, segIndex0, 0);
				e1.addIntersections(this._li, segIndex1, 1);
			}
		}
	},
	isDone: function isDone() {
		return false;
	},
	getInteriorIntersections: function getInteriorIntersections() {
		return this._interiorIntersections;
	},
	interfaces_: function interfaces_() {
		return [SegmentIntersector$1];
	},
	getClass: function getClass() {
		return InteriorIntersectionFinderAdder;
	}
});

function MCIndexSnapRounder() {
	this._pm = null;
	this._li = null;
	this._scaleFactor = null;
	this._noder = null;
	this._pointSnapper = null;
	this._nodedSegStrings = null;
	var pm = arguments[0];
	this._pm = pm;
	this._li = new RobustLineIntersector();
	this._li.setPrecisionModel(pm);
	this._scaleFactor = pm.getScale();
}
extend(MCIndexSnapRounder.prototype, {
	checkCorrectness: function checkCorrectness(inputSegmentStrings) {
		var resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);
		var nv = new NodingValidator(resultSegStrings);
		try {
			nv.checkValid();
		} catch (ex) {
			if (ex instanceof Exception) {
				ex.printStackTrace();
			} else throw ex;
		} finally {}
	},
	getNodedSubstrings: function getNodedSubstrings() {
		return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);
	},
	snapRound: function snapRound(segStrings, li) {
		var intersections = this.findInteriorIntersections(segStrings, li);
		this.computeIntersectionSnaps(intersections);
		this.computeVertexSnaps(segStrings);
	},
	findInteriorIntersections: function findInteriorIntersections(segStrings, li) {
		var intFinderAdder = new InteriorIntersectionFinderAdder(li);
		this._noder.setSegmentIntersector(intFinderAdder);
		this._noder.computeNodes(segStrings);
		return intFinderAdder.getInteriorIntersections();
	},
	computeVertexSnaps: function computeVertexSnaps() {
		if (hasInterface(arguments[0], Collection)) {
			var edges = arguments[0];
			for (var i0 = edges.iterator(); i0.hasNext();) {
				var edge0 = i0.next();
				this.computeVertexSnaps(edge0);
			}
		} else if (arguments[0] instanceof NodedSegmentString) {
			var e = arguments[0];
			var pts0 = e.getCoordinates();
			for (var i = 0; i < pts0.length; i++) {
				var hotPixel = new HotPixel(pts0[i], this._scaleFactor, this._li);
				var isNodeAdded = this._pointSnapper.snap(hotPixel, e, i);
				if (isNodeAdded) {
					e.addIntersection(pts0[i], i);
				}
			}
		}
	},
	computeNodes: function computeNodes(inputSegmentStrings) {
		this._nodedSegStrings = inputSegmentStrings;
		this._noder = new MCIndexNoder();
		this._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex());
		this.snapRound(inputSegmentStrings, this._li);
	},
	computeIntersectionSnaps: function computeIntersectionSnaps(snapPts) {
		for (var it = snapPts.iterator(); it.hasNext();) {
			var snapPt = it.next();
			var hotPixel = new HotPixel(snapPt, this._scaleFactor, this._li);
			this._pointSnapper.snap(hotPixel);
		}
	},
	interfaces_: function interfaces_() {
		return [Noder];
	},
	getClass: function getClass() {
		return MCIndexSnapRounder;
	}
});

function BufferOp() {
	this._argGeom = null;
	this._distance = null;
	this._bufParams = new BufferParameters();
	this._resultGeometry = null;
	this._saveException = null;
	if (arguments.length === 1) {
		var g = arguments[0];
		this._argGeom = g;
	} else if (arguments.length === 2) {
		var _g = arguments[0],
		    bufParams = arguments[1];
		this._argGeom = _g;
		this._bufParams = bufParams;
	}
}
extend(BufferOp.prototype, {
	bufferFixedPrecision: function bufferFixedPrecision(fixedPM) {
		var noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale());
		var bufBuilder = new BufferBuilder(this._bufParams);
		bufBuilder.setWorkingPrecisionModel(fixedPM);
		bufBuilder.setNoder(noder);
		this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
	},
	bufferReducedPrecision: function bufferReducedPrecision() {
		if (arguments.length === 0) {
			for (var precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {
				try {
					this.bufferReducedPrecision(precDigits);
				} catch (ex) {
					if (ex instanceof TopologyException) {
						this._saveException = ex;
					} else throw ex;
				} finally {}
				if (this._resultGeometry !== null) return null;
			}
			throw this._saveException;
		} else if (arguments.length === 1) {
			var precisionDigits = arguments[0];
			var sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);
			var fixedPM = new PrecisionModel(sizeBasedScaleFactor);
			this.bufferFixedPrecision(fixedPM);
		}
	},
	computeGeometry: function computeGeometry() {
		this.bufferOriginalPrecision();
		if (this._resultGeometry !== null) return null;
		var argPM = this._argGeom.getFactory().getPrecisionModel();
		if (argPM.getType() === PrecisionModel.FIXED) this.bufferFixedPrecision(argPM);else this.bufferReducedPrecision();
	},
	setQuadrantSegments: function setQuadrantSegments(quadrantSegments) {
		this._bufParams.setQuadrantSegments(quadrantSegments);
	},
	bufferOriginalPrecision: function bufferOriginalPrecision() {
		try {
			var bufBuilder = new BufferBuilder(this._bufParams);
			this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
		} catch (ex) {
			if (ex instanceof RuntimeException) {
				this._saveException = ex;
			} else throw ex;
		} finally {}
	},
	getResultGeometry: function getResultGeometry(distance) {
		this._distance = distance;
		this.computeGeometry();
		return this._resultGeometry;
	},
	setEndCapStyle: function setEndCapStyle(endCapStyle) {
		this._bufParams.setEndCapStyle(endCapStyle);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return BufferOp;
	}
});
BufferOp.bufferOp = function () {
	if (arguments.length === 2) {
		var g = arguments[0],
		    distance = arguments[1];
		var gBuf = new BufferOp(g);
		var geomBuf = gBuf.getResultGeometry(distance);
		return geomBuf;
	} else if (arguments.length === 3) {
		if (Number.isInteger(arguments[2]) && arguments[0] instanceof Geometry && typeof arguments[1] === "number") {
			var _g2 = arguments[0],
			    _distance = arguments[1],
			    quadrantSegments = arguments[2];
			var bufOp = new BufferOp(_g2);
			bufOp.setQuadrantSegments(quadrantSegments);
			var geomBuf = bufOp.getResultGeometry(_distance);
			return geomBuf;
		} else if (arguments[2] instanceof BufferParameters && arguments[0] instanceof Geometry && typeof arguments[1] === "number") {
			var _g3 = arguments[0],
			    _distance2 = arguments[1],
			    params = arguments[2];
			var bufOp = new BufferOp(_g3, params);
			var geomBuf = bufOp.getResultGeometry(_distance2);
			return geomBuf;
		}
	} else if (arguments.length === 4) {
		var _g4 = arguments[0],
		    _distance3 = arguments[1],
		    _quadrantSegments = arguments[2],
		    endCapStyle = arguments[3];
		var bufOp = new BufferOp(_g4);
		bufOp.setQuadrantSegments(_quadrantSegments);
		bufOp.setEndCapStyle(endCapStyle);
		var geomBuf = bufOp.getResultGeometry(_distance3);
		return geomBuf;
	}
};
BufferOp.precisionScaleFactor = function (g, distance, maxPrecisionDigits) {
	var env = g.getEnvelopeInternal();
	var envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));
	var expandByDistance = distance > 0.0 ? distance : 0.0;
	var bufEnvMax = envMax + 2 * expandByDistance;
	var bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);
	var minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;
	var scaleFactor = Math.pow(10.0, minUnitLog10);
	return scaleFactor;
};
BufferOp.CAP_ROUND = BufferParameters.CAP_ROUND;
BufferOp.CAP_BUTT = BufferParameters.CAP_FLAT;
BufferOp.CAP_FLAT = BufferParameters.CAP_FLAT;
BufferOp.CAP_SQUARE = BufferParameters.CAP_SQUARE;
BufferOp.MAX_PRECISION_DIGITS = 12;



var buffer = Object.freeze({
	BufferOp: BufferOp,
	BufferParameters: BufferParameters
});

function PolygonExtracter() {
	this._comps = null;
	var comps = arguments[0];
	this._comps = comps;
}
extend(PolygonExtracter.prototype, {
	filter: function filter(geom) {
		if (geom instanceof Polygon) this._comps.add(geom);
	},
	interfaces_: function interfaces_() {
		return [GeometryFilter];
	},
	getClass: function getClass() {
		return PolygonExtracter;
	}
});
PolygonExtracter.getPolygons = function () {
	if (arguments.length === 1) {
		var geom = arguments[0];
		return PolygonExtracter.getPolygons(geom, new ArrayList());
	} else if (arguments.length === 2) {
		var _geom = arguments[0],
		    list = arguments[1];
		if (_geom instanceof Polygon) {
			list.add(_geom);
		} else if (_geom instanceof GeometryCollection) {
			_geom.apply(new PolygonExtracter(list));
		}
		return list;
	}
};

function GeometryLocation() {
	this._component = null;
	this._segIndex = null;
	this._pt = null;
	if (arguments.length === 2) {
		var component = arguments[0],
		    pt = arguments[1];
		GeometryLocation.call(this, component, GeometryLocation.INSIDE_AREA, pt);
	} else if (arguments.length === 3) {
		var _component = arguments[0],
		    segIndex = arguments[1],
		    _pt = arguments[2];
		this._component = _component;
		this._segIndex = segIndex;
		this._pt = _pt;
	}
}
extend(GeometryLocation.prototype, {
	isInsideArea: function isInsideArea() {
		return this._segIndex === GeometryLocation.INSIDE_AREA;
	},
	getCoordinate: function getCoordinate() {
		return this._pt;
	},
	getGeometryComponent: function getGeometryComponent() {
		return this._component;
	},
	getSegmentIndex: function getSegmentIndex() {
		return this._segIndex;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return GeometryLocation;
	}
});
GeometryLocation.INSIDE_AREA = -1;

function PointExtracter() {
	this._pts = null;
	var pts = arguments[0];
	this._pts = pts;
}
extend(PointExtracter.prototype, {
	filter: function filter(geom) {
		if (geom instanceof Point) this._pts.add(geom);
	},
	interfaces_: function interfaces_() {
		return [GeometryFilter];
	},
	getClass: function getClass() {
		return PointExtracter;
	}
});
PointExtracter.getPoints = function () {
	if (arguments.length === 1) {
		var geom = arguments[0];
		if (geom instanceof Point) {
			return Collections.singletonList(geom);
		}
		return PointExtracter.getPoints(geom, new ArrayList());
	} else if (arguments.length === 2) {
		var _geom = arguments[0],
		    list = arguments[1];
		if (_geom instanceof Point) {
			list.add(_geom);
		} else if (_geom instanceof GeometryCollection) {
			_geom.apply(new PointExtracter(list));
		}
		return list;
	}
};

function ConnectedElementLocationFilter() {
	this._locations = null;
	var locations = arguments[0];
	this._locations = locations;
}
extend(ConnectedElementLocationFilter.prototype, {
	filter: function filter(geom) {
		if (geom instanceof Point || geom instanceof LineString || geom instanceof Polygon) this._locations.add(new GeometryLocation(geom, 0, geom.getCoordinate()));
	},
	interfaces_: function interfaces_() {
		return [GeometryFilter];
	},
	getClass: function getClass() {
		return ConnectedElementLocationFilter;
	}
});
ConnectedElementLocationFilter.getLocations = function (geom) {
	var locations = new ArrayList();
	geom.apply(new ConnectedElementLocationFilter(locations));
	return locations;
};

function DistanceOp() {
	this._geom = null;
	this._terminateDistance = 0.0;
	this._ptLocator = new PointLocator();
	this._minDistanceLocation = null;
	this._minDistance = Double.MAX_VALUE;
	if (arguments.length === 2) {
		var g0 = arguments[0],
		    g1 = arguments[1];
		DistanceOp.call(this, g0, g1, 0.0);
	} else if (arguments.length === 3) {
		var _g = arguments[0],
		    _g2 = arguments[1],
		    terminateDistance = arguments[2];
		this._geom = new Array(2).fill(null);
		this._geom[0] = _g;
		this._geom[1] = _g2;
		this._terminateDistance = terminateDistance;
	}
}
extend(DistanceOp.prototype, {
	computeContainmentDistance: function computeContainmentDistance() {
		if (arguments.length === 0) {
			var locPtPoly = new Array(2).fill(null);
			this.computeContainmentDistance(0, locPtPoly);
			if (this._minDistance <= this._terminateDistance) return null;
			this.computeContainmentDistance(1, locPtPoly);
		} else if (arguments.length === 2) {
			var polyGeomIndex = arguments[0],
			    _locPtPoly = arguments[1];
			var polyGeom = this._geom[polyGeomIndex];
			if (polyGeom.getDimension() < 2) return null;
			var locationsIndex = 1 - polyGeomIndex;
			var polys = PolygonExtracter.getPolygons(polyGeom);
			if (polys.size() > 0) {
				var insideLocs = ConnectedElementLocationFilter.getLocations(this._geom[locationsIndex]);
				this.computeContainmentDistance(insideLocs, polys, _locPtPoly);
				if (this._minDistance <= this._terminateDistance) {
					this._minDistanceLocation[locationsIndex] = _locPtPoly[0];
					this._minDistanceLocation[polyGeomIndex] = _locPtPoly[1];
					return null;
				}
			}
		} else if (arguments.length === 3) {
			if (arguments[2] instanceof Array && hasInterface(arguments[0], List) && hasInterface(arguments[1], List)) {
				var locs = arguments[0],
				    _polys = arguments[1],
				    _locPtPoly2 = arguments[2];
				for (var i = 0; i < locs.size(); i++) {
					var loc = locs.get(i);
					for (var j = 0; j < _polys.size(); j++) {
						this.computeContainmentDistance(loc, _polys.get(j), _locPtPoly2);
						if (this._minDistance <= this._terminateDistance) return null;
					}
				}
			} else if (arguments[2] instanceof Array && arguments[0] instanceof GeometryLocation && arguments[1] instanceof Polygon) {
				var ptLoc = arguments[0],
				    poly = arguments[1],
				    _locPtPoly3 = arguments[2];
				var pt = ptLoc.getCoordinate();
				if (Location.EXTERIOR !== this._ptLocator.locate(pt, poly)) {
					this._minDistance = 0.0;
					_locPtPoly3[0] = ptLoc;
					_locPtPoly3[1] = new GeometryLocation(poly, pt);
					
					return null;
				}
			}
		}
	},
	computeMinDistanceLinesPoints: function computeMinDistanceLinesPoints(lines, points, locGeom) {
		for (var i = 0; i < lines.size(); i++) {
			var line = lines.get(i);
			for (var j = 0; j < points.size(); j++) {
				var pt = points.get(j);
				this.computeMinDistance(line, pt, locGeom);
				if (this._minDistance <= this._terminateDistance) return null;
			}
		}
	},
	computeFacetDistance: function computeFacetDistance() {
		var locGeom = new Array(2).fill(null);
		var lines0 = LinearComponentExtracter.getLines(this._geom[0]);
		var lines1 = LinearComponentExtracter.getLines(this._geom[1]);
		var pts0 = PointExtracter.getPoints(this._geom[0]);
		var pts1 = PointExtracter.getPoints(this._geom[1]);
		this.computeMinDistanceLines(lines0, lines1, locGeom);
		this.updateMinDistance(locGeom, false);
		if (this._minDistance <= this._terminateDistance) return null;
		locGeom[0] = null;
		locGeom[1] = null;
		this.computeMinDistanceLinesPoints(lines0, pts1, locGeom);
		this.updateMinDistance(locGeom, false);
		if (this._minDistance <= this._terminateDistance) return null;
		locGeom[0] = null;
		locGeom[1] = null;
		this.computeMinDistanceLinesPoints(lines1, pts0, locGeom);
		this.updateMinDistance(locGeom, true);
		if (this._minDistance <= this._terminateDistance) return null;
		locGeom[0] = null;
		locGeom[1] = null;
		this.computeMinDistancePoints(pts0, pts1, locGeom);
		this.updateMinDistance(locGeom, false);
	},
	nearestLocations: function nearestLocations() {
		this.computeMinDistance();
		return this._minDistanceLocation;
	},
	updateMinDistance: function updateMinDistance(locGeom, flip) {
		if (locGeom[0] === null) return null;
		if (flip) {
			this._minDistanceLocation[0] = locGeom[1];
			this._minDistanceLocation[1] = locGeom[0];
		} else {
			this._minDistanceLocation[0] = locGeom[0];
			this._minDistanceLocation[1] = locGeom[1];
		}
	},
	nearestPoints: function nearestPoints() {
		this.computeMinDistance();
		var nearestPts = [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];
		return nearestPts;
	},
	computeMinDistance: function computeMinDistance() {
		if (arguments.length === 0) {
			if (this._minDistanceLocation !== null) return null;
			this._minDistanceLocation = new Array(2).fill(null);
			this.computeContainmentDistance();
			if (this._minDistance <= this._terminateDistance) return null;
			this.computeFacetDistance();
		} else if (arguments.length === 3) {
			if (arguments[2] instanceof Array && arguments[0] instanceof LineString && arguments[1] instanceof Point) {
				var line = arguments[0],
				    pt = arguments[1],
				    locGeom = arguments[2];
				if (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this._minDistance) return null;
				var coord0 = line.getCoordinates();
				var coord = pt.getCoordinate();
				for (var i = 0; i < coord0.length - 1; i++) {
					var dist = Distance.pointToSegment(coord, coord0[i], coord0[i + 1]);
					if (dist < this._minDistance) {
						this._minDistance = dist;
						var seg = new LineSegment(coord0[i], coord0[i + 1]);
						var segClosestPoint = seg.closestPoint(coord);
						locGeom[0] = new GeometryLocation(line, i, segClosestPoint);
						locGeom[1] = new GeometryLocation(pt, 0, coord);
					}
					if (this._minDistance <= this._terminateDistance) return null;
				}
			} else if (arguments[2] instanceof Array && arguments[0] instanceof LineString && arguments[1] instanceof LineString) {
				var line0 = arguments[0],
				    line1 = arguments[1],
				    _locGeom = arguments[2];
				if (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this._minDistance) return null;
				var coord0 = line0.getCoordinates();
				var coord1 = line1.getCoordinates();
				for (var i = 0; i < coord0.length - 1; i++) {
					for (var j = 0; j < coord1.length - 1; j++) {
						var dist = Distance.segmentToSegment(coord0[i], coord0[i + 1], coord1[j], coord1[j + 1]);
						if (dist < this._minDistance) {
							this._minDistance = dist;
							var seg0 = new LineSegment(coord0[i], coord0[i + 1]);
							var seg1 = new LineSegment(coord1[j], coord1[j + 1]);
							var closestPt = seg0.closestPoints(seg1);
							_locGeom[0] = new GeometryLocation(line0, i, closestPt[0]);
							_locGeom[1] = new GeometryLocation(line1, j, closestPt[1]);
						}
						if (this._minDistance <= this._terminateDistance) return null;
					}
				}
			}
		}
	},
	computeMinDistancePoints: function computeMinDistancePoints(points0, points1, locGeom) {
		for (var i = 0; i < points0.size(); i++) {
			var pt0 = points0.get(i);
			for (var j = 0; j < points1.size(); j++) {
				var pt1 = points1.get(j);
				var dist = pt0.getCoordinate().distance(pt1.getCoordinate());
				if (dist < this._minDistance) {
					this._minDistance = dist;
					locGeom[0] = new GeometryLocation(pt0, 0, pt0.getCoordinate());
					locGeom[1] = new GeometryLocation(pt1, 0, pt1.getCoordinate());
				}
				if (this._minDistance <= this._terminateDistance) return null;
			}
		}
	},
	distance: function distance() {
		if (this._geom[0] === null || this._geom[1] === null) throw new IllegalArgumentException("null geometries are not supported");
		if (this._geom[0].isEmpty() || this._geom[1].isEmpty()) return 0.0;
		this.computeMinDistance();
		return this._minDistance;
	},
	computeMinDistanceLines: function computeMinDistanceLines(lines0, lines1, locGeom) {
		for (var i = 0; i < lines0.size(); i++) {
			var line0 = lines0.get(i);
			for (var j = 0; j < lines1.size(); j++) {
				var line1 = lines1.get(j);
				this.computeMinDistance(line0, line1, locGeom);
				if (this._minDistance <= this._terminateDistance) return null;
			}
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return DistanceOp;
	}
});
DistanceOp.distance = function (g0, g1) {
	var distOp = new DistanceOp(g0, g1);
	return distOp.distance();
};
DistanceOp.isWithinDistance = function (g0, g1, distance) {
	var envDist = g0.getEnvelopeInternal().distance(g1.getEnvelopeInternal());
	if (envDist > distance) return false;
	var distOp = new DistanceOp(g0, g1, distance);
	return distOp.distance() <= distance;
};
DistanceOp.nearestPoints = function (g0, g1) {
	var distOp = new DistanceOp(g0, g1);
	return distOp.nearestPoints();
};



var distance = Object.freeze({
	DistanceOp: DistanceOp
});

function EdgeString() {
	this._factory = null;
	this._directedEdges = new ArrayList();
	this._coordinates = null;
	var factory = arguments[0];
	this._factory = factory;
}
extend(EdgeString.prototype, {
	getCoordinates: function getCoordinates() {
		if (this._coordinates === null) {
			var forwardDirectedEdges = 0;
			var reverseDirectedEdges = 0;
			var coordinateList = new CoordinateList();
			for (var i = this._directedEdges.iterator(); i.hasNext();) {
				var directedEdge = i.next();
				if (directedEdge.getEdgeDirection()) {
					forwardDirectedEdges++;
				} else {
					reverseDirectedEdges++;
				}
				coordinateList.add(directedEdge.getEdge().getLine().getCoordinates(), false, directedEdge.getEdgeDirection());
			}
			this._coordinates = coordinateList.toCoordinateArray();
			if (reverseDirectedEdges > forwardDirectedEdges) {
				CoordinateArrays.reverse(this._coordinates);
			}
		}
		return this._coordinates;
	},
	toLineString: function toLineString() {
		return this._factory.createLineString(this.getCoordinates());
	},
	add: function add(directedEdge) {
		this._directedEdges.add(directedEdge);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return EdgeString;
	}
});

function GraphComponent$1() {
	this._isMarked = false;
	this._isVisited = false;
	this._data = null;
}
extend(GraphComponent$1.prototype, {
	setVisited: function setVisited(isVisited) {
		this._isVisited = isVisited;
	},
	isMarked: function isMarked() {
		return this._isMarked;
	},
	setData: function setData(data) {
		this._data = data;
	},
	getData: function getData() {
		return this._data;
	},
	setMarked: function setMarked(isMarked) {
		this._isMarked = isMarked;
	},
	getContext: function getContext() {
		return this._data;
	},
	isVisited: function isVisited() {
		return this._isVisited;
	},
	setContext: function setContext(data) {
		this._data = data;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return GraphComponent$1;
	}
});
GraphComponent$1.getComponentWithVisitedState = function (i, visitedState) {
	while (i.hasNext()) {
		var comp = i.next();
		if (comp.isVisited() === visitedState) return comp;
	}
	return null;
};
GraphComponent$1.setVisited = function (i, visited) {
	while (i.hasNext()) {
		var comp = i.next();
		comp.setVisited(visited);
	}
};
GraphComponent$1.setMarked = function (i, marked) {
	while (i.hasNext()) {
		var comp = i.next();
		comp.setMarked(marked);
	}
};

function DirectedEdge$1() {
	GraphComponent$1.apply(this);
	this._parentEdge = null;
	this._from = null;
	this._to = null;
	this._p0 = null;
	this._p1 = null;
	this._sym = null;
	this._edgeDirection = null;
	this._quadrant = null;
	this._angle = null;
	var from = arguments[0],
	    to = arguments[1],
	    directionPt = arguments[2],
	    edgeDirection = arguments[3];
	this._from = from;
	this._to = to;
	this._edgeDirection = edgeDirection;
	this._p0 = from.getCoordinate();
	this._p1 = directionPt;
	var dx = this._p1.x - this._p0.x;
	var dy = this._p1.y - this._p0.y;
	this._quadrant = Quadrant.quadrant(dx, dy);
	this._angle = Math.atan2(dy, dx);
}
inherits(DirectedEdge$1, GraphComponent$1);
extend(DirectedEdge$1.prototype, {
	isRemoved: function isRemoved() {
		return this._parentEdge === null;
	},
	compareDirection: function compareDirection(e) {
		if (this._quadrant > e._quadrant) return 1;
		if (this._quadrant < e._quadrant) return -1;
		return Orientation.index(e._p0, e._p1, this._p1);
	},
	getCoordinate: function getCoordinate() {
		return this._from.getCoordinate();
	},
	print: function print(out) {
		var className = this.getClass().getName();
		var lastDotPos = className.lastIndexOf('.');
		var name = className.substring(lastDotPos + 1);
		out.print("  " + name + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + this._angle);
	},
	getDirectionPt: function getDirectionPt() {
		return this._p1;
	},
	getAngle: function getAngle() {
		return this._angle;
	},
	compareTo: function compareTo(obj) {
		var de = obj;
		return this.compareDirection(de);
	},
	getFromNode: function getFromNode() {
		return this._from;
	},
	getSym: function getSym() {
		return this._sym;
	},
	setEdge: function setEdge(parentEdge) {
		this._parentEdge = parentEdge;
	},
	remove: function remove() {
		this._sym = null;
		this._parentEdge = null;
	},
	getEdge: function getEdge() {
		return this._parentEdge;
	},
	getQuadrant: function getQuadrant() {
		return this._quadrant;
	},
	setSym: function setSym(sym) {
		this._sym = sym;
	},
	getToNode: function getToNode() {
		return this._to;
	},
	getEdgeDirection: function getEdgeDirection() {
		return this._edgeDirection;
	},
	interfaces_: function interfaces_() {
		return [Comparable];
	},
	getClass: function getClass() {
		return DirectedEdge$1;
	}
});
DirectedEdge$1.toEdges = function (dirEdges) {
	var edges = new ArrayList();
	for (var i = dirEdges.iterator(); i.hasNext();) {
		edges.add(i.next()._parentEdge);
	}
	return edges;
};

function LineMergeDirectedEdge() {
	var from = arguments[0],
	    to = arguments[1],
	    directionPt = arguments[2],
	    edgeDirection = arguments[3];
	DirectedEdge$1.call(this, from, to, directionPt, edgeDirection);
}
inherits(LineMergeDirectedEdge, DirectedEdge$1);
extend(LineMergeDirectedEdge.prototype, {
	getNext: function getNext() {
		if (this.getToNode().getDegree() !== 2) {
			return null;
		}
		if (this.getToNode().getOutEdges().getEdges().get(0) === this.getSym()) {
			return this.getToNode().getOutEdges().getEdges().get(1);
		}
		Assert.isTrue(this.getToNode().getOutEdges().getEdges().get(1) === this.getSym());
		return this.getToNode().getOutEdges().getEdges().get(0);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LineMergeDirectedEdge;
	}
});

function Edge$1() {
	GraphComponent$1.apply(this);
	this._dirEdge = null;
	if (arguments.length === 0) {} else if (arguments.length === 2) {
		var de0 = arguments[0],
		    de1 = arguments[1];
		this.setDirectedEdges(de0, de1);
	}
}
inherits(Edge$1, GraphComponent$1);
extend(Edge$1.prototype, {
	isRemoved: function isRemoved() {
		return this._dirEdge === null;
	},
	setDirectedEdges: function setDirectedEdges(de0, de1) {
		this._dirEdge = [de0, de1];
		de0.setEdge(this);
		de1.setEdge(this);
		de0.setSym(de1);
		de1.setSym(de0);
		de0.getFromNode().addOutEdge(de0);
		de1.getFromNode().addOutEdge(de1);
	},
	getDirEdge: function getDirEdge() {
		if (Number.isInteger(arguments[0])) {
			var i = arguments[0];
			return this._dirEdge[i];
		} else if (arguments[0] instanceof Node$3) {
			var fromNode = arguments[0];
			if (this._dirEdge[0].getFromNode() === fromNode) return this._dirEdge[0];
			if (this._dirEdge[1].getFromNode() === fromNode) return this._dirEdge[1];
			return null;
		}
	},
	remove: function remove() {
		this._dirEdge = null;
	},
	getOppositeNode: function getOppositeNode(node) {
		if (this._dirEdge[0].getFromNode() === node) return this._dirEdge[0].getToNode();
		if (this._dirEdge[1].getFromNode() === node) return this._dirEdge[1].getToNode();
		return null;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Edge$1;
	}
});

function DirectedEdgeStar$1() {
	this._outEdges = new ArrayList();
	this._sorted = false;
}
extend(DirectedEdgeStar$1.prototype, {
	getNextEdge: function getNextEdge(dirEdge) {
		var i = this.getIndex(dirEdge);
		return this._outEdges.get(this.getIndex(i + 1));
	},
	getCoordinate: function getCoordinate() {
		var it = this.iterator();
		if (!it.hasNext()) return null;
		var e = it.next();
		return e.getCoordinate();
	},
	iterator: function iterator() {
		this.sortEdges();
		return this._outEdges.iterator();
	},
	sortEdges: function sortEdges() {
		if (!this._sorted) {
			Collections.sort(this._outEdges);
			this._sorted = true;
		}
	},
	remove: function remove(de) {
		this._outEdges.remove(de);
	},
	getEdges: function getEdges() {
		this.sortEdges();
		return this._outEdges;
	},
	getNextCWEdge: function getNextCWEdge(dirEdge) {
		var i = this.getIndex(dirEdge);
		return this._outEdges.get(this.getIndex(i - 1));
	},
	getIndex: function getIndex() {
		if (arguments[0] instanceof Edge$1) {
			var edge = arguments[0];
			this.sortEdges();
			for (var i = 0; i < this._outEdges.size(); i++) {
				var de = this._outEdges.get(i);
				if (de.getEdge() === edge) return i;
			}
			return -1;
		} else if (arguments[0] instanceof DirectedEdge$1) {
			var dirEdge = arguments[0];
			this.sortEdges();
			for (var i = 0; i < this._outEdges.size(); i++) {
				var de = this._outEdges.get(i);
				if (de === dirEdge) return i;
			}
			return -1;
		} else if (Number.isInteger(arguments[0])) {
			var _i = arguments[0];
			var modi = _i % this._outEdges.size();
			if (modi < 0) modi += this._outEdges.size();
			return modi;
		}
	},
	add: function add(de) {
		this._outEdges.add(de);
		this._sorted = false;
	},
	getDegree: function getDegree() {
		return this._outEdges.size();
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return DirectedEdgeStar$1;
	}
});

function Node$3() {
	GraphComponent$1.apply(this);
	this._pt = null;
	this._deStar = null;
	if (arguments.length === 1) {
		var pt = arguments[0];
		Node$3.call(this, pt, new DirectedEdgeStar$1());
	} else if (arguments.length === 2) {
		var _pt = arguments[0],
		    deStar = arguments[1];
		this._pt = _pt;
		this._deStar = deStar;
	}
}
inherits(Node$3, GraphComponent$1);
extend(Node$3.prototype, {
	isRemoved: function isRemoved() {
		return this._pt === null;
	},
	addOutEdge: function addOutEdge(de) {
		this._deStar.add(de);
	},
	getCoordinate: function getCoordinate() {
		return this._pt;
	},
	getOutEdges: function getOutEdges() {
		return this._deStar;
	},
	remove: function remove() {
		if (arguments.length === 0) {
			this._pt = null;
		} else if (arguments.length === 1) {
			var de = arguments[0];
			this._deStar.remove(de);
		}
	},
	getIndex: function getIndex(edge) {
		return this._deStar.getIndex(edge);
	},
	getDegree: function getDegree() {
		return this._deStar.getDegree();
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Node$3;
	}
});
Node$3.getEdgesBetween = function (node0, node1) {
	var edges0 = DirectedEdge$1.toEdges(node0.getOutEdges().getEdges());
	var commonEdges = new HashSet(edges0);
	var edges1 = DirectedEdge$1.toEdges(node1.getOutEdges().getEdges());
	commonEdges.retainAll(edges1);
	return commonEdges;
};

function LineMergeEdge() {
	Edge$1.apply(this);
	this._line = null;
	var line = arguments[0];
	this._line = line;
}
inherits(LineMergeEdge, Edge$1);
extend(LineMergeEdge.prototype, {
	getLine: function getLine() {
		return this._line;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LineMergeEdge;
	}
});

function NodeMap$1() {
	this._nodeMap = new TreeMap();
}
extend(NodeMap$1.prototype, {
	find: function find(coord) {
		return this._nodeMap.get(coord);
	},
	iterator: function iterator() {
		return this._nodeMap.values().iterator();
	},
	remove: function remove(pt) {
		return this._nodeMap.remove(pt);
	},
	values: function values() {
		return this._nodeMap.values();
	},
	add: function add(n) {
		this._nodeMap.put(n.getCoordinate(), n);
		return n;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return NodeMap$1;
	}
});

function PlanarGraph$1() {
	this._edges = new HashSet();
	this._dirEdges = new HashSet();
	this._nodeMap = new NodeMap$1();
}
extend(PlanarGraph$1.prototype, {
	findNodesOfDegree: function findNodesOfDegree(degree) {
		var nodesFound = new ArrayList();
		for (var i = this.nodeIterator(); i.hasNext();) {
			var node = i.next();
			if (node.getDegree() === degree) nodesFound.add(node);
		}
		return nodesFound;
	},
	dirEdgeIterator: function dirEdgeIterator() {
		return this._dirEdges.iterator();
	},
	edgeIterator: function edgeIterator() {
		return this._edges.iterator();
	},
	remove: function remove() {
		if (arguments[0] instanceof Edge$1) {
			var _edge = arguments[0];
			this.remove(_edge.getDirEdge(0));
			this.remove(_edge.getDirEdge(1));
			this._edges.remove(_edge);
			_edge.remove();
		} else if (arguments[0] instanceof DirectedEdge$1) {
			var _de = arguments[0];
			var sym = _de.getSym();
			if (sym !== null) sym.setSym(null);
			_de.getFromNode().remove(_de);
			_de.remove();
			this._dirEdges.remove(_de);
		} else if (arguments[0] instanceof Node$3) {
			var node = arguments[0];
			var outEdges = node.getOutEdges().getEdges();
			for (var i = outEdges.iterator(); i.hasNext();) {
				var de = i.next();
				var sym = de.getSym();
				if (sym !== null) this.remove(sym);
				this._dirEdges.remove(de);
				var edge = de.getEdge();
				if (edge !== null) {
					this._edges.remove(edge);
				}
			}
			this._nodeMap.remove(node.getCoordinate());
			node.remove();
		}
	},
	findNode: function findNode(pt) {
		return this._nodeMap.find(pt);
	},
	getEdges: function getEdges() {
		return this._edges;
	},
	nodeIterator: function nodeIterator() {
		return this._nodeMap.iterator();
	},
	contains: function contains() {
		if (arguments[0] instanceof Edge$1) {
			var e = arguments[0];
			return this._edges.contains(e);
		} else if (arguments[0] instanceof DirectedEdge$1) {
			var de = arguments[0];
			return this._dirEdges.contains(de);
		}
	},
	add: function add() {
		if (arguments[0] instanceof Node$3) {
			var node = arguments[0];
			this._nodeMap.add(node);
		} else if (arguments[0] instanceof Edge$1) {
			var edge = arguments[0];
			this._edges.add(edge);
			this.add(edge.getDirEdge(0));
			this.add(edge.getDirEdge(1));
		} else if (arguments[0] instanceof DirectedEdge$1) {
			var dirEdge = arguments[0];
			this._dirEdges.add(dirEdge);
		}
	},
	getNodes: function getNodes() {
		return this._nodeMap.values();
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return PlanarGraph$1;
	}
});

function LineMergeGraph() {
	PlanarGraph$1.apply(this);
}
inherits(LineMergeGraph, PlanarGraph$1);
extend(LineMergeGraph.prototype, {
	addEdge: function addEdge(lineString) {
		if (lineString.isEmpty()) {
			return null;
		}
		var coordinates = CoordinateArrays.removeRepeatedPoints(lineString.getCoordinates());
		if (coordinates.length <= 1) return null;
		var startCoordinate = coordinates[0];
		var endCoordinate = coordinates[coordinates.length - 1];
		var startNode = this.getNode(startCoordinate);
		var endNode = this.getNode(endCoordinate);
		var directedEdge0 = new LineMergeDirectedEdge(startNode, endNode, coordinates[1], true);
		var directedEdge1 = new LineMergeDirectedEdge(endNode, startNode, coordinates[coordinates.length - 2], false);
		var edge = new LineMergeEdge(lineString);
		edge.setDirectedEdges(directedEdge0, directedEdge1);
		this.add(edge);
	},
	getNode: function getNode(coordinate) {
		var node = this.findNode(coordinate);
		if (node === null) {
			node = new Node$3(coordinate);
			this.add(node);
		}
		return node;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LineMergeGraph;
	}
});

function LineMerger() {
	this._graph = new LineMergeGraph();
	this._mergedLineStrings = null;
	this._factory = null;
	this._edgeStrings = null;
}
extend(LineMerger.prototype, {
	buildEdgeStringsForUnprocessedNodes: function buildEdgeStringsForUnprocessedNodes() {
		for (var i = this._graph.getNodes().iterator(); i.hasNext();) {
			var node = i.next();
			if (!node.isMarked()) {
				Assert.isTrue(node.getDegree() === 2);
				this.buildEdgeStringsStartingAt(node);
				node.setMarked(true);
			}
		}
	},
	buildEdgeStringsForNonDegree2Nodes: function buildEdgeStringsForNonDegree2Nodes() {
		for (var i = this._graph.getNodes().iterator(); i.hasNext();) {
			var node = i.next();
			if (node.getDegree() !== 2) {
				this.buildEdgeStringsStartingAt(node);
				node.setMarked(true);
			}
		}
	},
	buildEdgeStringsForObviousStartNodes: function buildEdgeStringsForObviousStartNodes() {
		this.buildEdgeStringsForNonDegree2Nodes();
	},
	getMergedLineStrings: function getMergedLineStrings() {
		this.merge();
		return this._mergedLineStrings;
	},
	buildEdgeStringsStartingAt: function buildEdgeStringsStartingAt(node) {
		for (var i = node.getOutEdges().iterator(); i.hasNext();) {
			var directedEdge = i.next();
			if (directedEdge.getEdge().isMarked()) {
				continue;
			}
			this._edgeStrings.add(this.buildEdgeStringStartingWith(directedEdge));
		}
	},
	merge: function merge() {
		if (this._mergedLineStrings !== null) {
			return null;
		}
		GraphComponent$1.setMarked(this._graph.nodeIterator(), false);
		GraphComponent$1.setMarked(this._graph.edgeIterator(), false);
		this._edgeStrings = new ArrayList();
		this.buildEdgeStringsForObviousStartNodes();
		this.buildEdgeStringsForIsolatedLoops();
		this._mergedLineStrings = new ArrayList();
		for (var i = this._edgeStrings.iterator(); i.hasNext();) {
			var edgeString = i.next();
			this._mergedLineStrings.add(edgeString.toLineString());
		}
	},
	buildEdgeStringStartingWith: function buildEdgeStringStartingWith(start) {
		var edgeString = new EdgeString(this._factory);
		var current = start;
		do {
			edgeString.add(current);
			current.getEdge().setMarked(true);
			current = current.getNext();
		} while (current !== null && current !== start);
		return edgeString;
	},
	add: function add() {
		if (arguments[0] instanceof Geometry) {
			var _geometry = arguments[0];
			_geometry.apply({
				interfaces_: function interfaces_() {
					return [GeometryComponentFilter];
				},
				filter: function filter(component) {
					if (component instanceof LineString) {
						this.add(component);
					}
				}
			});
		} else if (hasInterface(arguments[0], Collection)) {
			var geometries = arguments[0];
			this._mergedLineStrings = null;
			for (var i = geometries.iterator(); i.hasNext();) {
				var geometry = i.next();
				this.add(geometry);
			}
		} else if (arguments[0] instanceof LineString) {
			var lineString = arguments[0];
			if (this._factory === null) {
				this._factory = lineString.getFactory();
			}
			this._graph.addEdge(lineString);
		}
	},
	buildEdgeStringsForIsolatedLoops: function buildEdgeStringsForIsolatedLoops() {
		this.buildEdgeStringsForUnprocessedNodes();
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LineMerger;
	}
});



var linemerge = Object.freeze({
	LineMerger: LineMerger
});

function BasicSegmentString() {
	this._pts = null;
	this._data = null;
	var pts = arguments[0],
	    data = arguments[1];
	this._pts = pts;
	this._data = data;
}
extend(BasicSegmentString.prototype, {
	getCoordinates: function getCoordinates() {
		return this._pts;
	},
	size: function size() {
		return this._pts.length;
	},
	getCoordinate: function getCoordinate(i) {
		return this._pts[i];
	},
	isClosed: function isClosed() {
		return this._pts[0].equals(this._pts[this._pts.length - 1]);
	},
	getSegmentOctant: function getSegmentOctant(index) {
		if (index === this._pts.length - 1) return -1;
		return Octant.octant(this.getCoordinate(index), this.getCoordinate(index + 1));
	},
	setData: function setData(data) {
		this._data = data;
	},
	getData: function getData() {
		return this._data;
	},
	toString: function toString() {
		return WKTWriter.toLineString(new CoordinateArraySequence(this._pts));
	},
	interfaces_: function interfaces_() {
		return [SegmentString];
	},
	getClass: function getClass() {
		return BasicSegmentString;
	}
});

function InteriorIntersectionFinder() {
	this._findAllIntersections = false;
	this._isCheckEndSegmentsOnly = false;
	this._li = null;
	this._interiorIntersection = null;
	this._intSegments = null;
	this._intersections = new ArrayList();
	this._intersectionCount = 0;
	this._keepIntersections = true;
	var li = arguments[0];
	this._li = li;
	this._interiorIntersection = null;
}
extend(InteriorIntersectionFinder.prototype, {
	getInteriorIntersection: function getInteriorIntersection() {
		return this._interiorIntersection;
	},
	setCheckEndSegmentsOnly: function setCheckEndSegmentsOnly(isCheckEndSegmentsOnly) {
		this._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;
	},
	getIntersectionSegments: function getIntersectionSegments() {
		return this._intSegments;
	},
	count: function count() {
		return this._intersectionCount;
	},
	getIntersections: function getIntersections() {
		return this._intersections;
	},
	setFindAllIntersections: function setFindAllIntersections(findAllIntersections) {
		this._findAllIntersections = findAllIntersections;
	},
	setKeepIntersections: function setKeepIntersections(keepIntersections) {
		this._keepIntersections = keepIntersections;
	},
	processIntersections: function processIntersections(e0, segIndex0, e1, segIndex1) {
		if (!this._findAllIntersections && this.hasIntersection()) return null;
		if (e0 === e1 && segIndex0 === segIndex1) return null;
		if (this._isCheckEndSegmentsOnly) {
			var isEndSegPresent = this.isEndSegment(e0, segIndex0) || this.isEndSegment(e1, segIndex1);
			if (!isEndSegPresent) return null;
		}
		var p00 = e0.getCoordinates()[segIndex0];
		var p01 = e0.getCoordinates()[segIndex0 + 1];
		var p10 = e1.getCoordinates()[segIndex1];
		var p11 = e1.getCoordinates()[segIndex1 + 1];
		this._li.computeIntersection(p00, p01, p10, p11);
		if (this._li.hasIntersection()) {
			if (this._li.isInteriorIntersection()) {
				this._intSegments = new Array(4).fill(null);
				this._intSegments[0] = p00;
				this._intSegments[1] = p01;
				this._intSegments[2] = p10;
				this._intSegments[3] = p11;
				this._interiorIntersection = this._li.getIntersection(0);
				if (this._keepIntersections) this._intersections.add(this._interiorIntersection);
				this._intersectionCount++;
			}
		}
	},
	isEndSegment: function isEndSegment(segStr, index) {
		if (index === 0) return true;
		if (index >= segStr.size() - 2) return true;
		return false;
	},
	hasIntersection: function hasIntersection() {
		return this._interiorIntersection !== null;
	},
	isDone: function isDone() {
		if (this._findAllIntersections) return false;
		return this._interiorIntersection !== null;
	},
	interfaces_: function interfaces_() {
		return [SegmentIntersector$1];
	},
	getClass: function getClass() {
		return InteriorIntersectionFinder;
	}
});
InteriorIntersectionFinder.createAllIntersectionsFinder = function (li) {
	var finder = new InteriorIntersectionFinder(li);
	finder.setFindAllIntersections(true);
	return finder;
};
InteriorIntersectionFinder.createAnyIntersectionFinder = function (li) {
	return new InteriorIntersectionFinder(li);
};
InteriorIntersectionFinder.createIntersectionCounter = function (li) {
	var finder = new InteriorIntersectionFinder(li);
	finder.setFindAllIntersections(true);
	finder.setKeepIntersections(false);
	return finder;
};

function FastNodingValidator() {
	this._li = new RobustLineIntersector();
	this._segStrings = null;
	this._findAllIntersections = false;
	this._segInt = null;
	this._isValid = true;
	var segStrings = arguments[0];
	this._segStrings = segStrings;
}
extend(FastNodingValidator.prototype, {
	execute: function execute() {
		if (this._segInt !== null) return null;
		this.checkInteriorIntersections();
	},
	getIntersections: function getIntersections() {
		return this._segInt.getIntersections();
	},
	isValid: function isValid() {
		this.execute();
		return this._isValid;
	},
	setFindAllIntersections: function setFindAllIntersections(findAllIntersections) {
		this._findAllIntersections = findAllIntersections;
	},
	checkInteriorIntersections: function checkInteriorIntersections() {
		this._isValid = true;
		this._segInt = new InteriorIntersectionFinder(this._li);
		this._segInt.setFindAllIntersections(this._findAllIntersections);
		var noder = new MCIndexNoder();
		noder.setSegmentIntersector(this._segInt);
		noder.computeNodes(this._segStrings);
		if (this._segInt.hasIntersection()) {
			this._isValid = false;
			return null;
		}
	},
	checkValid: function checkValid() {
		this.execute();
		if (!this._isValid) throw new TopologyException(this.getErrorMessage(), this._segInt.getInteriorIntersection());
	},
	getErrorMessage: function getErrorMessage() {
		if (this._isValid) return "no intersections found";
		var intSegs = this._segInt.getIntersectionSegments();
		return "found non-noded intersection between " + WKTWriter.toLineString(intSegs[0], intSegs[1]) + " and " + WKTWriter.toLineString(intSegs[2], intSegs[3]);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return FastNodingValidator;
	}
});
FastNodingValidator.computeIntersections = function (segStrings) {
	var nv = new FastNodingValidator(segStrings);
	nv.setFindAllIntersections(true);
	nv.isValid();
	return nv.getIntersections();
};

function EdgeNodingValidator() {
	this._nv = null;
	var edges = arguments[0];
	this._nv = new FastNodingValidator(EdgeNodingValidator.toSegmentStrings(edges));
}
extend(EdgeNodingValidator.prototype, {
	checkValid: function checkValid() {
		this._nv.checkValid();
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return EdgeNodingValidator;
	}
});
EdgeNodingValidator.toSegmentStrings = function (edges) {
	var segStrings = new ArrayList();
	for (var i = edges.iterator(); i.hasNext();) {
		var e = i.next();
		segStrings.add(new BasicSegmentString(e.getCoordinates(), e));
	}
	return segStrings;
};
EdgeNodingValidator.checkValid = function (edges) {
	var validator = new EdgeNodingValidator(edges);
	validator.checkValid();
};

function GeometryCollectionMapper() {
	this._mapOp = null;
	var mapOp = arguments[0];
	this._mapOp = mapOp;
}
extend(GeometryCollectionMapper.prototype, {
	map: function map(gc) {
		var mapped = new ArrayList();
		for (var i = 0; i < gc.getNumGeometries(); i++) {
			var g = this._mapOp.map(gc.getGeometryN(i));
			if (!g.isEmpty()) mapped.add(g);
		}
		return gc.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(mapped));
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return GeometryCollectionMapper;
	}
});
GeometryCollectionMapper.map = function (gc, op) {
	var mapper = new GeometryCollectionMapper(op);
	return mapper.map(gc);
};

function LineBuilder() {
	this._op = null;
	this._geometryFactory = null;
	this._ptLocator = null;
	this._lineEdgesList = new ArrayList();
	this._resultLineList = new ArrayList();
	var op = arguments[0],
	    geometryFactory = arguments[1],
	    ptLocator = arguments[2];
	this._op = op;
	this._geometryFactory = geometryFactory;
	this._ptLocator = ptLocator;
}
extend(LineBuilder.prototype, {
	collectLines: function collectLines(opCode) {
		for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {
			var de = it.next();
			this.collectLineEdge(de, opCode, this._lineEdgesList);
			this.collectBoundaryTouchEdge(de, opCode, this._lineEdgesList);
		}
	},
	labelIsolatedLine: function labelIsolatedLine(e, targetIndex) {
		var loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));
		e.getLabel().setLocation(targetIndex, loc);
	},
	build: function build(opCode) {
		this.findCoveredLineEdges();
		this.collectLines(opCode);
		this.buildLines(opCode);
		return this._resultLineList;
	},
	collectLineEdge: function collectLineEdge(de, opCode, edges) {
		var label = de.getLabel();
		var e = de.getEdge();
		if (de.isLineEdge()) {
			if (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e.isCovered()) {
				edges.add(e);
				de.setVisitedEdge(true);
			}
		}
	},
	findCoveredLineEdges: function findCoveredLineEdges() {
		for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {
			var node = nodeit.next();
			node.getEdges().findCoveredLineEdges();
		}
		for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {
			var de = it.next();
			var e = de.getEdge();
			if (de.isLineEdge() && !e.isCoveredSet()) {
				var isCovered = this._op.isCoveredByA(de.getCoordinate());
				e.setCovered(isCovered);
			}
		}
	},
	labelIsolatedLines: function labelIsolatedLines(edgesList) {
		for (var it = edgesList.iterator(); it.hasNext();) {
			var e = it.next();
			var label = e.getLabel();
			if (e.isIsolated()) {
				if (label.isNull(0)) this.labelIsolatedLine(e, 0);else this.labelIsolatedLine(e, 1);
			}
		}
	},
	buildLines: function buildLines(opCode) {
		for (var it = this._lineEdgesList.iterator(); it.hasNext();) {
			var e = it.next();
			var label = e.getLabel();
			var line = this._geometryFactory.createLineString(e.getCoordinates());
			this._resultLineList.add(line);
			e.setInResult(true);
		}
	},
	collectBoundaryTouchEdge: function collectBoundaryTouchEdge(de, opCode, edges) {
		var label = de.getLabel();
		if (de.isLineEdge()) return null;
		if (de.isVisited()) return null;
		if (de.isInteriorAreaEdge()) return null;
		if (de.getEdge().isInResult()) return null;
		Assert.isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());
		if (OverlayOp.isResultOfOp(label, opCode) && opCode === OverlayOp.INTERSECTION) {
			edges.add(de.getEdge());
			de.setVisitedEdge(true);
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LineBuilder;
	}
});

function PointBuilder() {
	this._op = null;
	this._geometryFactory = null;
	this._resultPointList = new ArrayList();
	var op = arguments[0],
	    geometryFactory = arguments[1];
	this._op = op;
	this._geometryFactory = geometryFactory;
}
extend(PointBuilder.prototype, {
	filterCoveredNodeToPoint: function filterCoveredNodeToPoint(n) {
		var coord = n.getCoordinate();
		if (!this._op.isCoveredByLA(coord)) {
			var pt = this._geometryFactory.createPoint(coord);
			this._resultPointList.add(pt);
		}
	},
	extractNonCoveredResultNodes: function extractNonCoveredResultNodes(opCode) {
		for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {
			var n = nodeit.next();
			if (n.isInResult()) continue;
			if (n.isIncidentEdgeInResult()) continue;
			if (n.getEdges().getDegree() === 0 || opCode === OverlayOp.INTERSECTION) {
				var label = n.getLabel();
				if (OverlayOp.isResultOfOp(label, opCode)) {
					this.filterCoveredNodeToPoint(n);
				}
			}
		}
	},
	build: function build(opCode) {
		this.extractNonCoveredResultNodes(opCode);
		return this._resultPointList;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return PointBuilder;
	}
});

function LineStringSnapper() {
	this._snapTolerance = 0.0;
	this._srcPts = null;
	this._seg = new LineSegment();
	this._allowSnappingToSourceVertices = false;
	this._isClosed = false;
	if (arguments[0] instanceof LineString && typeof arguments[1] === "number") {
		var srcLine = arguments[0],
		    snapTolerance = arguments[1];
		LineStringSnapper.call(this, srcLine.getCoordinates(), snapTolerance);
	} else if (arguments[0] instanceof Array && typeof arguments[1] === "number") {
		var srcPts = arguments[0],
		    _snapTolerance = arguments[1];
		this._srcPts = srcPts;
		this._isClosed = LineStringSnapper.isClosed(srcPts);
		this._snapTolerance = _snapTolerance;
	}
}
extend(LineStringSnapper.prototype, {
	snapVertices: function snapVertices(srcCoords, snapPts) {
		var end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();
		for (var i = 0; i < end; i++) {
			var srcPt = srcCoords.get(i);
			var snapVert = this.findSnapForVertex(srcPt, snapPts);
			if (snapVert !== null) {
				srcCoords.set(i, new Coordinate(snapVert));
				if (i === 0 && this._isClosed) srcCoords.set(srcCoords.size() - 1, new Coordinate(snapVert));
			}
		}
	},
	findSnapForVertex: function findSnapForVertex(pt, snapPts) {
		for (var i = 0; i < snapPts.length; i++) {
			if (pt.equals2D(snapPts[i])) return null;
			if (pt.distance(snapPts[i]) < this._snapTolerance) return snapPts[i];
		}
		return null;
	},
	snapTo: function snapTo(snapPts) {
		var coordList = new CoordinateList(this._srcPts);
		this.snapVertices(coordList, snapPts);
		this.snapSegments(coordList, snapPts);
		var newPts = coordList.toCoordinateArray();
		return newPts;
	},
	snapSegments: function snapSegments(srcCoords, snapPts) {
		if (snapPts.length === 0) return null;
		var distinctPtCount = snapPts.length;
		if (snapPts[0].equals2D(snapPts[snapPts.length - 1])) distinctPtCount = snapPts.length - 1;
		for (var i = 0; i < distinctPtCount; i++) {
			var snapPt = snapPts[i];
			var index = this.findSegmentIndexToSnap(snapPt, srcCoords);
			if (index >= 0) {
				srcCoords.add(index + 1, new Coordinate(snapPt), false);
			}
		}
	},
	findSegmentIndexToSnap: function findSegmentIndexToSnap(snapPt, srcCoords) {
		var minDist = Double.MAX_VALUE;
		var snapIndex = -1;
		for (var i = 0; i < srcCoords.size() - 1; i++) {
			this._seg.p0 = srcCoords.get(i);
			this._seg.p1 = srcCoords.get(i + 1);
			if (this._seg.p0.equals2D(snapPt) || this._seg.p1.equals2D(snapPt)) {
				if (this._allowSnappingToSourceVertices) continue;else return -1;
			}
			var dist = this._seg.distance(snapPt);
			if (dist < this._snapTolerance && dist < minDist) {
				minDist = dist;
				snapIndex = i;
			}
		}
		return snapIndex;
	},
	setAllowSnappingToSourceVertices: function setAllowSnappingToSourceVertices(allowSnappingToSourceVertices) {
		this._allowSnappingToSourceVertices = allowSnappingToSourceVertices;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LineStringSnapper;
	}
});
LineStringSnapper.isClosed = function (pts) {
	if (pts.length <= 1) return false;
	return pts[0].equals2D(pts[pts.length - 1]);
};

function GeometrySnapper() {
	this._srcGeom = null;
	var srcGeom = arguments[0];
	this._srcGeom = srcGeom;
}
extend(GeometrySnapper.prototype, {
	snapTo: function snapTo(snapGeom, snapTolerance) {
		var snapPts = this.extractTargetCoordinates(snapGeom);
		var snapTrans = new SnapTransformer(snapTolerance, snapPts);
		return snapTrans.transform(this._srcGeom);
	},
	snapToSelf: function snapToSelf(snapTolerance, cleanResult) {
		var snapPts = this.extractTargetCoordinates(this._srcGeom);
		var snapTrans = new SnapTransformer(snapTolerance, snapPts, true);
		var snappedGeom = snapTrans.transform(this._srcGeom);
		var result = snappedGeom;
		if (cleanResult && hasInterface(result, Polygonal)) {
			result = snappedGeom.buffer(0);
		}
		return result;
	},
	computeSnapTolerance: function computeSnapTolerance(ringPts) {
		var minSegLen = this.computeMinimumSegmentLength(ringPts);
		var snapTol = minSegLen / 10;
		return snapTol;
	},
	extractTargetCoordinates: function extractTargetCoordinates(g) {
		var ptSet = new TreeSet();
		var pts = g.getCoordinates();
		for (var i = 0; i < pts.length; i++) {
			ptSet.add(pts[i]);
		}
		return ptSet.toArray(new Array(0).fill(null));
	},
	computeMinimumSegmentLength: function computeMinimumSegmentLength(pts) {
		var minSegLen = Double.MAX_VALUE;
		for (var i = 0; i < pts.length - 1; i++) {
			var segLen = pts[i].distance(pts[i + 1]);
			if (segLen < minSegLen) minSegLen = segLen;
		}
		return minSegLen;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return GeometrySnapper;
	}
});
GeometrySnapper.snap = function (g0, g1, snapTolerance) {
	var snapGeom = new Array(2).fill(null);
	var snapper0 = new GeometrySnapper(g0);
	snapGeom[0] = snapper0.snapTo(g1, snapTolerance);
	var snapper1 = new GeometrySnapper(g1);
	snapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);
	return snapGeom;
};
GeometrySnapper.computeOverlaySnapTolerance = function () {
	if (arguments.length === 1) {
		var g = arguments[0];
		var snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);
		var pm = g.getPrecisionModel();
		if (pm.getType() === PrecisionModel.FIXED) {
			var fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;
			if (fixedSnapTol > snapTolerance) snapTolerance = fixedSnapTol;
		}
		return snapTolerance;
	} else if (arguments.length === 2) {
		var g0 = arguments[0],
		    g1 = arguments[1];
		return Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1));
	}
};
GeometrySnapper.computeSizeBasedSnapTolerance = function (g) {
	var env = g.getEnvelopeInternal();
	var minDimension = Math.min(env.getHeight(), env.getWidth());
	var snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;
	return snapTol;
};
GeometrySnapper.snapToSelf = function (geom, snapTolerance, cleanResult) {
	var snapper0 = new GeometrySnapper(geom);
	return snapper0.snapToSelf(snapTolerance, cleanResult);
};
GeometrySnapper.SNAP_PRECISION_FACTOR = 1e-9;
function SnapTransformer() {
	GeometryTransformer.apply(this);
	this._snapTolerance = null;
	this._snapPts = null;
	this._isSelfSnap = false;
	if (arguments.length === 2) {
		var snapTolerance = arguments[0],
		    snapPts = arguments[1];
		this._snapTolerance = snapTolerance;
		this._snapPts = snapPts;
	} else if (arguments.length === 3) {
		var _snapTolerance = arguments[0],
		    _snapPts = arguments[1],
		    isSelfSnap = arguments[2];
		this._snapTolerance = _snapTolerance;
		this._snapPts = _snapPts;
		this._isSelfSnap = isSelfSnap;
	}
}
inherits(SnapTransformer, GeometryTransformer);
extend(SnapTransformer.prototype, {
	snapLine: function snapLine(srcPts, snapPts) {
		var snapper = new LineStringSnapper(srcPts, this._snapTolerance);
		snapper.setAllowSnappingToSourceVertices(this._isSelfSnap);
		return snapper.snapTo(snapPts);
	},
	transformCoordinates: function transformCoordinates(coords, parent) {
		var srcPts = coords.toCoordinateArray();
		var newPts = this.snapLine(srcPts, this._snapPts);
		return this._factory.getCoordinateSequenceFactory().create(newPts);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return SnapTransformer;
	}
});

function CommonBits() {
	this._isFirst = true;
	this._commonMantissaBitsCount = 53;
	this._commonBits = new Long();
	this._commonSignExp = null;
}
extend(CommonBits.prototype, {
	getCommon: function getCommon() {
		return Double.longBitsToDouble(this._commonBits);
	},
	add: function add(num) {
		var numBits = Double.doubleToLongBits(num);
		if (this._isFirst) {
			this._commonBits = numBits;
			this._commonSignExp = CommonBits.signExpBits(this._commonBits);
			this._isFirst = false;
			return null;
		}
		var numSignExp = CommonBits.signExpBits(numBits);
		if (numSignExp !== this._commonSignExp) {
			this._commonBits.high = 0 | 0;
			this._commonBits.low = 0 | 0;
			return null;
		}
		this._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);
		this._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
	},
	toString: function toString() {
		if (arguments.length === 1) {
			var bits = arguments[0];
			var x = Double.longBitsToDouble(bits);
			var numStr = Long.toBinaryString(bits);
			var padStr = "0000000000000000000000000000000000000000000000000000000000000000" + numStr;
			var bitStr = padStr.substring(padStr.length - 64);
			var str = bitStr.substring(0, 1) + "  " + bitStr.substring(1, 12) + "(exp) " + bitStr.substring(12) + " [ " + x + " ]";
			return str;
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return CommonBits;
	}
});
CommonBits.getBit = function (bits, i) {
	var mask = 1 << i % 32;
	if (i < 32) {
		return (bits.low & mask) != 0 ? 1 : 0;
	}
	return (bits.high & mask) != 0 ? 1 : 0;
};
CommonBits.signExpBits = function (num) {
	return num.high >>> 20;
};
CommonBits.zeroLowerBits = function (bits, nBits) {
	var prop = 'low';
	if (nBits > 32) {
		bits.low = 0 | 0;
		nBits %= 32;
		prop = 'high';
	}
	if (nBits > 0) {
		var mask = nBits < 32 ? ~((1 << nBits) - 1) : 0;
		bits[prop] &= mask;
	}
	return bits;
};
CommonBits.numCommonMostSigMantissaBits = function (num1, num2) {
	var count = 0;
	for (var i = 52; i >= 0; i--) {
		if (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) return count;
		count++;
	}
	return 52;
};

function CommonBitsRemover() {
	this._commonCoord = null;
	this._ccFilter = new CommonCoordinateFilter();
}
extend(CommonBitsRemover.prototype, {
	addCommonBits: function addCommonBits(geom) {
		var trans = new Translater(this._commonCoord);
		geom.apply(trans);
		geom.geometryChanged();
	},
	removeCommonBits: function removeCommonBits(geom) {
		if (this._commonCoord.x === 0.0 && this._commonCoord.y === 0.0) return geom;
		var invCoord = new Coordinate(this._commonCoord);
		invCoord.x = -invCoord.x;
		invCoord.y = -invCoord.y;
		var trans = new Translater(invCoord);
		geom.apply(trans);
		geom.geometryChanged();
		return geom;
	},
	getCommonCoordinate: function getCommonCoordinate() {
		return this._commonCoord;
	},
	add: function add(geom) {
		geom.apply(this._ccFilter);
		this._commonCoord = this._ccFilter.getCommonCoordinate();
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return CommonBitsRemover;
	}
});
function CommonCoordinateFilter() {
	this._commonBitsX = new CommonBits();
	this._commonBitsY = new CommonBits();
}
extend(CommonCoordinateFilter.prototype, {
	filter: function filter(coord) {
		this._commonBitsX.add(coord.x);
		this._commonBitsY.add(coord.y);
	},
	getCommonCoordinate: function getCommonCoordinate() {
		return new Coordinate(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
	},
	interfaces_: function interfaces_() {
		return [CoordinateFilter];
	},
	getClass: function getClass() {
		return CommonCoordinateFilter;
	}
});
function Translater() {
	this.trans = null;
	var trans = arguments[0];
	this.trans = trans;
}
extend(Translater.prototype, {
	filter: function filter(seq, i) {
		var xp = seq.getOrdinate(i, 0) + this.trans.x;
		var yp = seq.getOrdinate(i, 1) + this.trans.y;
		seq.setOrdinate(i, 0, xp);
		seq.setOrdinate(i, 1, yp);
	},
	isDone: function isDone() {
		return false;
	},
	isGeometryChanged: function isGeometryChanged() {
		return true;
	},
	interfaces_: function interfaces_() {
		return [CoordinateSequenceFilter];
	},
	getClass: function getClass() {
		return Translater;
	}
});
CommonBitsRemover.CommonCoordinateFilter = CommonCoordinateFilter;
CommonBitsRemover.Translater = Translater;

function SnapOverlayOp() {
	this._geom = new Array(2).fill(null);
	this._snapTolerance = null;
	this._cbr = null;
	var g1 = arguments[0],
	    g2 = arguments[1];
	this._geom[0] = g1;
	this._geom[1] = g2;
	this.computeSnapTolerance();
}
extend(SnapOverlayOp.prototype, {
	selfSnap: function selfSnap(geom) {
		var snapper0 = new GeometrySnapper(geom);
		var snapGeom = snapper0.snapTo(geom, this._snapTolerance);
		return snapGeom;
	},
	removeCommonBits: function removeCommonBits(geom) {
		this._cbr = new CommonBitsRemover();
		this._cbr.add(geom[0]);
		this._cbr.add(geom[1]);
		var remGeom = new Array(2).fill(null);
		remGeom[0] = this._cbr.removeCommonBits(geom[0].copy());
		remGeom[1] = this._cbr.removeCommonBits(geom[1].copy());
		return remGeom;
	},
	prepareResult: function prepareResult(geom) {
		this._cbr.addCommonBits(geom);
		return geom;
	},
	getResultGeometry: function getResultGeometry(opCode) {
		var prepGeom = this.snap(this._geom);
		var result = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);
		return this.prepareResult(result);
	},
	checkValid: function checkValid(g) {
		if (!g.isValid()) {
			System.out.println("Snapped geometry is invalid");
		}
	},
	computeSnapTolerance: function computeSnapTolerance() {
		this._snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
	},
	snap: function snap(geom) {
		var remGeom = this.removeCommonBits(geom);
		var snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1], this._snapTolerance);
		return snapGeom;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return SnapOverlayOp;
	}
});
SnapOverlayOp.overlayOp = function (g0, g1, opCode) {
	var op = new SnapOverlayOp(g0, g1);
	return op.getResultGeometry(opCode);
};
SnapOverlayOp.union = function (g0, g1) {
	return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);
};
SnapOverlayOp.intersection = function (g0, g1) {
	return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);
};
SnapOverlayOp.symDifference = function (g0, g1) {
	return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);
};
SnapOverlayOp.difference = function (g0, g1) {
	return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);
};

function SnapIfNeededOverlayOp() {
	this._geom = new Array(2).fill(null);
	var g1 = arguments[0],
	    g2 = arguments[1];
	this._geom[0] = g1;
	this._geom[1] = g2;
}
extend(SnapIfNeededOverlayOp.prototype, {
	getResultGeometry: function getResultGeometry(opCode) {
		var result = null;
		var isSuccess = false;
		var savedException = null;
		try {
			result = OverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);
			var isValid = true;
			if (isValid) isSuccess = true;
		} catch (ex) {
			if (ex instanceof RuntimeException) {
				savedException = ex;
			} else throw ex;
		} finally {}
		if (!isSuccess) {
			try {
				result = SnapOverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);
			} catch (ex) {
				if (ex instanceof RuntimeException) {
					throw savedException;
				} else throw ex;
			} finally {}
		}
		return result;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return SnapIfNeededOverlayOp;
	}
});
SnapIfNeededOverlayOp.overlayOp = function (g0, g1, opCode) {
	var op = new SnapIfNeededOverlayOp(g0, g1);
	return op.getResultGeometry(opCode);
};
SnapIfNeededOverlayOp.union = function (g0, g1) {
	return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);
};
SnapIfNeededOverlayOp.intersection = function (g0, g1) {
	return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);
};
SnapIfNeededOverlayOp.symDifference = function (g0, g1) {
	return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);
};
SnapIfNeededOverlayOp.difference = function (g0, g1) {
	return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);
};

function GeometryGraphOperation() {
	this._li = new RobustLineIntersector();
	this._resultPrecisionModel = null;
	this._arg = null;
	if (arguments.length === 1) {
		var g0 = arguments[0];
		this.setComputationPrecision(g0.getPrecisionModel());
		this._arg = new Array(1).fill(null);
		this._arg[0] = new GeometryGraph(0, g0);
		
	} else if (arguments.length === 2) {
		var _g = arguments[0],
		    g1 = arguments[1];
		GeometryGraphOperation.call(this, _g, g1, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);
	} else if (arguments.length === 3) {
		var _g2 = arguments[0],
		    _g3 = arguments[1],
		    boundaryNodeRule = arguments[2];
		if (_g2.getPrecisionModel().compareTo(_g3.getPrecisionModel()) >= 0) this.setComputationPrecision(_g2.getPrecisionModel());else this.setComputationPrecision(_g3.getPrecisionModel());
		this._arg = new Array(2).fill(null);
		this._arg[0] = new GeometryGraph(0, _g2, boundaryNodeRule);
		this._arg[1] = new GeometryGraph(1, _g3, boundaryNodeRule);
	}
}
extend(GeometryGraphOperation.prototype, {
	getArgGeometry: function getArgGeometry(i) {
		return this._arg[i].getGeometry();
	},
	setComputationPrecision: function setComputationPrecision(pm) {
		this._resultPrecisionModel = pm;
		this._li.setPrecisionModel(this._resultPrecisionModel);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return GeometryGraphOperation;
	}
});

function OverlayOp() {
	this._ptLocator = new PointLocator();
	this._geomFact = null;
	this._resultGeom = null;
	this._graph = null;
	this._edgeList = new EdgeList();
	this._resultPolyList = new ArrayList();
	this._resultLineList = new ArrayList();
	this._resultPointList = new ArrayList();
	var g0 = arguments[0],
	    g1 = arguments[1];
	GeometryGraphOperation.call(this, g0, g1);
	this._graph = new PlanarGraph(new OverlayNodeFactory());
	this._geomFact = g0.getFactory();
}
inherits(OverlayOp, GeometryGraphOperation);
extend(OverlayOp.prototype, {
	insertUniqueEdge: function insertUniqueEdge(e) {
		var existingEdge = this._edgeList.findEqualEdge(e);
		if (existingEdge !== null) {
			var existingLabel = existingEdge.getLabel();
			var labelToMerge = e.getLabel();
			if (!existingEdge.isPointwiseEqual(e)) {
				labelToMerge = new Label(e.getLabel());
				labelToMerge.flip();
			}
			var depth = existingEdge.getDepth();
			if (depth.isNull()) {
				depth.add(existingLabel);
			}
			depth.add(labelToMerge);
			existingLabel.merge(labelToMerge);
		} else {
			this._edgeList.add(e);
		}
	},
	getGraph: function getGraph() {
		return this._graph;
	},
	cancelDuplicateResultEdges: function cancelDuplicateResultEdges() {
		for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {
			var de = it.next();
			var sym = de.getSym();
			if (de.isInResult() && sym.isInResult()) {
				de.setInResult(false);
				sym.setInResult(false);
			}
		}
	},
	isCoveredByLA: function isCoveredByLA(coord) {
		if (this.isCovered(coord, this._resultLineList)) return true;
		if (this.isCovered(coord, this._resultPolyList)) return true;
		return false;
	},
	computeGeometry: function computeGeometry(resultPointList, resultLineList, resultPolyList, opcode) {
		var geomList = new ArrayList();
		geomList.addAll(resultPointList);
		geomList.addAll(resultLineList);
		geomList.addAll(resultPolyList);
		if (geomList.isEmpty()) return OverlayOp.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact);
		return this._geomFact.buildGeometry(geomList);
	},
	mergeSymLabels: function mergeSymLabels() {
		for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {
			var node = nodeit.next();
			node.getEdges().mergeSymLabels();
		}
	},
	isCovered: function isCovered(coord, geomList) {
		for (var it = geomList.iterator(); it.hasNext();) {
			var geom = it.next();
			var loc = this._ptLocator.locate(coord, geom);
			if (loc !== Location.EXTERIOR) return true;
		}
		return false;
	},
	replaceCollapsedEdges: function replaceCollapsedEdges() {
		var newEdges = new ArrayList();
		for (var it = this._edgeList.iterator(); it.hasNext();) {
			var e = it.next();
			if (e.isCollapsed()) {
				it.remove();
				newEdges.add(e.getCollapsedEdge());
			}
		}
		this._edgeList.addAll(newEdges);
	},
	updateNodeLabelling: function updateNodeLabelling() {
		for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {
			var node = nodeit.next();
			var lbl = node.getEdges().getLabel();
			node.getLabel().merge(lbl);
		}
	},
	getResultGeometry: function getResultGeometry(overlayOpCode) {
		this.computeOverlay(overlayOpCode);
		return this._resultGeom;
	},
	insertUniqueEdges: function insertUniqueEdges(edges) {
		for (var i = edges.iterator(); i.hasNext();) {
			var e = i.next();
			this.insertUniqueEdge(e);
		}
	},
	computeOverlay: function computeOverlay(opCode) {
		this.copyPoints(0);
		this.copyPoints(1);
		this._arg[0].computeSelfNodes(this._li, false);
		this._arg[1].computeSelfNodes(this._li, false);
		this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);
		var baseSplitEdges = new ArrayList();
		this._arg[0].computeSplitEdges(baseSplitEdges);
		this._arg[1].computeSplitEdges(baseSplitEdges);
		this.insertUniqueEdges(baseSplitEdges);
		this.computeLabelsFromDepths();
		this.replaceCollapsedEdges();
		EdgeNodingValidator.checkValid(this._edgeList.getEdges());
		this._graph.addEdges(this._edgeList.getEdges());
		this.computeLabelling();
		this.labelIncompleteNodes();
		this.findResultAreaEdges(opCode);
		this.cancelDuplicateResultEdges();
		var polyBuilder = new PolygonBuilder(this._geomFact);
		polyBuilder.add(this._graph);
		this._resultPolyList = polyBuilder.getPolygons();
		var lineBuilder = new LineBuilder(this, this._geomFact, this._ptLocator);
		this._resultLineList = lineBuilder.build(opCode);
		var pointBuilder = new PointBuilder(this, this._geomFact, this._ptLocator);
		this._resultPointList = pointBuilder.build(opCode);
		this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);
	},
	labelIncompleteNode: function labelIncompleteNode(n, targetIndex) {
		var loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());
		n.getLabel().setLocation(targetIndex, loc);
	},
	copyPoints: function copyPoints(argIndex) {
		for (var i = this._arg[argIndex].getNodeIterator(); i.hasNext();) {
			var graphNode = i.next();
			var newNode = this._graph.addNode(graphNode.getCoordinate());
			newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
		}
	},
	findResultAreaEdges: function findResultAreaEdges(opCode) {
		for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {
			var de = it.next();
			var label = de.getLabel();
			if (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) {
				de.setInResult(true);
			}
		}
	},
	computeLabelsFromDepths: function computeLabelsFromDepths() {
		for (var it = this._edgeList.iterator(); it.hasNext();) {
			var e = it.next();
			var lbl = e.getLabel();
			var depth = e.getDepth();
			if (!depth.isNull()) {
				depth.normalize();
				for (var i = 0; i < 2; i++) {
					if (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {
						if (depth.getDelta(i) === 0) {
							lbl.toLine(i);
						} else {
							Assert.isTrue(!depth.isNull(i, Position.LEFT), "depth of LEFT side has not been initialized");
							lbl.setLocation(i, Position.LEFT, depth.getLocation(i, Position.LEFT));
							Assert.isTrue(!depth.isNull(i, Position.RIGHT), "depth of RIGHT side has not been initialized");
							lbl.setLocation(i, Position.RIGHT, depth.getLocation(i, Position.RIGHT));
						}
					}
				}
			}
		}
	},
	computeLabelling: function computeLabelling() {
		for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {
			var node = nodeit.next();
			node.getEdges().computeLabelling(this._arg);
		}
		this.mergeSymLabels();
		this.updateNodeLabelling();
	},
	labelIncompleteNodes: function labelIncompleteNodes() {
		for (var ni = this._graph.getNodes().iterator(); ni.hasNext();) {
			var n = ni.next();
			var label = n.getLabel();
			if (n.isIsolated()) {
				if (label.isNull(0)) this.labelIncompleteNode(n, 0);else this.labelIncompleteNode(n, 1);
			}
			n.getEdges().updateLabelling(label);
		}
	},
	isCoveredByA: function isCoveredByA(coord) {
		if (this.isCovered(coord, this._resultPolyList)) return true;
		return false;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return OverlayOp;
	}
});
OverlayOp.overlayOp = function (geom0, geom1, opCode) {
	var gov = new OverlayOp(geom0, geom1);
	var geomOv = gov.getResultGeometry(opCode);
	return geomOv;
};
OverlayOp.union = function (geom, other) {
	if (geom.isEmpty() || other.isEmpty()) {
		if (geom.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.UNION, geom, other, geom.getFactory());
		if (geom.isEmpty()) return other.copy();
		if (other.isEmpty()) return geom.copy();
	}
	if (geom.isGeometryCollection() || other.isGeometryCollection()) throw new IllegalArgumentException("This method does not support GeometryCollection arguments");
	return SnapIfNeededOverlayOp.overlayOp(geom, other, OverlayOp.UNION);
};
OverlayOp.intersection = function (geom, other) {
	if (geom.isEmpty() || other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, geom, other, geom.getFactory());
	if (geom.isGeometryCollection()) {
		var g2 = other;
		return GeometryCollectionMapper.map(geom, {
			interfaces_: function interfaces_() {
				return [MapOp];
			},
			map: function map(g) {
				return g.intersection(g2);
			}
		});
	}
	if (geom.isGeometryCollection() || other.isGeometryCollection()) throw new IllegalArgumentException("This method does not support GeometryCollection arguments");
	return SnapIfNeededOverlayOp.overlayOp(geom, other, OverlayOp.INTERSECTION);
};
OverlayOp.symDifference = function (geom, other) {
	if (geom.isEmpty() || other.isEmpty()) {
		if (geom.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, geom, other, geom.getFactory());
		if (geom.isEmpty()) return other.copy();
		if (other.isEmpty()) return geom.copy();
	}
	if (geom.isGeometryCollection() || other.isGeometryCollection()) throw new IllegalArgumentException("This method does not support GeometryCollection arguments");
	return SnapIfNeededOverlayOp.overlayOp(geom, other, OverlayOp.SYMDIFFERENCE);
};
OverlayOp.resultDimension = function (opCode, g0, g1) {
	var dim0 = g0.getDimension();
	var dim1 = g1.getDimension();
	var resultDimension = -1;
	switch (opCode) {
		case OverlayOp.INTERSECTION:
			resultDimension = Math.min(dim0, dim1);
			break;
		case OverlayOp.UNION:
			resultDimension = Math.max(dim0, dim1);
			break;
		case OverlayOp.DIFFERENCE:
			resultDimension = dim0;
			break;
		case OverlayOp.SYMDIFFERENCE:
			resultDimension = Math.max(dim0, dim1);
			break;
	}
	return resultDimension;
};
OverlayOp.createEmptyResult = function (overlayOpCode, a, b, geomFact) {
	var result = null;
	switch (OverlayOp.resultDimension(overlayOpCode, a, b)) {
		case -1:
			result = geomFact.createGeometryCollection();
			break;
		case 0:
			result = geomFact.createPoint();
			break;
		case 1:
			result = geomFact.createLineString();
			break;
		case 2:
			result = geomFact.createPolygon();
			break;
	}
	return result;
};
OverlayOp.difference = function (geom, other) {
	if (geom.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, geom, other, geom.getFactory());
	if (other.isEmpty()) return geom.copy();
	if (geom.isGeometryCollection() || other.isGeometryCollection()) throw new IllegalArgumentException("This method does not support GeometryCollection arguments");
	return SnapIfNeededOverlayOp.overlayOp(geom, other, OverlayOp.DIFFERENCE);
};
OverlayOp.isResultOfOp = function () {
	if (arguments.length === 2) {
		var label = arguments[0],
		    opCode = arguments[1];
		var loc0 = label.getLocation(0);
		var loc1 = label.getLocation(1);
		return OverlayOp.isResultOfOp(loc0, loc1, opCode);
	} else if (arguments.length === 3) {
		var _loc = arguments[0],
		    _loc2 = arguments[1],
		    overlayOpCode = arguments[2];
		if (_loc === Location.BOUNDARY) _loc = Location.INTERIOR;
		if (_loc2 === Location.BOUNDARY) _loc2 = Location.INTERIOR;
		switch (overlayOpCode) {
			case OverlayOp.INTERSECTION:
				return _loc === Location.INTERIOR && _loc2 === Location.INTERIOR;
			case OverlayOp.UNION:
				return _loc === Location.INTERIOR || _loc2 === Location.INTERIOR;
			case OverlayOp.DIFFERENCE:
				return _loc === Location.INTERIOR && _loc2 !== Location.INTERIOR;
			case OverlayOp.SYMDIFFERENCE:
				return _loc === Location.INTERIOR && _loc2 !== Location.INTERIOR || _loc !== Location.INTERIOR && _loc2 === Location.INTERIOR;
		}
		return false;
	}
};
OverlayOp.INTERSECTION = 1;
OverlayOp.UNION = 2;
OverlayOp.DIFFERENCE = 3;
OverlayOp.SYMDIFFERENCE = 4;



var overlay = Object.freeze({
	OverlayOp: OverlayOp
});

function PolygonizeDirectedEdge() {
	this._edgeRing = null;
	this._next = null;
	this._label = -1;
	var from = arguments[0],
	    to = arguments[1],
	    directionPt = arguments[2],
	    edgeDirection = arguments[3];
	DirectedEdge$1.call(this, from, to, directionPt, edgeDirection);
}
inherits(PolygonizeDirectedEdge, DirectedEdge$1);
extend(PolygonizeDirectedEdge.prototype, {
	getNext: function getNext() {
		return this._next;
	},
	isInRing: function isInRing() {
		return this._edgeRing !== null;
	},
	setRing: function setRing(edgeRing) {
		this._edgeRing = edgeRing;
	},
	setLabel: function setLabel(label) {
		this._label = label;
	},
	getLabel: function getLabel() {
		return this._label;
	},
	setNext: function setNext(next) {
		this._next = next;
	},
	getRing: function getRing() {
		return this._edgeRing;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return PolygonizeDirectedEdge;
	}
});

function PolygonizeEdge() {
	Edge$1.apply(this);
	this._line = null;
	var line = arguments[0];
	this._line = line;
}
inherits(PolygonizeEdge, Edge$1);
extend(PolygonizeEdge.prototype, {
	getLine: function getLine() {
		return this._line;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return PolygonizeEdge;
	}
});

function EdgeRing$1() {
	this._factory = null;
	this._deList = new ArrayList();
	this._lowestEdge = null;
	this._ring = null;
	this._ringPts = null;
	this._holes = null;
	this._shell = null;
	this._isHole = null;
	this._isProcessed = false;
	this._isIncludedSet = false;
	this._isIncluded = false;
	var factory = arguments[0];
	this._factory = factory;
}
extend(EdgeRing$1.prototype, {
	isIncluded: function isIncluded() {
		return this._isIncluded;
	},
	getCoordinates: function getCoordinates() {
		if (this._ringPts === null) {
			var coordList = new CoordinateList();
			for (var i = this._deList.iterator(); i.hasNext();) {
				var de = i.next();
				var edge = de.getEdge();
				EdgeRing$1.addEdge(edge.getLine().getCoordinates(), de.getEdgeDirection(), coordList);
			}
			this._ringPts = coordList.toCoordinateArray();
		}
		return this._ringPts;
	},
	isIncludedSet: function isIncludedSet() {
		return this._isIncludedSet;
	},
	isValid: function isValid() {
		this.getCoordinates();
		if (this._ringPts.length <= 3) return false;
		this.getRing();
		return this._ring.isValid();
	},
	build: function build(startDE) {
		var de = startDE;
		do {
			this.add(de);
			de.setRing(this);
			de = de.getNext();
			Assert.isTrue(de !== null, "found null DE in ring");
			Assert.isTrue(de === startDE || !de.isInRing(), "found DE already in ring");
		} while (de !== startDE);
	},
	isOuterHole: function isOuterHole() {
		if (!this._isHole) return false;
		return !this.hasShell();
	},
	getPolygon: function getPolygon() {
		var holeLR = null;
		if (this._holes !== null) {
			holeLR = new Array(this._holes.size()).fill(null);
			for (var i = 0; i < this._holes.size(); i++) {
				holeLR[i] = this._holes.get(i);
			}
		}
		var poly = this._factory.createPolygon(this._ring, holeLR);
		return poly;
	},
	isHole: function isHole() {
		return this._isHole;
	},
	isProcessed: function isProcessed() {
		return this._isProcessed;
	},
	addHole: function addHole() {
		if (arguments[0] instanceof LinearRing) {
			var _hole = arguments[0];
			if (this._holes === null) this._holes = new ArrayList();
			this._holes.add(_hole);
		} else if (arguments[0] instanceof EdgeRing$1) {
			var holeER = arguments[0];
			holeER.setShell(this);
			var hole = holeER.getRing();
			if (this._holes === null) this._holes = new ArrayList();
			this._holes.add(hole);
		}
	},
	setIncluded: function setIncluded(isIncluded) {
		this._isIncluded = isIncluded;
		this._isIncludedSet = true;
	},
	getOuterHole: function getOuterHole() {
		if (this.isHole()) return null;
		for (var i = 0; i < this._deList.size(); i++) {
			var de = this._deList.get(i);
			var adjRing = de.getSym().getRing();
			if (adjRing.isOuterHole()) return adjRing;
		}
		return null;
	},
	computeHole: function computeHole() {
		var ring = this.getRing();
		this._isHole = Orientation.isCCW(ring.getCoordinates());
	},
	hasShell: function hasShell() {
		return this._shell !== null;
	},
	isOuterShell: function isOuterShell() {
		return this.getOuterHole() !== null;
	},
	getLineString: function getLineString() {
		this.getCoordinates();
		return this._factory.createLineString(this._ringPts);
	},
	toString: function toString() {
		return WKTWriter.toLineString(new CoordinateArraySequence(this.getCoordinates()));
	},
	getShell: function getShell() {
		if (this.isHole()) return this._shell;
		return this;
	},
	add: function add(de) {
		this._deList.add(de);
	},
	getRing: function getRing() {
		if (this._ring !== null) return this._ring;
		this.getCoordinates();
		if (this._ringPts.length < 3) System.out.println(this._ringPts);
		try {
			this._ring = this._factory.createLinearRing(this._ringPts);
		} catch (ex) {
			if (ex instanceof Exception) {
				System.out.println(this._ringPts);
			} else throw ex;
		} finally {}
		return this._ring;
	},
	updateIncluded: function updateIncluded() {
		if (this.isHole()) return null;
		for (var i = 0; i < this._deList.size(); i++) {
			var de = this._deList.get(i);
			var adjShell = de.getSym().getRing().getShell();
			if (adjShell !== null && adjShell.isIncludedSet()) {
				this.setIncluded(!adjShell.isIncluded());
				return null;
			}
		}
	},
	setShell: function setShell(shell) {
		this._shell = shell;
	},
	setProcessed: function setProcessed(isProcessed) {
		this._isProcessed = isProcessed;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return EdgeRing$1;
	}
});
EdgeRing$1.findDirEdgesInRing = function (startDE) {
	var de = startDE;
	var edges = new ArrayList();
	do {
		edges.add(de);
		de = de.getNext();
		Assert.isTrue(de !== null, "found null DE in ring");
		Assert.isTrue(de === startDE || !de.isInRing(), "found DE already in ring");
	} while (de !== startDE);
	return edges;
};
EdgeRing$1.addEdge = function (coords, isForward, coordList) {
	if (isForward) {
		for (var i = 0; i < coords.length; i++) {
			coordList.add(coords[i], false);
		}
	} else {
		for (var i = coords.length - 1; i >= 0; i--) {
			coordList.add(coords[i], false);
		}
	}
};
EdgeRing$1.findEdgeRingContaining = function (testEr, shellList) {
	var testRing = testEr.getRing();
	var testEnv = testRing.getEnvelopeInternal();
	var testPt = testRing.getCoordinateN(0);
	var minShell = null;
	var minShellEnv = null;
	for (var it = shellList.iterator(); it.hasNext();) {
		var tryShell = it.next();
		var tryShellRing = tryShell.getRing();
		var tryShellEnv = tryShellRing.getEnvelopeInternal();
		if (tryShellEnv.equals(testEnv)) continue;
		if (!tryShellEnv.contains(testEnv)) continue;
		testPt = CoordinateArrays.ptNotInList(testRing.getCoordinates(), tryShellRing.getCoordinates());
		var isContained = false;
		if (PointLocation.isInRing(testPt, tryShellRing.getCoordinates())) isContained = true;
		if (isContained) {
			if (minShell === null || minShellEnv.contains(tryShellEnv)) {
				minShell = tryShell;
				minShellEnv = minShell.getRing().getEnvelopeInternal();
			}
		}
	}
	return minShell;
};
function EnvelopeComparator() {}
extend(EnvelopeComparator.prototype, {
	compare: function compare(obj0, obj1) {
		var r0 = obj0;
		var r1 = obj1;
		return r0.getRing().getEnvelope().compareTo(r1.getRing().getEnvelope());
	},
	interfaces_: function interfaces_() {
		return [Comparator];
	},
	getClass: function getClass() {
		return EnvelopeComparator;
	}
});
EdgeRing$1.EnvelopeComparator = EnvelopeComparator;

function PolygonizeGraph() {
	PlanarGraph$1.apply(this);
	this._factory = null;
	var factory = arguments[0];
	this._factory = factory;
}
inherits(PolygonizeGraph, PlanarGraph$1);
extend(PolygonizeGraph.prototype, {
	findEdgeRing: function findEdgeRing(startDE) {
		var er = new EdgeRing$1(this._factory);
		er.build(startDE);
		return er;
	},
	computeDepthParity: function computeDepthParity() {
		if (arguments.length === 0) {
			while (true) {
				var de = null;
				if (de === null) return null;
				this.computeDepthParity(de);
			}
		} else if (arguments.length === 1) {
			
		}
	},
	computeNextCWEdges: function computeNextCWEdges() {
		for (var iNode = this.nodeIterator(); iNode.hasNext();) {
			var node = iNode.next();
			PolygonizeGraph.computeNextCWEdges(node);
		}
	},
	addEdge: function addEdge(line) {
		if (line.isEmpty()) {
			return null;
		}
		var linePts = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());
		if (linePts.length < 2) {
			return null;
		}
		var startPt = linePts[0];
		var endPt = linePts[linePts.length - 1];
		var nStart = this.getNode(startPt);
		var nEnd = this.getNode(endPt);
		var de0 = new PolygonizeDirectedEdge(nStart, nEnd, linePts[1], true);
		var de1 = new PolygonizeDirectedEdge(nEnd, nStart, linePts[linePts.length - 2], false);
		var edge = new PolygonizeEdge(line);
		edge.setDirectedEdges(de0, de1);
		this.add(edge);
	},
	deleteCutEdges: function deleteCutEdges() {
		this.computeNextCWEdges();
		PolygonizeGraph.findLabeledEdgeRings(this._dirEdges);
		var cutLines = new ArrayList();
		for (var i = this._dirEdges.iterator(); i.hasNext();) {
			var de = i.next();
			if (de.isMarked()) continue;
			var sym = de.getSym();
			if (de.getLabel() === sym.getLabel()) {
				de.setMarked(true);
				sym.setMarked(true);
				var e = de.getEdge();
				cutLines.add(e.getLine());
			}
		}
		return cutLines;
	},
	getEdgeRings: function getEdgeRings() {
		this.computeNextCWEdges();
		PolygonizeGraph.label(this._dirEdges, -1);
		var maximalRings = PolygonizeGraph.findLabeledEdgeRings(this._dirEdges);
		this.convertMaximalToMinimalEdgeRings(maximalRings);
		var edgeRingList = new ArrayList();
		for (var i = this._dirEdges.iterator(); i.hasNext();) {
			var de = i.next();
			if (de.isMarked()) continue;
			if (de.isInRing()) continue;
			var er = this.findEdgeRing(de);
			edgeRingList.add(er);
		}
		return edgeRingList;
	},
	getNode: function getNode(pt) {
		var node = this.findNode(pt);
		if (node === null) {
			node = new Node$3(pt);
			this.add(node);
		}
		return node;
	},
	convertMaximalToMinimalEdgeRings: function convertMaximalToMinimalEdgeRings(ringEdges) {
		for (var i = ringEdges.iterator(); i.hasNext();) {
			var de = i.next();
			var label = de.getLabel();
			var intNodes = PolygonizeGraph.findIntersectionNodes(de, label);
			if (intNodes === null) continue;
			for (var iNode = intNodes.iterator(); iNode.hasNext();) {
				var node = iNode.next();
				PolygonizeGraph.computeNextCCWEdges(node, label);
			}
		}
	},
	deleteDangles: function deleteDangles() {
		var nodesToRemove = this.findNodesOfDegree(1);
		var dangleLines = new HashSet();
		var nodeStack = new Stack();
		for (var i = nodesToRemove.iterator(); i.hasNext();) {
			nodeStack.push(i.next());
		}
		while (!nodeStack.isEmpty()) {
			var node = nodeStack.pop();
			PolygonizeGraph.deleteAllEdges(node);
			var nodeOutEdges = node.getOutEdges().getEdges();
			for (var i = nodeOutEdges.iterator(); i.hasNext();) {
				var de = i.next();
				de.setMarked(true);
				var sym = de.getSym();
				if (sym !== null) sym.setMarked(true);
				var e = de.getEdge();
				dangleLines.add(e.getLine());
				var toNode = de.getToNode();
				if (PolygonizeGraph.getDegreeNonDeleted(toNode) === 1) nodeStack.push(toNode);
			}
		}
		return dangleLines;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return PolygonizeGraph;
	}
});
PolygonizeGraph.findLabeledEdgeRings = function (dirEdges) {
	var edgeRingStarts = new ArrayList();
	var currLabel = 1;
	for (var i = dirEdges.iterator(); i.hasNext();) {
		var de = i.next();
		if (de.isMarked()) continue;
		if (de.getLabel() >= 0) continue;
		edgeRingStarts.add(de);
		var edges = EdgeRing$1.findDirEdgesInRing(de);
		PolygonizeGraph.label(edges, currLabel);
		currLabel++;
	}
	return edgeRingStarts;
};
PolygonizeGraph.getDegreeNonDeleted = function (node) {
	var edges = node.getOutEdges().getEdges();
	var degree = 0;
	for (var i = edges.iterator(); i.hasNext();) {
		var de = i.next();
		if (!de.isMarked()) degree++;
	}
	return degree;
};
PolygonizeGraph.deleteAllEdges = function (node) {
	var edges = node.getOutEdges().getEdges();
	for (var i = edges.iterator(); i.hasNext();) {
		var de = i.next();
		de.setMarked(true);
		var sym = de.getSym();
		if (sym !== null) sym.setMarked(true);
	}
};
PolygonizeGraph.label = function (dirEdges, label) {
	for (var i = dirEdges.iterator(); i.hasNext();) {
		var de = i.next();
		de.setLabel(label);
	}
};
PolygonizeGraph.computeNextCWEdges = function (node) {
	var deStar = node.getOutEdges();
	var startDE = null;
	var prevDE = null;
	for (var i = deStar.getEdges().iterator(); i.hasNext();) {
		var outDE = i.next();
		if (outDE.isMarked()) continue;
		if (startDE === null) startDE = outDE;
		if (prevDE !== null) {
			var sym = prevDE.getSym();
			sym.setNext(outDE);
		}
		prevDE = outDE;
	}
	if (prevDE !== null) {
		var sym = prevDE.getSym();
		sym.setNext(startDE);
	}
};
PolygonizeGraph.computeNextCCWEdges = function (node, label) {
	var deStar = node.getOutEdges();
	var firstOutDE = null;
	var prevInDE = null;
	var edges = deStar.getEdges();
	for (var i = edges.size() - 1; i >= 0; i--) {
		var de = edges.get(i);
		var sym = de.getSym();
		var outDE = null;
		if (de.getLabel() === label) outDE = de;
		var inDE = null;
		if (sym.getLabel() === label) inDE = sym;
		if (outDE === null && inDE === null) continue;
		if (inDE !== null) {
			prevInDE = inDE;
		}
		if (outDE !== null) {
			if (prevInDE !== null) {
				prevInDE.setNext(outDE);
				prevInDE = null;
			}
			if (firstOutDE === null) firstOutDE = outDE;
		}
	}
	if (prevInDE !== null) {
		Assert.isTrue(firstOutDE !== null);
		prevInDE.setNext(firstOutDE);
	}
};
PolygonizeGraph.getDegree = function (node, label) {
	var edges = node.getOutEdges().getEdges();
	var degree = 0;
	for (var i = edges.iterator(); i.hasNext();) {
		var de = i.next();
		if (de.getLabel() === label) degree++;
	}
	return degree;
};
PolygonizeGraph.findIntersectionNodes = function (startDE, label) {
	var de = startDE;
	var intNodes = null;
	do {
		var node = de.getFromNode();
		if (PolygonizeGraph.getDegree(node, label) > 1) {
			if (intNodes === null) intNodes = new ArrayList();
			intNodes.add(node);
		}
		de = de.getNext();
		Assert.isTrue(de !== null, "found null DE in ring");
		Assert.isTrue(de === startDE || !de.isInRing(), "found DE already in ring");
	} while (de !== startDE);
	return intNodes;
};

function Polygonizer() {
	this._lineStringAdder = new LineStringAdder(this);
	this._graph = null;
	this._dangles = new ArrayList();
	this._cutEdges = new ArrayList();
	this._invalidRingLines = new ArrayList();
	this._holeList = null;
	this._shellList = null;
	this._polyList = null;
	this._isCheckingRingsValid = true;
	this._extractOnlyPolygonal = null;
	this._geomFactory = null;
	if (arguments.length === 0) {
		Polygonizer.call(this, false);
	} else if (arguments.length === 1) {
		var extractOnlyPolygonal = arguments[0];
		this._extractOnlyPolygonal = extractOnlyPolygonal;
	}
}
extend(Polygonizer.prototype, {
	getGeometry: function getGeometry() {
		if (this._geomFactory === null) this._geomFactory = new GeometryFactory();
		this.polygonize();
		if (this._extractOnlyPolygonal) {
			return this._geomFactory.buildGeometry(this._polyList);
		}
		return this._geomFactory.createGeometryCollection(GeometryFactory.toGeometryArray(this._polyList));
	},
	getInvalidRingLines: function getInvalidRingLines() {
		this.polygonize();
		return this._invalidRingLines;
	},
	findValidRings: function findValidRings(edgeRingList, validEdgeRingList, invalidRingList) {
		for (var i = edgeRingList.iterator(); i.hasNext();) {
			var er = i.next();
			if (er.isValid()) validEdgeRingList.add(er);else invalidRingList.add(er.getLineString());
		}
	},
	polygonize: function polygonize() {
		if (this._polyList !== null) return null;
		this._polyList = new ArrayList();
		if (this._graph === null) return null;
		this._dangles = this._graph.deleteDangles();
		this._cutEdges = this._graph.deleteCutEdges();
		var edgeRingList = this._graph.getEdgeRings();
		var validEdgeRingList = new ArrayList();
		this._invalidRingLines = new ArrayList();
		if (this._isCheckingRingsValid) {
			this.findValidRings(edgeRingList, validEdgeRingList, this._invalidRingLines);
		} else {
			validEdgeRingList = edgeRingList;
		}
		this.findShellsAndHoles(validEdgeRingList);
		Polygonizer.assignHolesToShells(this._holeList, this._shellList);
		Collections.sort(this._shellList, new EdgeRing$1.EnvelopeComparator());
		var includeAll = true;
		if (this._extractOnlyPolygonal) {
			Polygonizer.findDisjointShells(this._shellList);
			includeAll = false;
		}
		this._polyList = Polygonizer.extractPolygons(this._shellList, includeAll);
	},
	getDangles: function getDangles() {
		this.polygonize();
		return this._dangles;
	},
	getCutEdges: function getCutEdges() {
		this.polygonize();
		return this._cutEdges;
	},
	getPolygons: function getPolygons() {
		this.polygonize();
		return this._polyList;
	},
	add: function add() {
		if (hasInterface(arguments[0], Collection)) {
			var geomList = arguments[0];
			for (var i = geomList.iterator(); i.hasNext();) {
				var geometry = i.next();
				this.add(geometry);
			}
		} else if (arguments[0] instanceof LineString) {
			var line = arguments[0];
			this._geomFactory = line.getFactory();
			if (this._graph === null) this._graph = new PolygonizeGraph(this._geomFactory);
			this._graph.addEdge(line);
		} else if (arguments[0] instanceof Geometry) {
			var g = arguments[0];
			g.apply(this._lineStringAdder);
		}
	},
	setCheckRingsValid: function setCheckRingsValid(isCheckingRingsValid) {
		this._isCheckingRingsValid = isCheckingRingsValid;
	},
	findShellsAndHoles: function findShellsAndHoles(edgeRingList) {
		this._holeList = new ArrayList();
		this._shellList = new ArrayList();
		for (var i = edgeRingList.iterator(); i.hasNext();) {
			var er = i.next();
			er.computeHole();
			if (er.isHole()) this._holeList.add(er);else this._shellList.add(er);
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Polygonizer;
	}
});
Polygonizer.findOuterShells = function (shellList) {
	for (var i = shellList.iterator(); i.hasNext();) {
		var er = i.next();
		var outerHoleER = er.getOuterHole();
		if (outerHoleER !== null && !outerHoleER.isProcessed()) {
			er.setIncluded(true);
			outerHoleER.setProcessed(true);
		}
	}
};
Polygonizer.extractPolygons = function (shellList, includeAll) {
	var polyList = new ArrayList();
	for (var i = shellList.iterator(); i.hasNext();) {
		var er = i.next();
		if (includeAll || er.isIncluded()) {
			polyList.add(er.getPolygon());
		}
	}
	return polyList;
};
Polygonizer.assignHolesToShells = function (holeList, shellList) {
	for (var i = holeList.iterator(); i.hasNext();) {
		var holeER = i.next();
		Polygonizer.assignHoleToShell(holeER, shellList);
	}
};
Polygonizer.assignHoleToShell = function (holeER, shellList) {
	var shell = EdgeRing$1.findEdgeRingContaining(holeER, shellList);
	if (shell !== null) {
		shell.addHole(holeER);
	}
};
Polygonizer.findDisjointShells = function (shellList) {
	Polygonizer.findOuterShells(shellList);
	var isMoreToScan = null;
	do {
		isMoreToScan = false;
		for (var i = shellList.iterator(); i.hasNext();) {
			var er = i.next();
			if (er.isIncludedSet()) continue;
			er.updateIncluded();
			if (!er.isIncludedSet()) {
				isMoreToScan = true;
			}
		}
	} while (isMoreToScan);
};
function LineStringAdder() {
	this.p = null;
	var p = arguments[0];
	this.p = p;
}
extend(LineStringAdder.prototype, {
	filter: function filter(g) {
		if (g instanceof LineString) this.p.add(g);
	},
	interfaces_: function interfaces_() {
		return [GeometryComponentFilter];
	},
	getClass: function getClass() {
		return LineStringAdder;
	}
});
Polygonizer.LineStringAdder = LineStringAdder;



var polygonize = Object.freeze({
	Polygonizer: Polygonizer
});

function EdgeEndBuilder() {}
extend(EdgeEndBuilder.prototype, {
	createEdgeEndForNext: function createEdgeEndForNext(edge, l, eiCurr, eiNext) {
		var iNext = eiCurr.segmentIndex + 1;
		if (iNext >= edge.getNumPoints() && eiNext === null) return null;
		var pNext = edge.getCoordinate(iNext);
		if (eiNext !== null && eiNext.segmentIndex === eiCurr.segmentIndex) pNext = eiNext.coord;
		var e = new EdgeEnd(edge, eiCurr.coord, pNext, new Label(edge.getLabel()));
		l.add(e);
	},
	createEdgeEndForPrev: function createEdgeEndForPrev(edge, l, eiCurr, eiPrev) {
		var iPrev = eiCurr.segmentIndex;
		if (eiCurr.dist === 0.0) {
			if (iPrev === 0) return null;
			iPrev--;
		}
		var pPrev = edge.getCoordinate(iPrev);
		if (eiPrev !== null && eiPrev.segmentIndex >= iPrev) pPrev = eiPrev.coord;
		var label = new Label(edge.getLabel());
		label.flip();
		var e = new EdgeEnd(edge, eiCurr.coord, pPrev, label);
		l.add(e);
	},
	computeEdgeEnds: function computeEdgeEnds() {
		if (arguments.length === 1) {
			var edges = arguments[0];
			var l = new ArrayList();
			for (var i = edges; i.hasNext();) {
				var e = i.next();
				this.computeEdgeEnds(e, l);
			}
			return l;
		} else if (arguments.length === 2) {
			var edge = arguments[0],
			    _l = arguments[1];
			var eiList = edge.getEdgeIntersectionList();
			eiList.addEndpoints();
			var it = eiList.iterator();
			var eiPrev = null;
			var eiCurr = null;
			if (!it.hasNext()) return null;
			var eiNext = it.next();
			do {
				eiPrev = eiCurr;
				eiCurr = eiNext;
				eiNext = null;
				if (it.hasNext()) eiNext = it.next();
				if (eiCurr !== null) {
					this.createEdgeEndForPrev(edge, _l, eiCurr, eiPrev);
					this.createEdgeEndForNext(edge, _l, eiCurr, eiNext);
				}
			} while (eiCurr !== null);
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return EdgeEndBuilder;
	}
});

function EdgeEndBundle() {
	this._edgeEnds = new ArrayList();
	if (arguments.length === 1) {
		var e = arguments[0];
		EdgeEndBundle.call(this, null, e);
	} else if (arguments.length === 2) {
		var boundaryNodeRule = arguments[0],
		    _e = arguments[1];
		EdgeEnd.call(this, _e.getEdge(), _e.getCoordinate(), _e.getDirectedCoordinate(), new Label(_e.getLabel()));
		this.insert(_e);
	}
}
inherits(EdgeEndBundle, EdgeEnd);
extend(EdgeEndBundle.prototype, {
	insert: function insert(e) {
		this._edgeEnds.add(e);
	},
	print: function print(out) {
		out.println("EdgeEndBundle--> Label: " + this._label);
		for (var it = this.iterator(); it.hasNext();) {
			var ee = it.next();
			ee.print(out);
			out.println();
		}
	},
	iterator: function iterator() {
		return this._edgeEnds.iterator();
	},
	getEdgeEnds: function getEdgeEnds() {
		return this._edgeEnds;
	},
	computeLabelOn: function computeLabelOn(geomIndex, boundaryNodeRule) {
		var boundaryCount = 0;
		var foundInterior = false;
		for (var it = this.iterator(); it.hasNext();) {
			var e = it.next();
			var loc = e.getLabel().getLocation(geomIndex);
			if (loc === Location.BOUNDARY) boundaryCount++;
			if (loc === Location.INTERIOR) foundInterior = true;
		}
		var loc = Location.NONE;
		if (foundInterior) loc = Location.INTERIOR;
		if (boundaryCount > 0) {
			loc = GeometryGraph.determineBoundary(boundaryNodeRule, boundaryCount);
		}
		this._label.setLocation(geomIndex, loc);
	},
	computeLabelSide: function computeLabelSide(geomIndex, side) {
		for (var it = this.iterator(); it.hasNext();) {
			var e = it.next();
			if (e.getLabel().isArea()) {
				var loc = e.getLabel().getLocation(geomIndex, side);
				if (loc === Location.INTERIOR) {
					this._label.setLocation(geomIndex, side, Location.INTERIOR);
					return null;
				} else if (loc === Location.EXTERIOR) this._label.setLocation(geomIndex, side, Location.EXTERIOR);
			}
		}
	},
	getLabel: function getLabel() {
		return this._label;
	},
	computeLabelSides: function computeLabelSides(geomIndex) {
		this.computeLabelSide(geomIndex, Position.LEFT);
		this.computeLabelSide(geomIndex, Position.RIGHT);
	},
	updateIM: function updateIM(im) {
		Edge.updateIM(this._label, im);
	},
	computeLabel: function computeLabel(boundaryNodeRule) {
		var isArea = false;
		for (var it = this.iterator(); it.hasNext();) {
			var e = it.next();
			if (e.getLabel().isArea()) isArea = true;
		}
		if (isArea) this._label = new Label(Location.NONE, Location.NONE, Location.NONE);else this._label = new Label(Location.NONE);
		for (var i = 0; i < 2; i++) {
			this.computeLabelOn(i, boundaryNodeRule);
			if (isArea) this.computeLabelSides(i);
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return EdgeEndBundle;
	}
});

function EdgeEndBundleStar() {
	EdgeEndStar.apply(this);
}
inherits(EdgeEndBundleStar, EdgeEndStar);
extend(EdgeEndBundleStar.prototype, {
	updateIM: function updateIM(im) {
		for (var it = this.iterator(); it.hasNext();) {
			var esb = it.next();
			esb.updateIM(im);
		}
	},
	insert: function insert(e) {
		var eb = this._edgeMap.get(e);
		if (eb === null) {
			eb = new EdgeEndBundle(e);
			this.insertEdgeEnd(e, eb);
		} else {
			eb.insert(e);
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return EdgeEndBundleStar;
	}
});

function RelateNode() {
	var coord = arguments[0],
	    edges = arguments[1];
	Node$1.call(this, coord, edges);
}
inherits(RelateNode, Node$1);
extend(RelateNode.prototype, {
	updateIMFromEdges: function updateIMFromEdges(im) {
		this._edges.updateIM(im);
	},
	computeIM: function computeIM(im) {
		im.setAtLeastIfValid(this._label.getLocation(0), this._label.getLocation(1), 0);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return RelateNode;
	}
});

function RelateNodeFactory() {
	NodeFactory.apply(this);
}
inherits(RelateNodeFactory, NodeFactory);
extend(RelateNodeFactory.prototype, {
	createNode: function createNode(coord) {
		return new RelateNode(coord, new EdgeEndBundleStar());
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return RelateNodeFactory;
	}
});

function RelateComputer() {
	this._li = new RobustLineIntersector();
	this._ptLocator = new PointLocator();
	this._arg = null;
	this._nodes = new NodeMap(new RelateNodeFactory());
	this._im = null;
	this._isolatedEdges = new ArrayList();
	this._invalidPoint = null;
	var arg = arguments[0];
	this._arg = arg;
}
extend(RelateComputer.prototype, {
	insertEdgeEnds: function insertEdgeEnds(ee) {
		for (var i = ee.iterator(); i.hasNext();) {
			var e = i.next();
			this._nodes.add(e);
		}
	},
	computeProperIntersectionIM: function computeProperIntersectionIM(intersector, im) {
		var dimA = this._arg[0].getGeometry().getDimension();
		var dimB = this._arg[1].getGeometry().getDimension();
		var hasProper = intersector.hasProperIntersection();
		var hasProperInterior = intersector.hasProperInteriorIntersection();
		if (dimA === 2 && dimB === 2) {
			if (hasProper) im.setAtLeast("212101212");
		} else if (dimA === 2 && dimB === 1) {
			if (hasProper) im.setAtLeast("FFF0FFFF2");
			if (hasProperInterior) im.setAtLeast("1FFFFF1FF");
		} else if (dimA === 1 && dimB === 2) {
			if (hasProper) im.setAtLeast("F0FFFFFF2");
			if (hasProperInterior) im.setAtLeast("1F1FFFFFF");
		} else if (dimA === 1 && dimB === 1) {
			if (hasProperInterior) im.setAtLeast("0FFFFFFFF");
		}
	},
	labelIsolatedEdges: function labelIsolatedEdges(thisIndex, targetIndex) {
		for (var ei = this._arg[thisIndex].getEdgeIterator(); ei.hasNext();) {
			var e = ei.next();
			if (e.isIsolated()) {
				this.labelIsolatedEdge(e, targetIndex, this._arg[targetIndex].getGeometry());
				this._isolatedEdges.add(e);
			}
		}
	},
	labelIsolatedEdge: function labelIsolatedEdge(e, targetIndex, target) {
		if (target.getDimension() > 0) {
			var loc = this._ptLocator.locate(e.getCoordinate(), target);
			e.getLabel().setAllLocations(targetIndex, loc);
		} else {
			e.getLabel().setAllLocations(targetIndex, Location.EXTERIOR);
		}
	},
	computeIM: function computeIM() {
		var im = new IntersectionMatrix();
		im.set(Location.EXTERIOR, Location.EXTERIOR, 2);
		if (!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal())) {
			this.computeDisjointIM(im);
			return im;
		}
		this._arg[0].computeSelfNodes(this._li, false);
		this._arg[1].computeSelfNodes(this._li, false);
		var intersector = this._arg[0].computeEdgeIntersections(this._arg[1], this._li, false);
		this.computeIntersectionNodes(0);
		this.computeIntersectionNodes(1);
		this.copyNodesAndLabels(0);
		this.copyNodesAndLabels(1);
		this.labelIsolatedNodes();
		this.computeProperIntersectionIM(intersector, im);
		var eeBuilder = new EdgeEndBuilder();
		var ee0 = eeBuilder.computeEdgeEnds(this._arg[0].getEdgeIterator());
		this.insertEdgeEnds(ee0);
		var ee1 = eeBuilder.computeEdgeEnds(this._arg[1].getEdgeIterator());
		this.insertEdgeEnds(ee1);
		this.labelNodeEdges();
		this.labelIsolatedEdges(0, 1);
		this.labelIsolatedEdges(1, 0);
		this.updateIM(im);
		return im;
	},
	labelNodeEdges: function labelNodeEdges() {
		for (var ni = this._nodes.iterator(); ni.hasNext();) {
			var node = ni.next();
			node.getEdges().computeLabelling(this._arg);
		}
	},
	copyNodesAndLabels: function copyNodesAndLabels(argIndex) {
		for (var i = this._arg[argIndex].getNodeIterator(); i.hasNext();) {
			var graphNode = i.next();
			var newNode = this._nodes.addNode(graphNode.getCoordinate());
			newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
		}
	},
	labelIntersectionNodes: function labelIntersectionNodes(argIndex) {
		for (var i = this._arg[argIndex].getEdgeIterator(); i.hasNext();) {
			var e = i.next();
			var eLoc = e.getLabel().getLocation(argIndex);
			for (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {
				var ei = eiIt.next();
				var n = this._nodes.find(ei.coord);
				if (n.getLabel().isNull(argIndex)) {
					if (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex);else n.setLabel(argIndex, Location.INTERIOR);
				}
			}
		}
	},
	labelIsolatedNode: function labelIsolatedNode(n, targetIndex) {
		var loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());
		n.getLabel().setAllLocations(targetIndex, loc);
	},
	computeIntersectionNodes: function computeIntersectionNodes(argIndex) {
		for (var i = this._arg[argIndex].getEdgeIterator(); i.hasNext();) {
			var e = i.next();
			var eLoc = e.getLabel().getLocation(argIndex);
			for (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {
				var ei = eiIt.next();
				var n = this._nodes.addNode(ei.coord);
				if (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex);else {
					if (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, Location.INTERIOR);
				}
			}
		}
	},
	labelIsolatedNodes: function labelIsolatedNodes() {
		for (var ni = this._nodes.iterator(); ni.hasNext();) {
			var n = ni.next();
			var label = n.getLabel();
			Assert.isTrue(label.getGeometryCount() > 0, "node with empty label found");
			if (n.isIsolated()) {
				if (label.isNull(0)) this.labelIsolatedNode(n, 0);else this.labelIsolatedNode(n, 1);
			}
		}
	},
	updateIM: function updateIM(im) {
		for (var ei = this._isolatedEdges.iterator(); ei.hasNext();) {
			var e = ei.next();
			e.updateIM(im);
		}
		for (var ni = this._nodes.iterator(); ni.hasNext();) {
			var node = ni.next();
			node.updateIM(im);
			node.updateIMFromEdges(im);
		}
	},
	computeDisjointIM: function computeDisjointIM(im) {
		var ga = this._arg[0].getGeometry();
		if (!ga.isEmpty()) {
			im.set(Location.INTERIOR, Location.EXTERIOR, ga.getDimension());
			im.set(Location.BOUNDARY, Location.EXTERIOR, ga.getBoundaryDimension());
		}
		var gb = this._arg[1].getGeometry();
		if (!gb.isEmpty()) {
			im.set(Location.EXTERIOR, Location.INTERIOR, gb.getDimension());
			im.set(Location.EXTERIOR, Location.BOUNDARY, gb.getBoundaryDimension());
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return RelateComputer;
	}
});

function RectangleContains() {
	this._rectEnv = null;
	var rectangle = arguments[0];
	this._rectEnv = rectangle.getEnvelopeInternal();
}
extend(RectangleContains.prototype, {
	isContainedInBoundary: function isContainedInBoundary(geom) {
		if (geom instanceof Polygon) return false;
		if (geom instanceof Point) return this.isPointContainedInBoundary(geom);
		if (geom instanceof LineString) return this.isLineStringContainedInBoundary(geom);
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var comp = geom.getGeometryN(i);
			if (!this.isContainedInBoundary(comp)) return false;
		}
		return true;
	},
	isLineSegmentContainedInBoundary: function isLineSegmentContainedInBoundary(p0, p1) {
		if (p0.equals(p1)) return this.isPointContainedInBoundary(p0);
		if (p0.x === p1.x) {
			if (p0.x === this._rectEnv.getMinX() || p0.x === this._rectEnv.getMaxX()) return true;
		} else if (p0.y === p1.y) {
			if (p0.y === this._rectEnv.getMinY() || p0.y === this._rectEnv.getMaxY()) return true;
		}
		return false;
	},
	isLineStringContainedInBoundary: function isLineStringContainedInBoundary(line) {
		var seq = line.getCoordinateSequence();
		var p0 = new Coordinate();
		var p1 = new Coordinate();
		for (var i = 0; i < seq.size() - 1; i++) {
			seq.getCoordinate(i, p0);
			seq.getCoordinate(i + 1, p1);
			if (!this.isLineSegmentContainedInBoundary(p0, p1)) return false;
		}
		return true;
	},
	isPointContainedInBoundary: function isPointContainedInBoundary() {
		if (arguments[0] instanceof Point) {
			var point = arguments[0];
			return this.isPointContainedInBoundary(point.getCoordinate());
		} else if (arguments[0] instanceof Coordinate) {
			var pt = arguments[0];
			return pt.x === this._rectEnv.getMinX() || pt.x === this._rectEnv.getMaxX() || pt.y === this._rectEnv.getMinY() || pt.y === this._rectEnv.getMaxY();
		}
	},
	contains: function contains(geom) {
		if (!this._rectEnv.contains(geom.getEnvelopeInternal())) return false;
		if (this.isContainedInBoundary(geom)) return false;
		return true;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return RectangleContains;
	}
});
RectangleContains.contains = function (rectangle, b) {
	var rc = new RectangleContains(rectangle);
	return rc.contains(b);
};

function RectangleLineIntersector() {
	this._li = new RobustLineIntersector();
	this._rectEnv = null;
	this._diagUp0 = null;
	this._diagUp1 = null;
	this._diagDown0 = null;
	this._diagDown1 = null;
	var rectEnv = arguments[0];
	this._rectEnv = rectEnv;
	this._diagUp0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMinY());
	this._diagUp1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMaxY());
	this._diagDown0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMaxY());
	this._diagDown1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMinY());
}
extend(RectangleLineIntersector.prototype, {
	intersects: function intersects(p0, p1) {
		var segEnv = new Envelope(p0, p1);
		if (!this._rectEnv.intersects(segEnv)) return false;
		if (this._rectEnv.intersects(p0)) return true;
		if (this._rectEnv.intersects(p1)) return true;
		if (p0.compareTo(p1) > 0) {
			var tmp = p0;
			p0 = p1;
			p1 = tmp;
		}
		var isSegUpwards = false;
		if (p1.y > p0.y) isSegUpwards = true;
		if (isSegUpwards) {
			this._li.computeIntersection(p0, p1, this._diagDown0, this._diagDown1);
		} else {
			this._li.computeIntersection(p0, p1, this._diagUp0, this._diagUp1);
		}
		if (this._li.hasIntersection()) return true;
		return false;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return RectangleLineIntersector;
	}
});

function ShortCircuitedGeometryVisitor() {
	this._isDone = false;
}
extend(ShortCircuitedGeometryVisitor.prototype, {
	applyTo: function applyTo(geom) {
		for (var i = 0; i < geom.getNumGeometries() && !this._isDone; i++) {
			var element = geom.getGeometryN(i);
			if (!(element instanceof GeometryCollection)) {
				this.visit(element);
				if (this.isDone()) {
					this._isDone = true;
					return null;
				}
			} else this.applyTo(element);
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return ShortCircuitedGeometryVisitor;
	}
});

function RectangleIntersects() {
	this._rectangle = null;
	this._rectEnv = null;
	var rectangle = arguments[0];
	this._rectangle = rectangle;
	this._rectEnv = rectangle.getEnvelopeInternal();
}
extend(RectangleIntersects.prototype, {
	intersects: function intersects(geom) {
		if (!this._rectEnv.intersects(geom.getEnvelopeInternal())) return false;
		var visitor = new EnvelopeIntersectsVisitor(this._rectEnv);
		visitor.applyTo(geom);
		if (visitor.intersects()) return true;
		var ecpVisitor = new GeometryContainsPointVisitor(this._rectangle);
		ecpVisitor.applyTo(geom);
		if (ecpVisitor.containsPoint()) return true;
		var riVisitor = new RectangleIntersectsSegmentVisitor(this._rectangle);
		riVisitor.applyTo(geom);
		if (riVisitor.intersects()) return true;
		return false;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return RectangleIntersects;
	}
});
RectangleIntersects.intersects = function (rectangle, b) {
	var rp = new RectangleIntersects(rectangle);
	return rp.intersects(b);
};
function EnvelopeIntersectsVisitor() {
	ShortCircuitedGeometryVisitor.apply(this);
	this._rectEnv = null;
	this._intersects = false;
	var rectEnv = arguments[0];
	this._rectEnv = rectEnv;
}
inherits(EnvelopeIntersectsVisitor, ShortCircuitedGeometryVisitor);
extend(EnvelopeIntersectsVisitor.prototype, {
	isDone: function isDone() {
		return this._intersects === true;
	},
	visit: function visit(element) {
		var elementEnv = element.getEnvelopeInternal();
		if (!this._rectEnv.intersects(elementEnv)) {
			return null;
		}
		if (this._rectEnv.contains(elementEnv)) {
			this._intersects = true;
			return null;
		}
		if (elementEnv.getMinX() >= this._rectEnv.getMinX() && elementEnv.getMaxX() <= this._rectEnv.getMaxX()) {
			this._intersects = true;
			return null;
		}
		if (elementEnv.getMinY() >= this._rectEnv.getMinY() && elementEnv.getMaxY() <= this._rectEnv.getMaxY()) {
			this._intersects = true;
			return null;
		}
	},
	intersects: function intersects() {
		return this._intersects;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return EnvelopeIntersectsVisitor;
	}
});
function GeometryContainsPointVisitor() {
	ShortCircuitedGeometryVisitor.apply(this);
	this._rectSeq = null;
	this._rectEnv = null;
	this._containsPoint = false;
	var rectangle = arguments[0];
	this._rectSeq = rectangle.getExteriorRing().getCoordinateSequence();
	this._rectEnv = rectangle.getEnvelopeInternal();
}
inherits(GeometryContainsPointVisitor, ShortCircuitedGeometryVisitor);
extend(GeometryContainsPointVisitor.prototype, {
	isDone: function isDone() {
		return this._containsPoint === true;
	},
	visit: function visit(geom) {
		if (!(geom instanceof Polygon)) return null;
		var elementEnv = geom.getEnvelopeInternal();
		if (!this._rectEnv.intersects(elementEnv)) return null;
		var rectPt = new Coordinate();
		for (var i = 0; i < 4; i++) {
			this._rectSeq.getCoordinate(i, rectPt);
			if (!elementEnv.contains(rectPt)) continue;
			if (SimplePointInAreaLocator.containsPointInPolygon(rectPt, geom)) {
				this._containsPoint = true;
				return null;
			}
		}
	},
	containsPoint: function containsPoint() {
		return this._containsPoint;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return GeometryContainsPointVisitor;
	}
});
function RectangleIntersectsSegmentVisitor() {
	ShortCircuitedGeometryVisitor.apply(this);
	this._rectEnv = null;
	this._rectIntersector = null;
	this._hasIntersection = false;
	this._p0 = new Coordinate();
	this._p1 = new Coordinate();
	var rectangle = arguments[0];
	this._rectEnv = rectangle.getEnvelopeInternal();
	this._rectIntersector = new RectangleLineIntersector(this._rectEnv);
}
inherits(RectangleIntersectsSegmentVisitor, ShortCircuitedGeometryVisitor);
extend(RectangleIntersectsSegmentVisitor.prototype, {
	intersects: function intersects() {
		return this._hasIntersection;
	},
	isDone: function isDone() {
		return this._hasIntersection === true;
	},
	visit: function visit(geom) {
		var elementEnv = geom.getEnvelopeInternal();
		if (!this._rectEnv.intersects(elementEnv)) return null;
		var lines = LinearComponentExtracter.getLines(geom);
		this.checkIntersectionWithLineStrings(lines);
	},
	checkIntersectionWithLineStrings: function checkIntersectionWithLineStrings(lines) {
		for (var i = lines.iterator(); i.hasNext();) {
			var testLine = i.next();
			this.checkIntersectionWithSegments(testLine);
			if (this._hasIntersection) return null;
		}
	},
	checkIntersectionWithSegments: function checkIntersectionWithSegments(testLine) {
		var seq1 = testLine.getCoordinateSequence();
		for (var j = 1; j < seq1.size(); j++) {
			seq1.getCoordinate(j - 1, this._p0);
			seq1.getCoordinate(j, this._p1);
			if (this._rectIntersector.intersects(this._p0, this._p1)) {
				this._hasIntersection = true;
				return null;
			}
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return RectangleIntersectsSegmentVisitor;
	}
});

function RelateOp() {
	this._relate = null;
	if (arguments.length === 2) {
		var g0 = arguments[0],
		    g1 = arguments[1];
		GeometryGraphOperation.call(this, g0, g1);
		this._relate = new RelateComputer(this._arg);
	} else if (arguments.length === 3) {
		var _g = arguments[0],
		    _g2 = arguments[1],
		    boundaryNodeRule = arguments[2];
		GeometryGraphOperation.call(this, _g, _g2, boundaryNodeRule);
		this._relate = new RelateComputer(this._arg);
	}
}
inherits(RelateOp, GeometryGraphOperation);
extend(RelateOp.prototype, {
	getIntersectionMatrix: function getIntersectionMatrix() {
		return this._relate.computeIM();
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return RelateOp;
	}
});
RelateOp.covers = function (g1, g2) {
	if (g2.getDimension() === 2 && g1.getDimension() < 2) {
		return false;
	}
	if (g2.getDimension() === 1 && g1.getDimension() < 1 && g2.getLength() > 0.0) {
		return false;
	}
	if (!g1.getEnvelopeInternal().covers(g2.getEnvelopeInternal())) return false;
	if (g1.isRectangle()) {
		return true;
	}
	return new RelateOp(g1, g2).getIntersectionMatrix().isCovers();
};
RelateOp.intersects = function (g1, g2) {
	if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;
	if (g1.isRectangle()) {
		return RectangleIntersects.intersects(g1, g2);
	}
	if (g2.isRectangle()) {
		return RectangleIntersects.intersects(g2, g1);
	}
	if (g1.isGeometryCollection() || g2.isGeometryCollection()) {
		for (var i = 0; i < g1.getNumGeometries(); i++) {
			for (var j = 0; j < g2.getNumGeometries(); j++) {
				if (g1.getGeometryN(i).intersects(g2.getGeometryN(j))) {
					return true;
				}
			}
		}
		return false;
	}
	return new RelateOp(g1, g2).getIntersectionMatrix().isIntersects();
};
RelateOp.touches = function (g1, g2) {
	if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;
	return new RelateOp(g1, g2).getIntersectionMatrix().isTouches(g1.getDimension(), g2.getDimension());
};
RelateOp.relate = function () {
	if (arguments.length === 2) {
		var a = arguments[0],
		    b = arguments[1];
		var relOp = new RelateOp(a, b);
		var im = relOp.getIntersectionMatrix();
		return im;
	} else if (arguments.length === 3) {
		var _a = arguments[0],
		    _b = arguments[1],
		    boundaryNodeRule = arguments[2];
		var relOp = new RelateOp(_a, _b, boundaryNodeRule);
		var im = relOp.getIntersectionMatrix();
		return im;
	}
};
RelateOp.overlaps = function (g1, g2) {
	if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;
	return new RelateOp(g1, g2).getIntersectionMatrix().isOverlaps(g1.getDimension(), g2.getDimension());
};
RelateOp.crosses = function (g1, g2) {
	if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;
	return new RelateOp(g1, g2).getIntersectionMatrix().isCrosses(g1.getDimension(), g2.getDimension());
};
RelateOp.contains = function (g1, g2) {
	if (g2.getDimension() === 2 && g1.getDimension() < 2) {
		return false;
	}
	if (g2.getDimension() === 1 && g1.getDimension() < 1 && g2.getLength() > 0.0) {
		return false;
	}
	if (!g1.getEnvelopeInternal().contains(g2.getEnvelopeInternal())) return false;
	if (g1.isRectangle()) {
		return RectangleContains.contains(g1, g2);
	}
	return new RelateOp(g1, g2).getIntersectionMatrix().isContains();
};



var relate = Object.freeze({
	RelateOp: RelateOp
});

function GeometryCombiner() {
	this._geomFactory = null;
	this._skipEmpty = false;
	this._inputGeoms = null;
	var geoms = arguments[0];
	this._geomFactory = GeometryCombiner.extractFactory(geoms);
	this._inputGeoms = geoms;
}
extend(GeometryCombiner.prototype, {
	extractElements: function extractElements(geom, elems) {
		if (geom === null) return null;
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var elemGeom = geom.getGeometryN(i);
			if (this._skipEmpty && elemGeom.isEmpty()) continue;
			elems.add(elemGeom);
		}
	},
	combine: function combine() {
		var elems = new ArrayList();
		for (var i = this._inputGeoms.iterator(); i.hasNext();) {
			var g = i.next();
			this.extractElements(g, elems);
		}
		if (elems.size() === 0) {
			if (this._geomFactory !== null) {
				return this._geomFactory.createGeometryCollection();
			}
			return null;
		}
		return this._geomFactory.buildGeometry(elems);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return GeometryCombiner;
	}
});
GeometryCombiner.combine = function () {
	if (arguments.length === 1) {
		var geoms = arguments[0];
		var combiner = new GeometryCombiner(geoms);
		return combiner.combine();
	} else if (arguments.length === 2) {
		var g0 = arguments[0],
		    g1 = arguments[1];
		var combiner = new GeometryCombiner(GeometryCombiner.createList(g0, g1));
		return combiner.combine();
	} else if (arguments.length === 3) {
		var _g = arguments[0],
		    _g2 = arguments[1],
		    g2 = arguments[2];
		var combiner = new GeometryCombiner(GeometryCombiner.createList(_g, _g2, g2));
		return combiner.combine();
	}
};
GeometryCombiner.extractFactory = function (geoms) {
	if (geoms.isEmpty()) return null;
	return geoms.iterator().next().getFactory();
};
GeometryCombiner.createList = function () {
	if (arguments.length === 2) {
		var obj0 = arguments[0],
		    obj1 = arguments[1];
		var list = new ArrayList();
		list.add(obj0);
		list.add(obj1);
		return list;
	} else if (arguments.length === 3) {
		var _obj = arguments[0],
		    _obj2 = arguments[1],
		    obj2 = arguments[2];
		var list = new ArrayList();
		list.add(_obj);
		list.add(_obj2);
		list.add(obj2);
		return list;
	}
};

function PointGeometryUnion() {
	this._pointGeom = null;
	this._otherGeom = null;
	this._geomFact = null;
	var pointGeom = arguments[0],
	    otherGeom = arguments[1];
	this._pointGeom = pointGeom;
	this._otherGeom = otherGeom;
	this._geomFact = otherGeom.getFactory();
}
extend(PointGeometryUnion.prototype, {
	union: function union() {
		var locater = new PointLocator();
		var exteriorCoords = new TreeSet();
		for (var i = 0; i < this._pointGeom.getNumGeometries(); i++) {
			var point = this._pointGeom.getGeometryN(i);
			var coord = point.getCoordinate();
			var loc = locater.locate(coord, this._otherGeom);
			if (loc === Location.EXTERIOR) exteriorCoords.add(coord);
		}
		if (exteriorCoords.size() === 0) return this._otherGeom;
		var ptComp = null;
		var coords = CoordinateArrays.toCoordinateArray(exteriorCoords);
		if (coords.length === 1) {
			ptComp = this._geomFact.createPoint(coords[0]);
		} else {
			ptComp = this._geomFact.createMultiPointFromCoords(coords);
		}
		return GeometryCombiner.combine(ptComp, this._otherGeom);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return PointGeometryUnion;
	}
});
PointGeometryUnion.union = function (pointGeom, otherGeom) {
	var unioner = new PointGeometryUnion(pointGeom, otherGeom);
	return unioner.union();
};

function GeometryExtracter() {
	this._geometryType = null;
	this._comps = null;
	var geometryType = arguments[0],
	    comps = arguments[1];
	this._geometryType = geometryType;
	this._comps = comps;
}
extend(GeometryExtracter.prototype, {
	filter: function filter(geom) {
		if (this._geometryType === null || GeometryExtracter.isOfType(geom, this._geometryType)) this._comps.add(geom);
	},
	interfaces_: function interfaces_() {
		return [GeometryFilter];
	},
	getClass: function getClass() {
		return GeometryExtracter;
	}
});
GeometryExtracter.isOfType = function (geom, geometryType) {
	if (geom.getGeometryType() === geometryType) return true;
	if (geometryType === Geometry.TYPENAME_LINESTRING && geom.getGeometryType() === Geometry.TYPENAME_LINEARRING) return true;
	return false;
};
GeometryExtracter.extract = function () {
	if (arguments.length === 2) {
		var geom = arguments[0],
		    geometryType = arguments[1];
		return GeometryExtracter.extract(geom, geometryType, new ArrayList());
	} else if (arguments.length === 3) {
		if (hasInterface(arguments[2], List) && arguments[0] instanceof Geometry && typeof arguments[1] === "string") {
			var _geom = arguments[0],
			    _geometryType = arguments[1],
			    list = arguments[2];
			if (_geom.getGeometryType() === _geometryType) {
				list.add(_geom);
			} else if (_geom instanceof GeometryCollection) {
				_geom.apply(new GeometryExtracter(_geometryType, list));
			}
			return list;
		} else if (hasInterface(arguments[2], List) && arguments[0] instanceof Geometry && arguments[1] instanceof Class) {
			var _geom2 = arguments[0],
			    clz = arguments[1],
			    _list = arguments[2];
			return GeometryExtracter.extract(_geom2, GeometryExtracter.toGeometryType(clz), _list);
		}
	}
};

function CascadedPolygonUnion() {
	this._inputPolys = null;
	this._geomFactory = null;
	var polys = arguments[0];
	this._inputPolys = polys;
	if (this._inputPolys === null) this._inputPolys = new ArrayList();
}
extend(CascadedPolygonUnion.prototype, {
	reduceToGeometries: function reduceToGeometries(geomTree) {
		var geoms = new ArrayList();
		for (var i = geomTree.iterator(); i.hasNext();) {
			var o = i.next();
			var geom = null;
			if (hasInterface(o, List)) {
				geom = this.unionTree(o);
			} else if (o instanceof Geometry) {
				geom = o;
			}
			geoms.add(geom);
		}
		return geoms;
	},
	extractByEnvelope: function extractByEnvelope(env, geom, disjointGeoms) {
		var intersectingGeoms = new ArrayList();
		for (var i = 0; i < geom.getNumGeometries(); i++) {
			var elem = geom.getGeometryN(i);
			if (elem.getEnvelopeInternal().intersects(env)) intersectingGeoms.add(elem);else disjointGeoms.add(elem);
		}
		return this._geomFactory.buildGeometry(intersectingGeoms);
	},
	unionOptimized: function unionOptimized(g0, g1) {
		var g0Env = g0.getEnvelopeInternal();
		var g1Env = g1.getEnvelopeInternal();
		if (!g0Env.intersects(g1Env)) {
			var combo = GeometryCombiner.combine(g0, g1);
			return combo;
		}
		if (g0.getNumGeometries() <= 1 && g1.getNumGeometries() <= 1) return this.unionActual(g0, g1);
		var commonEnv = g0Env.intersection(g1Env);
		return this.unionUsingEnvelopeIntersection(g0, g1, commonEnv);
	},
	union: function union() {
		if (this._inputPolys === null) throw new IllegalStateException("union() method cannot be called twice");
		if (this._inputPolys.isEmpty()) return null;
		this._geomFactory = this._inputPolys.iterator().next().getFactory();
		var index = new STRtree(CascadedPolygonUnion.STRTREE_NODE_CAPACITY);
		for (var i = this._inputPolys.iterator(); i.hasNext();) {
			var item = i.next();
			index.insert(item.getEnvelopeInternal(), item);
		}
		this._inputPolys = null;
		var itemTree = index.itemsTree();
		var unionAll = this.unionTree(itemTree);
		return unionAll;
	},
	binaryUnion: function binaryUnion() {
		if (arguments.length === 1) {
			var geoms = arguments[0];
			return this.binaryUnion(geoms, 0, geoms.size());
		} else if (arguments.length === 3) {
			var _geoms = arguments[0],
			    start = arguments[1],
			    end = arguments[2];
			if (end - start <= 1) {
				var g0 = CascadedPolygonUnion.getGeometry(_geoms, start);
				return this.unionSafe(g0, null);
			} else if (end - start === 2) {
				return this.unionSafe(CascadedPolygonUnion.getGeometry(_geoms, start), CascadedPolygonUnion.getGeometry(_geoms, start + 1));
			} else {
				var mid = Math.trunc((end + start) / 2);
				var g0 = this.binaryUnion(_geoms, start, mid);
				var g1 = this.binaryUnion(_geoms, mid, end);
				return this.unionSafe(g0, g1);
			}
		}
	},
	repeatedUnion: function repeatedUnion(geoms) {
		var union = null;
		for (var i = geoms.iterator(); i.hasNext();) {
			var g = i.next();
			if (union === null) union = g.copy();else union = union.union(g);
		}
		return union;
	},
	unionSafe: function unionSafe(g0, g1) {
		if (g0 === null && g1 === null) return null;
		if (g0 === null) return g1.copy();
		if (g1 === null) return g0.copy();
		return this.unionOptimized(g0, g1);
	},
	unionActual: function unionActual(g0, g1) {
		return CascadedPolygonUnion.restrictToPolygons(g0.union(g1));
	},
	unionTree: function unionTree(geomTree) {
		var geoms = this.reduceToGeometries(geomTree);
		var union = this.binaryUnion(geoms);
		return union;
	},
	unionUsingEnvelopeIntersection: function unionUsingEnvelopeIntersection(g0, g1, common) {
		var disjointPolys = new ArrayList();
		var g0Int = this.extractByEnvelope(common, g0, disjointPolys);
		var g1Int = this.extractByEnvelope(common, g1, disjointPolys);
		var union = this.unionActual(g0Int, g1Int);
		disjointPolys.add(union);
		var overallUnion = GeometryCombiner.combine(disjointPolys);
		return overallUnion;
	},
	bufferUnion: function bufferUnion() {
		if (arguments.length === 1) {
			var geoms = arguments[0];
			var factory = geoms.get(0).getFactory();
			var gColl = factory.buildGeometry(geoms);
			var unionAll = gColl.buffer(0.0);
			return unionAll;
		} else if (arguments.length === 2) {
			var g0 = arguments[0],
			    g1 = arguments[1];
			var factory = g0.getFactory();
			var gColl = factory.createGeometryCollection([g0, g1]);
			var unionAll = gColl.buffer(0.0);
			return unionAll;
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return CascadedPolygonUnion;
	}
});
CascadedPolygonUnion.restrictToPolygons = function (g) {
	if (hasInterface(g, Polygonal)) {
		return g;
	}
	var polygons = PolygonExtracter.getPolygons(g);
	if (polygons.size() === 1) return polygons.get(0);
	return g.getFactory().createMultiPolygon(GeometryFactory.toPolygonArray(polygons));
};
CascadedPolygonUnion.getGeometry = function (list, index) {
	if (index >= list.size()) return null;
	return list.get(index);
};
CascadedPolygonUnion.union = function (polys) {
	var op = new CascadedPolygonUnion(polys);
	return op.union();
};
CascadedPolygonUnion.STRTREE_NODE_CAPACITY = 4;

function UnaryUnionOp() {
	this._polygons = new ArrayList();
	this._lines = new ArrayList();
	this._points = new ArrayList();
	this._geomFact = null;
	if (arguments.length === 1) {
		if (hasInterface(arguments[0], Collection)) {
			var geoms = arguments[0];
			this.extract(geoms);
		} else if (arguments[0] instanceof Geometry) {
			var geom = arguments[0];
			this.extract(geom);
		}
	} else if (arguments.length === 2) {
		var _geoms = arguments[0],
		    geomFact = arguments[1];
		this._geomFact = geomFact;
		this.extract(_geoms);
	}
}
extend(UnaryUnionOp.prototype, {
	unionNoOpt: function unionNoOpt(g0) {
		var empty = this._geomFact.createPoint();
		return SnapIfNeededOverlayOp.overlayOp(g0, empty, OverlayOp.UNION);
	},
	unionWithNull: function unionWithNull(g0, g1) {
		if (g0 === null && g1 === null) return null;
		if (g1 === null) return g0;
		if (g0 === null) return g1;
		return g0.union(g1);
	},
	extract: function extract() {
		if (hasInterface(arguments[0], Collection)) {
			var geoms = arguments[0];
			for (var i = geoms.iterator(); i.hasNext();) {
				var geom = i.next();
				this.extract(geom);
			}
		} else if (arguments[0] instanceof Geometry) {
			var _geom = arguments[0];
			if (this._geomFact === null) this._geomFact = _geom.getFactory();
			GeometryExtracter.extract(_geom, Geometry.TYPENAME_POLYGON, this._polygons);
			GeometryExtracter.extract(_geom, Geometry.TYPENAME_LINESTRING, this._lines);
			GeometryExtracter.extract(_geom, Geometry.TYPENAME_POINT, this._points);
		}
	},
	union: function union() {
		if (this._geomFact === null) {
			return null;
		}
		var unionPoints = null;
		if (this._points.size() > 0) {
			var ptGeom = this._geomFact.buildGeometry(this._points);
			unionPoints = this.unionNoOpt(ptGeom);
		}
		var unionLines = null;
		if (this._lines.size() > 0) {
			var lineGeom = this._geomFact.buildGeometry(this._lines);
			unionLines = this.unionNoOpt(lineGeom);
		}
		var unionPolygons = null;
		if (this._polygons.size() > 0) {
			unionPolygons = CascadedPolygonUnion.union(this._polygons);
		}
		var unionLA = this.unionWithNull(unionLines, unionPolygons);
		var union = null;
		if (unionPoints === null) union = unionLA;else if (unionLA === null) union = unionPoints;else union = PointGeometryUnion.union(unionPoints, unionLA);
		if (union === null) return this._geomFact.createGeometryCollection();
		return union;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return UnaryUnionOp;
	}
});
UnaryUnionOp.union = function () {
	if (arguments.length === 1) {
		if (hasInterface(arguments[0], Collection)) {
			var geoms = arguments[0];
			var op = new UnaryUnionOp(geoms);
			return op.union();
		} else if (arguments[0] instanceof Geometry) {
			var geom = arguments[0];
			var op = new UnaryUnionOp(geom);
			return op.union();
		}
	} else if (arguments.length === 2) {
		var _geoms2 = arguments[0],
		    geomFact = arguments[1];
		var op = new UnaryUnionOp(_geoms2, geomFact);
		return op.union();
	}
};



var union = Object.freeze({
	UnaryUnionOp: UnaryUnionOp
});

function ConnectedInteriorTester() {
	this._geometryFactory = new GeometryFactory();
	this._geomGraph = null;
	this._disconnectedRingcoord = null;
	var geomGraph = arguments[0];
	this._geomGraph = geomGraph;
}
extend(ConnectedInteriorTester.prototype, {
	visitInteriorRing: function visitInteriorRing(ring, graph) {
		var pts = ring.getCoordinates();
		var pt0 = pts[0];
		var pt1 = ConnectedInteriorTester.findDifferentPoint(pts, pt0);
		var e = graph.findEdgeInSameDirection(pt0, pt1);
		var de = graph.findEdgeEnd(e);
		var intDe = null;
		if (de.getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) {
			intDe = de;
		} else if (de.getSym().getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) {
			intDe = de.getSym();
		}
		Assert.isTrue(intDe !== null, "unable to find dirEdge with Interior on RHS");
		this.visitLinkedDirectedEdges(intDe);
	},
	visitShellInteriors: function visitShellInteriors(g, graph) {
		if (g instanceof Polygon) {
			var p = g;
			this.visitInteriorRing(p.getExteriorRing(), graph);
		}
		if (g instanceof MultiPolygon) {
			var mp = g;
			for (var i = 0; i < mp.getNumGeometries(); i++) {
				var p = mp.getGeometryN(i);
				this.visitInteriorRing(p.getExteriorRing(), graph);
			}
		}
	},
	getCoordinate: function getCoordinate() {
		return this._disconnectedRingcoord;
	},
	setInteriorEdgesInResult: function setInteriorEdgesInResult(graph) {
		for (var it = graph.getEdgeEnds().iterator(); it.hasNext();) {
			var de = it.next();
			if (de.getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) {
				de.setInResult(true);
			}
		}
	},
	visitLinkedDirectedEdges: function visitLinkedDirectedEdges(start) {
		var startDe = start;
		var de = start;
		do {
			Assert.isTrue(de !== null, "found null Directed Edge");
			de.setVisited(true);
			de = de.getNext();
		} while (de !== startDe);
	},
	buildEdgeRings: function buildEdgeRings(dirEdges) {
		var edgeRings = new ArrayList();
		for (var it = dirEdges.iterator(); it.hasNext();) {
			var de = it.next();
			if (de.isInResult() && de.getEdgeRing() === null) {
				var er = new MaximalEdgeRing(de, this._geometryFactory);
				er.linkDirectedEdgesForMinimalEdgeRings();
				var minEdgeRings = er.buildMinimalRings();
				edgeRings.addAll(minEdgeRings);
			}
		}
		return edgeRings;
	},
	hasUnvisitedShellEdge: function hasUnvisitedShellEdge(edgeRings) {
		for (var i = 0; i < edgeRings.size(); i++) {
			var er = edgeRings.get(i);
			if (er.isHole()) continue;
			var edges = er.getEdges();
			var de = edges.get(0);
			if (de.getLabel().getLocation(0, Position.RIGHT) !== Location.INTERIOR) continue;
			for (var j = 0; j < edges.size(); j++) {
				de = edges.get(j);
				if (!de.isVisited()) {
					this._disconnectedRingcoord = de.getCoordinate();
					return true;
				}
			}
		}
		return false;
	},
	isInteriorsConnected: function isInteriorsConnected() {
		var splitEdges = new ArrayList();
		this._geomGraph.computeSplitEdges(splitEdges);
		var graph = new PlanarGraph(new OverlayNodeFactory());
		graph.addEdges(splitEdges);
		this.setInteriorEdgesInResult(graph);
		graph.linkResultDirectedEdges();
		var edgeRings = this.buildEdgeRings(graph.getEdgeEnds());
		this.visitShellInteriors(this._geomGraph.getGeometry(), graph);
		return !this.hasUnvisitedShellEdge(edgeRings);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return ConnectedInteriorTester;
	}
});
ConnectedInteriorTester.findDifferentPoint = function (coord, pt) {
	for (var i = 0; i < coord.length; i++) {
		if (!coord[i].equals(pt)) return coord[i];
	}
	return null;
};

function RelateNodeGraph() {
	this._nodes = new NodeMap(new RelateNodeFactory());
}
extend(RelateNodeGraph.prototype, {
	insertEdgeEnds: function insertEdgeEnds(ee) {
		for (var i = ee.iterator(); i.hasNext();) {
			var e = i.next();
			this._nodes.add(e);
		}
	},
	getNodeIterator: function getNodeIterator() {
		return this._nodes.iterator();
	},
	copyNodesAndLabels: function copyNodesAndLabels(geomGraph, argIndex) {
		for (var nodeIt = geomGraph.getNodeIterator(); nodeIt.hasNext();) {
			var graphNode = nodeIt.next();
			var newNode = this._nodes.addNode(graphNode.getCoordinate());
			newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
		}
	},
	build: function build(geomGraph) {
		this.computeIntersectionNodes(geomGraph, 0);
		this.copyNodesAndLabels(geomGraph, 0);
		var eeBuilder = new EdgeEndBuilder();
		var eeList = eeBuilder.computeEdgeEnds(geomGraph.getEdgeIterator());
		this.insertEdgeEnds(eeList);
	},
	computeIntersectionNodes: function computeIntersectionNodes(geomGraph, argIndex) {
		for (var edgeIt = geomGraph.getEdgeIterator(); edgeIt.hasNext();) {
			var e = edgeIt.next();
			var eLoc = e.getLabel().getLocation(argIndex);
			for (var eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {
				var ei = eiIt.next();
				var n = this._nodes.addNode(ei.coord);
				if (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex);else {
					if (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, Location.INTERIOR);
				}
			}
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return RelateNodeGraph;
	}
});

function ConsistentAreaTester() {
	this._li = new RobustLineIntersector();
	this._geomGraph = null;
	this._nodeGraph = new RelateNodeGraph();
	this._invalidPoint = null;
	var geomGraph = arguments[0];
	this._geomGraph = geomGraph;
}
extend(ConsistentAreaTester.prototype, {
	isNodeEdgeAreaLabelsConsistent: function isNodeEdgeAreaLabelsConsistent() {
		for (var nodeIt = this._nodeGraph.getNodeIterator(); nodeIt.hasNext();) {
			var node = nodeIt.next();
			if (!node.getEdges().isAreaLabelsConsistent(this._geomGraph)) {
				this._invalidPoint = node.getCoordinate().copy();
				return false;
			}
		}
		return true;
	},
	getInvalidPoint: function getInvalidPoint() {
		return this._invalidPoint;
	},
	hasDuplicateRings: function hasDuplicateRings() {
		for (var nodeIt = this._nodeGraph.getNodeIterator(); nodeIt.hasNext();) {
			var node = nodeIt.next();
			for (var i = node.getEdges().iterator(); i.hasNext();) {
				var eeb = i.next();
				if (eeb.getEdgeEnds().size() > 1) {
					this._invalidPoint = eeb.getEdge().getCoordinate(0);
					return true;
				}
			}
		}
		return false;
	},
	isNodeConsistentArea: function isNodeConsistentArea() {
		var intersector = this._geomGraph.computeSelfNodes(this._li, true, true);
		if (intersector.hasProperIntersection()) {
			this._invalidPoint = intersector.getProperIntersectionPoint();
			return false;
		}
		this._nodeGraph.build(this._geomGraph);
		return this.isNodeEdgeAreaLabelsConsistent();
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return ConsistentAreaTester;
	}
});

function IndexedNestedRingTester() {
	this._graph = null;
	this._rings = new ArrayList();
	this._totalEnv = new Envelope();
	this._index = null;
	this._nestedPt = null;
	var graph = arguments[0];
	this._graph = graph;
}
extend(IndexedNestedRingTester.prototype, {
	buildIndex: function buildIndex() {
		this._index = new STRtree();
		for (var i = 0; i < this._rings.size(); i++) {
			var ring = this._rings.get(i);
			var env = ring.getEnvelopeInternal();
			this._index.insert(env, ring);
		}
	},
	getNestedPoint: function getNestedPoint() {
		return this._nestedPt;
	},
	isNonNested: function isNonNested() {
		this.buildIndex();
		for (var i = 0; i < this._rings.size(); i++) {
			var innerRing = this._rings.get(i);
			var innerRingPts = innerRing.getCoordinates();
			var results = this._index.query(innerRing.getEnvelopeInternal());
			for (var j = 0; j < results.size(); j++) {
				var searchRing = results.get(j);
				var searchRingPts = searchRing.getCoordinates();
				if (innerRing === searchRing) continue;
				if (!innerRing.getEnvelopeInternal().intersects(searchRing.getEnvelopeInternal())) continue;
				var innerRingPt = IsValidOp.findPtNotNode(innerRingPts, searchRing, this._graph);
				if (innerRingPt === null) continue;
				var isInside = PointLocation.isInRing(innerRingPt, searchRingPts);
				if (isInside) {
					this._nestedPt = innerRingPt;
					return false;
				}
			}
		}
		return true;
	},
	add: function add(ring) {
		this._rings.add(ring);
		this._totalEnv.expandToInclude(ring.getEnvelopeInternal());
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return IndexedNestedRingTester;
	}
});

function TopologyValidationError() {
	this._errorType = null;
	this._pt = null;
	if (arguments.length === 1) {
		var errorType = arguments[0];
		TopologyValidationError.call(this, errorType, null);
	} else if (arguments.length === 2) {
		var _errorType = arguments[0],
		    pt = arguments[1];
		this._errorType = _errorType;
		if (pt !== null) this._pt = pt.copy();
	}
}
extend(TopologyValidationError.prototype, {
	getErrorType: function getErrorType() {
		return this._errorType;
	},
	getMessage: function getMessage() {
		return TopologyValidationError.errMsg[this._errorType];
	},
	getCoordinate: function getCoordinate() {
		return this._pt;
	},
	toString: function toString() {
		var locStr = "";
		if (this._pt !== null) locStr = " at or near point " + this._pt;
		return this.getMessage() + locStr;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return TopologyValidationError;
	}
});
TopologyValidationError.ERROR = 0;
TopologyValidationError.REPEATED_POINT = 1;
TopologyValidationError.HOLE_OUTSIDE_SHELL = 2;
TopologyValidationError.NESTED_HOLES = 3;
TopologyValidationError.DISCONNECTED_INTERIOR = 4;
TopologyValidationError.SELF_INTERSECTION = 5;
TopologyValidationError.RING_SELF_INTERSECTION = 6;
TopologyValidationError.NESTED_SHELLS = 7;
TopologyValidationError.DUPLICATE_RINGS = 8;
TopologyValidationError.TOO_FEW_POINTS = 9;
TopologyValidationError.INVALID_COORDINATE = 10;
TopologyValidationError.RING_NOT_CLOSED = 11;
TopologyValidationError.errMsg = ["Topology Validation Error", "Repeated Point", "Hole lies outside shell", "Holes are nested", "Interior is disconnected", "Self-intersection", "Ring Self-intersection", "Nested shells", "Duplicate Rings", "Too few distinct points in geometry component", "Invalid Coordinate", "Ring is not closed"];

function IsValidOp() {
	this._parentGeometry = null;
	this._isSelfTouchingRingFormingHoleValid = false;
	this._validErr = null;
	var parentGeometry = arguments[0];
	this._parentGeometry = parentGeometry;
}
extend(IsValidOp.prototype, {
	checkInvalidCoordinates: function checkInvalidCoordinates() {
		if (arguments[0] instanceof Array) {
			var coords = arguments[0];
			for (var i = 0; i < coords.length; i++) {
				if (!IsValidOp.isValid(coords[i])) {
					this._validErr = new TopologyValidationError(TopologyValidationError.INVALID_COORDINATE, coords[i]);
					return null;
				}
			}
		} else if (arguments[0] instanceof Polygon) {
			var poly = arguments[0];
			this.checkInvalidCoordinates(poly.getExteriorRing().getCoordinates());
			if (this._validErr !== null) return null;
			for (var i = 0; i < poly.getNumInteriorRing(); i++) {
				this.checkInvalidCoordinates(poly.getInteriorRingN(i).getCoordinates());
				if (this._validErr !== null) return null;
			}
		}
	},
	checkHolesNotNested: function checkHolesNotNested(p, graph) {
		var nestedTester = new IndexedNestedRingTester(graph);
		for (var i = 0; i < p.getNumInteriorRing(); i++) {
			var innerHole = p.getInteriorRingN(i);
			nestedTester.add(innerHole);
		}
		var isNonNested = nestedTester.isNonNested();
		if (!isNonNested) {
			this._validErr = new TopologyValidationError(TopologyValidationError.NESTED_HOLES, nestedTester.getNestedPoint());
		}
	},
	checkConsistentArea: function checkConsistentArea(graph) {
		var cat = new ConsistentAreaTester(graph);
		var isValidArea = cat.isNodeConsistentArea();
		if (!isValidArea) {
			this._validErr = new TopologyValidationError(TopologyValidationError.SELF_INTERSECTION, cat.getInvalidPoint());
			return null;
		}
		if (cat.hasDuplicateRings()) {
			this._validErr = new TopologyValidationError(TopologyValidationError.DUPLICATE_RINGS, cat.getInvalidPoint());
		}
	},
	isValid: function isValid() {
		this.checkValid(this._parentGeometry);
		return this._validErr === null;
	},
	checkShellInsideHole: function checkShellInsideHole(shell, hole, graph) {
		var shellPts = shell.getCoordinates();
		var holePts = hole.getCoordinates();
		var shellPt = IsValidOp.findPtNotNode(shellPts, hole, graph);
		if (shellPt !== null) {
			var insideHole = PointLocation.isInRing(shellPt, holePts);
			if (!insideHole) {
				return shellPt;
			}
		}
		var holePt = IsValidOp.findPtNotNode(holePts, shell, graph);
		if (holePt !== null) {
			var insideShell = PointLocation.isInRing(holePt, shellPts);
			if (insideShell) {
				return holePt;
			}
			return null;
		}
		Assert.shouldNeverReachHere("points in shell and hole appear to be equal");
		return null;
	},
	checkNoSelfIntersectingRings: function checkNoSelfIntersectingRings(graph) {
		for (var i = graph.getEdgeIterator(); i.hasNext();) {
			var e = i.next();
			this.checkNoSelfIntersectingRing(e.getEdgeIntersectionList());
			if (this._validErr !== null) return null;
		}
	},
	checkConnectedInteriors: function checkConnectedInteriors(graph) {
		var cit = new ConnectedInteriorTester(graph);
		if (!cit.isInteriorsConnected()) this._validErr = new TopologyValidationError(TopologyValidationError.DISCONNECTED_INTERIOR, cit.getCoordinate());
	},
	checkNoSelfIntersectingRing: function checkNoSelfIntersectingRing(eiList) {
		var nodeSet = new TreeSet();
		var isFirst = true;
		for (var i = eiList.iterator(); i.hasNext();) {
			var ei = i.next();
			if (isFirst) {
				isFirst = false;
				continue;
			}
			if (nodeSet.contains(ei.coord)) {
				this._validErr = new TopologyValidationError(TopologyValidationError.RING_SELF_INTERSECTION, ei.coord);
				return null;
			} else {
				nodeSet.add(ei.coord);
			}
		}
	},
	checkHolesInShell: function checkHolesInShell(p, graph) {
		var shell = p.getExteriorRing();
		var pir = new IndexedPointInAreaLocator(shell);
		for (var i = 0; i < p.getNumInteriorRing(); i++) {
			var hole = p.getInteriorRingN(i);
			var holePt = IsValidOp.findPtNotNode(hole.getCoordinates(), shell, graph);
			if (holePt === null) return null;
			var outside = Location.EXTERIOR === pir.locate(holePt);
			if (outside) {
				this._validErr = new TopologyValidationError(TopologyValidationError.HOLE_OUTSIDE_SHELL, holePt);
				return null;
			}
		}
	},
	checkTooFewPoints: function checkTooFewPoints(graph) {
		if (graph.hasTooFewPoints()) {
			this._validErr = new TopologyValidationError(TopologyValidationError.TOO_FEW_POINTS, graph.getInvalidPoint());
			return null;
		}
	},
	getValidationError: function getValidationError() {
		this.checkValid(this._parentGeometry);
		return this._validErr;
	},
	checkValid: function checkValid() {
		if (arguments[0] instanceof Point) {
			var _g = arguments[0];
			this.checkInvalidCoordinates(_g.getCoordinates());
		} else if (arguments[0] instanceof MultiPoint) {
			var _g2 = arguments[0];
			this.checkInvalidCoordinates(_g2.getCoordinates());
		} else if (arguments[0] instanceof LinearRing) {
			var _g3 = arguments[0];
			this.checkInvalidCoordinates(_g3.getCoordinates());
			if (this._validErr !== null) return null;
			this.checkClosedRing(_g3);
			if (this._validErr !== null) return null;
			var graph = new GeometryGraph(0, _g3);
			this.checkTooFewPoints(graph);
			if (this._validErr !== null) return null;
			var li = new RobustLineIntersector();
			graph.computeSelfNodes(li, true, true);
			this.checkNoSelfIntersectingRings(graph);
		} else if (arguments[0] instanceof LineString) {
			var _g4 = arguments[0];
			this.checkInvalidCoordinates(_g4.getCoordinates());
			if (this._validErr !== null) return null;
			var graph = new GeometryGraph(0, _g4);
			this.checkTooFewPoints(graph);
		} else if (arguments[0] instanceof Polygon) {
			var _g5 = arguments[0];
			this.checkInvalidCoordinates(_g5);
			if (this._validErr !== null) return null;
			this.checkClosedRings(_g5);
			if (this._validErr !== null) return null;
			var graph = new GeometryGraph(0, _g5);
			this.checkTooFewPoints(graph);
			if (this._validErr !== null) return null;
			this.checkConsistentArea(graph);
			if (this._validErr !== null) return null;
			if (!this._isSelfTouchingRingFormingHoleValid) {
				this.checkNoSelfIntersectingRings(graph);
				if (this._validErr !== null) return null;
			}
			this.checkHolesInShell(_g5, graph);
			if (this._validErr !== null) return null;
			this.checkHolesNotNested(_g5, graph);
			if (this._validErr !== null) return null;
			this.checkConnectedInteriors(graph);
		} else if (arguments[0] instanceof MultiPolygon) {
			var _g6 = arguments[0];
			for (var i = 0; i < _g6.getNumGeometries(); i++) {
				var p = _g6.getGeometryN(i);
				this.checkInvalidCoordinates(p);
				if (this._validErr !== null) return null;
				this.checkClosedRings(p);
				if (this._validErr !== null) return null;
			}
			var graph = new GeometryGraph(0, _g6);
			this.checkTooFewPoints(graph);
			if (this._validErr !== null) return null;
			this.checkConsistentArea(graph);
			if (this._validErr !== null) return null;
			if (!this._isSelfTouchingRingFormingHoleValid) {
				this.checkNoSelfIntersectingRings(graph);
				if (this._validErr !== null) return null;
			}
			for (var i = 0; i < _g6.getNumGeometries(); i++) {
				var p = _g6.getGeometryN(i);
				this.checkHolesInShell(p, graph);
				if (this._validErr !== null) return null;
			}
			for (var i = 0; i < _g6.getNumGeometries(); i++) {
				var p = _g6.getGeometryN(i);
				this.checkHolesNotNested(p, graph);
				if (this._validErr !== null) return null;
			}
			this.checkShellsNotNested(_g6, graph);
			if (this._validErr !== null) return null;
			this.checkConnectedInteriors(graph);
		} else if (arguments[0] instanceof GeometryCollection) {
			var gc = arguments[0];
			for (var i = 0; i < gc.getNumGeometries(); i++) {
				var g = gc.getGeometryN(i);
				this.checkValid(g);
				if (this._validErr !== null) return null;
			}
		} else if (arguments[0] instanceof Geometry) {
			var _g7 = arguments[0];
			this._validErr = null;
			if (_g7.isEmpty()) return null;
			if (_g7 instanceof Point) this.checkValid(_g7);else if (_g7 instanceof MultiPoint) this.checkValid(_g7);else if (_g7 instanceof LinearRing) this.checkValid(_g7);else if (_g7 instanceof LineString) this.checkValid(_g7);else if (_g7 instanceof Polygon) this.checkValid(_g7);else if (_g7 instanceof MultiPolygon) this.checkValid(_g7);else if (_g7 instanceof GeometryCollection) this.checkValid(_g7);else throw new UnsupportedOperationException(_g7.getClass().getName());
		}
	},
	setSelfTouchingRingFormingHoleValid: function setSelfTouchingRingFormingHoleValid(isValid) {
		this._isSelfTouchingRingFormingHoleValid = isValid;
	},
	checkShellNotNested: function checkShellNotNested(shell, p, graph) {
		var shellPts = shell.getCoordinates();
		var polyShell = p.getExteriorRing();
		var polyPts = polyShell.getCoordinates();
		var shellPt = IsValidOp.findPtNotNode(shellPts, polyShell, graph);
		if (shellPt === null) return null;
		var insidePolyShell = PointLocation.isInRing(shellPt, polyPts);
		if (!insidePolyShell) return null;
		if (p.getNumInteriorRing() <= 0) {
			this._validErr = new TopologyValidationError(TopologyValidationError.NESTED_SHELLS, shellPt);
			return null;
		}
		var badNestedPt = null;
		for (var i = 0; i < p.getNumInteriorRing(); i++) {
			var hole = p.getInteriorRingN(i);
			badNestedPt = this.checkShellInsideHole(shell, hole, graph);
			if (badNestedPt === null) return null;
		}
		this._validErr = new TopologyValidationError(TopologyValidationError.NESTED_SHELLS, badNestedPt);
	},
	checkClosedRings: function checkClosedRings(poly) {
		this.checkClosedRing(poly.getExteriorRing());
		if (this._validErr !== null) return null;
		for (var i = 0; i < poly.getNumInteriorRing(); i++) {
			this.checkClosedRing(poly.getInteriorRingN(i));
			if (this._validErr !== null) return null;
		}
	},
	checkClosedRing: function checkClosedRing(ring) {
		if (!ring.isClosed()) {
			var pt = null;
			if (ring.getNumPoints() >= 1) pt = ring.getCoordinateN(0);
			this._validErr = new TopologyValidationError(TopologyValidationError.RING_NOT_CLOSED, pt);
		}
	},
	checkShellsNotNested: function checkShellsNotNested(mp, graph) {
		for (var i = 0; i < mp.getNumGeometries(); i++) {
			var p = mp.getGeometryN(i);
			var shell = p.getExteriorRing();
			for (var j = 0; j < mp.getNumGeometries(); j++) {
				if (i === j) continue;
				var p2 = mp.getGeometryN(j);
				this.checkShellNotNested(shell, p2, graph);
				if (this._validErr !== null) return null;
			}
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return IsValidOp;
	}
});
IsValidOp.findPtNotNode = function (testCoords, searchRing, graph) {
	var searchEdge = graph.findEdge(searchRing);
	var eiList = searchEdge.getEdgeIntersectionList();
	for (var i = 0; i < testCoords.length; i++) {
		var pt = testCoords[i];
		if (!eiList.isIntersection(pt)) return pt;
	}
	return null;
};
IsValidOp.isValid = function () {
	if (arguments[0] instanceof Geometry) {
		var geom = arguments[0];
		var isValidOp = new IsValidOp(geom);
		return isValidOp.isValid();
	} else if (arguments[0] instanceof Coordinate) {
		var coord = arguments[0];
		if (Double.isNaN(coord.x)) return false;
		if (Double.isInfinite(coord.x)) return false;
		if (Double.isNaN(coord.y)) return false;
		if (Double.isInfinite(coord.y)) return false;
		return true;
	}
};



var valid = Object.freeze({
	IsValidOp: IsValidOp,
	ConsistentAreaTester: ConsistentAreaTester
});



var operation = Object.freeze({
	BoundaryOp: BoundaryOp,
	IsSimpleOp: IsSimpleOp,
	buffer: buffer,
	distance: distance,
	linemerge: linemerge,
	overlay: overlay,
	polygonize: polygonize,
	relate: relate,
	union: union,
	valid: valid
});

function PrecisionReducerCoordinateOperation() {
	GeometryEditor.CoordinateOperation.apply(this);
	this._targetPM = null;
	this._removeCollapsed = true;
	var targetPM = arguments[0],
	    removeCollapsed = arguments[1];
	this._targetPM = targetPM;
	this._removeCollapsed = removeCollapsed;
}
inherits(PrecisionReducerCoordinateOperation, GeometryEditor.CoordinateOperation);
extend(PrecisionReducerCoordinateOperation.prototype, {
	edit: function edit() {
		if (arguments.length === 2 && arguments[1] instanceof Geometry && arguments[0] instanceof Array) {
			var coordinates = arguments[0],
			    geom = arguments[1];
			if (coordinates.length === 0) return null;
			var reducedCoords = new Array(coordinates.length).fill(null);
			for (var i = 0; i < coordinates.length; i++) {
				var coord = new Coordinate(coordinates[i]);
				this._targetPM.makePrecise(coord);
				reducedCoords[i] = coord;
			}
			var noRepeatedCoordList = new CoordinateList(reducedCoords, false);
			var noRepeatedCoords = noRepeatedCoordList.toCoordinateArray();
			var minLength = 0;
			if (geom instanceof LineString) minLength = 2;
			if (geom instanceof LinearRing) minLength = 4;
			var collapsedCoords = reducedCoords;
			if (this._removeCollapsed) collapsedCoords = null;
			if (noRepeatedCoords.length < minLength) {
				return collapsedCoords;
			}
			return noRepeatedCoords;
		} else return GeometryEditor.CoordinateOperation.prototype.edit.apply(this, arguments);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return PrecisionReducerCoordinateOperation;
	}
});

function GeometryPrecisionReducer() {
	this._targetPM = null;
	this._removeCollapsed = true;
	this._changePrecisionModel = false;
	this._isPointwise = false;
	var pm = arguments[0];
	this._targetPM = pm;
}
extend(GeometryPrecisionReducer.prototype, {
	fixPolygonalTopology: function fixPolygonalTopology(geom) {
		var geomToBuffer = geom;
		if (!this._changePrecisionModel) {
			geomToBuffer = this.changePM(geom, this._targetPM);
		}
		var bufGeom = BufferOp.bufferOp(geomToBuffer, 0);
		var finalGeom = bufGeom;
		if (!this._changePrecisionModel) {
			finalGeom = bufGeom.copy();
			this.changePM(finalGeom, geom.getPrecisionModel());
		}
		return finalGeom;
	},
	reducePointwise: function reducePointwise(geom) {
		var geomEdit = null;
		if (this._changePrecisionModel) {
			var newFactory = this.createFactory(geom.getFactory(), this._targetPM);
			geomEdit = new GeometryEditor(newFactory);
		} else geomEdit = new GeometryEditor();
		var finalRemoveCollapsed = this._removeCollapsed;
		if (geom.getDimension() >= 2) finalRemoveCollapsed = true;
		var reduceGeom = geomEdit.edit(geom, new PrecisionReducerCoordinateOperation(this._targetPM, finalRemoveCollapsed));
		return reduceGeom;
	},
	changePM: function changePM(geom, newPM) {
		var geomEditor = this.createEditor(geom.getFactory(), newPM);
		return geomEditor.edit(geom, new GeometryEditor.NoOpGeometryOperation());
	},
	setRemoveCollapsedComponents: function setRemoveCollapsedComponents(removeCollapsed) {
		this._removeCollapsed = removeCollapsed;
	},
	createFactory: function createFactory(inputFactory, pm) {
		var newFactory = new GeometryFactory(pm, inputFactory.getSRID(), inputFactory.getCoordinateSequenceFactory());
		return newFactory;
	},
	setChangePrecisionModel: function setChangePrecisionModel(changePrecisionModel) {
		this._changePrecisionModel = changePrecisionModel;
	},
	reduce: function reduce(geom) {
		var reducePW = this.reducePointwise(geom);
		if (this._isPointwise) return reducePW;
		if (!hasInterface(reducePW, Polygonal)) return reducePW;
		if (IsValidOp.isValid(reducePW)) return reducePW;
		return this.fixPolygonalTopology(reducePW);
	},
	setPointwise: function setPointwise(isPointwise) {
		this._isPointwise = isPointwise;
	},
	createEditor: function createEditor(geomFactory, newPM) {
		if (geomFactory.getPrecisionModel() === newPM) return new GeometryEditor();
		var newFactory = this.createFactory(geomFactory, newPM);
		var geomEdit = new GeometryEditor(newFactory);
		return geomEdit;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return GeometryPrecisionReducer;
	}
});
GeometryPrecisionReducer.reduce = function (g, precModel) {
	var reducer = new GeometryPrecisionReducer(precModel);
	return reducer.reduce(g);
};
GeometryPrecisionReducer.reducePointwise = function (g, precModel) {
	var reducer = new GeometryPrecisionReducer(precModel);
	reducer.setPointwise(true);
	return reducer.reduce(g);
};



var precision = Object.freeze({
	GeometryPrecisionReducer: GeometryPrecisionReducer
});

function DouglasPeuckerLineSimplifier() {
	this._pts = null;
	this._usePt = null;
	this._distanceTolerance = null;
	this._seg = new LineSegment();
	var pts = arguments[0];
	this._pts = pts;
}
extend(DouglasPeuckerLineSimplifier.prototype, {
	simplifySection: function simplifySection(i, j) {
		if (i + 1 === j) {
			return null;
		}
		this._seg.p0 = this._pts[i];
		this._seg.p1 = this._pts[j];
		var maxDistance = -1.0;
		var maxIndex = i;
		for (var k = i + 1; k < j; k++) {
			var distance = this._seg.distance(this._pts[k]);
			if (distance > maxDistance) {
				maxDistance = distance;
				maxIndex = k;
			}
		}
		if (maxDistance <= this._distanceTolerance) {
			for (var k = i + 1; k < j; k++) {
				this._usePt[k] = false;
			}
		} else {
			this.simplifySection(i, maxIndex);
			this.simplifySection(maxIndex, j);
		}
	},
	setDistanceTolerance: function setDistanceTolerance(distanceTolerance) {
		this._distanceTolerance = distanceTolerance;
	},
	simplify: function simplify() {
		this._usePt = new Array(this._pts.length).fill(null);
		for (var i = 0; i < this._pts.length; i++) {
			this._usePt[i] = true;
		}
		this.simplifySection(0, this._pts.length - 1);
		var coordList = new CoordinateList();
		for (var i = 0; i < this._pts.length; i++) {
			if (this._usePt[i]) coordList.add(new Coordinate(this._pts[i]));
		}
		return coordList.toCoordinateArray();
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return DouglasPeuckerLineSimplifier;
	}
});
DouglasPeuckerLineSimplifier.simplify = function (pts, distanceTolerance) {
	var simp = new DouglasPeuckerLineSimplifier(pts);
	simp.setDistanceTolerance(distanceTolerance);
	return simp.simplify();
};

function DouglasPeuckerSimplifier() {
	this._inputGeom = null;
	this._distanceTolerance = null;
	this._isEnsureValidTopology = true;
	var inputGeom = arguments[0];
	this._inputGeom = inputGeom;
}
extend(DouglasPeuckerSimplifier.prototype, {
	setEnsureValid: function setEnsureValid(isEnsureValidTopology) {
		this._isEnsureValidTopology = isEnsureValidTopology;
	},
	getResultGeometry: function getResultGeometry() {
		if (this._inputGeom.isEmpty()) return this._inputGeom.copy();
		return new DPTransformer(this._isEnsureValidTopology, this._distanceTolerance).transform(this._inputGeom);
	},
	setDistanceTolerance: function setDistanceTolerance(distanceTolerance) {
		if (distanceTolerance < 0.0) throw new IllegalArgumentException("Tolerance must be non-negative");
		this._distanceTolerance = distanceTolerance;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return DouglasPeuckerSimplifier;
	}
});
DouglasPeuckerSimplifier.simplify = function (geom, distanceTolerance) {
	var tss = new DouglasPeuckerSimplifier(geom);
	tss.setDistanceTolerance(distanceTolerance);
	return tss.getResultGeometry();
};
function DPTransformer() {
	GeometryTransformer.apply(this);
	this._isEnsureValidTopology = true;
	this._distanceTolerance = null;
	var isEnsureValidTopology = arguments[0],
	    distanceTolerance = arguments[1];
	this._isEnsureValidTopology = isEnsureValidTopology;
	this._distanceTolerance = distanceTolerance;
}
inherits(DPTransformer, GeometryTransformer);
extend(DPTransformer.prototype, {
	transformPolygon: function transformPolygon(geom, parent) {
		if (geom.isEmpty()) return null;
		var rawGeom = GeometryTransformer.prototype.transformPolygon.call(this, geom, parent);
		if (parent instanceof MultiPolygon) {
			return rawGeom;
		}
		return this.createValidArea(rawGeom);
	},
	createValidArea: function createValidArea(rawAreaGeom) {
		if (this._isEnsureValidTopology) return rawAreaGeom.buffer(0.0);
		return rawAreaGeom;
	},
	transformCoordinates: function transformCoordinates(coords, parent) {
		var inputPts = coords.toCoordinateArray();
		var newPts = null;
		if (inputPts.length === 0) {
			newPts = new Array(0).fill(null);
		} else {
			newPts = DouglasPeuckerLineSimplifier.simplify(inputPts, this._distanceTolerance);
		}
		return this._factory.getCoordinateSequenceFactory().create(newPts);
	},
	transformMultiPolygon: function transformMultiPolygon(geom, parent) {
		var rawGeom = GeometryTransformer.prototype.transformMultiPolygon.call(this, geom, parent);
		return this.createValidArea(rawGeom);
	},
	transformLinearRing: function transformLinearRing(geom, parent) {
		var removeDegenerateRings = parent instanceof Polygon;
		var simpResult = GeometryTransformer.prototype.transformLinearRing.call(this, geom, parent);
		if (removeDegenerateRings && !(simpResult instanceof LinearRing)) return null;
		
		return simpResult;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return DPTransformer;
	}
});
DouglasPeuckerSimplifier.DPTransformer = DPTransformer;

function TaggedLineSegment() {
	this._parent = null;
	this._index = null;
	if (arguments.length === 2) {
		var p0 = arguments[0],
		    p1 = arguments[1];
		TaggedLineSegment.call(this, p0, p1, null, -1);
	} else if (arguments.length === 4) {
		var _p = arguments[0],
		    _p2 = arguments[1],
		    parent = arguments[2],
		    index = arguments[3];
		LineSegment.call(this, _p, _p2);
		this._parent = parent;
		this._index = index;
	}
}
inherits(TaggedLineSegment, LineSegment);
extend(TaggedLineSegment.prototype, {
	getIndex: function getIndex() {
		return this._index;
	},
	getParent: function getParent() {
		return this._parent;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return TaggedLineSegment;
	}
});

function TaggedLineString() {
	this._parentLine = null;
	this._segs = null;
	this._resultSegs = new ArrayList();
	this._minimumSize = null;
	if (arguments.length === 1) {
		var parentLine = arguments[0];
		TaggedLineString.call(this, parentLine, 2);
	} else if (arguments.length === 2) {
		var _parentLine = arguments[0],
		    minimumSize = arguments[1];
		this._parentLine = _parentLine;
		this._minimumSize = minimumSize;
		this.init();
	}
}
extend(TaggedLineString.prototype, {
	addToResult: function addToResult(seg) {
		this._resultSegs.add(seg);
	},
	asLineString: function asLineString() {
		return this._parentLine.getFactory().createLineString(TaggedLineString.extractCoordinates(this._resultSegs));
	},
	getResultSize: function getResultSize() {
		var resultSegsSize = this._resultSegs.size();
		return resultSegsSize === 0 ? 0 : resultSegsSize + 1;
	},
	getParent: function getParent() {
		return this._parentLine;
	},
	getSegment: function getSegment(i) {
		return this._segs[i];
	},
	getParentCoordinates: function getParentCoordinates() {
		return this._parentLine.getCoordinates();
	},
	getMinimumSize: function getMinimumSize() {
		return this._minimumSize;
	},
	asLinearRing: function asLinearRing() {
		return this._parentLine.getFactory().createLinearRing(TaggedLineString.extractCoordinates(this._resultSegs));
	},
	getSegments: function getSegments() {
		return this._segs;
	},
	init: function init() {
		var pts = this._parentLine.getCoordinates();
		this._segs = new Array(pts.length - 1).fill(null);
		for (var i = 0; i < pts.length - 1; i++) {
			var seg = new TaggedLineSegment(pts[i], pts[i + 1], this._parentLine, i);
			this._segs[i] = seg;
		}
	},
	getResultCoordinates: function getResultCoordinates() {
		return TaggedLineString.extractCoordinates(this._resultSegs);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return TaggedLineString;
	}
});
TaggedLineString.extractCoordinates = function (segs) {
	var pts = new Array(segs.size() + 1).fill(null);
	var seg = null;
	for (var i = 0; i < segs.size(); i++) {
		seg = segs.get(i);
		pts[i] = seg.p0;
	}
	pts[pts.length - 1] = seg.p1;
	return pts;
};

function LineSegmentIndex() {
	this._index = new Quadtree();
}
extend(LineSegmentIndex.prototype, {
	remove: function remove(seg) {
		this._index.remove(new Envelope(seg.p0, seg.p1), seg);
	},
	add: function add() {
		if (arguments[0] instanceof TaggedLineString) {
			var line = arguments[0];
			var segs = line.getSegments();
			for (var i = 0; i < segs.length; i++) {
				var seg = segs[i];
				this.add(seg);
			}
		} else if (arguments[0] instanceof LineSegment) {
			var _seg = arguments[0];
			this._index.insert(new Envelope(_seg.p0, _seg.p1), _seg);
		}
	},
	query: function query(querySeg) {
		var env = new Envelope(querySeg.p0, querySeg.p1);
		var visitor = new LineSegmentVisitor(querySeg);
		this._index.query(env, visitor);
		var itemsFound = visitor.getItems();
		return itemsFound;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LineSegmentIndex;
	}
});
function LineSegmentVisitor() {
	this._querySeg = null;
	this._items = new ArrayList();
	var querySeg = arguments[0];
	this._querySeg = querySeg;
}
extend(LineSegmentVisitor.prototype, {
	visitItem: function visitItem(item) {
		var seg = item;
		if (Envelope.intersects(seg.p0, seg.p1, this._querySeg.p0, this._querySeg.p1)) this._items.add(item);
	},
	getItems: function getItems() {
		return this._items;
	},
	interfaces_: function interfaces_() {
		return [ItemVisitor];
	},
	getClass: function getClass() {
		return LineSegmentVisitor;
	}
});

function TaggedLineStringSimplifier() {
	this._li = new RobustLineIntersector();
	this._inputIndex = new LineSegmentIndex();
	this._outputIndex = new LineSegmentIndex();
	this._line = null;
	this._linePts = null;
	this._distanceTolerance = 0.0;
	var inputIndex = arguments[0],
	    outputIndex = arguments[1];
	this._inputIndex = inputIndex;
	this._outputIndex = outputIndex;
}
extend(TaggedLineStringSimplifier.prototype, {
	flatten: function flatten(start, end) {
		var p0 = this._linePts[start];
		var p1 = this._linePts[end];
		var newSeg = new LineSegment(p0, p1);
		this.remove(this._line, start, end);
		this._outputIndex.add(newSeg);
		return newSeg;
	},
	hasBadIntersection: function hasBadIntersection(parentLine, sectionIndex, candidateSeg) {
		if (this.hasBadOutputIntersection(candidateSeg)) return true;
		if (this.hasBadInputIntersection(parentLine, sectionIndex, candidateSeg)) return true;
		return false;
	},
	setDistanceTolerance: function setDistanceTolerance(distanceTolerance) {
		this._distanceTolerance = distanceTolerance;
	},
	simplifySection: function simplifySection(i, j, depth) {
		depth += 1;
		var sectionIndex = new Array(2).fill(null);
		if (i + 1 === j) {
			var newSeg = this._line.getSegment(i);
			this._line.addToResult(newSeg);
			return null;
		}
		var isValidToSimplify = true;
		if (this._line.getResultSize() < this._line.getMinimumSize()) {
			var worstCaseSize = depth + 1;
			if (worstCaseSize < this._line.getMinimumSize()) isValidToSimplify = false;
		}
		var distance = new Array(1).fill(null);
		var furthestPtIndex = this.findFurthestPoint(this._linePts, i, j, distance);
		if (distance[0] > this._distanceTolerance) isValidToSimplify = false;
		var candidateSeg = new LineSegment();
		candidateSeg.p0 = this._linePts[i];
		candidateSeg.p1 = this._linePts[j];
		sectionIndex[0] = i;
		sectionIndex[1] = j;
		if (this.hasBadIntersection(this._line, sectionIndex, candidateSeg)) isValidToSimplify = false;
		if (isValidToSimplify) {
			var newSeg = this.flatten(i, j);
			this._line.addToResult(newSeg);
			return null;
		}
		this.simplifySection(i, furthestPtIndex, depth);
		this.simplifySection(furthestPtIndex, j, depth);
	},
	hasBadOutputIntersection: function hasBadOutputIntersection(candidateSeg) {
		var querySegs = this._outputIndex.query(candidateSeg);
		for (var i = querySegs.iterator(); i.hasNext();) {
			var querySeg = i.next();
			if (this.hasInteriorIntersection(querySeg, candidateSeg)) {
				return true;
			}
		}
		return false;
	},
	findFurthestPoint: function findFurthestPoint(pts, i, j, maxDistance) {
		var seg = new LineSegment();
		seg.p0 = pts[i];
		seg.p1 = pts[j];
		var maxDist = -1.0;
		var maxIndex = i;
		for (var k = i + 1; k < j; k++) {
			var midPt = pts[k];
			var distance = seg.distance(midPt);
			if (distance > maxDist) {
				maxDist = distance;
				maxIndex = k;
			}
		}
		maxDistance[0] = maxDist;
		return maxIndex;
	},
	simplify: function simplify(line) {
		this._line = line;
		this._linePts = line.getParentCoordinates();
		this.simplifySection(0, this._linePts.length - 1, 0);
	},
	remove: function remove(line, start, end) {
		for (var i = start; i < end; i++) {
			var seg = line.getSegment(i);
			this._inputIndex.remove(seg);
		}
	},
	hasInteriorIntersection: function hasInteriorIntersection(seg0, seg1) {
		this._li.computeIntersection(seg0.p0, seg0.p1, seg1.p0, seg1.p1);
		return this._li.isInteriorIntersection();
	},
	hasBadInputIntersection: function hasBadInputIntersection(parentLine, sectionIndex, candidateSeg) {
		var querySegs = this._inputIndex.query(candidateSeg);
		for (var i = querySegs.iterator(); i.hasNext();) {
			var querySeg = i.next();
			if (this.hasInteriorIntersection(querySeg, candidateSeg)) {
				if (TaggedLineStringSimplifier.isInLineSection(parentLine, sectionIndex, querySeg)) continue;
				return true;
			}
		}
		return false;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return TaggedLineStringSimplifier;
	}
});
TaggedLineStringSimplifier.isInLineSection = function (line, sectionIndex, seg) {
	if (seg.getParent() !== line.getParent()) return false;
	var segIndex = seg.getIndex();
	if (segIndex >= sectionIndex[0] && segIndex < sectionIndex[1]) return true;
	return false;
};

function TaggedLinesSimplifier() {
	this._inputIndex = new LineSegmentIndex();
	this._outputIndex = new LineSegmentIndex();
	this._distanceTolerance = 0.0;
}
extend(TaggedLinesSimplifier.prototype, {
	setDistanceTolerance: function setDistanceTolerance(distanceTolerance) {
		this._distanceTolerance = distanceTolerance;
	},
	simplify: function simplify(taggedLines) {
		for (var i = taggedLines.iterator(); i.hasNext();) {
			this._inputIndex.add(i.next());
		}
		for (var i = taggedLines.iterator(); i.hasNext();) {
			var tlss = new TaggedLineStringSimplifier(this._inputIndex, this._outputIndex);
			tlss.setDistanceTolerance(this._distanceTolerance);
			tlss.simplify(i.next());
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return TaggedLinesSimplifier;
	}
});

function TopologyPreservingSimplifier() {
	this._inputGeom = null;
	this._lineSimplifier = new TaggedLinesSimplifier();
	this._linestringMap = null;
	var inputGeom = arguments[0];
	this._inputGeom = inputGeom;
}
extend(TopologyPreservingSimplifier.prototype, {
	getResultGeometry: function getResultGeometry() {
		if (this._inputGeom.isEmpty()) return this._inputGeom.copy();
		this._linestringMap = new HashMap();
		this._inputGeom.apply(new LineStringMapBuilderFilter(this));
		this._lineSimplifier.simplify(this._linestringMap.values());
		var result = new LineStringTransformer(this._linestringMap).transform(this._inputGeom);
		return result;
	},
	setDistanceTolerance: function setDistanceTolerance(distanceTolerance) {
		if (distanceTolerance < 0.0) throw new IllegalArgumentException("Tolerance must be non-negative");
		this._lineSimplifier.setDistanceTolerance(distanceTolerance);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return TopologyPreservingSimplifier;
	}
});
TopologyPreservingSimplifier.simplify = function (geom, distanceTolerance) {
	var tss = new TopologyPreservingSimplifier(geom);
	tss.setDistanceTolerance(distanceTolerance);
	return tss.getResultGeometry();
};
function LineStringTransformer() {
	GeometryTransformer.apply(this);
	this._linestringMap = null;
	var linestringMap = arguments[0];
	this._linestringMap = linestringMap;
}
inherits(LineStringTransformer, GeometryTransformer);
extend(LineStringTransformer.prototype, {
	transformCoordinates: function transformCoordinates(coords, parent) {
		if (coords.size() === 0) return null;
		if (parent instanceof LineString) {
			var taggedLine = this._linestringMap.get(parent);
			return this.createCoordinateSequence(taggedLine.getResultCoordinates());
		}
		return GeometryTransformer.prototype.transformCoordinates.call(this, coords, parent);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LineStringTransformer;
	}
});
function LineStringMapBuilderFilter() {
	this.tps = null;
	var tps = arguments[0];
	this.tps = tps;
}
extend(LineStringMapBuilderFilter.prototype, {
	filter: function filter(geom) {
		if (geom instanceof LineString) {
			var line = geom;
			if (line.isEmpty()) return null;
			var minSize = line.isClosed() ? 4 : 2;
			var taggedLine = new TaggedLineString(line, minSize);
			this.tps._linestringMap.put(line, taggedLine);
		}
	},
	interfaces_: function interfaces_() {
		return [GeometryComponentFilter];
	},
	getClass: function getClass() {
		return LineStringMapBuilderFilter;
	}
});
TopologyPreservingSimplifier.LineStringTransformer = LineStringTransformer;
TopologyPreservingSimplifier.LineStringMapBuilderFilter = LineStringMapBuilderFilter;



var simplify = Object.freeze({
	DouglasPeuckerSimplifier: DouglasPeuckerSimplifier,
	TopologyPreservingSimplifier: TopologyPreservingSimplifier
});

function SplitSegment() {
	this._seg = null;
	this._segLen = null;
	this._splitPt = null;
	this._minimumLen = 0.0;
	var seg = arguments[0];
	this._seg = seg;
	this._segLen = seg.getLength();
}
extend(SplitSegment.prototype, {
	splitAt: function splitAt() {
		if (arguments.length === 1) {
			var pt = arguments[0];
			var minFrac = this._minimumLen / this._segLen;
			if (pt.distance(this._seg.p0) < this._minimumLen) {
				this._splitPt = this._seg.pointAlong(minFrac);
				return null;
			}
			if (pt.distance(this._seg.p1) < this._minimumLen) {
				this._splitPt = SplitSegment.pointAlongReverse(this._seg, minFrac);
				return null;
			}
			this._splitPt = pt;
		} else if (arguments.length === 2) {
			var length = arguments[0],
			    endPt = arguments[1];
			var actualLen = this.getConstrainedLength(length);
			var frac = actualLen / this._segLen;
			if (endPt.equals2D(this._seg.p0)) this._splitPt = this._seg.pointAlong(frac);else this._splitPt = SplitSegment.pointAlongReverse(this._seg, frac);
		}
	},
	setMinimumLength: function setMinimumLength(minLen) {
		this._minimumLen = minLen;
	},
	getConstrainedLength: function getConstrainedLength(len) {
		if (len < this._minimumLen) return this._minimumLen;
		return len;
	},
	getSplitPoint: function getSplitPoint() {
		return this._splitPt;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return SplitSegment;
	}
});
SplitSegment.pointAlongReverse = function (seg, segmentLengthFraction) {
	var coord = new Coordinate();
	coord.x = seg.p1.x - segmentLengthFraction * (seg.p1.x - seg.p0.x);
	coord.y = seg.p1.y - segmentLengthFraction * (seg.p1.y - seg.p0.y);
	return coord;
};

function ConstraintSplitPointFinder() {}
extend(ConstraintSplitPointFinder.prototype, {
	findSplitPoint: function findSplitPoint(seg, encroachPt) {},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return ConstraintSplitPointFinder;
	}
});

function NonEncroachingSplitPointFinder() {}
extend(NonEncroachingSplitPointFinder.prototype, {
	findSplitPoint: function findSplitPoint(seg, encroachPt) {
		var lineSeg = seg.getLineSegment();
		var segLen = lineSeg.getLength();
		var midPtLen = segLen / 2;
		var splitSeg = new SplitSegment(lineSeg);
		var projPt = NonEncroachingSplitPointFinder.projectedSplitPoint(seg, encroachPt);
		var nonEncroachDiam = projPt.distance(encroachPt) * 2 * 0.8;
		var maxSplitLen = nonEncroachDiam;
		if (maxSplitLen > midPtLen) {
			maxSplitLen = midPtLen;
		}
		splitSeg.setMinimumLength(maxSplitLen);
		splitSeg.splitAt(projPt);
		return splitSeg.getSplitPoint();
	},
	interfaces_: function interfaces_() {
		return [ConstraintSplitPointFinder];
	},
	getClass: function getClass() {
		return NonEncroachingSplitPointFinder;
	}
});
NonEncroachingSplitPointFinder.projectedSplitPoint = function (seg, encroachPt) {
	var lineSeg = seg.getLineSegment();
	var projPt = lineSeg.project(encroachPt);
	return projPt;
};

function TrianglePredicate() {}
extend(TrianglePredicate.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return TrianglePredicate;
	}
});
TrianglePredicate.triArea = function (a, b, c) {
	return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
};
TrianglePredicate.isInCircleDDNormalized = function (a, b, c, p) {
	var adx = DD.valueOf(a.x).selfSubtract(p.x);
	var ady = DD.valueOf(a.y).selfSubtract(p.y);
	var bdx = DD.valueOf(b.x).selfSubtract(p.x);
	var bdy = DD.valueOf(b.y).selfSubtract(p.y);
	var cdx = DD.valueOf(c.x).selfSubtract(p.x);
	var cdy = DD.valueOf(c.y).selfSubtract(p.y);
	var abdet = adx.multiply(bdy).selfSubtract(bdx.multiply(ady));
	var bcdet = bdx.multiply(cdy).selfSubtract(cdx.multiply(bdy));
	var cadet = cdx.multiply(ady).selfSubtract(adx.multiply(cdy));
	var alift = adx.multiply(adx).selfAdd(ady.multiply(ady));
	var blift = bdx.multiply(bdx).selfAdd(bdy.multiply(bdy));
	var clift = cdx.multiply(cdx).selfAdd(cdy.multiply(cdy));
	var sum = alift.selfMultiply(bcdet).selfAdd(blift.selfMultiply(cadet)).selfAdd(clift.selfMultiply(abdet));
	var isInCircle = sum.doubleValue() > 0;
	return isInCircle;
};
TrianglePredicate.checkRobustInCircle = function (a, b, c, p) {
	var nonRobustInCircle = TrianglePredicate.isInCircleNonRobust(a, b, c, p);
	var isInCircleDD = TrianglePredicate.isInCircleDDSlow(a, b, c, p);
	var isInCircleCC = TrianglePredicate.isInCircleCC(a, b, c, p);
	var circumCentre = Triangle.circumcentre(a, b, c);
	System.out.println("p radius diff a = " + Math.abs(p.distance(circumCentre) - a.distance(circumCentre)) / a.distance(circumCentre));
	if (nonRobustInCircle !== isInCircleDD || nonRobustInCircle !== isInCircleCC) {
		System.out.println("inCircle robustness failure (double result = " + nonRobustInCircle + ", DD result = " + isInCircleDD + ", CC result = " + isInCircleCC + ")");
		System.out.println(WKTWriter.toLineString(new CoordinateArraySequence([a, b, c, p])));
		System.out.println("Circumcentre = " + WKTWriter.toPoint(circumCentre) + " radius = " + a.distance(circumCentre));
		System.out.println("p radius diff a = " + Math.abs(p.distance(circumCentre) / a.distance(circumCentre) - 1));
		System.out.println("p radius diff b = " + Math.abs(p.distance(circumCentre) / b.distance(circumCentre) - 1));
		System.out.println("p radius diff c = " + Math.abs(p.distance(circumCentre) / c.distance(circumCentre) - 1));
		System.out.println();
	}
};
TrianglePredicate.isInCircleDDFast = function (a, b, c, p) {
	var aTerm = DD.sqr(a.x).selfAdd(DD.sqr(a.y)).selfMultiply(TrianglePredicate.triAreaDDFast(b, c, p));
	var bTerm = DD.sqr(b.x).selfAdd(DD.sqr(b.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, c, p));
	var cTerm = DD.sqr(c.x).selfAdd(DD.sqr(c.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, b, p));
	var pTerm = DD.sqr(p.x).selfAdd(DD.sqr(p.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, b, c));
	var sum = aTerm.selfSubtract(bTerm).selfAdd(cTerm).selfSubtract(pTerm);
	var isInCircle = sum.doubleValue() > 0;
	return isInCircle;
};
TrianglePredicate.isInCircleCC = function (a, b, c, p) {
	var cc = Triangle.circumcentre(a, b, c);
	var ccRadius = a.distance(cc);
	var pRadiusDiff = p.distance(cc) - ccRadius;
	return pRadiusDiff <= 0;
};
TrianglePredicate.isInCircleNormalized = function (a, b, c, p) {
	var adx = a.x - p.x;
	var ady = a.y - p.y;
	var bdx = b.x - p.x;
	var bdy = b.y - p.y;
	var cdx = c.x - p.x;
	var cdy = c.y - p.y;
	var abdet = adx * bdy - bdx * ady;
	var bcdet = bdx * cdy - cdx * bdy;
	var cadet = cdx * ady - adx * cdy;
	var alift = adx * adx + ady * ady;
	var blift = bdx * bdx + bdy * bdy;
	var clift = cdx * cdx + cdy * cdy;
	var disc = alift * bcdet + blift * cadet + clift * abdet;
	return disc > 0;
};
TrianglePredicate.isInCircleDDSlow = function (a, b, c, p) {
	var px = DD.valueOf(p.x);
	var py = DD.valueOf(p.y);
	var ax = DD.valueOf(a.x);
	var ay = DD.valueOf(a.y);
	var bx = DD.valueOf(b.x);
	var by = DD.valueOf(b.y);
	var cx = DD.valueOf(c.x);
	var cy = DD.valueOf(c.y);
	var aTerm = ax.multiply(ax).add(ay.multiply(ay)).multiply(TrianglePredicate.triAreaDDSlow(bx, by, cx, cy, px, py));
	var bTerm = bx.multiply(bx).add(by.multiply(by)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, cx, cy, px, py));
	var cTerm = cx.multiply(cx).add(cy.multiply(cy)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, bx, by, px, py));
	var pTerm = px.multiply(px).add(py.multiply(py)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, bx, by, cx, cy));
	var sum = aTerm.subtract(bTerm).add(cTerm).subtract(pTerm);
	var isInCircle = sum.doubleValue() > 0;
	return isInCircle;
};
TrianglePredicate.isInCircleNonRobust = function (a, b, c, p) {
	var isInCircle = (a.x * a.x + a.y * a.y) * TrianglePredicate.triArea(b, c, p) - (b.x * b.x + b.y * b.y) * TrianglePredicate.triArea(a, c, p) + (c.x * c.x + c.y * c.y) * TrianglePredicate.triArea(a, b, p) - (p.x * p.x + p.y * p.y) * TrianglePredicate.triArea(a, b, c) > 0;
	return isInCircle;
};
TrianglePredicate.isInCircleRobust = function (a, b, c, p) {
	return TrianglePredicate.isInCircleNormalized(a, b, c, p);
};
TrianglePredicate.triAreaDDSlow = function (ax, ay, bx, by, cx, cy) {
	return bx.subtract(ax).multiply(cy.subtract(ay)).subtract(by.subtract(ay).multiply(cx.subtract(ax)));
};
TrianglePredicate.triAreaDDFast = function (a, b, c) {
	var t1 = DD.valueOf(b.x).selfSubtract(a.x).selfMultiply(DD.valueOf(c.y).selfSubtract(a.y));
	var t2 = DD.valueOf(b.y).selfSubtract(a.y).selfMultiply(DD.valueOf(c.x).selfSubtract(a.x));
	return t1.selfSubtract(t2);
};

function Vertex() {
	this._p = null;
	if (arguments.length === 1) {
		var _p = arguments[0];
		this._p = new Coordinate(_p);
	} else if (arguments.length === 2) {
		var _x = arguments[0],
		    _y = arguments[1];
		this._p = new Coordinate(_x, _y);
	} else if (arguments.length === 3) {
		var _x2 = arguments[0],
		    _y2 = arguments[1],
		    _z = arguments[2];
		this._p = new Coordinate(_x2, _y2, _z);
	}
}
extend(Vertex.prototype, {
	circleCenter: function circleCenter(b, c) {
		var a = new Vertex(this.getX(), this.getY());
		var cab = this.bisector(a, b);
		var cbc = this.bisector(b, c);
		var hcc = new HCoordinate(cab, cbc);
		var cc = null;
		try {
			cc = new Vertex(hcc.getX(), hcc.getY());
		} catch (nre) {
			if (nre instanceof NotRepresentableException) {
				System.err.println("a: " + a + "  b: " + b + "  c: " + c);
				System.err.println(nre);
			} else throw nre;
		} finally {}
		return cc;
	},
	dot: function dot(v) {
		return this._p.x * v.getX() + this._p.y * v.getY();
	},
	magn: function magn() {
		return Math.sqrt(this._p.x * this._p.x + this._p.y * this._p.y);
	},
	getZ: function getZ() {
		return this._p.z;
	},
	bisector: function bisector(a, b) {
		var dx = b.getX() - a.getX();
		var dy = b.getY() - a.getY();
		var l1 = new HCoordinate(a.getX() + dx / 2.0, a.getY() + dy / 2.0, 1.0);
		var l2 = new HCoordinate(a.getX() - dy + dx / 2.0, a.getY() + dx + dy / 2.0, 1.0);
		return new HCoordinate(l1, l2);
	},
	equals: function equals() {
		if (arguments.length === 1) {
			var _x = arguments[0];
			if (this._p.x === _x.getX() && this._p.y === _x.getY()) {
				return true;
			} else {
				return false;
			}
		} else if (arguments.length === 2) {
			var _x3 = arguments[0],
			    tolerance = arguments[1];
			if (this._p.distance(_x3.getCoordinate()) < tolerance) {
				return true;
			} else {
				return false;
			}
		}
	},
	getCoordinate: function getCoordinate() {
		return this._p;
	},
	isInCircle: function isInCircle(a, b, c) {
		return TrianglePredicate.isInCircleRobust(a._p, b._p, c._p, this._p);
	},
	interpolateZValue: function interpolateZValue(v0, v1, v2) {
		var x0 = v0.getX();
		var y0 = v0.getY();
		var a = v1.getX() - x0;
		var b = v2.getX() - x0;
		var c = v1.getY() - y0;
		var d = v2.getY() - y0;
		var det = a * d - b * c;
		var dx = this.getX() - x0;
		var dy = this.getY() - y0;
		var t = (d * dx - b * dy) / det;
		var u = (-c * dx + a * dy) / det;
		var z = v0.getZ() + t * (v1.getZ() - v0.getZ()) + u * (v2.getZ() - v0.getZ());
		return z;
	},
	midPoint: function midPoint(a) {
		var xm = (this._p.x + a.getX()) / 2.0;
		var ym = (this._p.y + a.getY()) / 2.0;
		var zm = (this._p.z + a.getZ()) / 2.0;
		return new Vertex(xm, ym, zm);
	},
	rightOf: function rightOf(e) {
		return this.isCCW(e.dest(), e.orig());
	},
	isCCW: function isCCW(b, c) {
		return (b._p.x - this._p.x) * (c._p.y - this._p.y) - (b._p.y - this._p.y) * (c._p.x - this._p.x) > 0;
	},
	getX: function getX() {
		return this._p.x;
	},
	crossProduct: function crossProduct(v) {
		return this._p.x * v.getY() - this._p.y * v.getX();
	},
	setZ: function setZ(_z) {
		this._p.z = _z;
	},
	times: function times(c) {
		return new Vertex(c * this._p.x, c * this._p.y);
	},
	cross: function cross() {
		return new Vertex(this._p.y, -this._p.x);
	},
	leftOf: function leftOf(e) {
		return this.isCCW(e.orig(), e.dest());
	},
	toString: function toString() {
		return "POINT (" + this._p.x + " " + this._p.y + ")";
	},
	sub: function sub(v) {
		return new Vertex(this._p.x - v.getX(), this._p.y - v.getY());
	},
	getY: function getY() {
		return this._p.y;
	},
	classify: function classify(p0, p1) {
		var p2 = this;
		var a = p1.sub(p0);
		var b = p2.sub(p0);
		var sa = a.crossProduct(b);
		if (sa > 0.0) return Vertex.LEFT;
		if (sa < 0.0) return Vertex.RIGHT;
		if (a.getX() * b.getX() < 0.0 || a.getY() * b.getY() < 0.0) return Vertex.BEHIND;
		if (a.magn() < b.magn()) return Vertex.BEYOND;
		if (p0.equals(p2)) return Vertex.ORIGIN;
		if (p1.equals(p2)) return Vertex.DESTINATION;
		return Vertex.BETWEEN;
	},
	sum: function sum(v) {
		return new Vertex(this._p.x + v.getX(), this._p.y + v.getY());
	},
	distance: function distance(v1, v2) {
		return Math.sqrt(Math.pow(v2.getX() - v1.getX(), 2.0) + Math.pow(v2.getY() - v1.getY(), 2.0));
	},
	circumRadiusRatio: function circumRadiusRatio(b, c) {
		var x = this.circleCenter(b, c);
		var radius = this.distance(x, b);
		var edgeLength = this.distance(this, b);
		var el = this.distance(b, c);
		if (el < edgeLength) {
			edgeLength = el;
		}
		el = this.distance(c, this);
		if (el < edgeLength) {
			edgeLength = el;
		}
		return radius / edgeLength;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Vertex;
	}
});
Vertex.interpolateZ = function () {
	if (arguments.length === 3) {
		var p = arguments[0],
		    p0 = arguments[1],
		    p1 = arguments[2];
		var segLen = p0.distance(p1);
		var ptLen = p.distance(p0);
		var dz = p1.z - p0.z;
		var pz = p0.z + dz * (ptLen / segLen);
		return pz;
	} else if (arguments.length === 4) {
		var _p2 = arguments[0],
		    v0 = arguments[1],
		    v1 = arguments[2],
		    v2 = arguments[3];
		var x0 = v0.x;
		var y0 = v0.y;
		var a = v1.x - x0;
		var b = v2.x - x0;
		var c = v1.y - y0;
		var d = v2.y - y0;
		var det = a * d - b * c;
		var dx = _p2.x - x0;
		var dy = _p2.y - y0;
		var t = (d * dx - b * dy) / det;
		var u = (-c * dx + a * dy) / det;
		var z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);
		return z;
	}
};
Vertex.LEFT = 0;
Vertex.RIGHT = 1;
Vertex.BEYOND = 2;
Vertex.BEHIND = 3;
Vertex.BETWEEN = 4;
Vertex.ORIGIN = 5;
Vertex.DESTINATION = 6;

function ConstraintVertex() {
	this._isOnConstraint = null;
	this._constraint = null;
	var p = arguments[0];
	Vertex.call(this, p);
}
inherits(ConstraintVertex, Vertex);
extend(ConstraintVertex.prototype, {
	getConstraint: function getConstraint() {
		return this._constraint;
	},
	setOnConstraint: function setOnConstraint(isOnConstraint) {
		this._isOnConstraint = isOnConstraint;
	},
	merge: function merge(other) {
		if (other._isOnConstraint) {
			this._isOnConstraint = true;
			this._constraint = other._constraint;
		}
	},
	isOnConstraint: function isOnConstraint() {
		return this._isOnConstraint;
	},
	setConstraint: function setConstraint(constraint) {
		this._isOnConstraint = true;
		this._constraint = constraint;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return ConstraintVertex;
	}
});

function QuadEdge() {
	this._rot = null;
	this._vertex = null;
	this._next = null;
	this._data = null;
}
extend(QuadEdge.prototype, {
	equalsNonOriented: function equalsNonOriented(qe) {
		if (this.equalsOriented(qe)) return true;
		if (this.equalsOriented(qe.sym())) return true;
		return false;
	},
	toLineSegment: function toLineSegment() {
		return new LineSegment(this._vertex.getCoordinate(), this.dest().getCoordinate());
	},
	dest: function dest() {
		return this.sym().orig();
	},
	oNext: function oNext() {
		return this._next;
	},
	equalsOriented: function equalsOriented(qe) {
		if (this.orig().getCoordinate().equals2D(qe.orig().getCoordinate()) && this.dest().getCoordinate().equals2D(qe.dest().getCoordinate())) return true;
		return false;
	},
	dNext: function dNext() {
		return this.sym().oNext().sym();
	},
	lPrev: function lPrev() {
		return this._next.sym();
	},
	rPrev: function rPrev() {
		return this.sym().oNext();
	},
	rot: function rot() {
		return this._rot;
	},
	oPrev: function oPrev() {
		return this._rot._next._rot;
	},
	sym: function sym() {
		return this._rot._rot;
	},
	setOrig: function setOrig(o) {
		this._vertex = o;
	},
	lNext: function lNext() {
		return this.invRot().oNext().rot();
	},
	getLength: function getLength() {
		return this.orig().getCoordinate().distance(this.dest().getCoordinate());
	},
	invRot: function invRot() {
		return this._rot.sym();
	},
	setDest: function setDest(d) {
		this.sym().setOrig(d);
	},
	setData: function setData(data) {
		this._data = data;
	},
	getData: function getData() {
		return this._data;
	},
	delete: function _delete() {
		this._rot = null;
	},
	orig: function orig() {
		return this._vertex;
	},
	rNext: function rNext() {
		return this._rot._next.invRot();
	},
	toString: function toString() {
		var p0 = this._vertex.getCoordinate();
		var p1 = this.dest().getCoordinate();
		return WKTWriter.toLineString(p0, p1);
	},
	isLive: function isLive() {
		return this._rot !== null;
	},
	getPrimary: function getPrimary() {
		if (this.orig().getCoordinate().compareTo(this.dest().getCoordinate()) <= 0) return this;else return this.sym();
	},
	dPrev: function dPrev() {
		return this.invRot().oNext().invRot();
	},
	setNext: function setNext(next) {
		this._next = next;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return QuadEdge;
	}
});
QuadEdge.makeEdge = function (o, d) {
	var q0 = new QuadEdge();
	var q1 = new QuadEdge();
	var q2 = new QuadEdge();
	var q3 = new QuadEdge();
	q0._rot = q1;
	q1._rot = q2;
	q2._rot = q3;
	q3._rot = q0;
	q0.setNext(q0);
	q1.setNext(q3);
	q2.setNext(q2);
	q3.setNext(q1);
	var base = q0;
	base.setOrig(o);
	base.setDest(d);
	return base;
};
QuadEdge.swap = function (e) {
	var a = e.oPrev();
	var b = e.sym().oPrev();
	QuadEdge.splice(e, a);
	QuadEdge.splice(e.sym(), b);
	QuadEdge.splice(e, a.lNext());
	QuadEdge.splice(e.sym(), b.lNext());
	e.setOrig(a.dest());
	e.setDest(b.dest());
};
QuadEdge.splice = function (a, b) {
	var alpha = a.oNext().rot();
	var beta = b.oNext().rot();
	var t1 = b.oNext();
	var t2 = a.oNext();
	var t3 = beta.oNext();
	var t4 = alpha.oNext();
	a.setNext(t1);
	b.setNext(t2);
	alpha.setNext(t3);
	beta.setNext(t4);
};
QuadEdge.connect = function (a, b) {
	var e = QuadEdge.makeEdge(a.dest(), b.orig());
	QuadEdge.splice(e, a.lNext());
	QuadEdge.splice(e.sym(), b);
	return e;
};

function IncrementalDelaunayTriangulator() {
	this._subdiv = null;
	this._isUsingTolerance = false;
	var subdiv = arguments[0];
	this._subdiv = subdiv;
	this._isUsingTolerance = subdiv.getTolerance() > 0.0;
}
extend(IncrementalDelaunayTriangulator.prototype, {
	insertSite: function insertSite(v) {
		var e = this._subdiv.locate(v);
		if (this._subdiv.isVertexOfEdge(e, v)) {
			return e;
		} else if (this._subdiv.isOnEdge(e, v.getCoordinate())) {
			e = e.oPrev();
			this._subdiv.delete(e.oNext());
		}
		var base = this._subdiv.makeEdge(e.orig(), v);
		QuadEdge.splice(base, e);
		var startEdge = base;
		do {
			base = this._subdiv.connect(e, base.sym());
			e = base.oPrev();
		} while (e.lNext() !== startEdge);
		do {
			var t = e.oPrev();
			if (t.dest().rightOf(e) && v.isInCircle(e.orig(), t.dest(), e.dest())) {
				QuadEdge.swap(e);
				e = e.oPrev();
			} else if (e.oNext() === startEdge) {
				return base;
			} else {
				e = e.oNext().lPrev();
			}
		} while (true);
	},
	insertSites: function insertSites(vertices) {
		for (var i = vertices.iterator(); i.hasNext();) {
			var v = i.next();
			this.insertSite(v);
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return IncrementalDelaunayTriangulator;
	}
});

function QuadEdgeLocator() {}
extend(QuadEdgeLocator.prototype, {
	locate: function locate(v) {},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return QuadEdgeLocator;
	}
});

function LastFoundQuadEdgeLocator() {
	this._subdiv = null;
	this._lastEdge = null;
	var subdiv = arguments[0];
	this._subdiv = subdiv;
	this.init();
}
extend(LastFoundQuadEdgeLocator.prototype, {
	init: function init() {
		this._lastEdge = this.findEdge();
	},
	locate: function locate(v) {
		if (!this._lastEdge.isLive()) {
			this.init();
		}
		var e = this._subdiv.locateFromEdge(v, this._lastEdge);
		this._lastEdge = e;
		return e;
	},
	findEdge: function findEdge() {
		var edges = this._subdiv.getEdges();
		return edges.iterator().next();
	},
	interfaces_: function interfaces_() {
		return [QuadEdgeLocator];
	},
	getClass: function getClass() {
		return LastFoundQuadEdgeLocator;
	}
});

function LocateFailureException() {
	this._seg = null;
	if (arguments.length === 1) {
		if (typeof arguments[0] === "string") {
			var msg = arguments[0];
			RuntimeException.call(this, msg);
		} else if (arguments[0] instanceof LineSegment) {
			var seg = arguments[0];
			RuntimeException.call(this, "Locate failed to converge (at edge: " + seg + ").  Possible causes include invalid Subdivision topology or very close sites");
			this._seg = new LineSegment(seg);
		}
	} else if (arguments.length === 2) {
		var _msg = arguments[0],
		    _seg = arguments[1];
		RuntimeException.call(this, LocateFailureException.msgWithSpatial(_msg, _seg));
		this._seg = new LineSegment(_seg);
	}
}
inherits(LocateFailureException, RuntimeException);
extend(LocateFailureException.prototype, {
	getSegment: function getSegment() {
		return this._seg;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LocateFailureException;
	}
});
LocateFailureException.msgWithSpatial = function (msg, seg) {
	if (seg !== null) return msg + " [ " + seg + " ]";
	return msg;
};

function TriangleVisitor() {}
extend(TriangleVisitor.prototype, {
	visit: function visit(triEdges) {},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return TriangleVisitor;
	}
});

function QuadEdgeSubdivision() {
	this._visitedKey = 0;
	this._quadEdges = new ArrayList();
	this._startingEdge = null;
	this._tolerance = null;
	this._edgeCoincidenceTolerance = null;
	this._frameVertex = new Array(3).fill(null);
	this._frameEnv = null;
	this._locator = null;
	this._seg = new LineSegment();
	this._triEdges = new Array(3).fill(null);
	var env = arguments[0],
	    tolerance = arguments[1];
	this._tolerance = tolerance;
	this._edgeCoincidenceTolerance = tolerance / QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR;
	this.createFrame(env);
	this._startingEdge = this.initSubdiv();
	this._locator = new LastFoundQuadEdgeLocator(this);
}
extend(QuadEdgeSubdivision.prototype, {
	getTriangleVertices: function getTriangleVertices(includeFrame) {
		var visitor = new TriangleVertexListVisitor();
		this.visitTriangles(visitor, includeFrame);
		return visitor.getTriangleVertices();
	},
	isFrameVertex: function isFrameVertex(v) {
		if (v.equals(this._frameVertex[0])) return true;
		if (v.equals(this._frameVertex[1])) return true;
		if (v.equals(this._frameVertex[2])) return true;
		return false;
	},
	isVertexOfEdge: function isVertexOfEdge(e, v) {
		if (v.equals(e.orig(), this._tolerance) || v.equals(e.dest(), this._tolerance)) {
			return true;
		}
		return false;
	},
	connect: function connect(a, b) {
		var q = QuadEdge.connect(a, b);
		this._quadEdges.add(q);
		return q;
	},
	getVoronoiCellPolygon: function getVoronoiCellPolygon(qe, geomFact) {
		var cellPts = new ArrayList();
		var startQE = qe;
		do {
			var cc = qe.rot().orig().getCoordinate();
			cellPts.add(cc);
			qe = qe.oPrev();
		} while (qe !== startQE);
		var coordList = new CoordinateList();
		coordList.addAll(cellPts, false);
		coordList.closeRing();
		if (coordList.size() < 4) {
			System.out.println(coordList);
			coordList.add(coordList.get(coordList.size() - 1), true);
		}
		var pts = coordList.toCoordinateArray();
		var cellPoly = geomFact.createPolygon(geomFact.createLinearRing(pts));
		var v = startQE.orig();
		cellPoly.setUserData(v.getCoordinate());
		return cellPoly;
	},
	setLocator: function setLocator(locator) {
		this._locator = locator;
	},
	initSubdiv: function initSubdiv() {
		var ea = this.makeEdge(this._frameVertex[0], this._frameVertex[1]);
		var eb = this.makeEdge(this._frameVertex[1], this._frameVertex[2]);
		QuadEdge.splice(ea.sym(), eb);
		var ec = this.makeEdge(this._frameVertex[2], this._frameVertex[0]);
		QuadEdge.splice(eb.sym(), ec);
		QuadEdge.splice(ec.sym(), ea);
		return ea;
	},
	isFrameBorderEdge: function isFrameBorderEdge(e) {
		var leftTri = new Array(3).fill(null);
		QuadEdgeSubdivision.getTriangleEdges(e, leftTri);
		var rightTri = new Array(3).fill(null);
		QuadEdgeSubdivision.getTriangleEdges(e.sym(), rightTri);
		var vLeftTriOther = e.lNext().dest();
		if (this.isFrameVertex(vLeftTriOther)) return true;
		var vRightTriOther = e.sym().lNext().dest();
		if (this.isFrameVertex(vRightTriOther)) return true;
		return false;
	},
	makeEdge: function makeEdge(o, d) {
		var q = QuadEdge.makeEdge(o, d);
		this._quadEdges.add(q);
		return q;
	},
	visitTriangles: function visitTriangles(triVisitor, includeFrame) {
		this._visitedKey++;
		var edgeStack = new Stack();
		edgeStack.push(this._startingEdge);
		var visitedEdges = new HashSet();
		while (!edgeStack.empty()) {
			var edge = edgeStack.pop();
			if (!visitedEdges.contains(edge)) {
				var triEdges = this.fetchTriangleToVisit(edge, edgeStack, includeFrame, visitedEdges);
				if (triEdges !== null) triVisitor.visit(triEdges);
			}
		}
	},
	isFrameEdge: function isFrameEdge(e) {
		if (this.isFrameVertex(e.orig()) || this.isFrameVertex(e.dest())) return true;
		return false;
	},
	isOnEdge: function isOnEdge(e, p) {
		this._seg.setCoordinates(e.orig().getCoordinate(), e.dest().getCoordinate());
		var dist = this._seg.distance(p);
		return dist < this._edgeCoincidenceTolerance;
	},
	getEnvelope: function getEnvelope() {
		return new Envelope(this._frameEnv);
	},
	createFrame: function createFrame(env) {
		var deltaX = env.getWidth();
		var deltaY = env.getHeight();
		var offset = 0.0;
		if (deltaX > deltaY) {
			offset = deltaX * 10.0;
		} else {
			offset = deltaY * 10.0;
		}
		this._frameVertex[0] = new Vertex((env.getMaxX() + env.getMinX()) / 2.0, env.getMaxY() + offset);
		this._frameVertex[1] = new Vertex(env.getMinX() - offset, env.getMinY() - offset);
		this._frameVertex[2] = new Vertex(env.getMaxX() + offset, env.getMinY() - offset);
		this._frameEnv = new Envelope(this._frameVertex[0].getCoordinate(), this._frameVertex[1].getCoordinate());
		this._frameEnv.expandToInclude(this._frameVertex[2].getCoordinate());
	},
	getTriangleCoordinates: function getTriangleCoordinates(includeFrame) {
		var visitor = new TriangleCoordinatesVisitor();
		this.visitTriangles(visitor, includeFrame);
		return visitor.getTriangles();
	},
	getVertices: function getVertices(includeFrame) {
		var vertices = new HashSet();
		for (var i = this._quadEdges.iterator(); i.hasNext();) {
			var qe = i.next();
			var v = qe.orig();
			if (includeFrame || !this.isFrameVertex(v)) vertices.add(v);
			var vd = qe.dest();
			if (includeFrame || !this.isFrameVertex(vd)) vertices.add(vd);
		}
		return vertices;
	},
	fetchTriangleToVisit: function fetchTriangleToVisit(edge, edgeStack, includeFrame, visitedEdges) {
		var curr = edge;
		var edgeCount = 0;
		var isFrame = false;
		do {
			this._triEdges[edgeCount] = curr;
			if (this.isFrameEdge(curr)) isFrame = true;
			var sym = curr.sym();
			if (!visitedEdges.contains(sym)) edgeStack.push(sym);
			visitedEdges.add(curr);
			edgeCount++;
			curr = curr.lNext();
		} while (curr !== edge);
		if (isFrame && !includeFrame) return null;
		return this._triEdges;
	},
	getEdges: function getEdges() {
		if (arguments.length === 0) {
			return this._quadEdges;
		} else if (arguments.length === 1) {
			var geomFact = arguments[0];
			var quadEdges = this.getPrimaryEdges(false);
			var edges = new Array(quadEdges.size()).fill(null);
			var i = 0;
			for (var it = quadEdges.iterator(); it.hasNext();) {
				var qe = it.next();
				edges[i++] = geomFact.createLineString([qe.orig().getCoordinate(), qe.dest().getCoordinate()]);
			}
			return geomFact.createMultiLineString(edges);
		}
	},
	getVertexUniqueEdges: function getVertexUniqueEdges(includeFrame) {
		var edges = new ArrayList();
		var visitedVertices = new HashSet();
		for (var i = this._quadEdges.iterator(); i.hasNext();) {
			var qe = i.next();
			var v = qe.orig();
			if (!visitedVertices.contains(v)) {
				visitedVertices.add(v);
				if (includeFrame || !this.isFrameVertex(v)) {
					edges.add(qe);
				}
			}
			var qd = qe.sym();
			var vd = qd.orig();
			if (!visitedVertices.contains(vd)) {
				visitedVertices.add(vd);
				if (includeFrame || !this.isFrameVertex(vd)) {
					edges.add(qd);
				}
			}
		}
		return edges;
	},
	getTriangleEdges: function getTriangleEdges(includeFrame) {
		var visitor = new TriangleEdgesListVisitor();
		this.visitTriangles(visitor, includeFrame);
		return visitor.getTriangleEdges();
	},
	getPrimaryEdges: function getPrimaryEdges(includeFrame) {
		this._visitedKey++;
		var edges = new ArrayList();
		var edgeStack = new Stack();
		edgeStack.push(this._startingEdge);
		var visitedEdges = new HashSet();
		while (!edgeStack.empty()) {
			var edge = edgeStack.pop();
			if (!visitedEdges.contains(edge)) {
				var priQE = edge.getPrimary();
				if (includeFrame || !this.isFrameEdge(priQE)) edges.add(priQE);
				edgeStack.push(edge.oNext());
				edgeStack.push(edge.sym().oNext());
				visitedEdges.add(edge);
				visitedEdges.add(edge.sym());
			}
		}
		return edges;
	},
	delete: function _delete(e) {
		QuadEdge.splice(e, e.oPrev());
		QuadEdge.splice(e.sym(), e.sym().oPrev());
		var eSym = e.sym();
		var eRot = e.rot();
		var eRotSym = e.rot().sym();
		this._quadEdges.remove(e);
		this._quadEdges.remove(eSym);
		this._quadEdges.remove(eRot);
		this._quadEdges.remove(eRotSym);
		e.delete();
		eSym.delete();
		eRot.delete();
		eRotSym.delete();
	},
	locateFromEdge: function locateFromEdge(v, startEdge) {
		var iter = 0;
		var maxIter = this._quadEdges.size();
		var e = startEdge;
		while (true) {
			iter++;
			if (iter > maxIter) {
				throw new LocateFailureException(e.toLineSegment());
			}
			if (v.equals(e.orig()) || v.equals(e.dest())) {
				break;
			} else if (v.rightOf(e)) {
				e = e.sym();
			} else if (!v.rightOf(e.oNext())) {
				e = e.oNext();
			} else if (!v.rightOf(e.dPrev())) {
				e = e.dPrev();
			} else {
				break;
			}
		}
		return e;
	},
	getTolerance: function getTolerance() {
		return this._tolerance;
	},
	getVoronoiCellPolygons: function getVoronoiCellPolygons(geomFact) {
		this.visitTriangles(new TriangleCircumcentreVisitor(), true);
		var cells = new ArrayList();
		var edges = this.getVertexUniqueEdges(false);
		for (var i = edges.iterator(); i.hasNext();) {
			var qe = i.next();
			cells.add(this.getVoronoiCellPolygon(qe, geomFact));
		}
		return cells;
	},
	getVoronoiDiagram: function getVoronoiDiagram(geomFact) {
		var vorCells = this.getVoronoiCellPolygons(geomFact);
		return geomFact.createGeometryCollection(GeometryFactory.toGeometryArray(vorCells));
	},
	getTriangles: function getTriangles(geomFact) {
		var triPtsList = this.getTriangleCoordinates(false);
		var tris = new Array(triPtsList.size()).fill(null);
		var i = 0;
		for (var it = triPtsList.iterator(); it.hasNext();) {
			var triPt = it.next();
			tris[i++] = geomFact.createPolygon(geomFact.createLinearRing(triPt));
		}
		return geomFact.createGeometryCollection(tris);
	},
	insertSite: function insertSite(v) {
		var e = this.locate(v);
		if (v.equals(e.orig(), this._tolerance) || v.equals(e.dest(), this._tolerance)) {
			return e;
		}
		var base = this.makeEdge(e.orig(), v);
		QuadEdge.splice(base, e);
		var startEdge = base;
		do {
			base = this.connect(e, base.sym());
			e = base.oPrev();
		} while (e.lNext() !== startEdge);
		return startEdge;
	},
	locate: function locate() {
		if (arguments.length === 1) {
			if (arguments[0] instanceof Vertex) {
				var v = arguments[0];
				return this._locator.locate(v);
			} else if (arguments[0] instanceof Coordinate) {
				var p = arguments[0];
				return this._locator.locate(new Vertex(p));
			}
		} else if (arguments.length === 2) {
			var p0 = arguments[0],
			    p1 = arguments[1];
			var e = this._locator.locate(new Vertex(p0));
			if (e === null) return null;
			var base = e;
			if (e.dest().getCoordinate().equals2D(p0)) base = e.sym();
			var locEdge = base;
			do {
				if (locEdge.dest().getCoordinate().equals2D(p1)) return locEdge;
				locEdge = locEdge.oNext();
			} while (locEdge !== base);
			return null;
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return QuadEdgeSubdivision;
	}
});
QuadEdgeSubdivision.getTriangleEdges = function (startQE, triEdge) {
	triEdge[0] = startQE;
	triEdge[1] = triEdge[0].lNext();
	triEdge[2] = triEdge[1].lNext();
	if (triEdge[2].lNext() !== triEdge[0]) throw new IllegalArgumentException("Edges do not form a triangle");
};
function TriangleCircumcentreVisitor() {}
extend(TriangleCircumcentreVisitor.prototype, {
	visit: function visit(triEdges) {
		var a = triEdges[0].orig().getCoordinate();
		var b = triEdges[1].orig().getCoordinate();
		var c = triEdges[2].orig().getCoordinate();
		var cc = Triangle.circumcentre(a, b, c);
		var ccVertex = new Vertex(cc);
		for (var i = 0; i < 3; i++) {
			triEdges[i].rot().setOrig(ccVertex);
		}
	},
	interfaces_: function interfaces_() {
		return [TriangleVisitor];
	},
	getClass: function getClass() {
		return TriangleCircumcentreVisitor;
	}
});
function TriangleEdgesListVisitor() {
	this._triList = new ArrayList();
}
extend(TriangleEdgesListVisitor.prototype, {
	getTriangleEdges: function getTriangleEdges() {
		return this._triList;
	},
	visit: function visit(triEdges) {
		this._triList.add(triEdges);
	},
	interfaces_: function interfaces_() {
		return [TriangleVisitor];
	},
	getClass: function getClass() {
		return TriangleEdgesListVisitor;
	}
});
function TriangleVertexListVisitor() {
	this._triList = new ArrayList();
}
extend(TriangleVertexListVisitor.prototype, {
	visit: function visit(triEdges) {
		this._triList.add([triEdges[0].orig(), triEdges[1].orig(), triEdges[2].orig()]);
	},
	getTriangleVertices: function getTriangleVertices() {
		return this._triList;
	},
	interfaces_: function interfaces_() {
		return [TriangleVisitor];
	},
	getClass: function getClass() {
		return TriangleVertexListVisitor;
	}
});
function TriangleCoordinatesVisitor() {
	this._coordList = new CoordinateList();
	this._triCoords = new ArrayList();
}
extend(TriangleCoordinatesVisitor.prototype, {
	checkTriangleSize: function checkTriangleSize(pts) {
		var loc = "";
		if (pts.length >= 2) loc = WKTWriter.toLineString(pts[0], pts[1]);else {
			if (pts.length >= 1) loc = WKTWriter.toPoint(pts[0]);
		}
	},
	visit: function visit(triEdges) {
		this._coordList.clear();
		for (var i = 0; i < 3; i++) {
			var v = triEdges[i].orig();
			this._coordList.add(v.getCoordinate());
		}
		if (this._coordList.size() > 0) {
			this._coordList.closeRing();
			var pts = this._coordList.toCoordinateArray();
			if (pts.length !== 4) {
				return null;
			}
			this._triCoords.add(pts);
		}
	},
	getTriangles: function getTriangles() {
		return this._triCoords;
	},
	interfaces_: function interfaces_() {
		return [TriangleVisitor];
	},
	getClass: function getClass() {
		return TriangleCoordinatesVisitor;
	}
});
QuadEdgeSubdivision.TriangleCircumcentreVisitor = TriangleCircumcentreVisitor;
QuadEdgeSubdivision.TriangleEdgesListVisitor = TriangleEdgesListVisitor;
QuadEdgeSubdivision.TriangleVertexListVisitor = TriangleVertexListVisitor;
QuadEdgeSubdivision.TriangleCoordinatesVisitor = TriangleCoordinatesVisitor;
QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR = 1000;

function Segment() {
	this._ls = null;
	this._data = null;
	if (arguments.length === 2) {
		var p0 = arguments[0],
		    p1 = arguments[1];
		this._ls = new LineSegment(p0, p1);
	} else if (arguments.length === 3) {
		var _p = arguments[0],
		    _p2 = arguments[1],
		    data = arguments[2];
		this._ls = new LineSegment(_p, _p2);
		this._data = data;
	} else if (arguments.length === 6) {
		var x1 = arguments[0],
		    y1 = arguments[1],
		    z1 = arguments[2],
		    x2 = arguments[3],
		    y2 = arguments[4],
		    z2 = arguments[5];
		Segment.call(this, new Coordinate(x1, y1, z1), new Coordinate(x2, y2, z2));
	} else if (arguments.length === 7) {
		var _x = arguments[0],
		    _y = arguments[1],
		    _z = arguments[2],
		    _x2 = arguments[3],
		    _y2 = arguments[4],
		    _z2 = arguments[5],
		    _data = arguments[6];
		Segment.call(this, new Coordinate(_x, _y, _z), new Coordinate(_x2, _y2, _z2), _data);
	}
}
extend(Segment.prototype, {
	getLineSegment: function getLineSegment() {
		return this._ls;
	},
	getEndZ: function getEndZ() {
		var p = this._ls.getCoordinate(1);
		return p.z;
	},
	getStartZ: function getStartZ() {
		var p = this._ls.getCoordinate(0);
		return p.z;
	},
	intersection: function intersection(s) {
		return this._ls.intersection(s.getLineSegment());
	},
	getStart: function getStart() {
		return this._ls.getCoordinate(0);
	},
	getEnd: function getEnd() {
		return this._ls.getCoordinate(1);
	},
	getEndY: function getEndY() {
		var p = this._ls.getCoordinate(1);
		return p.y;
	},
	getStartX: function getStartX() {
		var p = this._ls.getCoordinate(0);
		return p.x;
	},
	equalsTopo: function equalsTopo(s) {
		return this._ls.equalsTopo(s.getLineSegment());
	},
	getStartY: function getStartY() {
		var p = this._ls.getCoordinate(0);
		return p.y;
	},
	setData: function setData(data) {
		this._data = data;
	},
	getData: function getData() {
		return this._data;
	},
	getEndX: function getEndX() {
		var p = this._ls.getCoordinate(1);
		return p.x;
	},
	toString: function toString() {
		return this._ls.toString();
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return Segment;
	}
});

function ConformingDelaunayTriangulator() {
	this._initialVertices = null;
	this._segVertices = null;
	this._segments = new ArrayList();
	this._subdiv = null;
	this._incDel = null;
	this._convexHull = null;
	this._splitFinder = new NonEncroachingSplitPointFinder();
	this._kdt = null;
	this._vertexFactory = null;
	this._computeAreaEnv = null;
	this._splitPt = null;
	this._tolerance = null;
	var initialVertices = arguments[0],
	    tolerance = arguments[1];
	this._initialVertices = new ArrayList(initialVertices);
	this._tolerance = tolerance;
	this._kdt = new KdTree(tolerance);
}
extend(ConformingDelaunayTriangulator.prototype, {
	getInitialVertices: function getInitialVertices() {
		return this._initialVertices;
	},
	getKDT: function getKDT() {
		return this._kdt;
	},
	enforceConstraints: function enforceConstraints() {
		this.addConstraintVertices();
		var count = 0;
		var splits = 0;
		do {
			splits = this.enforceGabriel(this._segments);
			count++;
		} while (splits > 0 && count < ConformingDelaunayTriangulator.MAX_SPLIT_ITER);
	},
	insertSites: function insertSites(vertices) {
		for (var i = vertices.iterator(); i.hasNext();) {
			var v = i.next();
			this.insertSite(v);
		}
	},
	getVertexFactory: function getVertexFactory() {
		return this._vertexFactory;
	},
	getPointArray: function getPointArray() {
		var pts = new Array(this._initialVertices.size() + this._segVertices.size()).fill(null);
		var index = 0;
		for (var i = this._initialVertices.iterator(); i.hasNext();) {
			var v = i.next();
			pts[index++] = v.getCoordinate();
		}
		for (var i2 = this._segVertices.iterator(); i2.hasNext();) {
			var v = i2.next();
			pts[index++] = v.getCoordinate();
		}
		return pts;
	},
	setConstraints: function setConstraints(segments, segVertices) {
		this._segments = segments;
		this._segVertices = segVertices;
	},
	computeConvexHull: function computeConvexHull() {
		var fact = new GeometryFactory();
		var coords = this.getPointArray();
		var hull = new ConvexHull(coords, fact);
		this._convexHull = hull.getConvexHull();
	},
	addConstraintVertices: function addConstraintVertices() {
		this.computeConvexHull();
		this.insertSites(this._segVertices);
	},
	findNonGabrielPoint: function findNonGabrielPoint(seg) {
		var p = seg.getStart();
		var q = seg.getEnd();
		var midPt = new Coordinate((p.x + q.x) / 2.0, (p.y + q.y) / 2.0);
		var segRadius = p.distance(midPt);
		var env = new Envelope(midPt);
		env.expandBy(segRadius);
		var result = this._kdt.query(env);
		var closestNonGabriel = null;
		var minDist = Double.MAX_VALUE;
		for (var i = result.iterator(); i.hasNext();) {
			var nextNode = i.next();
			var testPt = nextNode.getCoordinate();
			if (testPt.equals2D(p) || testPt.equals2D(q)) continue;
			var testRadius = midPt.distance(testPt);
			if (testRadius < segRadius) {
				var testDist = testRadius;
				if (closestNonGabriel === null || testDist < minDist) {
					closestNonGabriel = testPt;
					minDist = testDist;
				}
			}
		}
		return closestNonGabriel;
	},
	getConstraintSegments: function getConstraintSegments() {
		return this._segments;
	},
	setSplitPointFinder: function setSplitPointFinder(splitFinder) {
		this._splitFinder = splitFinder;
	},
	getConvexHull: function getConvexHull() {
		return this._convexHull;
	},
	getTolerance: function getTolerance() {
		return this._tolerance;
	},
	enforceGabriel: function enforceGabriel(segsToInsert) {
		var newSegments = new ArrayList();
		var splits = 0;
		var segsToRemove = new ArrayList();
		for (var i = segsToInsert.iterator(); i.hasNext();) {
			var seg = i.next();
			var encroachPt = this.findNonGabrielPoint(seg);
			if (encroachPt === null) continue;
			this._splitPt = this._splitFinder.findSplitPoint(seg, encroachPt);
			var splitVertex = this.createVertex(this._splitPt, seg);
			var insertedVertex = this.insertSite(splitVertex);
			if (!insertedVertex.getCoordinate().equals2D(this._splitPt)) {}
			var s1 = new Segment(seg.getStartX(), seg.getStartY(), seg.getStartZ(), splitVertex.getX(), splitVertex.getY(), splitVertex.getZ(), seg.getData());
			var s2 = new Segment(splitVertex.getX(), splitVertex.getY(), splitVertex.getZ(), seg.getEndX(), seg.getEndY(), seg.getEndZ(), seg.getData());
			newSegments.add(s1);
			newSegments.add(s2);
			segsToRemove.add(seg);
			splits = splits + 1;
		}
		segsToInsert.removeAll(segsToRemove);
		segsToInsert.addAll(newSegments);
		return splits;
	},
	createVertex: function createVertex() {
		if (arguments.length === 1) {
			var p = arguments[0];
			var v = null;
			if (this._vertexFactory !== null) v = this._vertexFactory.createVertex(p, null);else v = new ConstraintVertex(p);
			return v;
		} else if (arguments.length === 2) {
			var _p = arguments[0],
			    seg = arguments[1];
			var v = null;
			if (this._vertexFactory !== null) v = this._vertexFactory.createVertex(_p, seg);else v = new ConstraintVertex(_p);
			v.setOnConstraint(true);
			return v;
		}
	},
	getSubdivision: function getSubdivision() {
		return this._subdiv;
	},
	computeBoundingBox: function computeBoundingBox() {
		var vertexEnv = ConformingDelaunayTriangulator.computeVertexEnvelope(this._initialVertices);
		var segEnv = ConformingDelaunayTriangulator.computeVertexEnvelope(this._segVertices);
		var allPointsEnv = new Envelope(vertexEnv);
		allPointsEnv.expandToInclude(segEnv);
		var deltaX = allPointsEnv.getWidth() * 0.2;
		var deltaY = allPointsEnv.getHeight() * 0.2;
		var delta = Math.max(deltaX, deltaY);
		this._computeAreaEnv = new Envelope(allPointsEnv);
		this._computeAreaEnv.expandBy(delta);
	},
	setVertexFactory: function setVertexFactory(vertexFactory) {
		this._vertexFactory = vertexFactory;
	},
	formInitialDelaunay: function formInitialDelaunay() {
		this.computeBoundingBox();
		this._subdiv = new QuadEdgeSubdivision(this._computeAreaEnv, this._tolerance);
		this._subdiv.setLocator(new LastFoundQuadEdgeLocator(this._subdiv));
		this._incDel = new IncrementalDelaunayTriangulator(this._subdiv);
		this.insertSites(this._initialVertices);
	},
	insertSite: function insertSite() {
		if (arguments[0] instanceof ConstraintVertex) {
			var v = arguments[0];
			var kdnode = this._kdt.insert(v.getCoordinate(), v);
			if (!kdnode.isRepeated()) {
				this._incDel.insertSite(v);
			} else {
				var snappedV = kdnode.getData();
				snappedV.merge(v);
				return snappedV;
			}
			return v;
		} else if (arguments[0] instanceof Coordinate) {
			var p = arguments[0];
			this.insertSite(this.createVertex(p));
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return ConformingDelaunayTriangulator;
	}
});
ConformingDelaunayTriangulator.computeVertexEnvelope = function (vertices) {
	var env = new Envelope();
	for (var i = vertices.iterator(); i.hasNext();) {
		var v = i.next();
		env.expandToInclude(v.getCoordinate());
	}
	return env;
};
ConformingDelaunayTriangulator.MAX_SPLIT_ITER = 99;

function DelaunayTriangulationBuilder() {
	this._siteCoords = null;
	this._tolerance = 0.0;
	this._subdiv = null;
}
extend(DelaunayTriangulationBuilder.prototype, {
	create: function create() {
		if (this._subdiv !== null) return null;
		var siteEnv = DelaunayTriangulationBuilder.envelope(this._siteCoords);
		var vertices = DelaunayTriangulationBuilder.toVertices(this._siteCoords);
		this._subdiv = new QuadEdgeSubdivision(siteEnv, this._tolerance);
		var triangulator = new IncrementalDelaunayTriangulator(this._subdiv);
		triangulator.insertSites(vertices);
	},
	setTolerance: function setTolerance(tolerance) {
		this._tolerance = tolerance;
	},
	setSites: function setSites() {
		if (arguments[0] instanceof Geometry) {
			var geom = arguments[0];
			this._siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);
		} else if (hasInterface(arguments[0], Collection)) {
			var coords = arguments[0];
			this._siteCoords = DelaunayTriangulationBuilder.unique(CoordinateArrays.toCoordinateArray(coords));
		}
	},
	getEdges: function getEdges(geomFact) {
		this.create();
		return this._subdiv.getEdges(geomFact);
	},
	getSubdivision: function getSubdivision() {
		this.create();
		return this._subdiv;
	},
	getTriangles: function getTriangles(geomFact) {
		this.create();
		return this._subdiv.getTriangles(geomFact);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return DelaunayTriangulationBuilder;
	}
});
DelaunayTriangulationBuilder.extractUniqueCoordinates = function (geom) {
	if (geom === null) return new CoordinateList();
	var coords = geom.getCoordinates();
	return DelaunayTriangulationBuilder.unique(coords);
};
DelaunayTriangulationBuilder.envelope = function (coords) {
	var env = new Envelope();
	for (var i = coords.iterator(); i.hasNext();) {
		var coord = i.next();
		env.expandToInclude(coord);
	}
	return env;
};
DelaunayTriangulationBuilder.unique = function (coords) {
	var coordsCopy = CoordinateArrays.copyDeep(coords);
	Arrays.sort(coordsCopy);
	var coordList = new CoordinateList(coordsCopy, false);
	return coordList;
};
DelaunayTriangulationBuilder.toVertices = function (coords) {
	var verts = new ArrayList();
	for (var i = coords.iterator(); i.hasNext();) {
		var coord = i.next();
		verts.add(new Vertex(coord));
	}
	return verts;
};

function ConformingDelaunayTriangulationBuilder() {
	this._siteCoords = null;
	this._constraintLines = null;
	this._tolerance = 0.0;
	this._subdiv = null;
	this._constraintVertexMap = new TreeMap();
}
extend(ConformingDelaunayTriangulationBuilder.prototype, {
	createSiteVertices: function createSiteVertices(coords) {
		var verts = new ArrayList();
		for (var i = coords.iterator(); i.hasNext();) {
			var coord = i.next();
			if (this._constraintVertexMap.containsKey(coord)) continue;
			verts.add(new ConstraintVertex(coord));
		}
		return verts;
	},
	create: function create() {
		if (this._subdiv !== null) return null;
		var siteEnv = DelaunayTriangulationBuilder.envelope(this._siteCoords);
		var segments = new ArrayList();
		if (this._constraintLines !== null) {
			siteEnv.expandToInclude(this._constraintLines.getEnvelopeInternal());
			this.createVertices(this._constraintLines);
			segments = ConformingDelaunayTriangulationBuilder.createConstraintSegments(this._constraintLines);
		}
		var sites = this.createSiteVertices(this._siteCoords);
		var cdt = new ConformingDelaunayTriangulator(sites, this._tolerance);
		cdt.setConstraints(segments, new ArrayList(this._constraintVertexMap.values()));
		cdt.formInitialDelaunay();
		cdt.enforceConstraints();
		this._subdiv = cdt.getSubdivision();
	},
	setTolerance: function setTolerance(tolerance) {
		this._tolerance = tolerance;
	},
	setConstraints: function setConstraints(constraintLines) {
		this._constraintLines = constraintLines;
	},
	setSites: function setSites(geom) {
		this._siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);
	},
	getEdges: function getEdges(geomFact) {
		this.create();
		return this._subdiv.getEdges(geomFact);
	},
	getSubdivision: function getSubdivision() {
		this.create();
		return this._subdiv;
	},
	getTriangles: function getTriangles(geomFact) {
		this.create();
		return this._subdiv.getTriangles(geomFact);
	},
	createVertices: function createVertices(geom) {
		var coords = geom.getCoordinates();
		for (var i = 0; i < coords.length; i++) {
			var v = new ConstraintVertex(coords[i]);
			this._constraintVertexMap.put(coords[i], v);
		}
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return ConformingDelaunayTriangulationBuilder;
	}
});
ConformingDelaunayTriangulationBuilder.createConstraintSegments = function () {
	if (arguments.length === 1) {
		var geom = arguments[0];
		var lines = LinearComponentExtracter.getLines(geom);
		var constraintSegs = new ArrayList();
		for (var i = lines.iterator(); i.hasNext();) {
			var line = i.next();
			ConformingDelaunayTriangulationBuilder.createConstraintSegments(line, constraintSegs);
		}
		return constraintSegs;
	} else if (arguments.length === 2) {
		var _line = arguments[0],
		    _constraintSegs = arguments[1];
		var coords = _line.getCoordinates();
		for (var i = 1; i < coords.length; i++) {
			_constraintSegs.add(new Segment(coords[i - 1], coords[i]));
		}
	}
};

function VoronoiDiagramBuilder() {
	this._siteCoords = null;
	this._tolerance = 0.0;
	this._subdiv = null;
	this._clipEnv = null;
	this._diagramEnv = null;
}
extend(VoronoiDiagramBuilder.prototype, {
	create: function create() {
		if (this._subdiv !== null) return null;
		var siteEnv = DelaunayTriangulationBuilder.envelope(this._siteCoords);
		this._diagramEnv = siteEnv;
		var expandBy = Math.max(this._diagramEnv.getWidth(), this._diagramEnv.getHeight());
		this._diagramEnv.expandBy(expandBy);
		if (this._clipEnv !== null) this._diagramEnv.expandToInclude(this._clipEnv);
		var vertices = DelaunayTriangulationBuilder.toVertices(this._siteCoords);
		this._subdiv = new QuadEdgeSubdivision(siteEnv, this._tolerance);
		var triangulator = new IncrementalDelaunayTriangulator(this._subdiv);
		triangulator.insertSites(vertices);
	},
	getDiagram: function getDiagram(geomFact) {
		this.create();
		var polys = this._subdiv.getVoronoiDiagram(geomFact);
		return VoronoiDiagramBuilder.clipGeometryCollection(polys, this._diagramEnv);
	},
	setTolerance: function setTolerance(tolerance) {
		this._tolerance = tolerance;
	},
	setSites: function setSites() {
		if (arguments[0] instanceof Geometry) {
			var geom = arguments[0];
			this._siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);
		} else if (hasInterface(arguments[0], Collection)) {
			var coords = arguments[0];
			this._siteCoords = DelaunayTriangulationBuilder.unique(CoordinateArrays.toCoordinateArray(coords));
		}
	},
	setClipEnvelope: function setClipEnvelope(clipEnv) {
		this._clipEnv = clipEnv;
	},
	getSubdivision: function getSubdivision() {
		this.create();
		return this._subdiv;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return VoronoiDiagramBuilder;
	}
});
VoronoiDiagramBuilder.clipGeometryCollection = function (geom, clipEnv) {
	var clipPoly = geom.getFactory().toGeometry(clipEnv);
	var clipped = new ArrayList();
	for (var i = 0; i < geom.getNumGeometries(); i++) {
		var g = geom.getGeometryN(i);
		var result = null;
		if (clipEnv.contains(g.getEnvelopeInternal())) result = g;else if (clipEnv.intersects(g.getEnvelopeInternal())) {
			result = clipPoly.intersection(g);
			result.setUserData(g.getUserData());
		}
		if (result !== null && !result.isEmpty()) {
			clipped.add(result);
		}
	}
	return geom.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(clipped));
};



var quadedge = Object.freeze({
	Vertex: Vertex
});



var triangulate = Object.freeze({
	ConformingDelaunayTriangulationBuilder: ConformingDelaunayTriangulationBuilder,
	DelaunayTriangulationBuilder: DelaunayTriangulationBuilder,
	VoronoiDiagramBuilder: VoronoiDiagramBuilder,
	quadedge: quadedge
});

function LinearLocation() {
	this._componentIndex = 0;
	this._segmentIndex = 0;
	this._segmentFraction = 0.0;
	if (arguments.length === 0) {} else if (arguments.length === 1) {
		var loc = arguments[0];
		this._componentIndex = loc._componentIndex;
		this._segmentIndex = loc._segmentIndex;
		this._segmentFraction = loc._segmentFraction;
	} else if (arguments.length === 2) {
		var segmentIndex = arguments[0],
		    segmentFraction = arguments[1];
		LinearLocation.call(this, 0, segmentIndex, segmentFraction);
	} else if (arguments.length === 3) {
		var componentIndex = arguments[0],
		    _segmentIndex = arguments[1],
		    _segmentFraction = arguments[2];
		this._componentIndex = componentIndex;
		this._segmentIndex = _segmentIndex;
		this._segmentFraction = _segmentFraction;
		this.normalize();
	} else if (arguments.length === 4) {
		var _componentIndex = arguments[0],
		    _segmentIndex2 = arguments[1],
		    _segmentFraction2 = arguments[2],
		    doNormalize = arguments[3];
		this._componentIndex = _componentIndex;
		this._segmentIndex = _segmentIndex2;
		this._segmentFraction = _segmentFraction2;
		if (doNormalize) this.normalize();
	}
}
extend(LinearLocation.prototype, {
	getSegmentIndex: function getSegmentIndex() {
		return this._segmentIndex;
	},
	getComponentIndex: function getComponentIndex() {
		return this._componentIndex;
	},
	isEndpoint: function isEndpoint(linearGeom) {
		var lineComp = linearGeom.getGeometryN(this._componentIndex);
		var nseg = lineComp.getNumPoints() - 1;
		return this._segmentIndex >= nseg || this._segmentIndex === nseg && this._segmentFraction >= 1.0;
	},
	isValid: function isValid(linearGeom) {
		if (this._componentIndex < 0 || this._componentIndex >= linearGeom.getNumGeometries()) return false;
		var lineComp = linearGeom.getGeometryN(this._componentIndex);
		if (this._segmentIndex < 0 || this._segmentIndex > lineComp.getNumPoints()) return false;
		if (this._segmentIndex === lineComp.getNumPoints() && this._segmentFraction !== 0.0) return false;
		if (this._segmentFraction < 0.0 || this._segmentFraction > 1.0) return false;
		return true;
	},
	normalize: function normalize() {
		if (this._segmentFraction < 0.0) {
			this._segmentFraction = 0.0;
		}
		if (this._segmentFraction > 1.0) {
			this._segmentFraction = 1.0;
		}
		if (this._componentIndex < 0) {
			this._componentIndex = 0;
			this._segmentIndex = 0;
			this._segmentFraction = 0.0;
		}
		if (this._segmentIndex < 0) {
			this._segmentIndex = 0;
			this._segmentFraction = 0.0;
		}
		if (this._segmentFraction === 1.0) {
			this._segmentFraction = 0.0;
			this._segmentIndex += 1;
		}
	},
	toLowest: function toLowest(linearGeom) {
		var lineComp = linearGeom.getGeometryN(this._componentIndex);
		var nseg = lineComp.getNumPoints() - 1;
		if (this._segmentIndex < nseg) return this;
		return new LinearLocation(this._componentIndex, nseg, 1.0, false);
	},
	getCoordinate: function getCoordinate(linearGeom) {
		var lineComp = linearGeom.getGeometryN(this._componentIndex);
		var p0 = lineComp.getCoordinateN(this._segmentIndex);
		if (this._segmentIndex >= lineComp.getNumPoints() - 1) return p0;
		var p1 = lineComp.getCoordinateN(this._segmentIndex + 1);
		return LinearLocation.pointAlongSegmentByFraction(p0, p1, this._segmentFraction);
	},
	getSegmentFraction: function getSegmentFraction() {
		return this._segmentFraction;
	},
	getSegment: function getSegment(linearGeom) {
		var lineComp = linearGeom.getGeometryN(this._componentIndex);
		var p0 = lineComp.getCoordinateN(this._segmentIndex);
		if (this._segmentIndex >= lineComp.getNumPoints() - 1) {
			var prev = lineComp.getCoordinateN(lineComp.getNumPoints() - 2);
			return new LineSegment(prev, p0);
		}
		var p1 = lineComp.getCoordinateN(this._segmentIndex + 1);
		return new LineSegment(p0, p1);
	},
	clamp: function clamp(linear) {
		if (this._componentIndex >= linear.getNumGeometries()) {
			this.setToEnd(linear);
			return null;
		}
		if (this._segmentIndex >= linear.getNumPoints()) {
			var line = linear.getGeometryN(this._componentIndex);
			this._segmentIndex = line.getNumPoints() - 1;
			this._segmentFraction = 1.0;
		}
	},
	setToEnd: function setToEnd(linear) {
		this._componentIndex = linear.getNumGeometries() - 1;
		var lastLine = linear.getGeometryN(this._componentIndex);
		this._segmentIndex = lastLine.getNumPoints() - 1;
		this._segmentFraction = 1.0;
	},
	compareTo: function compareTo(o) {
		var other = o;
		if (this._componentIndex < other._componentIndex) return -1;
		if (this._componentIndex > other._componentIndex) return 1;
		if (this._segmentIndex < other._segmentIndex) return -1;
		if (this._segmentIndex > other._segmentIndex) return 1;
		if (this._segmentFraction < other._segmentFraction) return -1;
		if (this._segmentFraction > other._segmentFraction) return 1;
		return 0;
	},
	copy: function copy() {
		return new LinearLocation(this._componentIndex, this._segmentIndex, this._segmentFraction);
	},
	toString: function toString() {
		return "LinearLoc[" + this._componentIndex + ", " + this._segmentIndex + ", " + this._segmentFraction + "]";
	},
	isOnSameSegment: function isOnSameSegment(loc) {
		if (this._componentIndex !== loc._componentIndex) return false;
		if (this._segmentIndex === loc._segmentIndex) return true;
		if (loc._segmentIndex - this._segmentIndex === 1 && loc._segmentFraction === 0.0) return true;
		if (this._segmentIndex - loc._segmentIndex === 1 && this._segmentFraction === 0.0) return true;
		return false;
	},
	snapToVertex: function snapToVertex(linearGeom, minDistance) {
		if (this._segmentFraction <= 0.0 || this._segmentFraction >= 1.0) return null;
		var segLen = this.getSegmentLength(linearGeom);
		var lenToStart = this._segmentFraction * segLen;
		var lenToEnd = segLen - lenToStart;
		if (lenToStart <= lenToEnd && lenToStart < minDistance) {
			this._segmentFraction = 0.0;
		} else if (lenToEnd <= lenToStart && lenToEnd < minDistance) {
			this._segmentFraction = 1.0;
		}
	},
	compareLocationValues: function compareLocationValues(componentIndex1, segmentIndex1, segmentFraction1) {
		if (this._componentIndex < componentIndex1) return -1;
		if (this._componentIndex > componentIndex1) return 1;
		if (this._segmentIndex < segmentIndex1) return -1;
		if (this._segmentIndex > segmentIndex1) return 1;
		if (this._segmentFraction < segmentFraction1) return -1;
		if (this._segmentFraction > segmentFraction1) return 1;
		return 0;
	},
	getSegmentLength: function getSegmentLength(linearGeom) {
		var lineComp = linearGeom.getGeometryN(this._componentIndex);
		var segIndex = this._segmentIndex;
		if (this._segmentIndex >= lineComp.getNumPoints() - 1) segIndex = lineComp.getNumPoints() - 2;
		var p0 = lineComp.getCoordinateN(segIndex);
		var p1 = lineComp.getCoordinateN(segIndex + 1);
		return p0.distance(p1);
	},
	isVertex: function isVertex() {
		return this._segmentFraction <= 0.0 || this._segmentFraction >= 1.0;
	},
	interfaces_: function interfaces_() {
		return [Comparable];
	},
	getClass: function getClass() {
		return LinearLocation;
	}
});
LinearLocation.getEndLocation = function (linear) {
	var loc = new LinearLocation();
	loc.setToEnd(linear);
	return loc;
};
LinearLocation.pointAlongSegmentByFraction = function (p0, p1, frac) {
	if (frac <= 0.0) return p0;
	if (frac >= 1.0) return p1;
	var x = (p1.x - p0.x) * frac + p0.x;
	var y = (p1.y - p0.y) * frac + p0.y;
	var z = (p1.z - p0.z) * frac + p0.z;
	return new Coordinate(x, y, z);
};
LinearLocation.compareLocationValues = function (componentIndex0, segmentIndex0, segmentFraction0, componentIndex1, segmentIndex1, segmentFraction1) {
	if (componentIndex0 < componentIndex1) return -1;
	if (componentIndex0 > componentIndex1) return 1;
	if (segmentIndex0 < segmentIndex1) return -1;
	if (segmentIndex0 > segmentIndex1) return 1;
	if (segmentFraction0 < segmentFraction1) return -1;
	if (segmentFraction0 > segmentFraction1) return 1;
	return 0;
};

function LinearIterator() {
	this._linearGeom = null;
	this._numLines = null;
	this._currentLine = null;
	this._componentIndex = 0;
	this._vertexIndex = 0;
	if (arguments.length === 1) {
		var linear = arguments[0];
		LinearIterator.call(this, linear, 0, 0);
	} else if (arguments.length === 2) {
		var _linear = arguments[0],
		    start = arguments[1];
		LinearIterator.call(this, _linear, start.getComponentIndex(), LinearIterator.segmentEndVertexIndex(start));
	} else if (arguments.length === 3) {
		var linearGeom = arguments[0],
		    componentIndex = arguments[1],
		    vertexIndex = arguments[2];
		if (!hasInterface(linearGeom, Lineal)) throw new IllegalArgumentException("Lineal geometry is required");
		this._linearGeom = linearGeom;
		this._numLines = linearGeom.getNumGeometries();
		this._componentIndex = componentIndex;
		this._vertexIndex = vertexIndex;
		this.loadCurrentLine();
	}
}
extend(LinearIterator.prototype, {
	getComponentIndex: function getComponentIndex() {
		return this._componentIndex;
	},
	getLine: function getLine() {
		return this._currentLine;
	},
	getVertexIndex: function getVertexIndex() {
		return this._vertexIndex;
	},
	getSegmentEnd: function getSegmentEnd() {
		if (this._vertexIndex < this.getLine().getNumPoints() - 1) return this._currentLine.getCoordinateN(this._vertexIndex + 1);
		return null;
	},
	next: function next() {
		if (!this.hasNext()) return null;
		this._vertexIndex++;
		if (this._vertexIndex >= this._currentLine.getNumPoints()) {
			this._componentIndex++;
			this.loadCurrentLine();
			this._vertexIndex = 0;
		}
	},
	loadCurrentLine: function loadCurrentLine() {
		if (this._componentIndex >= this._numLines) {
			this._currentLine = null;
			return null;
		}
		this._currentLine = this._linearGeom.getGeometryN(this._componentIndex);
	},
	getSegmentStart: function getSegmentStart() {
		return this._currentLine.getCoordinateN(this._vertexIndex);
	},
	isEndOfLine: function isEndOfLine() {
		if (this._componentIndex >= this._numLines) return false;
		if (this._vertexIndex < this._currentLine.getNumPoints() - 1) return false;
		return true;
	},
	hasNext: function hasNext() {
		if (this._componentIndex >= this._numLines) return false;
		if (this._componentIndex === this._numLines - 1 && this._vertexIndex >= this._currentLine.getNumPoints()) return false;
		return true;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LinearIterator;
	}
});
LinearIterator.segmentEndVertexIndex = function (loc) {
	if (loc.getSegmentFraction() > 0.0) return loc.getSegmentIndex() + 1;
	return loc.getSegmentIndex();
};

function LocationIndexOfPoint() {
	this._linearGeom = null;
	var linearGeom = arguments[0];
	this._linearGeom = linearGeom;
}
extend(LocationIndexOfPoint.prototype, {
	indexOf: function indexOf(inputPt) {
		return this.indexOfFromStart(inputPt, null);
	},
	indexOfFromStart: function indexOfFromStart(inputPt, minIndex) {
		var minDistance = Double.MAX_VALUE;
		var minComponentIndex = 0;
		var minSegmentIndex = 0;
		var minFrac = -1.0;
		var seg = new LineSegment();
		for (var it = new LinearIterator(this._linearGeom); it.hasNext(); it.next()) {
			if (!it.isEndOfLine()) {
				seg.p0 = it.getSegmentStart();
				seg.p1 = it.getSegmentEnd();
				var segDistance = seg.distance(inputPt);
				var segFrac = seg.segmentFraction(inputPt);
				var candidateComponentIndex = it.getComponentIndex();
				var candidateSegmentIndex = it.getVertexIndex();
				if (segDistance < minDistance) {
					if (minIndex === null || minIndex.compareLocationValues(candidateComponentIndex, candidateSegmentIndex, segFrac) < 0) {
						minComponentIndex = candidateComponentIndex;
						minSegmentIndex = candidateSegmentIndex;
						minFrac = segFrac;
						minDistance = segDistance;
					}
				}
			}
		}
		if (minDistance === Double.MAX_VALUE) {
			return new LinearLocation(minIndex);
		}
		var loc = new LinearLocation(minComponentIndex, minSegmentIndex, minFrac);
		return loc;
	},
	indexOfAfter: function indexOfAfter(inputPt, minIndex) {
		if (minIndex === null) return this.indexOf(inputPt);
		var endLoc = LinearLocation.getEndLocation(this._linearGeom);
		if (endLoc.compareTo(minIndex) <= 0) return endLoc;
		var closestAfter = this.indexOfFromStart(inputPt, minIndex);
		Assert.isTrue(closestAfter.compareTo(minIndex) >= 0, "computed location is before specified minimum location");
		return closestAfter;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LocationIndexOfPoint;
	}
});
LocationIndexOfPoint.indexOf = function (linearGeom, inputPt) {
	var locater = new LocationIndexOfPoint(linearGeom);
	return locater.indexOf(inputPt);
};
LocationIndexOfPoint.indexOfAfter = function (linearGeom, inputPt, minIndex) {
	var locater = new LocationIndexOfPoint(linearGeom);
	return locater.indexOfAfter(inputPt, minIndex);
};

function LocationIndexOfLine() {
	this._linearGeom = null;
	var linearGeom = arguments[0];
	this._linearGeom = linearGeom;
}
extend(LocationIndexOfLine.prototype, {
	indicesOf: function indicesOf(subLine) {
		var startPt = subLine.getGeometryN(0).getCoordinateN(0);
		var lastLine = subLine.getGeometryN(subLine.getNumGeometries() - 1);
		var endPt = lastLine.getCoordinateN(lastLine.getNumPoints() - 1);
		var locPt = new LocationIndexOfPoint(this._linearGeom);
		var subLineLoc = new Array(2).fill(null);
		subLineLoc[0] = locPt.indexOf(startPt);
		if (subLine.getLength() === 0.0) {
			subLineLoc[1] = subLineLoc[0].copy();
		} else {
			subLineLoc[1] = locPt.indexOfAfter(endPt, subLineLoc[0]);
		}
		return subLineLoc;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LocationIndexOfLine;
	}
});
LocationIndexOfLine.indicesOf = function (linearGeom, subLine) {
	var locater = new LocationIndexOfLine(linearGeom);
	return locater.indicesOf(subLine);
};

function LinearGeometryBuilder() {
	this._geomFact = null;
	this._lines = new ArrayList();
	this._coordList = null;
	this._ignoreInvalidLines = false;
	this._fixInvalidLines = false;
	this._lastPt = null;
	var geomFact = arguments[0];
	this._geomFact = geomFact;
}
extend(LinearGeometryBuilder.prototype, {
	getGeometry: function getGeometry() {
		this.endLine();
		return this._geomFact.buildGeometry(this._lines);
	},
	getLastCoordinate: function getLastCoordinate() {
		return this._lastPt;
	},
	endLine: function endLine() {
		if (this._coordList === null) {
			return null;
		}
		if (this._ignoreInvalidLines && this._coordList.size() < 2) {
			this._coordList = null;
			return null;
		}
		var rawPts = this._coordList.toCoordinateArray();
		var pts = rawPts;
		if (this._fixInvalidLines) pts = this.validCoordinateSequence(rawPts);
		this._coordList = null;
		var line = null;
		try {
			line = this._geomFact.createLineString(pts);
		} catch (ex) {
			if (ex instanceof IllegalArgumentException) {
				if (!this._ignoreInvalidLines) throw ex;
			} else throw ex;
		} finally {}
		if (line !== null) this._lines.add(line);
	},
	setFixInvalidLines: function setFixInvalidLines(fixInvalidLines) {
		this._fixInvalidLines = fixInvalidLines;
	},
	add: function add() {
		if (arguments.length === 1) {
			var pt = arguments[0];
			this.add(pt, true);
		} else if (arguments.length === 2) {
			var _pt = arguments[0],
			    allowRepeatedPoints = arguments[1];
			if (this._coordList === null) this._coordList = new CoordinateList();
			this._coordList.add(_pt, allowRepeatedPoints);
			this._lastPt = _pt;
		}
	},
	setIgnoreInvalidLines: function setIgnoreInvalidLines(ignoreInvalidLines) {
		this._ignoreInvalidLines = ignoreInvalidLines;
	},
	validCoordinateSequence: function validCoordinateSequence(pts) {
		if (pts.length >= 2) return pts;
		var validPts = [pts[0], pts[0]];
		return validPts;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LinearGeometryBuilder;
	}
});

function ExtractLineByLocation() {
	this._line = null;
	var line = arguments[0];
	this._line = line;
}
extend(ExtractLineByLocation.prototype, {
	computeLinear: function computeLinear(start, end) {
		var builder = new LinearGeometryBuilder(this._line.getFactory());
		builder.setFixInvalidLines(true);
		if (!start.isVertex()) builder.add(start.getCoordinate(this._line));
		for (var it = new LinearIterator(this._line, start); it.hasNext(); it.next()) {
			if (end.compareLocationValues(it.getComponentIndex(), it.getVertexIndex(), 0.0) < 0) break;
			var pt = it.getSegmentStart();
			builder.add(pt);
			if (it.isEndOfLine()) builder.endLine();
		}
		if (!end.isVertex()) builder.add(end.getCoordinate(this._line));
		return builder.getGeometry();
	},
	computeLine: function computeLine(start, end) {
		var coordinates = this._line.getCoordinates();
		var newCoordinates = new CoordinateList();
		var startSegmentIndex = start.getSegmentIndex();
		if (start.getSegmentFraction() > 0.0) startSegmentIndex += 1;
		var lastSegmentIndex = end.getSegmentIndex();
		if (end.getSegmentFraction() === 1.0) lastSegmentIndex += 1;
		if (lastSegmentIndex >= coordinates.length) lastSegmentIndex = coordinates.length - 1;
		if (!start.isVertex()) newCoordinates.add(start.getCoordinate(this._line));
		for (var i = startSegmentIndex; i <= lastSegmentIndex; i++) {
			newCoordinates.add(coordinates[i]);
		}
		if (!end.isVertex()) newCoordinates.add(end.getCoordinate(this._line));
		if (newCoordinates.size() <= 0) newCoordinates.add(start.getCoordinate(this._line));
		var newCoordinateArray = newCoordinates.toCoordinateArray();
		if (newCoordinateArray.length <= 1) {
			newCoordinateArray = [newCoordinateArray[0], newCoordinateArray[0]];
		}
		return this._line.getFactory().createLineString(newCoordinateArray);
	},
	extract: function extract(start, end) {
		if (end.compareTo(start) < 0) {
			return this.reverse(this.computeLinear(end, start));
		}
		return this.computeLinear(start, end);
	},
	reverse: function reverse(linear) {
		if (linear instanceof LineString) return linear.reverse();
		if (linear instanceof MultiLineString) return linear.reverse();
		Assert.shouldNeverReachHere("non-linear geometry encountered");
		return null;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return ExtractLineByLocation;
	}
});
ExtractLineByLocation.extract = function (line, start, end) {
	var ls = new ExtractLineByLocation(line);
	return ls.extract(start, end);
};

function LocationIndexedLine() {
	this._linearGeom = null;
	var linearGeom = arguments[0];
	this._linearGeom = linearGeom;
	this.checkGeometryType();
}
extend(LocationIndexedLine.prototype, {
	clampIndex: function clampIndex(index) {
		var loc = index.copy();
		loc.clamp(this._linearGeom);
		return loc;
	},
	project: function project(pt) {
		return LocationIndexOfPoint.indexOf(this._linearGeom, pt);
	},
	checkGeometryType: function checkGeometryType() {
		if (!(this._linearGeom instanceof LineString || this._linearGeom instanceof MultiLineString)) throw new IllegalArgumentException("Input geometry must be linear");
	},
	extractPoint: function extractPoint() {
		if (arguments.length === 1) {
			var index = arguments[0];
			return index.getCoordinate(this._linearGeom);
		} else if (arguments.length === 2) {
			var _index = arguments[0],
			    offsetDistance = arguments[1];
			var indexLow = _index.toLowest(this._linearGeom);
			return indexLow.getSegment(this._linearGeom).pointAlongOffset(indexLow.getSegmentFraction(), offsetDistance);
		}
	},
	isValidIndex: function isValidIndex(index) {
		return index.isValid(this._linearGeom);
	},
	getEndIndex: function getEndIndex() {
		return LinearLocation.getEndLocation(this._linearGeom);
	},
	getStartIndex: function getStartIndex() {
		return new LinearLocation();
	},
	indexOfAfter: function indexOfAfter(pt, minIndex) {
		return LocationIndexOfPoint.indexOfAfter(this._linearGeom, pt, minIndex);
	},
	extractLine: function extractLine(startIndex, endIndex) {
		return ExtractLineByLocation.extract(this._linearGeom, startIndex, endIndex);
	},
	indexOf: function indexOf(pt) {
		return LocationIndexOfPoint.indexOf(this._linearGeom, pt);
	},
	indicesOf: function indicesOf(subLine) {
		return LocationIndexOfLine.indicesOf(this._linearGeom, subLine);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LocationIndexedLine;
	}
});

function LengthIndexOfPoint() {
	this._linearGeom = null;
	var linearGeom = arguments[0];
	this._linearGeom = linearGeom;
}
extend(LengthIndexOfPoint.prototype, {
	indexOf: function indexOf(inputPt) {
		return this.indexOfFromStart(inputPt, -1.0);
	},
	indexOfFromStart: function indexOfFromStart(inputPt, minIndex) {
		var minDistance = Double.MAX_VALUE;
		var ptMeasure = minIndex;
		var segmentStartMeasure = 0.0;
		var seg = new LineSegment();
		var it = new LinearIterator(this._linearGeom);
		while (it.hasNext()) {
			if (!it.isEndOfLine()) {
				seg.p0 = it.getSegmentStart();
				seg.p1 = it.getSegmentEnd();
				var segDistance = seg.distance(inputPt);
				var segMeasureToPt = this.segmentNearestMeasure(seg, inputPt, segmentStartMeasure);
				if (segDistance < minDistance && segMeasureToPt > minIndex) {
					ptMeasure = segMeasureToPt;
					minDistance = segDistance;
				}
				segmentStartMeasure += seg.getLength();
			}
			it.next();
		}
		return ptMeasure;
	},
	indexOfAfter: function indexOfAfter(inputPt, minIndex) {
		if (minIndex < 0.0) return this.indexOf(inputPt);
		var endIndex = this._linearGeom.getLength();
		if (endIndex < minIndex) return endIndex;
		var closestAfter = this.indexOfFromStart(inputPt, minIndex);
		Assert.isTrue(closestAfter >= minIndex, "computed index is before specified minimum index");
		return closestAfter;
	},
	segmentNearestMeasure: function segmentNearestMeasure(seg, inputPt, segmentStartMeasure) {
		var projFactor = seg.projectionFactor(inputPt);
		if (projFactor <= 0.0) return segmentStartMeasure;
		if (projFactor <= 1.0) return segmentStartMeasure + projFactor * seg.getLength();
		return segmentStartMeasure + seg.getLength();
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LengthIndexOfPoint;
	}
});
LengthIndexOfPoint.indexOf = function (linearGeom, inputPt) {
	var locater = new LengthIndexOfPoint(linearGeom);
	return locater.indexOf(inputPt);
};
LengthIndexOfPoint.indexOfAfter = function (linearGeom, inputPt, minIndex) {
	var locater = new LengthIndexOfPoint(linearGeom);
	return locater.indexOfAfter(inputPt, minIndex);
};

function LengthLocationMap() {
	this._linearGeom = null;
	var linearGeom = arguments[0];
	this._linearGeom = linearGeom;
}
extend(LengthLocationMap.prototype, {
	getLength: function getLength(loc) {
		var totalLength = 0.0;
		var it = new LinearIterator(this._linearGeom);
		while (it.hasNext()) {
			if (!it.isEndOfLine()) {
				var p0 = it.getSegmentStart();
				var p1 = it.getSegmentEnd();
				var segLen = p1.distance(p0);
				if (loc.getComponentIndex() === it.getComponentIndex() && loc.getSegmentIndex() === it.getVertexIndex()) {
					return totalLength + segLen * loc.getSegmentFraction();
				}
				totalLength += segLen;
			}
			it.next();
		}
		return totalLength;
	},
	resolveHigher: function resolveHigher(loc) {
		if (!loc.isEndpoint(this._linearGeom)) return loc;
		var compIndex = loc.getComponentIndex();
		if (compIndex >= this._linearGeom.getNumGeometries() - 1) return loc;
		do {
			compIndex++;
		} while (compIndex < this._linearGeom.getNumGeometries() - 1 && this._linearGeom.getGeometryN(compIndex).getLength() === 0);
		return new LinearLocation(compIndex, 0, 0.0);
	},
	getLocation: function getLocation() {
		if (arguments.length === 1) {
			var length = arguments[0];
			return this.getLocation(length, true);
		} else if (arguments.length === 2) {
			var _length = arguments[0],
			    resolveLower = arguments[1];
			var forwardLength = _length;
			if (_length < 0.0) {
				var lineLen = this._linearGeom.getLength();
				forwardLength = lineLen + _length;
			}
			var loc = this.getLocationForward(forwardLength);
			if (resolveLower) {
				return loc;
			}
			return this.resolveHigher(loc);
		}
	},
	getLocationForward: function getLocationForward(length) {
		if (length <= 0.0) return new LinearLocation();
		var totalLength = 0.0;
		var it = new LinearIterator(this._linearGeom);
		while (it.hasNext()) {
			if (it.isEndOfLine()) {
				if (totalLength === length) {
					var compIndex = it.getComponentIndex();
					var segIndex = it.getVertexIndex();
					return new LinearLocation(compIndex, segIndex, 0.0);
				}
			} else {
				var p0 = it.getSegmentStart();
				var p1 = it.getSegmentEnd();
				var segLen = p1.distance(p0);
				if (totalLength + segLen > length) {
					var frac = (length - totalLength) / segLen;
					var compIndex = it.getComponentIndex();
					var segIndex = it.getVertexIndex();
					return new LinearLocation(compIndex, segIndex, frac);
				}
				totalLength += segLen;
			}
			it.next();
		}
		return LinearLocation.getEndLocation(this._linearGeom);
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LengthLocationMap;
	}
});
LengthLocationMap.getLength = function (linearGeom, loc) {
	var locater = new LengthLocationMap(linearGeom);
	return locater.getLength(loc);
};
LengthLocationMap.getLocation = function () {
	if (arguments.length === 2) {
		var linearGeom = arguments[0],
		    length = arguments[1];
		var locater = new LengthLocationMap(linearGeom);
		return locater.getLocation(length);
	} else if (arguments.length === 3) {
		var _linearGeom = arguments[0],
		    _length2 = arguments[1],
		    resolveLower = arguments[2];
		var locater = new LengthLocationMap(_linearGeom);
		return locater.getLocation(_length2, resolveLower);
	}
};

function LengthIndexedLine() {
	this._linearGeom = null;
	var linearGeom = arguments[0];
	this._linearGeom = linearGeom;
}
extend(LengthIndexedLine.prototype, {
	clampIndex: function clampIndex(index) {
		var posIndex = this.positiveIndex(index);
		var startIndex = this.getStartIndex();
		if (posIndex < startIndex) return startIndex;
		var endIndex = this.getEndIndex();
		if (posIndex > endIndex) return endIndex;
		return posIndex;
	},
	locationOf: function locationOf() {
		if (arguments.length === 1) {
			var index = arguments[0];
			return LengthLocationMap.getLocation(this._linearGeom, index);
		} else if (arguments.length === 2) {
			var _index = arguments[0],
			    resolveLower = arguments[1];
			return LengthLocationMap.getLocation(this._linearGeom, _index, resolveLower);
		}
	},
	project: function project(pt) {
		return LengthIndexOfPoint.indexOf(this._linearGeom, pt);
	},
	positiveIndex: function positiveIndex(index) {
		if (index >= 0.0) return index;
		return this._linearGeom.getLength() + index;
	},
	extractPoint: function extractPoint() {
		if (arguments.length === 1) {
			var index = arguments[0];
			var loc = LengthLocationMap.getLocation(this._linearGeom, index);
			return loc.getCoordinate(this._linearGeom);
		} else if (arguments.length === 2) {
			var _index2 = arguments[0],
			    offsetDistance = arguments[1];
			var loc = LengthLocationMap.getLocation(this._linearGeom, _index2);
			var locLow = loc.toLowest(this._linearGeom);
			return locLow.getSegment(this._linearGeom).pointAlongOffset(locLow.getSegmentFraction(), offsetDistance);
		}
	},
	isValidIndex: function isValidIndex(index) {
		return index >= this.getStartIndex() && index <= this.getEndIndex();
	},
	getEndIndex: function getEndIndex() {
		return this._linearGeom.getLength();
	},
	getStartIndex: function getStartIndex() {
		return 0.0;
	},
	indexOfAfter: function indexOfAfter(pt, minIndex) {
		return LengthIndexOfPoint.indexOfAfter(this._linearGeom, pt, minIndex);
	},
	extractLine: function extractLine(startIndex, endIndex) {
		var lil = new LocationIndexedLine(this._linearGeom);
		var startIndex2 = this.clampIndex(startIndex);
		var endIndex2 = this.clampIndex(endIndex);
		var resolveStartLower = startIndex2 === endIndex2;
		var startLoc = this.locationOf(startIndex2, resolveStartLower);
		var endLoc = this.locationOf(endIndex2);
		return ExtractLineByLocation.extract(this._linearGeom, startLoc, endLoc);
	},
	indexOf: function indexOf(pt) {
		return LengthIndexOfPoint.indexOf(this._linearGeom, pt);
	},
	indicesOf: function indicesOf(subLine) {
		var locIndex = LocationIndexOfLine.indicesOf(this._linearGeom, subLine);
		var index = [LengthLocationMap.getLength(this._linearGeom, locIndex[0]), LengthLocationMap.getLength(this._linearGeom, locIndex[1])];
		return index;
	},
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return LengthIndexedLine;
	}
});



var linearref = Object.freeze({
	LengthIndexedLine: LengthIndexedLine,
	LengthLocationMap: LengthLocationMap,
	LinearGeometryBuilder: LinearGeometryBuilder,
	LinearIterator: LinearIterator,
	LinearLocation: LinearLocation,
	LocationIndexedLine: LocationIndexedLine
});

function UnionOp() {}
extend(UnionOp.prototype, {
	interfaces_: function interfaces_() {
		return [];
	},
	getClass: function getClass() {
		return UnionOp;
	}
});
UnionOp.union = function (g, other) {
	if (g.isEmpty() || other.isEmpty()) {
		if (g.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.UNION, g, other, g.getFactory());
		if (g.isEmpty()) return other.copy();
		if (other.isEmpty()) return g.copy();
	}
	g.checkNotGeometryCollection(g);
	g.checkNotGeometryCollection(other);
	return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.UNION);
};

extend(Geometry.prototype, {
	equalsTopo: function equalsTopo(g) {
		if (!this.getEnvelopeInternal().equals(g.getEnvelopeInternal())) return false;
		return RelateOp.relate(this, g).isEquals(this.getDimension(), g.getDimension());
	},
	union: function union() {
		if (arguments.length === 0) {
			return UnaryUnionOp.union(this);
		} else if (arguments.length === 1) {
			var other = arguments[0];
			return UnionOp.union(this, other);
		}
	},
	isValid: function isValid() {
		return IsValidOp.isValid(this);
	},
	intersection: function intersection(other) {
		if (this.isEmpty() || other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, this, other, this._factory);
		if (this.isGeometryCollection()) {
			var g2 = other;
			return GeometryCollectionMapper.map(this, {
				interfaces_: function interfaces_() {
					return [MapOp];
				},
				map: function map(g) {
					return g.intersection(g2);
				}
			});
		}
		this.checkNotGeometryCollection(this);
		this.checkNotGeometryCollection(other);
		return SnapIfNeededOverlayOp.overlayOp(this, other, OverlayOp.INTERSECTION);
	},
	covers: function covers(g) {
		return RelateOp.covers(this, g);
	},
	coveredBy: function coveredBy(g) {
		return RelateOp.covers(g, this);
	},
	touches: function touches(g) {
		return RelateOp.touches(this, g);
	},
	intersects: function intersects(g) {
		return RelateOp.intersects(this, g);
	},
	within: function within(g) {
		return RelateOp.within(this, g);
	},
	overlaps: function overlaps(g) {
		return RelateOp.overlaps(this, g);
	},
	disjoint: function disjoint(g) {
		return RelateOp.disjoint(this, g);
	},
	crosses: function crosses(g) {
		return RelateOp.crosses(this, g);
	},
	buffer: function buffer() {
		if (arguments.length === 1) {
			var distance = arguments[0];
			return BufferOp.bufferOp(this, distance);
		} else if (arguments.length === 2) {
			var _distance = arguments[0],
			    quadrantSegments = arguments[1];
			return BufferOp.bufferOp(this, _distance, quadrantSegments);
		} else if (arguments.length === 3) {
			var _distance2 = arguments[0],
			    _quadrantSegments = arguments[1],
			    endCapStyle = arguments[2];
			return BufferOp.bufferOp(this, _distance2, _quadrantSegments, endCapStyle);
		}
	},
	convexHull: function convexHull() {
		return new ConvexHull(this).getConvexHull();
	},
	relate: function relate() {
		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		if (arguments.length === 1) {
			var geometry = arguments[0];
			return RelateOp.relate(this, geometry);
		} else if (arguments.length === 2) {
			var _geometry = arguments[0],
			    intersectionPattern = arguments[1];
			return RelateOp.relate(this, _geometry).matches(intersectionPattern);
		}
	},
	getCentroid: function getCentroid() {
		if (this.isEmpty()) return this._factory.createPoint();
		var centPt = Centroid.getCentroid(this);
		return this.createPointFromInternalCoord(centPt, this);
	},
	getInteriorPoint: function getInteriorPoint() {
		if (this.isEmpty()) return this._factory.createPoint();
		var interiorPt = null;
		var dim = this.getDimension();
		if (dim === 0) {
			var intPt = new InteriorPointPoint(this);
			interiorPt = intPt.getInteriorPoint();
		} else if (dim === 1) {
			var intPt = new InteriorPointLine(this);
			interiorPt = intPt.getInteriorPoint();
		} else {
			var intPt = new InteriorPointArea(this);
			interiorPt = intPt.getInteriorPoint();
		}
		return this.createPointFromInternalCoord(interiorPt, this);
	},
	symDifference: function symDifference(other) {
		if (this.isEmpty() || other.isEmpty()) {
			if (this.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, this, other, this._factory);
			if (this.isEmpty()) return other.copy();
			if (other.isEmpty()) return this.copy();
		}
		this.checkNotGeometryCollection(this);
		this.checkNotGeometryCollection(other);
		return SnapIfNeededOverlayOp.overlayOp(this, other, OverlayOp.SYMDIFFERENCE);
	},
	createPointFromInternalCoord: function createPointFromInternalCoord(coord, exemplar) {
		exemplar.getPrecisionModel().makePrecise(coord);
		return exemplar.getFactory().createPoint(coord);
	},
	toText: function toText() {
		var writer = new WKTWriter();
		return writer.write(this);
	},
	toString: function toString() {
		this.toText();
	},
	contains: function contains(g) {
		return RelateOp.contains(this, g);
	},
	difference: function difference(other) {
		if (this.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, this, other, this._factory);
		if (other.isEmpty()) return this.copy();
		this.checkNotGeometryCollection(this);
		this.checkNotGeometryCollection(other);
		return SnapIfNeededOverlayOp.overlayOp(this, other, OverlayOp.DIFFERENCE);
	},
	isSimple: function isSimple() {
		var op = new IsSimpleOp(this);
		return op.isSimple();
	},
	isWithinDistance: function isWithinDistance(geom, distance) {
		var envDist = this.getEnvelopeInternal().distance(geom.getEnvelopeInternal());
		if (envDist > distance) return false;
		return DistanceOp.isWithinDistance(this, geom, distance);
	},
	distance: function distance(g) {
		return DistanceOp.distance(this, g);
	},
	isEquivalentClass: function isEquivalentClass(other) {
		return this.getClass() === other.getClass();
	}
});

var version = '1.6.0 (ac4d0f6)';

exports.version = version;
exports.algorithm = algorithm;
exports.densify = densify;
exports.dissolve = dissolve;
exports.geom = geom;
exports.geomgraph = geomgraph;
exports.index = index;
exports.io = io;
exports.noding = noding;
exports.operation = operation;
exports.precision = precision;
exports.simplify = simplify;
exports.triangulate = triangulate;
exports.linearref = linearref;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=jsts.js.map


/***/ }),

/***/ "./node_modules/mousetrap/mousetrap.js":
/*!*********************************************!*\
  !*** ./node_modules/mousetrap/mousetrap.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*global define:false */
/**
 * Copyright 2012-2017 Craig Campbell
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Mousetrap is a simple keyboard shortcut library for Javascript with
 * no external dependencies
 *
 * @version 1.6.2
 * @url craig.is/killing/mice
 */
(function(window, document, undefined) {

    // Check if mousetrap is used inside browser, if not, return
    if (!window) {
        return;
    }

    /**
     * mapping of special keycodes to their corresponding keys
     *
     * everything in this dictionary cannot use keypress events
     * so it has to be here to map to the correct keycodes for
     * keyup/keydown events
     *
     * @type {Object}
     */
    var _MAP = {
        8: 'backspace',
        9: 'tab',
        13: 'enter',
        16: 'shift',
        17: 'ctrl',
        18: 'alt',
        20: 'capslock',
        27: 'esc',
        32: 'space',
        33: 'pageup',
        34: 'pagedown',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down',
        45: 'ins',
        46: 'del',
        91: 'meta',
        93: 'meta',
        224: 'meta'
    };

    /**
     * mapping for special characters so they can support
     *
     * this dictionary is only used incase you want to bind a
     * keyup or keydown event to one of these keys
     *
     * @type {Object}
     */
    var _KEYCODE_MAP = {
        106: '*',
        107: '+',
        109: '-',
        110: '.',
        111 : '/',
        186: ';',
        187: '=',
        188: ',',
        189: '-',
        190: '.',
        191: '/',
        192: '`',
        219: '[',
        220: '\\',
        221: ']',
        222: '\''
    };

    /**
     * this is a mapping of keys that require shift on a US keypad
     * back to the non shift equivelents
     *
     * this is so you can use keyup events with these keys
     *
     * note that this will only work reliably on US keyboards
     *
     * @type {Object}
     */
    var _SHIFT_MAP = {
        '~': '`',
        '!': '1',
        '@': '2',
        '#': '3',
        '$': '4',
        '%': '5',
        '^': '6',
        '&': '7',
        '*': '8',
        '(': '9',
        ')': '0',
        '_': '-',
        '+': '=',
        ':': ';',
        '\"': '\'',
        '<': ',',
        '>': '.',
        '?': '/',
        '|': '\\'
    };

    /**
     * this is a list of special strings you can use to map
     * to modifier keys when you specify your keyboard shortcuts
     *
     * @type {Object}
     */
    var _SPECIAL_ALIASES = {
        'option': 'alt',
        'command': 'meta',
        'return': 'enter',
        'escape': 'esc',
        'plus': '+',
        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'
    };

    /**
     * variable to store the flipped version of _MAP from above
     * needed to check if we should use keypress or not when no action
     * is specified
     *
     * @type {Object|undefined}
     */
    var _REVERSE_MAP;

    /**
     * loop through the f keys, f1 to f19 and add them to the map
     * programatically
     */
    for (var i = 1; i < 20; ++i) {
        _MAP[111 + i] = 'f' + i;
    }

    /**
     * loop through to map numbers on the numeric keypad
     */
    for (i = 0; i <= 9; ++i) {

        // This needs to use a string cause otherwise since 0 is falsey
        // mousetrap will never fire for numpad 0 pressed as part of a keydown
        // event.
        //
        // @see https://github.com/ccampbell/mousetrap/pull/258
        _MAP[i + 96] = i.toString();
    }

    /**
     * cross browser add event method
     *
     * @param {Element|HTMLDocument} object
     * @param {string} type
     * @param {Function} callback
     * @returns void
     */
    function _addEvent(object, type, callback) {
        if (object.addEventListener) {
            object.addEventListener(type, callback, false);
            return;
        }

        object.attachEvent('on' + type, callback);
    }

    /**
     * takes the event and returns the key character
     *
     * @param {Event} e
     * @return {string}
     */
    function _characterFromEvent(e) {

        // for keypress events we should return the character as is
        if (e.type == 'keypress') {
            var character = String.fromCharCode(e.which);

            // if the shift key is not pressed then it is safe to assume
            // that we want the character to be lowercase.  this means if
            // you accidentally have caps lock on then your key bindings
            // will continue to work
            //
            // the only side effect that might not be desired is if you
            // bind something like 'A' cause you want to trigger an
            // event when capital A is pressed caps lock will no longer
            // trigger the event.  shift+a will though.
            if (!e.shiftKey) {
                character = character.toLowerCase();
            }

            return character;
        }

        // for non keypress events the special maps are needed
        if (_MAP[e.which]) {
            return _MAP[e.which];
        }

        if (_KEYCODE_MAP[e.which]) {
            return _KEYCODE_MAP[e.which];
        }

        // if it is not in the special map

        // with keydown and keyup events the character seems to always
        // come in as an uppercase character whether you are pressing shift
        // or not.  we should make sure it is always lowercase for comparisons
        return String.fromCharCode(e.which).toLowerCase();
    }

    /**
     * checks if two arrays are equal
     *
     * @param {Array} modifiers1
     * @param {Array} modifiers2
     * @returns {boolean}
     */
    function _modifiersMatch(modifiers1, modifiers2) {
        return modifiers1.sort().join(',') === modifiers2.sort().join(',');
    }

    /**
     * takes a key event and figures out what the modifiers are
     *
     * @param {Event} e
     * @returns {Array}
     */
    function _eventModifiers(e) {
        var modifiers = [];

        if (e.shiftKey) {
            modifiers.push('shift');
        }

        if (e.altKey) {
            modifiers.push('alt');
        }

        if (e.ctrlKey) {
            modifiers.push('ctrl');
        }

        if (e.metaKey) {
            modifiers.push('meta');
        }

        return modifiers;
    }

    /**
     * prevents default for this event
     *
     * @param {Event} e
     * @returns void
     */
    function _preventDefault(e) {
        if (e.preventDefault) {
            e.preventDefault();
            return;
        }

        e.returnValue = false;
    }

    /**
     * stops propogation for this event
     *
     * @param {Event} e
     * @returns void
     */
    function _stopPropagation(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
            return;
        }

        e.cancelBubble = true;
    }

    /**
     * determines if the keycode specified is a modifier key or not
     *
     * @param {string} key
     * @returns {boolean}
     */
    function _isModifier(key) {
        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
    }

    /**
     * reverses the map lookup so that we can look for specific keys
     * to see what can and can't use keypress
     *
     * @return {Object}
     */
    function _getReverseMap() {
        if (!_REVERSE_MAP) {
            _REVERSE_MAP = {};
            for (var key in _MAP) {

                // pull out the numeric keypad from here cause keypress should
                // be able to detect the keys from the character
                if (key > 95 && key < 112) {
                    continue;
                }

                if (_MAP.hasOwnProperty(key)) {
                    _REVERSE_MAP[_MAP[key]] = key;
                }
            }
        }
        return _REVERSE_MAP;
    }

    /**
     * picks the best action based on the key combination
     *
     * @param {string} key - character for key
     * @param {Array} modifiers
     * @param {string=} action passed in
     */
    function _pickBestAction(key, modifiers, action) {

        // if no action was picked in we should try to pick the one
        // that we think would work best for this key
        if (!action) {
            action = _getReverseMap()[key] ? 'keydown' : 'keypress';
        }

        // modifier keys don't work as expected with keypress,
        // switch to keydown
        if (action == 'keypress' && modifiers.length) {
            action = 'keydown';
        }

        return action;
    }

    /**
     * Converts from a string key combination to an array
     *
     * @param  {string} combination like "command+shift+l"
     * @return {Array}
     */
    function _keysFromString(combination) {
        if (combination === '+') {
            return ['+'];
        }

        combination = combination.replace(/\+{2}/g, '+plus');
        return combination.split('+');
    }

    /**
     * Gets info for a specific key combination
     *
     * @param  {string} combination key combination ("command+s" or "a" or "*")
     * @param  {string=} action
     * @returns {Object}
     */
    function _getKeyInfo(combination, action) {
        var keys;
        var key;
        var i;
        var modifiers = [];

        // take the keys from this pattern and figure out what the actual
        // pattern is all about
        keys = _keysFromString(combination);

        for (i = 0; i < keys.length; ++i) {
            key = keys[i];

            // normalize key names
            if (_SPECIAL_ALIASES[key]) {
                key = _SPECIAL_ALIASES[key];
            }

            // if this is not a keypress event then we should
            // be smart about using shift keys
            // this will only work for US keyboards however
            if (action && action != 'keypress' && _SHIFT_MAP[key]) {
                key = _SHIFT_MAP[key];
                modifiers.push('shift');
            }

            // if this key is a modifier then add it to the list of modifiers
            if (_isModifier(key)) {
                modifiers.push(key);
            }
        }

        // depending on what the key combination is
        // we will try to pick the best event for it
        action = _pickBestAction(key, modifiers, action);

        return {
            key: key,
            modifiers: modifiers,
            action: action
        };
    }

    function _belongsTo(element, ancestor) {
        if (element === null || element === document) {
            return false;
        }

        if (element === ancestor) {
            return true;
        }

        return _belongsTo(element.parentNode, ancestor);
    }

    function Mousetrap(targetElement) {
        var self = this;

        targetElement = targetElement || document;

        if (!(self instanceof Mousetrap)) {
            return new Mousetrap(targetElement);
        }

        /**
         * element to attach key events to
         *
         * @type {Element}
         */
        self.target = targetElement;

        /**
         * a list of all the callbacks setup via Mousetrap.bind()
         *
         * @type {Object}
         */
        self._callbacks = {};

        /**
         * direct map of string combinations to callbacks used for trigger()
         *
         * @type {Object}
         */
        self._directMap = {};

        /**
         * keeps track of what level each sequence is at since multiple
         * sequences can start out with the same sequence
         *
         * @type {Object}
         */
        var _sequenceLevels = {};

        /**
         * variable to store the setTimeout call
         *
         * @type {null|number}
         */
        var _resetTimer;

        /**
         * temporary state where we will ignore the next keyup
         *
         * @type {boolean|string}
         */
        var _ignoreNextKeyup = false;

        /**
         * temporary state where we will ignore the next keypress
         *
         * @type {boolean}
         */
        var _ignoreNextKeypress = false;

        /**
         * are we currently inside of a sequence?
         * type of action ("keyup" or "keydown" or "keypress") or false
         *
         * @type {boolean|string}
         */
        var _nextExpectedAction = false;

        /**
         * resets all sequence counters except for the ones passed in
         *
         * @param {Object} doNotReset
         * @returns void
         */
        function _resetSequences(doNotReset) {
            doNotReset = doNotReset || {};

            var activeSequences = false,
                key;

            for (key in _sequenceLevels) {
                if (doNotReset[key]) {
                    activeSequences = true;
                    continue;
                }
                _sequenceLevels[key] = 0;
            }

            if (!activeSequences) {
                _nextExpectedAction = false;
            }
        }

        /**
         * finds all callbacks that match based on the keycode, modifiers,
         * and action
         *
         * @param {string} character
         * @param {Array} modifiers
         * @param {Event|Object} e
         * @param {string=} sequenceName - name of the sequence we are looking for
         * @param {string=} combination
         * @param {number=} level
         * @returns {Array}
         */
        function _getMatches(character, modifiers, e, sequenceName, combination, level) {
            var i;
            var callback;
            var matches = [];
            var action = e.type;

            // if there are no events related to this keycode
            if (!self._callbacks[character]) {
                return [];
            }

            // if a modifier key is coming up on its own we should allow it
            if (action == 'keyup' && _isModifier(character)) {
                modifiers = [character];
            }

            // loop through all callbacks for the key that was pressed
            // and see if any of them match
            for (i = 0; i < self._callbacks[character].length; ++i) {
                callback = self._callbacks[character][i];

                // if a sequence name is not specified, but this is a sequence at
                // the wrong level then move onto the next match
                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
                    continue;
                }

                // if the action we are looking for doesn't match the action we got
                // then we should keep going
                if (action != callback.action) {
                    continue;
                }

                // if this is a keypress event and the meta key and control key
                // are not pressed that means that we need to only look at the
                // character, otherwise check the modifiers as well
                //
                // chrome will not fire a keypress if meta or control is down
                // safari will fire a keypress if meta or meta+shift is down
                // firefox will fire a keypress if meta or control is down
                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {

                    // when you bind a combination or sequence a second time it
                    // should overwrite the first one.  if a sequenceName or
                    // combination is specified in this call it does just that
                    //
                    // @todo make deleting its own method?
                    var deleteCombo = !sequenceName && callback.combo == combination;
                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
                    if (deleteCombo || deleteSequence) {
                        self._callbacks[character].splice(i, 1);
                    }

                    matches.push(callback);
                }
            }

            return matches;
        }

        /**
         * actually calls the callback function
         *
         * if your callback function returns false this will use the jquery
         * convention - prevent default and stop propogation on the event
         *
         * @param {Function} callback
         * @param {Event} e
         * @returns void
         */
        function _fireCallback(callback, e, combo, sequence) {

            // if this event should not happen stop here
            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
                return;
            }

            if (callback(e, combo) === false) {
                _preventDefault(e);
                _stopPropagation(e);
            }
        }

        /**
         * handles a character key event
         *
         * @param {string} character
         * @param {Array} modifiers
         * @param {Event} e
         * @returns void
         */
        self._handleKey = function(character, modifiers, e) {
            var callbacks = _getMatches(character, modifiers, e);
            var i;
            var doNotReset = {};
            var maxLevel = 0;
            var processedSequenceCallback = false;

            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence
            for (i = 0; i < callbacks.length; ++i) {
                if (callbacks[i].seq) {
                    maxLevel = Math.max(maxLevel, callbacks[i].level);
                }
            }

            // loop through matching callbacks for this key event
            for (i = 0; i < callbacks.length; ++i) {

                // fire for all sequence callbacks
                // this is because if for example you have multiple sequences
                // bound such as "g i" and "g t" they both need to fire the
                // callback for matching g cause otherwise you can only ever
                // match the first one
                if (callbacks[i].seq) {

                    // only fire callbacks for the maxLevel to prevent
                    // subsequences from also firing
                    //
                    // for example 'a option b' should not cause 'option b' to fire
                    // even though 'option b' is part of the other sequence
                    //
                    // any sequences that do not match here will be discarded
                    // below by the _resetSequences call
                    if (callbacks[i].level != maxLevel) {
                        continue;
                    }

                    processedSequenceCallback = true;

                    // keep a list of which sequences were matches for later
                    doNotReset[callbacks[i].seq] = 1;
                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);
                    continue;
                }

                // if there were no sequence matches but we are still here
                // that means this is a regular match so we should fire that
                if (!processedSequenceCallback) {
                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
                }
            }

            // if the key you pressed matches the type of sequence without
            // being a modifier (ie "keyup" or "keypress") then we should
            // reset all sequences that were not matched by this event
            //
            // this is so, for example, if you have the sequence "h a t" and you
            // type "h e a r t" it does not match.  in this case the "e" will
            // cause the sequence to reset
            //
            // modifier keys are ignored because you can have a sequence
            // that contains modifiers such as "enter ctrl+space" and in most
            // cases the modifier key will be pressed before the next key
            //
            // also if you have a sequence such as "ctrl+b a" then pressing the
            // "b" key will trigger a "keypress" and a "keydown"
            //
            // the "keydown" is expected when there is a modifier, but the
            // "keypress" ends up matching the _nextExpectedAction since it occurs
            // after and that causes the sequence to reset
            //
            // we ignore keypresses in a sequence that directly follow a keydown
            // for the same character
            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;
            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
                _resetSequences(doNotReset);
            }

            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';
        };

        /**
         * handles a keydown event
         *
         * @param {Event} e
         * @returns void
         */
        function _handleKeyEvent(e) {

            // normalize e.which for key events
            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
            if (typeof e.which !== 'number') {
                e.which = e.keyCode;
            }

            var character = _characterFromEvent(e);

            // no character found then stop
            if (!character) {
                return;
            }

            // need to use === for the character check because the character can be 0
            if (e.type == 'keyup' && _ignoreNextKeyup === character) {
                _ignoreNextKeyup = false;
                return;
            }

            self.handleKey(character, _eventModifiers(e), e);
        }

        /**
         * called to set a 1 second timeout on the specified sequence
         *
         * this is so after each key press in the sequence you have 1 second
         * to press the next key before you have to start over
         *
         * @returns void
         */
        function _resetSequenceTimer() {
            clearTimeout(_resetTimer);
            _resetTimer = setTimeout(_resetSequences, 1000);
        }

        /**
         * binds a key sequence to an event
         *
         * @param {string} combo - combo specified in bind call
         * @param {Array} keys
         * @param {Function} callback
         * @param {string=} action
         * @returns void
         */
        function _bindSequence(combo, keys, callback, action) {

            // start off by adding a sequence level record for this combination
            // and setting the level to 0
            _sequenceLevels[combo] = 0;

            /**
             * callback to increase the sequence level for this sequence and reset
             * all other sequences that were active
             *
             * @param {string} nextAction
             * @returns {Function}
             */
            function _increaseSequence(nextAction) {
                return function() {
                    _nextExpectedAction = nextAction;
                    ++_sequenceLevels[combo];
                    _resetSequenceTimer();
                };
            }

            /**
             * wraps the specified callback inside of another function in order
             * to reset all sequence counters as soon as this sequence is done
             *
             * @param {Event} e
             * @returns void
             */
            function _callbackAndReset(e) {
                _fireCallback(callback, e, combo);

                // we should ignore the next key up if the action is key down
                // or keypress.  this is so if you finish a sequence and
                // release the key the final key will not trigger a keyup
                if (action !== 'keyup') {
                    _ignoreNextKeyup = _characterFromEvent(e);
                }

                // weird race condition if a sequence ends with the key
                // another sequence begins with
                setTimeout(_resetSequences, 10);
            }

            // loop through keys one at a time and bind the appropriate callback
            // function.  for any key leading up to the final one it should
            // increase the sequence. after the final, it should reset all sequences
            //
            // if an action is specified in the original bind call then that will
            // be used throughout.  otherwise we will pass the action that the
            // next key in the sequence should match.  this allows a sequence
            // to mix and match keypress and keydown events depending on which
            // ones are better suited to the key provided
            for (var i = 0; i < keys.length; ++i) {
                var isFinal = i + 1 === keys.length;
                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);
                _bindSingle(keys[i], wrappedCallback, action, combo, i);
            }
        }

        /**
         * binds a single keyboard combination
         *
         * @param {string} combination
         * @param {Function} callback
         * @param {string=} action
         * @param {string=} sequenceName - name of sequence if part of sequence
         * @param {number=} level - what part of the sequence the command is
         * @returns void
         */
        function _bindSingle(combination, callback, action, sequenceName, level) {

            // store a direct mapped reference for use with Mousetrap.trigger
            self._directMap[combination + ':' + action] = callback;

            // make sure multiple spaces in a row become a single space
            combination = combination.replace(/\s+/g, ' ');

            var sequence = combination.split(' ');
            var info;

            // if this pattern is a sequence of keys then run through this method
            // to reprocess each pattern one key at a time
            if (sequence.length > 1) {
                _bindSequence(combination, sequence, callback, action);
                return;
            }

            info = _getKeyInfo(combination, action);

            // make sure to initialize array if this is the first time
            // a callback is added for this key
            self._callbacks[info.key] = self._callbacks[info.key] || [];

            // remove an existing match if there is one
            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);

            // add this call back to the array
            // if it is a sequence put it at the beginning
            // if not put it at the end
            //
            // this is important because the way these are processed expects
            // the sequence ones to come first
            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({
                callback: callback,
                modifiers: info.modifiers,
                action: info.action,
                seq: sequenceName,
                level: level,
                combo: combination
            });
        }

        /**
         * binds multiple combinations to the same callback
         *
         * @param {Array} combinations
         * @param {Function} callback
         * @param {string|undefined} action
         * @returns void
         */
        self._bindMultiple = function(combinations, callback, action) {
            for (var i = 0; i < combinations.length; ++i) {
                _bindSingle(combinations[i], callback, action);
            }
        };

        // start!
        _addEvent(targetElement, 'keypress', _handleKeyEvent);
        _addEvent(targetElement, 'keydown', _handleKeyEvent);
        _addEvent(targetElement, 'keyup', _handleKeyEvent);
    }

    /**
     * binds an event to mousetrap
     *
     * can be a single key, a combination of keys separated with +,
     * an array of keys, or a sequence of keys separated by spaces
     *
     * be sure to list the modifier keys first to make sure that the
     * correct key ends up getting bound (the last key in the pattern)
     *
     * @param {string|Array} keys
     * @param {Function} callback
     * @param {string=} action - 'keypress', 'keydown', or 'keyup'
     * @returns void
     */
    Mousetrap.prototype.bind = function(keys, callback, action) {
        var self = this;
        keys = keys instanceof Array ? keys : [keys];
        self._bindMultiple.call(self, keys, callback, action);
        return self;
    };

    /**
     * unbinds an event to mousetrap
     *
     * the unbinding sets the callback function of the specified key combo
     * to an empty function and deletes the corresponding key in the
     * _directMap dict.
     *
     * TODO: actually remove this from the _callbacks dictionary instead
     * of binding an empty function
     *
     * the keycombo+action has to be exactly the same as
     * it was defined in the bind method
     *
     * @param {string|Array} keys
     * @param {string} action
     * @returns void
     */
    Mousetrap.prototype.unbind = function(keys, action) {
        var self = this;
        return self.bind.call(self, keys, function() {}, action);
    };

    /**
     * triggers an event that has already been bound
     *
     * @param {string} keys
     * @param {string=} action
     * @returns void
     */
    Mousetrap.prototype.trigger = function(keys, action) {
        var self = this;
        if (self._directMap[keys + ':' + action]) {
            self._directMap[keys + ':' + action]({}, keys);
        }
        return self;
    };

    /**
     * resets the library back to its initial state.  this is useful
     * if you want to clear out the current keyboard shortcuts and bind
     * new ones - for example if you switch to another page
     *
     * @returns void
     */
    Mousetrap.prototype.reset = function() {
        var self = this;
        self._callbacks = {};
        self._directMap = {};
        return self;
    };

    /**
     * should we stop this event before firing off callbacks
     *
     * @param {Event} e
     * @param {Element} element
     * @return {boolean}
     */
    Mousetrap.prototype.stopCallback = function(e, element) {
        var self = this;

        // if the element has the class "mousetrap" then no need to stop
        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
            return false;
        }

        if (_belongsTo(element, self.target)) {
            return false;
        }

        // stop for input, select, and textarea
        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;
    };

    /**
     * exposes _handleKey publicly so it can be overwritten by extensions
     */
    Mousetrap.prototype.handleKey = function() {
        var self = this;
        return self._handleKey.apply(self, arguments);
    };

    /**
     * allow custom key mappings
     */
    Mousetrap.addKeycodes = function(object) {
        for (var key in object) {
            if (object.hasOwnProperty(key)) {
                _MAP[key] = object[key];
            }
        }
        _REVERSE_MAP = null;
    };

    /**
     * Init the global mousetrap functions
     *
     * This method is needed to allow the global mousetrap functions to work
     * now that mousetrap is a constructor function.
     */
    Mousetrap.init = function() {
        var documentMousetrap = Mousetrap(document);
        for (var method in documentMousetrap) {
            if (method.charAt(0) !== '_') {
                Mousetrap[method] = (function(method) {
                    return function() {
                        return documentMousetrap[method].apply(documentMousetrap, arguments);
                    };
                } (method));
            }
        }
    };

    Mousetrap.init();

    // expose mousetrap to the global object
    window.Mousetrap = Mousetrap;

    // expose as a common js module
    if ( true && module.exports) {
        module.exports = Mousetrap;
    }

    // expose mousetrap as an AMD module
    if (true) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
            return Mousetrap;
        }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);


/***/ }),

/***/ "./node_modules/remarkable/index.js":
/*!******************************************!*\
  !*** ./node_modules/remarkable/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./lib/ */ "./node_modules/remarkable/lib/index.js");


/***/ }),

/***/ "./node_modules/remarkable/lib/common/entities.js":
/*!********************************************************!*\
  !*** ./node_modules/remarkable/lib/common/entities.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// List of valid entities
//
// Generate with ./support/entities.js script
//


/*eslint quotes:0*/
module.exports = {
  "Aacute":"\u00C1",
  "aacute":"\u00E1",
  "Abreve":"\u0102",
  "abreve":"\u0103",
  "ac":"\u223E",
  "acd":"\u223F",
  "acE":"\u223E\u0333",
  "Acirc":"\u00C2",
  "acirc":"\u00E2",
  "acute":"\u00B4",
  "Acy":"\u0410",
  "acy":"\u0430",
  "AElig":"\u00C6",
  "aelig":"\u00E6",
  "af":"\u2061",
  "Afr":"\uD835\uDD04",
  "afr":"\uD835\uDD1E",
  "Agrave":"\u00C0",
  "agrave":"\u00E0",
  "alefsym":"\u2135",
  "aleph":"\u2135",
  "Alpha":"\u0391",
  "alpha":"\u03B1",
  "Amacr":"\u0100",
  "amacr":"\u0101",
  "amalg":"\u2A3F",
  "AMP":"\u0026",
  "amp":"\u0026",
  "And":"\u2A53",
  "and":"\u2227",
  "andand":"\u2A55",
  "andd":"\u2A5C",
  "andslope":"\u2A58",
  "andv":"\u2A5A",
  "ang":"\u2220",
  "ange":"\u29A4",
  "angle":"\u2220",
  "angmsd":"\u2221",
  "angmsdaa":"\u29A8",
  "angmsdab":"\u29A9",
  "angmsdac":"\u29AA",
  "angmsdad":"\u29AB",
  "angmsdae":"\u29AC",
  "angmsdaf":"\u29AD",
  "angmsdag":"\u29AE",
  "angmsdah":"\u29AF",
  "angrt":"\u221F",
  "angrtvb":"\u22BE",
  "angrtvbd":"\u299D",
  "angsph":"\u2222",
  "angst":"\u00C5",
  "angzarr":"\u237C",
  "Aogon":"\u0104",
  "aogon":"\u0105",
  "Aopf":"\uD835\uDD38",
  "aopf":"\uD835\uDD52",
  "ap":"\u2248",
  "apacir":"\u2A6F",
  "apE":"\u2A70",
  "ape":"\u224A",
  "apid":"\u224B",
  "apos":"\u0027",
  "ApplyFunction":"\u2061",
  "approx":"\u2248",
  "approxeq":"\u224A",
  "Aring":"\u00C5",
  "aring":"\u00E5",
  "Ascr":"\uD835\uDC9C",
  "ascr":"\uD835\uDCB6",
  "Assign":"\u2254",
  "ast":"\u002A",
  "asymp":"\u2248",
  "asympeq":"\u224D",
  "Atilde":"\u00C3",
  "atilde":"\u00E3",
  "Auml":"\u00C4",
  "auml":"\u00E4",
  "awconint":"\u2233",
  "awint":"\u2A11",
  "backcong":"\u224C",
  "backepsilon":"\u03F6",
  "backprime":"\u2035",
  "backsim":"\u223D",
  "backsimeq":"\u22CD",
  "Backslash":"\u2216",
  "Barv":"\u2AE7",
  "barvee":"\u22BD",
  "Barwed":"\u2306",
  "barwed":"\u2305",
  "barwedge":"\u2305",
  "bbrk":"\u23B5",
  "bbrktbrk":"\u23B6",
  "bcong":"\u224C",
  "Bcy":"\u0411",
  "bcy":"\u0431",
  "bdquo":"\u201E",
  "becaus":"\u2235",
  "Because":"\u2235",
  "because":"\u2235",
  "bemptyv":"\u29B0",
  "bepsi":"\u03F6",
  "bernou":"\u212C",
  "Bernoullis":"\u212C",
  "Beta":"\u0392",
  "beta":"\u03B2",
  "beth":"\u2136",
  "between":"\u226C",
  "Bfr":"\uD835\uDD05",
  "bfr":"\uD835\uDD1F",
  "bigcap":"\u22C2",
  "bigcirc":"\u25EF",
  "bigcup":"\u22C3",
  "bigodot":"\u2A00",
  "bigoplus":"\u2A01",
  "bigotimes":"\u2A02",
  "bigsqcup":"\u2A06",
  "bigstar":"\u2605",
  "bigtriangledown":"\u25BD",
  "bigtriangleup":"\u25B3",
  "biguplus":"\u2A04",
  "bigvee":"\u22C1",
  "bigwedge":"\u22C0",
  "bkarow":"\u290D",
  "blacklozenge":"\u29EB",
  "blacksquare":"\u25AA",
  "blacktriangle":"\u25B4",
  "blacktriangledown":"\u25BE",
  "blacktriangleleft":"\u25C2",
  "blacktriangleright":"\u25B8",
  "blank":"\u2423",
  "blk12":"\u2592",
  "blk14":"\u2591",
  "blk34":"\u2593",
  "block":"\u2588",
  "bne":"\u003D\u20E5",
  "bnequiv":"\u2261\u20E5",
  "bNot":"\u2AED",
  "bnot":"\u2310",
  "Bopf":"\uD835\uDD39",
  "bopf":"\uD835\uDD53",
  "bot":"\u22A5",
  "bottom":"\u22A5",
  "bowtie":"\u22C8",
  "boxbox":"\u29C9",
  "boxDL":"\u2557",
  "boxDl":"\u2556",
  "boxdL":"\u2555",
  "boxdl":"\u2510",
  "boxDR":"\u2554",
  "boxDr":"\u2553",
  "boxdR":"\u2552",
  "boxdr":"\u250C",
  "boxH":"\u2550",
  "boxh":"\u2500",
  "boxHD":"\u2566",
  "boxHd":"\u2564",
  "boxhD":"\u2565",
  "boxhd":"\u252C",
  "boxHU":"\u2569",
  "boxHu":"\u2567",
  "boxhU":"\u2568",
  "boxhu":"\u2534",
  "boxminus":"\u229F",
  "boxplus":"\u229E",
  "boxtimes":"\u22A0",
  "boxUL":"\u255D",
  "boxUl":"\u255C",
  "boxuL":"\u255B",
  "boxul":"\u2518",
  "boxUR":"\u255A",
  "boxUr":"\u2559",
  "boxuR":"\u2558",
  "boxur":"\u2514",
  "boxV":"\u2551",
  "boxv":"\u2502",
  "boxVH":"\u256C",
  "boxVh":"\u256B",
  "boxvH":"\u256A",
  "boxvh":"\u253C",
  "boxVL":"\u2563",
  "boxVl":"\u2562",
  "boxvL":"\u2561",
  "boxvl":"\u2524",
  "boxVR":"\u2560",
  "boxVr":"\u255F",
  "boxvR":"\u255E",
  "boxvr":"\u251C",
  "bprime":"\u2035",
  "Breve":"\u02D8",
  "breve":"\u02D8",
  "brvbar":"\u00A6",
  "Bscr":"\u212C",
  "bscr":"\uD835\uDCB7",
  "bsemi":"\u204F",
  "bsim":"\u223D",
  "bsime":"\u22CD",
  "bsol":"\u005C",
  "bsolb":"\u29C5",
  "bsolhsub":"\u27C8",
  "bull":"\u2022",
  "bullet":"\u2022",
  "bump":"\u224E",
  "bumpE":"\u2AAE",
  "bumpe":"\u224F",
  "Bumpeq":"\u224E",
  "bumpeq":"\u224F",
  "Cacute":"\u0106",
  "cacute":"\u0107",
  "Cap":"\u22D2",
  "cap":"\u2229",
  "capand":"\u2A44",
  "capbrcup":"\u2A49",
  "capcap":"\u2A4B",
  "capcup":"\u2A47",
  "capdot":"\u2A40",
  "CapitalDifferentialD":"\u2145",
  "caps":"\u2229\uFE00",
  "caret":"\u2041",
  "caron":"\u02C7",
  "Cayleys":"\u212D",
  "ccaps":"\u2A4D",
  "Ccaron":"\u010C",
  "ccaron":"\u010D",
  "Ccedil":"\u00C7",
  "ccedil":"\u00E7",
  "Ccirc":"\u0108",
  "ccirc":"\u0109",
  "Cconint":"\u2230",
  "ccups":"\u2A4C",
  "ccupssm":"\u2A50",
  "Cdot":"\u010A",
  "cdot":"\u010B",
  "cedil":"\u00B8",
  "Cedilla":"\u00B8",
  "cemptyv":"\u29B2",
  "cent":"\u00A2",
  "CenterDot":"\u00B7",
  "centerdot":"\u00B7",
  "Cfr":"\u212D",
  "cfr":"\uD835\uDD20",
  "CHcy":"\u0427",
  "chcy":"\u0447",
  "check":"\u2713",
  "checkmark":"\u2713",
  "Chi":"\u03A7",
  "chi":"\u03C7",
  "cir":"\u25CB",
  "circ":"\u02C6",
  "circeq":"\u2257",
  "circlearrowleft":"\u21BA",
  "circlearrowright":"\u21BB",
  "circledast":"\u229B",
  "circledcirc":"\u229A",
  "circleddash":"\u229D",
  "CircleDot":"\u2299",
  "circledR":"\u00AE",
  "circledS":"\u24C8",
  "CircleMinus":"\u2296",
  "CirclePlus":"\u2295",
  "CircleTimes":"\u2297",
  "cirE":"\u29C3",
  "cire":"\u2257",
  "cirfnint":"\u2A10",
  "cirmid":"\u2AEF",
  "cirscir":"\u29C2",
  "ClockwiseContourIntegral":"\u2232",
  "CloseCurlyDoubleQuote":"\u201D",
  "CloseCurlyQuote":"\u2019",
  "clubs":"\u2663",
  "clubsuit":"\u2663",
  "Colon":"\u2237",
  "colon":"\u003A",
  "Colone":"\u2A74",
  "colone":"\u2254",
  "coloneq":"\u2254",
  "comma":"\u002C",
  "commat":"\u0040",
  "comp":"\u2201",
  "compfn":"\u2218",
  "complement":"\u2201",
  "complexes":"\u2102",
  "cong":"\u2245",
  "congdot":"\u2A6D",
  "Congruent":"\u2261",
  "Conint":"\u222F",
  "conint":"\u222E",
  "ContourIntegral":"\u222E",
  "Copf":"\u2102",
  "copf":"\uD835\uDD54",
  "coprod":"\u2210",
  "Coproduct":"\u2210",
  "COPY":"\u00A9",
  "copy":"\u00A9",
  "copysr":"\u2117",
  "CounterClockwiseContourIntegral":"\u2233",
  "crarr":"\u21B5",
  "Cross":"\u2A2F",
  "cross":"\u2717",
  "Cscr":"\uD835\uDC9E",
  "cscr":"\uD835\uDCB8",
  "csub":"\u2ACF",
  "csube":"\u2AD1",
  "csup":"\u2AD0",
  "csupe":"\u2AD2",
  "ctdot":"\u22EF",
  "cudarrl":"\u2938",
  "cudarrr":"\u2935",
  "cuepr":"\u22DE",
  "cuesc":"\u22DF",
  "cularr":"\u21B6",
  "cularrp":"\u293D",
  "Cup":"\u22D3",
  "cup":"\u222A",
  "cupbrcap":"\u2A48",
  "CupCap":"\u224D",
  "cupcap":"\u2A46",
  "cupcup":"\u2A4A",
  "cupdot":"\u228D",
  "cupor":"\u2A45",
  "cups":"\u222A\uFE00",
  "curarr":"\u21B7",
  "curarrm":"\u293C",
  "curlyeqprec":"\u22DE",
  "curlyeqsucc":"\u22DF",
  "curlyvee":"\u22CE",
  "curlywedge":"\u22CF",
  "curren":"\u00A4",
  "curvearrowleft":"\u21B6",
  "curvearrowright":"\u21B7",
  "cuvee":"\u22CE",
  "cuwed":"\u22CF",
  "cwconint":"\u2232",
  "cwint":"\u2231",
  "cylcty":"\u232D",
  "Dagger":"\u2021",
  "dagger":"\u2020",
  "daleth":"\u2138",
  "Darr":"\u21A1",
  "dArr":"\u21D3",
  "darr":"\u2193",
  "dash":"\u2010",
  "Dashv":"\u2AE4",
  "dashv":"\u22A3",
  "dbkarow":"\u290F",
  "dblac":"\u02DD",
  "Dcaron":"\u010E",
  "dcaron":"\u010F",
  "Dcy":"\u0414",
  "dcy":"\u0434",
  "DD":"\u2145",
  "dd":"\u2146",
  "ddagger":"\u2021",
  "ddarr":"\u21CA",
  "DDotrahd":"\u2911",
  "ddotseq":"\u2A77",
  "deg":"\u00B0",
  "Del":"\u2207",
  "Delta":"\u0394",
  "delta":"\u03B4",
  "demptyv":"\u29B1",
  "dfisht":"\u297F",
  "Dfr":"\uD835\uDD07",
  "dfr":"\uD835\uDD21",
  "dHar":"\u2965",
  "dharl":"\u21C3",
  "dharr":"\u21C2",
  "DiacriticalAcute":"\u00B4",
  "DiacriticalDot":"\u02D9",
  "DiacriticalDoubleAcute":"\u02DD",
  "DiacriticalGrave":"\u0060",
  "DiacriticalTilde":"\u02DC",
  "diam":"\u22C4",
  "Diamond":"\u22C4",
  "diamond":"\u22C4",
  "diamondsuit":"\u2666",
  "diams":"\u2666",
  "die":"\u00A8",
  "DifferentialD":"\u2146",
  "digamma":"\u03DD",
  "disin":"\u22F2",
  "div":"\u00F7",
  "divide":"\u00F7",
  "divideontimes":"\u22C7",
  "divonx":"\u22C7",
  "DJcy":"\u0402",
  "djcy":"\u0452",
  "dlcorn":"\u231E",
  "dlcrop":"\u230D",
  "dollar":"\u0024",
  "Dopf":"\uD835\uDD3B",
  "dopf":"\uD835\uDD55",
  "Dot":"\u00A8",
  "dot":"\u02D9",
  "DotDot":"\u20DC",
  "doteq":"\u2250",
  "doteqdot":"\u2251",
  "DotEqual":"\u2250",
  "dotminus":"\u2238",
  "dotplus":"\u2214",
  "dotsquare":"\u22A1",
  "doublebarwedge":"\u2306",
  "DoubleContourIntegral":"\u222F",
  "DoubleDot":"\u00A8",
  "DoubleDownArrow":"\u21D3",
  "DoubleLeftArrow":"\u21D0",
  "DoubleLeftRightArrow":"\u21D4",
  "DoubleLeftTee":"\u2AE4",
  "DoubleLongLeftArrow":"\u27F8",
  "DoubleLongLeftRightArrow":"\u27FA",
  "DoubleLongRightArrow":"\u27F9",
  "DoubleRightArrow":"\u21D2",
  "DoubleRightTee":"\u22A8",
  "DoubleUpArrow":"\u21D1",
  "DoubleUpDownArrow":"\u21D5",
  "DoubleVerticalBar":"\u2225",
  "DownArrow":"\u2193",
  "Downarrow":"\u21D3",
  "downarrow":"\u2193",
  "DownArrowBar":"\u2913",
  "DownArrowUpArrow":"\u21F5",
  "DownBreve":"\u0311",
  "downdownarrows":"\u21CA",
  "downharpoonleft":"\u21C3",
  "downharpoonright":"\u21C2",
  "DownLeftRightVector":"\u2950",
  "DownLeftTeeVector":"\u295E",
  "DownLeftVector":"\u21BD",
  "DownLeftVectorBar":"\u2956",
  "DownRightTeeVector":"\u295F",
  "DownRightVector":"\u21C1",
  "DownRightVectorBar":"\u2957",
  "DownTee":"\u22A4",
  "DownTeeArrow":"\u21A7",
  "drbkarow":"\u2910",
  "drcorn":"\u231F",
  "drcrop":"\u230C",
  "Dscr":"\uD835\uDC9F",
  "dscr":"\uD835\uDCB9",
  "DScy":"\u0405",
  "dscy":"\u0455",
  "dsol":"\u29F6",
  "Dstrok":"\u0110",
  "dstrok":"\u0111",
  "dtdot":"\u22F1",
  "dtri":"\u25BF",
  "dtrif":"\u25BE",
  "duarr":"\u21F5",
  "duhar":"\u296F",
  "dwangle":"\u29A6",
  "DZcy":"\u040F",
  "dzcy":"\u045F",
  "dzigrarr":"\u27FF",
  "Eacute":"\u00C9",
  "eacute":"\u00E9",
  "easter":"\u2A6E",
  "Ecaron":"\u011A",
  "ecaron":"\u011B",
  "ecir":"\u2256",
  "Ecirc":"\u00CA",
  "ecirc":"\u00EA",
  "ecolon":"\u2255",
  "Ecy":"\u042D",
  "ecy":"\u044D",
  "eDDot":"\u2A77",
  "Edot":"\u0116",
  "eDot":"\u2251",
  "edot":"\u0117",
  "ee":"\u2147",
  "efDot":"\u2252",
  "Efr":"\uD835\uDD08",
  "efr":"\uD835\uDD22",
  "eg":"\u2A9A",
  "Egrave":"\u00C8",
  "egrave":"\u00E8",
  "egs":"\u2A96",
  "egsdot":"\u2A98",
  "el":"\u2A99",
  "Element":"\u2208",
  "elinters":"\u23E7",
  "ell":"\u2113",
  "els":"\u2A95",
  "elsdot":"\u2A97",
  "Emacr":"\u0112",
  "emacr":"\u0113",
  "empty":"\u2205",
  "emptyset":"\u2205",
  "EmptySmallSquare":"\u25FB",
  "emptyv":"\u2205",
  "EmptyVerySmallSquare":"\u25AB",
  "emsp":"\u2003",
  "emsp13":"\u2004",
  "emsp14":"\u2005",
  "ENG":"\u014A",
  "eng":"\u014B",
  "ensp":"\u2002",
  "Eogon":"\u0118",
  "eogon":"\u0119",
  "Eopf":"\uD835\uDD3C",
  "eopf":"\uD835\uDD56",
  "epar":"\u22D5",
  "eparsl":"\u29E3",
  "eplus":"\u2A71",
  "epsi":"\u03B5",
  "Epsilon":"\u0395",
  "epsilon":"\u03B5",
  "epsiv":"\u03F5",
  "eqcirc":"\u2256",
  "eqcolon":"\u2255",
  "eqsim":"\u2242",
  "eqslantgtr":"\u2A96",
  "eqslantless":"\u2A95",
  "Equal":"\u2A75",
  "equals":"\u003D",
  "EqualTilde":"\u2242",
  "equest":"\u225F",
  "Equilibrium":"\u21CC",
  "equiv":"\u2261",
  "equivDD":"\u2A78",
  "eqvparsl":"\u29E5",
  "erarr":"\u2971",
  "erDot":"\u2253",
  "Escr":"\u2130",
  "escr":"\u212F",
  "esdot":"\u2250",
  "Esim":"\u2A73",
  "esim":"\u2242",
  "Eta":"\u0397",
  "eta":"\u03B7",
  "ETH":"\u00D0",
  "eth":"\u00F0",
  "Euml":"\u00CB",
  "euml":"\u00EB",
  "euro":"\u20AC",
  "excl":"\u0021",
  "exist":"\u2203",
  "Exists":"\u2203",
  "expectation":"\u2130",
  "ExponentialE":"\u2147",
  "exponentiale":"\u2147",
  "fallingdotseq":"\u2252",
  "Fcy":"\u0424",
  "fcy":"\u0444",
  "female":"\u2640",
  "ffilig":"\uFB03",
  "fflig":"\uFB00",
  "ffllig":"\uFB04",
  "Ffr":"\uD835\uDD09",
  "ffr":"\uD835\uDD23",
  "filig":"\uFB01",
  "FilledSmallSquare":"\u25FC",
  "FilledVerySmallSquare":"\u25AA",
  "fjlig":"\u0066\u006A",
  "flat":"\u266D",
  "fllig":"\uFB02",
  "fltns":"\u25B1",
  "fnof":"\u0192",
  "Fopf":"\uD835\uDD3D",
  "fopf":"\uD835\uDD57",
  "ForAll":"\u2200",
  "forall":"\u2200",
  "fork":"\u22D4",
  "forkv":"\u2AD9",
  "Fouriertrf":"\u2131",
  "fpartint":"\u2A0D",
  "frac12":"\u00BD",
  "frac13":"\u2153",
  "frac14":"\u00BC",
  "frac15":"\u2155",
  "frac16":"\u2159",
  "frac18":"\u215B",
  "frac23":"\u2154",
  "frac25":"\u2156",
  "frac34":"\u00BE",
  "frac35":"\u2157",
  "frac38":"\u215C",
  "frac45":"\u2158",
  "frac56":"\u215A",
  "frac58":"\u215D",
  "frac78":"\u215E",
  "frasl":"\u2044",
  "frown":"\u2322",
  "Fscr":"\u2131",
  "fscr":"\uD835\uDCBB",
  "gacute":"\u01F5",
  "Gamma":"\u0393",
  "gamma":"\u03B3",
  "Gammad":"\u03DC",
  "gammad":"\u03DD",
  "gap":"\u2A86",
  "Gbreve":"\u011E",
  "gbreve":"\u011F",
  "Gcedil":"\u0122",
  "Gcirc":"\u011C",
  "gcirc":"\u011D",
  "Gcy":"\u0413",
  "gcy":"\u0433",
  "Gdot":"\u0120",
  "gdot":"\u0121",
  "gE":"\u2267",
  "ge":"\u2265",
  "gEl":"\u2A8C",
  "gel":"\u22DB",
  "geq":"\u2265",
  "geqq":"\u2267",
  "geqslant":"\u2A7E",
  "ges":"\u2A7E",
  "gescc":"\u2AA9",
  "gesdot":"\u2A80",
  "gesdoto":"\u2A82",
  "gesdotol":"\u2A84",
  "gesl":"\u22DB\uFE00",
  "gesles":"\u2A94",
  "Gfr":"\uD835\uDD0A",
  "gfr":"\uD835\uDD24",
  "Gg":"\u22D9",
  "gg":"\u226B",
  "ggg":"\u22D9",
  "gimel":"\u2137",
  "GJcy":"\u0403",
  "gjcy":"\u0453",
  "gl":"\u2277",
  "gla":"\u2AA5",
  "glE":"\u2A92",
  "glj":"\u2AA4",
  "gnap":"\u2A8A",
  "gnapprox":"\u2A8A",
  "gnE":"\u2269",
  "gne":"\u2A88",
  "gneq":"\u2A88",
  "gneqq":"\u2269",
  "gnsim":"\u22E7",
  "Gopf":"\uD835\uDD3E",
  "gopf":"\uD835\uDD58",
  "grave":"\u0060",
  "GreaterEqual":"\u2265",
  "GreaterEqualLess":"\u22DB",
  "GreaterFullEqual":"\u2267",
  "GreaterGreater":"\u2AA2",
  "GreaterLess":"\u2277",
  "GreaterSlantEqual":"\u2A7E",
  "GreaterTilde":"\u2273",
  "Gscr":"\uD835\uDCA2",
  "gscr":"\u210A",
  "gsim":"\u2273",
  "gsime":"\u2A8E",
  "gsiml":"\u2A90",
  "GT":"\u003E",
  "Gt":"\u226B",
  "gt":"\u003E",
  "gtcc":"\u2AA7",
  "gtcir":"\u2A7A",
  "gtdot":"\u22D7",
  "gtlPar":"\u2995",
  "gtquest":"\u2A7C",
  "gtrapprox":"\u2A86",
  "gtrarr":"\u2978",
  "gtrdot":"\u22D7",
  "gtreqless":"\u22DB",
  "gtreqqless":"\u2A8C",
  "gtrless":"\u2277",
  "gtrsim":"\u2273",
  "gvertneqq":"\u2269\uFE00",
  "gvnE":"\u2269\uFE00",
  "Hacek":"\u02C7",
  "hairsp":"\u200A",
  "half":"\u00BD",
  "hamilt":"\u210B",
  "HARDcy":"\u042A",
  "hardcy":"\u044A",
  "hArr":"\u21D4",
  "harr":"\u2194",
  "harrcir":"\u2948",
  "harrw":"\u21AD",
  "Hat":"\u005E",
  "hbar":"\u210F",
  "Hcirc":"\u0124",
  "hcirc":"\u0125",
  "hearts":"\u2665",
  "heartsuit":"\u2665",
  "hellip":"\u2026",
  "hercon":"\u22B9",
  "Hfr":"\u210C",
  "hfr":"\uD835\uDD25",
  "HilbertSpace":"\u210B",
  "hksearow":"\u2925",
  "hkswarow":"\u2926",
  "hoarr":"\u21FF",
  "homtht":"\u223B",
  "hookleftarrow":"\u21A9",
  "hookrightarrow":"\u21AA",
  "Hopf":"\u210D",
  "hopf":"\uD835\uDD59",
  "horbar":"\u2015",
  "HorizontalLine":"\u2500",
  "Hscr":"\u210B",
  "hscr":"\uD835\uDCBD",
  "hslash":"\u210F",
  "Hstrok":"\u0126",
  "hstrok":"\u0127",
  "HumpDownHump":"\u224E",
  "HumpEqual":"\u224F",
  "hybull":"\u2043",
  "hyphen":"\u2010",
  "Iacute":"\u00CD",
  "iacute":"\u00ED",
  "ic":"\u2063",
  "Icirc":"\u00CE",
  "icirc":"\u00EE",
  "Icy":"\u0418",
  "icy":"\u0438",
  "Idot":"\u0130",
  "IEcy":"\u0415",
  "iecy":"\u0435",
  "iexcl":"\u00A1",
  "iff":"\u21D4",
  "Ifr":"\u2111",
  "ifr":"\uD835\uDD26",
  "Igrave":"\u00CC",
  "igrave":"\u00EC",
  "ii":"\u2148",
  "iiiint":"\u2A0C",
  "iiint":"\u222D",
  "iinfin":"\u29DC",
  "iiota":"\u2129",
  "IJlig":"\u0132",
  "ijlig":"\u0133",
  "Im":"\u2111",
  "Imacr":"\u012A",
  "imacr":"\u012B",
  "image":"\u2111",
  "ImaginaryI":"\u2148",
  "imagline":"\u2110",
  "imagpart":"\u2111",
  "imath":"\u0131",
  "imof":"\u22B7",
  "imped":"\u01B5",
  "Implies":"\u21D2",
  "in":"\u2208",
  "incare":"\u2105",
  "infin":"\u221E",
  "infintie":"\u29DD",
  "inodot":"\u0131",
  "Int":"\u222C",
  "int":"\u222B",
  "intcal":"\u22BA",
  "integers":"\u2124",
  "Integral":"\u222B",
  "intercal":"\u22BA",
  "Intersection":"\u22C2",
  "intlarhk":"\u2A17",
  "intprod":"\u2A3C",
  "InvisibleComma":"\u2063",
  "InvisibleTimes":"\u2062",
  "IOcy":"\u0401",
  "iocy":"\u0451",
  "Iogon":"\u012E",
  "iogon":"\u012F",
  "Iopf":"\uD835\uDD40",
  "iopf":"\uD835\uDD5A",
  "Iota":"\u0399",
  "iota":"\u03B9",
  "iprod":"\u2A3C",
  "iquest":"\u00BF",
  "Iscr":"\u2110",
  "iscr":"\uD835\uDCBE",
  "isin":"\u2208",
  "isindot":"\u22F5",
  "isinE":"\u22F9",
  "isins":"\u22F4",
  "isinsv":"\u22F3",
  "isinv":"\u2208",
  "it":"\u2062",
  "Itilde":"\u0128",
  "itilde":"\u0129",
  "Iukcy":"\u0406",
  "iukcy":"\u0456",
  "Iuml":"\u00CF",
  "iuml":"\u00EF",
  "Jcirc":"\u0134",
  "jcirc":"\u0135",
  "Jcy":"\u0419",
  "jcy":"\u0439",
  "Jfr":"\uD835\uDD0D",
  "jfr":"\uD835\uDD27",
  "jmath":"\u0237",
  "Jopf":"\uD835\uDD41",
  "jopf":"\uD835\uDD5B",
  "Jscr":"\uD835\uDCA5",
  "jscr":"\uD835\uDCBF",
  "Jsercy":"\u0408",
  "jsercy":"\u0458",
  "Jukcy":"\u0404",
  "jukcy":"\u0454",
  "Kappa":"\u039A",
  "kappa":"\u03BA",
  "kappav":"\u03F0",
  "Kcedil":"\u0136",
  "kcedil":"\u0137",
  "Kcy":"\u041A",
  "kcy":"\u043A",
  "Kfr":"\uD835\uDD0E",
  "kfr":"\uD835\uDD28",
  "kgreen":"\u0138",
  "KHcy":"\u0425",
  "khcy":"\u0445",
  "KJcy":"\u040C",
  "kjcy":"\u045C",
  "Kopf":"\uD835\uDD42",
  "kopf":"\uD835\uDD5C",
  "Kscr":"\uD835\uDCA6",
  "kscr":"\uD835\uDCC0",
  "lAarr":"\u21DA",
  "Lacute":"\u0139",
  "lacute":"\u013A",
  "laemptyv":"\u29B4",
  "lagran":"\u2112",
  "Lambda":"\u039B",
  "lambda":"\u03BB",
  "Lang":"\u27EA",
  "lang":"\u27E8",
  "langd":"\u2991",
  "langle":"\u27E8",
  "lap":"\u2A85",
  "Laplacetrf":"\u2112",
  "laquo":"\u00AB",
  "Larr":"\u219E",
  "lArr":"\u21D0",
  "larr":"\u2190",
  "larrb":"\u21E4",
  "larrbfs":"\u291F",
  "larrfs":"\u291D",
  "larrhk":"\u21A9",
  "larrlp":"\u21AB",
  "larrpl":"\u2939",
  "larrsim":"\u2973",
  "larrtl":"\u21A2",
  "lat":"\u2AAB",
  "lAtail":"\u291B",
  "latail":"\u2919",
  "late":"\u2AAD",
  "lates":"\u2AAD\uFE00",
  "lBarr":"\u290E",
  "lbarr":"\u290C",
  "lbbrk":"\u2772",
  "lbrace":"\u007B",
  "lbrack":"\u005B",
  "lbrke":"\u298B",
  "lbrksld":"\u298F",
  "lbrkslu":"\u298D",
  "Lcaron":"\u013D",
  "lcaron":"\u013E",
  "Lcedil":"\u013B",
  "lcedil":"\u013C",
  "lceil":"\u2308",
  "lcub":"\u007B",
  "Lcy":"\u041B",
  "lcy":"\u043B",
  "ldca":"\u2936",
  "ldquo":"\u201C",
  "ldquor":"\u201E",
  "ldrdhar":"\u2967",
  "ldrushar":"\u294B",
  "ldsh":"\u21B2",
  "lE":"\u2266",
  "le":"\u2264",
  "LeftAngleBracket":"\u27E8",
  "LeftArrow":"\u2190",
  "Leftarrow":"\u21D0",
  "leftarrow":"\u2190",
  "LeftArrowBar":"\u21E4",
  "LeftArrowRightArrow":"\u21C6",
  "leftarrowtail":"\u21A2",
  "LeftCeiling":"\u2308",
  "LeftDoubleBracket":"\u27E6",
  "LeftDownTeeVector":"\u2961",
  "LeftDownVector":"\u21C3",
  "LeftDownVectorBar":"\u2959",
  "LeftFloor":"\u230A",
  "leftharpoondown":"\u21BD",
  "leftharpoonup":"\u21BC",
  "leftleftarrows":"\u21C7",
  "LeftRightArrow":"\u2194",
  "Leftrightarrow":"\u21D4",
  "leftrightarrow":"\u2194",
  "leftrightarrows":"\u21C6",
  "leftrightharpoons":"\u21CB",
  "leftrightsquigarrow":"\u21AD",
  "LeftRightVector":"\u294E",
  "LeftTee":"\u22A3",
  "LeftTeeArrow":"\u21A4",
  "LeftTeeVector":"\u295A",
  "leftthreetimes":"\u22CB",
  "LeftTriangle":"\u22B2",
  "LeftTriangleBar":"\u29CF",
  "LeftTriangleEqual":"\u22B4",
  "LeftUpDownVector":"\u2951",
  "LeftUpTeeVector":"\u2960",
  "LeftUpVector":"\u21BF",
  "LeftUpVectorBar":"\u2958",
  "LeftVector":"\u21BC",
  "LeftVectorBar":"\u2952",
  "lEg":"\u2A8B",
  "leg":"\u22DA",
  "leq":"\u2264",
  "leqq":"\u2266",
  "leqslant":"\u2A7D",
  "les":"\u2A7D",
  "lescc":"\u2AA8",
  "lesdot":"\u2A7F",
  "lesdoto":"\u2A81",
  "lesdotor":"\u2A83",
  "lesg":"\u22DA\uFE00",
  "lesges":"\u2A93",
  "lessapprox":"\u2A85",
  "lessdot":"\u22D6",
  "lesseqgtr":"\u22DA",
  "lesseqqgtr":"\u2A8B",
  "LessEqualGreater":"\u22DA",
  "LessFullEqual":"\u2266",
  "LessGreater":"\u2276",
  "lessgtr":"\u2276",
  "LessLess":"\u2AA1",
  "lesssim":"\u2272",
  "LessSlantEqual":"\u2A7D",
  "LessTilde":"\u2272",
  "lfisht":"\u297C",
  "lfloor":"\u230A",
  "Lfr":"\uD835\uDD0F",
  "lfr":"\uD835\uDD29",
  "lg":"\u2276",
  "lgE":"\u2A91",
  "lHar":"\u2962",
  "lhard":"\u21BD",
  "lharu":"\u21BC",
  "lharul":"\u296A",
  "lhblk":"\u2584",
  "LJcy":"\u0409",
  "ljcy":"\u0459",
  "Ll":"\u22D8",
  "ll":"\u226A",
  "llarr":"\u21C7",
  "llcorner":"\u231E",
  "Lleftarrow":"\u21DA",
  "llhard":"\u296B",
  "lltri":"\u25FA",
  "Lmidot":"\u013F",
  "lmidot":"\u0140",
  "lmoust":"\u23B0",
  "lmoustache":"\u23B0",
  "lnap":"\u2A89",
  "lnapprox":"\u2A89",
  "lnE":"\u2268",
  "lne":"\u2A87",
  "lneq":"\u2A87",
  "lneqq":"\u2268",
  "lnsim":"\u22E6",
  "loang":"\u27EC",
  "loarr":"\u21FD",
  "lobrk":"\u27E6",
  "LongLeftArrow":"\u27F5",
  "Longleftarrow":"\u27F8",
  "longleftarrow":"\u27F5",
  "LongLeftRightArrow":"\u27F7",
  "Longleftrightarrow":"\u27FA",
  "longleftrightarrow":"\u27F7",
  "longmapsto":"\u27FC",
  "LongRightArrow":"\u27F6",
  "Longrightarrow":"\u27F9",
  "longrightarrow":"\u27F6",
  "looparrowleft":"\u21AB",
  "looparrowright":"\u21AC",
  "lopar":"\u2985",
  "Lopf":"\uD835\uDD43",
  "lopf":"\uD835\uDD5D",
  "loplus":"\u2A2D",
  "lotimes":"\u2A34",
  "lowast":"\u2217",
  "lowbar":"\u005F",
  "LowerLeftArrow":"\u2199",
  "LowerRightArrow":"\u2198",
  "loz":"\u25CA",
  "lozenge":"\u25CA",
  "lozf":"\u29EB",
  "lpar":"\u0028",
  "lparlt":"\u2993",
  "lrarr":"\u21C6",
  "lrcorner":"\u231F",
  "lrhar":"\u21CB",
  "lrhard":"\u296D",
  "lrm":"\u200E",
  "lrtri":"\u22BF",
  "lsaquo":"\u2039",
  "Lscr":"\u2112",
  "lscr":"\uD835\uDCC1",
  "Lsh":"\u21B0",
  "lsh":"\u21B0",
  "lsim":"\u2272",
  "lsime":"\u2A8D",
  "lsimg":"\u2A8F",
  "lsqb":"\u005B",
  "lsquo":"\u2018",
  "lsquor":"\u201A",
  "Lstrok":"\u0141",
  "lstrok":"\u0142",
  "LT":"\u003C",
  "Lt":"\u226A",
  "lt":"\u003C",
  "ltcc":"\u2AA6",
  "ltcir":"\u2A79",
  "ltdot":"\u22D6",
  "lthree":"\u22CB",
  "ltimes":"\u22C9",
  "ltlarr":"\u2976",
  "ltquest":"\u2A7B",
  "ltri":"\u25C3",
  "ltrie":"\u22B4",
  "ltrif":"\u25C2",
  "ltrPar":"\u2996",
  "lurdshar":"\u294A",
  "luruhar":"\u2966",
  "lvertneqq":"\u2268\uFE00",
  "lvnE":"\u2268\uFE00",
  "macr":"\u00AF",
  "male":"\u2642",
  "malt":"\u2720",
  "maltese":"\u2720",
  "Map":"\u2905",
  "map":"\u21A6",
  "mapsto":"\u21A6",
  "mapstodown":"\u21A7",
  "mapstoleft":"\u21A4",
  "mapstoup":"\u21A5",
  "marker":"\u25AE",
  "mcomma":"\u2A29",
  "Mcy":"\u041C",
  "mcy":"\u043C",
  "mdash":"\u2014",
  "mDDot":"\u223A",
  "measuredangle":"\u2221",
  "MediumSpace":"\u205F",
  "Mellintrf":"\u2133",
  "Mfr":"\uD835\uDD10",
  "mfr":"\uD835\uDD2A",
  "mho":"\u2127",
  "micro":"\u00B5",
  "mid":"\u2223",
  "midast":"\u002A",
  "midcir":"\u2AF0",
  "middot":"\u00B7",
  "minus":"\u2212",
  "minusb":"\u229F",
  "minusd":"\u2238",
  "minusdu":"\u2A2A",
  "MinusPlus":"\u2213",
  "mlcp":"\u2ADB",
  "mldr":"\u2026",
  "mnplus":"\u2213",
  "models":"\u22A7",
  "Mopf":"\uD835\uDD44",
  "mopf":"\uD835\uDD5E",
  "mp":"\u2213",
  "Mscr":"\u2133",
  "mscr":"\uD835\uDCC2",
  "mstpos":"\u223E",
  "Mu":"\u039C",
  "mu":"\u03BC",
  "multimap":"\u22B8",
  "mumap":"\u22B8",
  "nabla":"\u2207",
  "Nacute":"\u0143",
  "nacute":"\u0144",
  "nang":"\u2220\u20D2",
  "nap":"\u2249",
  "napE":"\u2A70\u0338",
  "napid":"\u224B\u0338",
  "napos":"\u0149",
  "napprox":"\u2249",
  "natur":"\u266E",
  "natural":"\u266E",
  "naturals":"\u2115",
  "nbsp":"\u00A0",
  "nbump":"\u224E\u0338",
  "nbumpe":"\u224F\u0338",
  "ncap":"\u2A43",
  "Ncaron":"\u0147",
  "ncaron":"\u0148",
  "Ncedil":"\u0145",
  "ncedil":"\u0146",
  "ncong":"\u2247",
  "ncongdot":"\u2A6D\u0338",
  "ncup":"\u2A42",
  "Ncy":"\u041D",
  "ncy":"\u043D",
  "ndash":"\u2013",
  "ne":"\u2260",
  "nearhk":"\u2924",
  "neArr":"\u21D7",
  "nearr":"\u2197",
  "nearrow":"\u2197",
  "nedot":"\u2250\u0338",
  "NegativeMediumSpace":"\u200B",
  "NegativeThickSpace":"\u200B",
  "NegativeThinSpace":"\u200B",
  "NegativeVeryThinSpace":"\u200B",
  "nequiv":"\u2262",
  "nesear":"\u2928",
  "nesim":"\u2242\u0338",
  "NestedGreaterGreater":"\u226B",
  "NestedLessLess":"\u226A",
  "NewLine":"\u000A",
  "nexist":"\u2204",
  "nexists":"\u2204",
  "Nfr":"\uD835\uDD11",
  "nfr":"\uD835\uDD2B",
  "ngE":"\u2267\u0338",
  "nge":"\u2271",
  "ngeq":"\u2271",
  "ngeqq":"\u2267\u0338",
  "ngeqslant":"\u2A7E\u0338",
  "nges":"\u2A7E\u0338",
  "nGg":"\u22D9\u0338",
  "ngsim":"\u2275",
  "nGt":"\u226B\u20D2",
  "ngt":"\u226F",
  "ngtr":"\u226F",
  "nGtv":"\u226B\u0338",
  "nhArr":"\u21CE",
  "nharr":"\u21AE",
  "nhpar":"\u2AF2",
  "ni":"\u220B",
  "nis":"\u22FC",
  "nisd":"\u22FA",
  "niv":"\u220B",
  "NJcy":"\u040A",
  "njcy":"\u045A",
  "nlArr":"\u21CD",
  "nlarr":"\u219A",
  "nldr":"\u2025",
  "nlE":"\u2266\u0338",
  "nle":"\u2270",
  "nLeftarrow":"\u21CD",
  "nleftarrow":"\u219A",
  "nLeftrightarrow":"\u21CE",
  "nleftrightarrow":"\u21AE",
  "nleq":"\u2270",
  "nleqq":"\u2266\u0338",
  "nleqslant":"\u2A7D\u0338",
  "nles":"\u2A7D\u0338",
  "nless":"\u226E",
  "nLl":"\u22D8\u0338",
  "nlsim":"\u2274",
  "nLt":"\u226A\u20D2",
  "nlt":"\u226E",
  "nltri":"\u22EA",
  "nltrie":"\u22EC",
  "nLtv":"\u226A\u0338",
  "nmid":"\u2224",
  "NoBreak":"\u2060",
  "NonBreakingSpace":"\u00A0",
  "Nopf":"\u2115",
  "nopf":"\uD835\uDD5F",
  "Not":"\u2AEC",
  "not":"\u00AC",
  "NotCongruent":"\u2262",
  "NotCupCap":"\u226D",
  "NotDoubleVerticalBar":"\u2226",
  "NotElement":"\u2209",
  "NotEqual":"\u2260",
  "NotEqualTilde":"\u2242\u0338",
  "NotExists":"\u2204",
  "NotGreater":"\u226F",
  "NotGreaterEqual":"\u2271",
  "NotGreaterFullEqual":"\u2267\u0338",
  "NotGreaterGreater":"\u226B\u0338",
  "NotGreaterLess":"\u2279",
  "NotGreaterSlantEqual":"\u2A7E\u0338",
  "NotGreaterTilde":"\u2275",
  "NotHumpDownHump":"\u224E\u0338",
  "NotHumpEqual":"\u224F\u0338",
  "notin":"\u2209",
  "notindot":"\u22F5\u0338",
  "notinE":"\u22F9\u0338",
  "notinva":"\u2209",
  "notinvb":"\u22F7",
  "notinvc":"\u22F6",
  "NotLeftTriangle":"\u22EA",
  "NotLeftTriangleBar":"\u29CF\u0338",
  "NotLeftTriangleEqual":"\u22EC",
  "NotLess":"\u226E",
  "NotLessEqual":"\u2270",
  "NotLessGreater":"\u2278",
  "NotLessLess":"\u226A\u0338",
  "NotLessSlantEqual":"\u2A7D\u0338",
  "NotLessTilde":"\u2274",
  "NotNestedGreaterGreater":"\u2AA2\u0338",
  "NotNestedLessLess":"\u2AA1\u0338",
  "notni":"\u220C",
  "notniva":"\u220C",
  "notnivb":"\u22FE",
  "notnivc":"\u22FD",
  "NotPrecedes":"\u2280",
  "NotPrecedesEqual":"\u2AAF\u0338",
  "NotPrecedesSlantEqual":"\u22E0",
  "NotReverseElement":"\u220C",
  "NotRightTriangle":"\u22EB",
  "NotRightTriangleBar":"\u29D0\u0338",
  "NotRightTriangleEqual":"\u22ED",
  "NotSquareSubset":"\u228F\u0338",
  "NotSquareSubsetEqual":"\u22E2",
  "NotSquareSuperset":"\u2290\u0338",
  "NotSquareSupersetEqual":"\u22E3",
  "NotSubset":"\u2282\u20D2",
  "NotSubsetEqual":"\u2288",
  "NotSucceeds":"\u2281",
  "NotSucceedsEqual":"\u2AB0\u0338",
  "NotSucceedsSlantEqual":"\u22E1",
  "NotSucceedsTilde":"\u227F\u0338",
  "NotSuperset":"\u2283\u20D2",
  "NotSupersetEqual":"\u2289",
  "NotTilde":"\u2241",
  "NotTildeEqual":"\u2244",
  "NotTildeFullEqual":"\u2247",
  "NotTildeTilde":"\u2249",
  "NotVerticalBar":"\u2224",
  "npar":"\u2226",
  "nparallel":"\u2226",
  "nparsl":"\u2AFD\u20E5",
  "npart":"\u2202\u0338",
  "npolint":"\u2A14",
  "npr":"\u2280",
  "nprcue":"\u22E0",
  "npre":"\u2AAF\u0338",
  "nprec":"\u2280",
  "npreceq":"\u2AAF\u0338",
  "nrArr":"\u21CF",
  "nrarr":"\u219B",
  "nrarrc":"\u2933\u0338",
  "nrarrw":"\u219D\u0338",
  "nRightarrow":"\u21CF",
  "nrightarrow":"\u219B",
  "nrtri":"\u22EB",
  "nrtrie":"\u22ED",
  "nsc":"\u2281",
  "nsccue":"\u22E1",
  "nsce":"\u2AB0\u0338",
  "Nscr":"\uD835\uDCA9",
  "nscr":"\uD835\uDCC3",
  "nshortmid":"\u2224",
  "nshortparallel":"\u2226",
  "nsim":"\u2241",
  "nsime":"\u2244",
  "nsimeq":"\u2244",
  "nsmid":"\u2224",
  "nspar":"\u2226",
  "nsqsube":"\u22E2",
  "nsqsupe":"\u22E3",
  "nsub":"\u2284",
  "nsubE":"\u2AC5\u0338",
  "nsube":"\u2288",
  "nsubset":"\u2282\u20D2",
  "nsubseteq":"\u2288",
  "nsubseteqq":"\u2AC5\u0338",
  "nsucc":"\u2281",
  "nsucceq":"\u2AB0\u0338",
  "nsup":"\u2285",
  "nsupE":"\u2AC6\u0338",
  "nsupe":"\u2289",
  "nsupset":"\u2283\u20D2",
  "nsupseteq":"\u2289",
  "nsupseteqq":"\u2AC6\u0338",
  "ntgl":"\u2279",
  "Ntilde":"\u00D1",
  "ntilde":"\u00F1",
  "ntlg":"\u2278",
  "ntriangleleft":"\u22EA",
  "ntrianglelefteq":"\u22EC",
  "ntriangleright":"\u22EB",
  "ntrianglerighteq":"\u22ED",
  "Nu":"\u039D",
  "nu":"\u03BD",
  "num":"\u0023",
  "numero":"\u2116",
  "numsp":"\u2007",
  "nvap":"\u224D\u20D2",
  "nVDash":"\u22AF",
  "nVdash":"\u22AE",
  "nvDash":"\u22AD",
  "nvdash":"\u22AC",
  "nvge":"\u2265\u20D2",
  "nvgt":"\u003E\u20D2",
  "nvHarr":"\u2904",
  "nvinfin":"\u29DE",
  "nvlArr":"\u2902",
  "nvle":"\u2264\u20D2",
  "nvlt":"\u003C\u20D2",
  "nvltrie":"\u22B4\u20D2",
  "nvrArr":"\u2903",
  "nvrtrie":"\u22B5\u20D2",
  "nvsim":"\u223C\u20D2",
  "nwarhk":"\u2923",
  "nwArr":"\u21D6",
  "nwarr":"\u2196",
  "nwarrow":"\u2196",
  "nwnear":"\u2927",
  "Oacute":"\u00D3",
  "oacute":"\u00F3",
  "oast":"\u229B",
  "ocir":"\u229A",
  "Ocirc":"\u00D4",
  "ocirc":"\u00F4",
  "Ocy":"\u041E",
  "ocy":"\u043E",
  "odash":"\u229D",
  "Odblac":"\u0150",
  "odblac":"\u0151",
  "odiv":"\u2A38",
  "odot":"\u2299",
  "odsold":"\u29BC",
  "OElig":"\u0152",
  "oelig":"\u0153",
  "ofcir":"\u29BF",
  "Ofr":"\uD835\uDD12",
  "ofr":"\uD835\uDD2C",
  "ogon":"\u02DB",
  "Ograve":"\u00D2",
  "ograve":"\u00F2",
  "ogt":"\u29C1",
  "ohbar":"\u29B5",
  "ohm":"\u03A9",
  "oint":"\u222E",
  "olarr":"\u21BA",
  "olcir":"\u29BE",
  "olcross":"\u29BB",
  "oline":"\u203E",
  "olt":"\u29C0",
  "Omacr":"\u014C",
  "omacr":"\u014D",
  "Omega":"\u03A9",
  "omega":"\u03C9",
  "Omicron":"\u039F",
  "omicron":"\u03BF",
  "omid":"\u29B6",
  "ominus":"\u2296",
  "Oopf":"\uD835\uDD46",
  "oopf":"\uD835\uDD60",
  "opar":"\u29B7",
  "OpenCurlyDoubleQuote":"\u201C",
  "OpenCurlyQuote":"\u2018",
  "operp":"\u29B9",
  "oplus":"\u2295",
  "Or":"\u2A54",
  "or":"\u2228",
  "orarr":"\u21BB",
  "ord":"\u2A5D",
  "order":"\u2134",
  "orderof":"\u2134",
  "ordf":"\u00AA",
  "ordm":"\u00BA",
  "origof":"\u22B6",
  "oror":"\u2A56",
  "orslope":"\u2A57",
  "orv":"\u2A5B",
  "oS":"\u24C8",
  "Oscr":"\uD835\uDCAA",
  "oscr":"\u2134",
  "Oslash":"\u00D8",
  "oslash":"\u00F8",
  "osol":"\u2298",
  "Otilde":"\u00D5",
  "otilde":"\u00F5",
  "Otimes":"\u2A37",
  "otimes":"\u2297",
  "otimesas":"\u2A36",
  "Ouml":"\u00D6",
  "ouml":"\u00F6",
  "ovbar":"\u233D",
  "OverBar":"\u203E",
  "OverBrace":"\u23DE",
  "OverBracket":"\u23B4",
  "OverParenthesis":"\u23DC",
  "par":"\u2225",
  "para":"\u00B6",
  "parallel":"\u2225",
  "parsim":"\u2AF3",
  "parsl":"\u2AFD",
  "part":"\u2202",
  "PartialD":"\u2202",
  "Pcy":"\u041F",
  "pcy":"\u043F",
  "percnt":"\u0025",
  "period":"\u002E",
  "permil":"\u2030",
  "perp":"\u22A5",
  "pertenk":"\u2031",
  "Pfr":"\uD835\uDD13",
  "pfr":"\uD835\uDD2D",
  "Phi":"\u03A6",
  "phi":"\u03C6",
  "phiv":"\u03D5",
  "phmmat":"\u2133",
  "phone":"\u260E",
  "Pi":"\u03A0",
  "pi":"\u03C0",
  "pitchfork":"\u22D4",
  "piv":"\u03D6",
  "planck":"\u210F",
  "planckh":"\u210E",
  "plankv":"\u210F",
  "plus":"\u002B",
  "plusacir":"\u2A23",
  "plusb":"\u229E",
  "pluscir":"\u2A22",
  "plusdo":"\u2214",
  "plusdu":"\u2A25",
  "pluse":"\u2A72",
  "PlusMinus":"\u00B1",
  "plusmn":"\u00B1",
  "plussim":"\u2A26",
  "plustwo":"\u2A27",
  "pm":"\u00B1",
  "Poincareplane":"\u210C",
  "pointint":"\u2A15",
  "Popf":"\u2119",
  "popf":"\uD835\uDD61",
  "pound":"\u00A3",
  "Pr":"\u2ABB",
  "pr":"\u227A",
  "prap":"\u2AB7",
  "prcue":"\u227C",
  "prE":"\u2AB3",
  "pre":"\u2AAF",
  "prec":"\u227A",
  "precapprox":"\u2AB7",
  "preccurlyeq":"\u227C",
  "Precedes":"\u227A",
  "PrecedesEqual":"\u2AAF",
  "PrecedesSlantEqual":"\u227C",
  "PrecedesTilde":"\u227E",
  "preceq":"\u2AAF",
  "precnapprox":"\u2AB9",
  "precneqq":"\u2AB5",
  "precnsim":"\u22E8",
  "precsim":"\u227E",
  "Prime":"\u2033",
  "prime":"\u2032",
  "primes":"\u2119",
  "prnap":"\u2AB9",
  "prnE":"\u2AB5",
  "prnsim":"\u22E8",
  "prod":"\u220F",
  "Product":"\u220F",
  "profalar":"\u232E",
  "profline":"\u2312",
  "profsurf":"\u2313",
  "prop":"\u221D",
  "Proportion":"\u2237",
  "Proportional":"\u221D",
  "propto":"\u221D",
  "prsim":"\u227E",
  "prurel":"\u22B0",
  "Pscr":"\uD835\uDCAB",
  "pscr":"\uD835\uDCC5",
  "Psi":"\u03A8",
  "psi":"\u03C8",
  "puncsp":"\u2008",
  "Qfr":"\uD835\uDD14",
  "qfr":"\uD835\uDD2E",
  "qint":"\u2A0C",
  "Qopf":"\u211A",
  "qopf":"\uD835\uDD62",
  "qprime":"\u2057",
  "Qscr":"\uD835\uDCAC",
  "qscr":"\uD835\uDCC6",
  "quaternions":"\u210D",
  "quatint":"\u2A16",
  "quest":"\u003F",
  "questeq":"\u225F",
  "QUOT":"\u0022",
  "quot":"\u0022",
  "rAarr":"\u21DB",
  "race":"\u223D\u0331",
  "Racute":"\u0154",
  "racute":"\u0155",
  "radic":"\u221A",
  "raemptyv":"\u29B3",
  "Rang":"\u27EB",
  "rang":"\u27E9",
  "rangd":"\u2992",
  "range":"\u29A5",
  "rangle":"\u27E9",
  "raquo":"\u00BB",
  "Rarr":"\u21A0",
  "rArr":"\u21D2",
  "rarr":"\u2192",
  "rarrap":"\u2975",
  "rarrb":"\u21E5",
  "rarrbfs":"\u2920",
  "rarrc":"\u2933",
  "rarrfs":"\u291E",
  "rarrhk":"\u21AA",
  "rarrlp":"\u21AC",
  "rarrpl":"\u2945",
  "rarrsim":"\u2974",
  "Rarrtl":"\u2916",
  "rarrtl":"\u21A3",
  "rarrw":"\u219D",
  "rAtail":"\u291C",
  "ratail":"\u291A",
  "ratio":"\u2236",
  "rationals":"\u211A",
  "RBarr":"\u2910",
  "rBarr":"\u290F",
  "rbarr":"\u290D",
  "rbbrk":"\u2773",
  "rbrace":"\u007D",
  "rbrack":"\u005D",
  "rbrke":"\u298C",
  "rbrksld":"\u298E",
  "rbrkslu":"\u2990",
  "Rcaron":"\u0158",
  "rcaron":"\u0159",
  "Rcedil":"\u0156",
  "rcedil":"\u0157",
  "rceil":"\u2309",
  "rcub":"\u007D",
  "Rcy":"\u0420",
  "rcy":"\u0440",
  "rdca":"\u2937",
  "rdldhar":"\u2969",
  "rdquo":"\u201D",
  "rdquor":"\u201D",
  "rdsh":"\u21B3",
  "Re":"\u211C",
  "real":"\u211C",
  "realine":"\u211B",
  "realpart":"\u211C",
  "reals":"\u211D",
  "rect":"\u25AD",
  "REG":"\u00AE",
  "reg":"\u00AE",
  "ReverseElement":"\u220B",
  "ReverseEquilibrium":"\u21CB",
  "ReverseUpEquilibrium":"\u296F",
  "rfisht":"\u297D",
  "rfloor":"\u230B",
  "Rfr":"\u211C",
  "rfr":"\uD835\uDD2F",
  "rHar":"\u2964",
  "rhard":"\u21C1",
  "rharu":"\u21C0",
  "rharul":"\u296C",
  "Rho":"\u03A1",
  "rho":"\u03C1",
  "rhov":"\u03F1",
  "RightAngleBracket":"\u27E9",
  "RightArrow":"\u2192",
  "Rightarrow":"\u21D2",
  "rightarrow":"\u2192",
  "RightArrowBar":"\u21E5",
  "RightArrowLeftArrow":"\u21C4",
  "rightarrowtail":"\u21A3",
  "RightCeiling":"\u2309",
  "RightDoubleBracket":"\u27E7",
  "RightDownTeeVector":"\u295D",
  "RightDownVector":"\u21C2",
  "RightDownVectorBar":"\u2955",
  "RightFloor":"\u230B",
  "rightharpoondown":"\u21C1",
  "rightharpoonup":"\u21C0",
  "rightleftarrows":"\u21C4",
  "rightleftharpoons":"\u21CC",
  "rightrightarrows":"\u21C9",
  "rightsquigarrow":"\u219D",
  "RightTee":"\u22A2",
  "RightTeeArrow":"\u21A6",
  "RightTeeVector":"\u295B",
  "rightthreetimes":"\u22CC",
  "RightTriangle":"\u22B3",
  "RightTriangleBar":"\u29D0",
  "RightTriangleEqual":"\u22B5",
  "RightUpDownVector":"\u294F",
  "RightUpTeeVector":"\u295C",
  "RightUpVector":"\u21BE",
  "RightUpVectorBar":"\u2954",
  "RightVector":"\u21C0",
  "RightVectorBar":"\u2953",
  "ring":"\u02DA",
  "risingdotseq":"\u2253",
  "rlarr":"\u21C4",
  "rlhar":"\u21CC",
  "rlm":"\u200F",
  "rmoust":"\u23B1",
  "rmoustache":"\u23B1",
  "rnmid":"\u2AEE",
  "roang":"\u27ED",
  "roarr":"\u21FE",
  "robrk":"\u27E7",
  "ropar":"\u2986",
  "Ropf":"\u211D",
  "ropf":"\uD835\uDD63",
  "roplus":"\u2A2E",
  "rotimes":"\u2A35",
  "RoundImplies":"\u2970",
  "rpar":"\u0029",
  "rpargt":"\u2994",
  "rppolint":"\u2A12",
  "rrarr":"\u21C9",
  "Rrightarrow":"\u21DB",
  "rsaquo":"\u203A",
  "Rscr":"\u211B",
  "rscr":"\uD835\uDCC7",
  "Rsh":"\u21B1",
  "rsh":"\u21B1",
  "rsqb":"\u005D",
  "rsquo":"\u2019",
  "rsquor":"\u2019",
  "rthree":"\u22CC",
  "rtimes":"\u22CA",
  "rtri":"\u25B9",
  "rtrie":"\u22B5",
  "rtrif":"\u25B8",
  "rtriltri":"\u29CE",
  "RuleDelayed":"\u29F4",
  "ruluhar":"\u2968",
  "rx":"\u211E",
  "Sacute":"\u015A",
  "sacute":"\u015B",
  "sbquo":"\u201A",
  "Sc":"\u2ABC",
  "sc":"\u227B",
  "scap":"\u2AB8",
  "Scaron":"\u0160",
  "scaron":"\u0161",
  "sccue":"\u227D",
  "scE":"\u2AB4",
  "sce":"\u2AB0",
  "Scedil":"\u015E",
  "scedil":"\u015F",
  "Scirc":"\u015C",
  "scirc":"\u015D",
  "scnap":"\u2ABA",
  "scnE":"\u2AB6",
  "scnsim":"\u22E9",
  "scpolint":"\u2A13",
  "scsim":"\u227F",
  "Scy":"\u0421",
  "scy":"\u0441",
  "sdot":"\u22C5",
  "sdotb":"\u22A1",
  "sdote":"\u2A66",
  "searhk":"\u2925",
  "seArr":"\u21D8",
  "searr":"\u2198",
  "searrow":"\u2198",
  "sect":"\u00A7",
  "semi":"\u003B",
  "seswar":"\u2929",
  "setminus":"\u2216",
  "setmn":"\u2216",
  "sext":"\u2736",
  "Sfr":"\uD835\uDD16",
  "sfr":"\uD835\uDD30",
  "sfrown":"\u2322",
  "sharp":"\u266F",
  "SHCHcy":"\u0429",
  "shchcy":"\u0449",
  "SHcy":"\u0428",
  "shcy":"\u0448",
  "ShortDownArrow":"\u2193",
  "ShortLeftArrow":"\u2190",
  "shortmid":"\u2223",
  "shortparallel":"\u2225",
  "ShortRightArrow":"\u2192",
  "ShortUpArrow":"\u2191",
  "shy":"\u00AD",
  "Sigma":"\u03A3",
  "sigma":"\u03C3",
  "sigmaf":"\u03C2",
  "sigmav":"\u03C2",
  "sim":"\u223C",
  "simdot":"\u2A6A",
  "sime":"\u2243",
  "simeq":"\u2243",
  "simg":"\u2A9E",
  "simgE":"\u2AA0",
  "siml":"\u2A9D",
  "simlE":"\u2A9F",
  "simne":"\u2246",
  "simplus":"\u2A24",
  "simrarr":"\u2972",
  "slarr":"\u2190",
  "SmallCircle":"\u2218",
  "smallsetminus":"\u2216",
  "smashp":"\u2A33",
  "smeparsl":"\u29E4",
  "smid":"\u2223",
  "smile":"\u2323",
  "smt":"\u2AAA",
  "smte":"\u2AAC",
  "smtes":"\u2AAC\uFE00",
  "SOFTcy":"\u042C",
  "softcy":"\u044C",
  "sol":"\u002F",
  "solb":"\u29C4",
  "solbar":"\u233F",
  "Sopf":"\uD835\uDD4A",
  "sopf":"\uD835\uDD64",
  "spades":"\u2660",
  "spadesuit":"\u2660",
  "spar":"\u2225",
  "sqcap":"\u2293",
  "sqcaps":"\u2293\uFE00",
  "sqcup":"\u2294",
  "sqcups":"\u2294\uFE00",
  "Sqrt":"\u221A",
  "sqsub":"\u228F",
  "sqsube":"\u2291",
  "sqsubset":"\u228F",
  "sqsubseteq":"\u2291",
  "sqsup":"\u2290",
  "sqsupe":"\u2292",
  "sqsupset":"\u2290",
  "sqsupseteq":"\u2292",
  "squ":"\u25A1",
  "Square":"\u25A1",
  "square":"\u25A1",
  "SquareIntersection":"\u2293",
  "SquareSubset":"\u228F",
  "SquareSubsetEqual":"\u2291",
  "SquareSuperset":"\u2290",
  "SquareSupersetEqual":"\u2292",
  "SquareUnion":"\u2294",
  "squarf":"\u25AA",
  "squf":"\u25AA",
  "srarr":"\u2192",
  "Sscr":"\uD835\uDCAE",
  "sscr":"\uD835\uDCC8",
  "ssetmn":"\u2216",
  "ssmile":"\u2323",
  "sstarf":"\u22C6",
  "Star":"\u22C6",
  "star":"\u2606",
  "starf":"\u2605",
  "straightepsilon":"\u03F5",
  "straightphi":"\u03D5",
  "strns":"\u00AF",
  "Sub":"\u22D0",
  "sub":"\u2282",
  "subdot":"\u2ABD",
  "subE":"\u2AC5",
  "sube":"\u2286",
  "subedot":"\u2AC3",
  "submult":"\u2AC1",
  "subnE":"\u2ACB",
  "subne":"\u228A",
  "subplus":"\u2ABF",
  "subrarr":"\u2979",
  "Subset":"\u22D0",
  "subset":"\u2282",
  "subseteq":"\u2286",
  "subseteqq":"\u2AC5",
  "SubsetEqual":"\u2286",
  "subsetneq":"\u228A",
  "subsetneqq":"\u2ACB",
  "subsim":"\u2AC7",
  "subsub":"\u2AD5",
  "subsup":"\u2AD3",
  "succ":"\u227B",
  "succapprox":"\u2AB8",
  "succcurlyeq":"\u227D",
  "Succeeds":"\u227B",
  "SucceedsEqual":"\u2AB0",
  "SucceedsSlantEqual":"\u227D",
  "SucceedsTilde":"\u227F",
  "succeq":"\u2AB0",
  "succnapprox":"\u2ABA",
  "succneqq":"\u2AB6",
  "succnsim":"\u22E9",
  "succsim":"\u227F",
  "SuchThat":"\u220B",
  "Sum":"\u2211",
  "sum":"\u2211",
  "sung":"\u266A",
  "Sup":"\u22D1",
  "sup":"\u2283",
  "sup1":"\u00B9",
  "sup2":"\u00B2",
  "sup3":"\u00B3",
  "supdot":"\u2ABE",
  "supdsub":"\u2AD8",
  "supE":"\u2AC6",
  "supe":"\u2287",
  "supedot":"\u2AC4",
  "Superset":"\u2283",
  "SupersetEqual":"\u2287",
  "suphsol":"\u27C9",
  "suphsub":"\u2AD7",
  "suplarr":"\u297B",
  "supmult":"\u2AC2",
  "supnE":"\u2ACC",
  "supne":"\u228B",
  "supplus":"\u2AC0",
  "Supset":"\u22D1",
  "supset":"\u2283",
  "supseteq":"\u2287",
  "supseteqq":"\u2AC6",
  "supsetneq":"\u228B",
  "supsetneqq":"\u2ACC",
  "supsim":"\u2AC8",
  "supsub":"\u2AD4",
  "supsup":"\u2AD6",
  "swarhk":"\u2926",
  "swArr":"\u21D9",
  "swarr":"\u2199",
  "swarrow":"\u2199",
  "swnwar":"\u292A",
  "szlig":"\u00DF",
  "Tab":"\u0009",
  "target":"\u2316",
  "Tau":"\u03A4",
  "tau":"\u03C4",
  "tbrk":"\u23B4",
  "Tcaron":"\u0164",
  "tcaron":"\u0165",
  "Tcedil":"\u0162",
  "tcedil":"\u0163",
  "Tcy":"\u0422",
  "tcy":"\u0442",
  "tdot":"\u20DB",
  "telrec":"\u2315",
  "Tfr":"\uD835\uDD17",
  "tfr":"\uD835\uDD31",
  "there4":"\u2234",
  "Therefore":"\u2234",
  "therefore":"\u2234",
  "Theta":"\u0398",
  "theta":"\u03B8",
  "thetasym":"\u03D1",
  "thetav":"\u03D1",
  "thickapprox":"\u2248",
  "thicksim":"\u223C",
  "ThickSpace":"\u205F\u200A",
  "thinsp":"\u2009",
  "ThinSpace":"\u2009",
  "thkap":"\u2248",
  "thksim":"\u223C",
  "THORN":"\u00DE",
  "thorn":"\u00FE",
  "Tilde":"\u223C",
  "tilde":"\u02DC",
  "TildeEqual":"\u2243",
  "TildeFullEqual":"\u2245",
  "TildeTilde":"\u2248",
  "times":"\u00D7",
  "timesb":"\u22A0",
  "timesbar":"\u2A31",
  "timesd":"\u2A30",
  "tint":"\u222D",
  "toea":"\u2928",
  "top":"\u22A4",
  "topbot":"\u2336",
  "topcir":"\u2AF1",
  "Topf":"\uD835\uDD4B",
  "topf":"\uD835\uDD65",
  "topfork":"\u2ADA",
  "tosa":"\u2929",
  "tprime":"\u2034",
  "TRADE":"\u2122",
  "trade":"\u2122",
  "triangle":"\u25B5",
  "triangledown":"\u25BF",
  "triangleleft":"\u25C3",
  "trianglelefteq":"\u22B4",
  "triangleq":"\u225C",
  "triangleright":"\u25B9",
  "trianglerighteq":"\u22B5",
  "tridot":"\u25EC",
  "trie":"\u225C",
  "triminus":"\u2A3A",
  "TripleDot":"\u20DB",
  "triplus":"\u2A39",
  "trisb":"\u29CD",
  "tritime":"\u2A3B",
  "trpezium":"\u23E2",
  "Tscr":"\uD835\uDCAF",
  "tscr":"\uD835\uDCC9",
  "TScy":"\u0426",
  "tscy":"\u0446",
  "TSHcy":"\u040B",
  "tshcy":"\u045B",
  "Tstrok":"\u0166",
  "tstrok":"\u0167",
  "twixt":"\u226C",
  "twoheadleftarrow":"\u219E",
  "twoheadrightarrow":"\u21A0",
  "Uacute":"\u00DA",
  "uacute":"\u00FA",
  "Uarr":"\u219F",
  "uArr":"\u21D1",
  "uarr":"\u2191",
  "Uarrocir":"\u2949",
  "Ubrcy":"\u040E",
  "ubrcy":"\u045E",
  "Ubreve":"\u016C",
  "ubreve":"\u016D",
  "Ucirc":"\u00DB",
  "ucirc":"\u00FB",
  "Ucy":"\u0423",
  "ucy":"\u0443",
  "udarr":"\u21C5",
  "Udblac":"\u0170",
  "udblac":"\u0171",
  "udhar":"\u296E",
  "ufisht":"\u297E",
  "Ufr":"\uD835\uDD18",
  "ufr":"\uD835\uDD32",
  "Ugrave":"\u00D9",
  "ugrave":"\u00F9",
  "uHar":"\u2963",
  "uharl":"\u21BF",
  "uharr":"\u21BE",
  "uhblk":"\u2580",
  "ulcorn":"\u231C",
  "ulcorner":"\u231C",
  "ulcrop":"\u230F",
  "ultri":"\u25F8",
  "Umacr":"\u016A",
  "umacr":"\u016B",
  "uml":"\u00A8",
  "UnderBar":"\u005F",
  "UnderBrace":"\u23DF",
  "UnderBracket":"\u23B5",
  "UnderParenthesis":"\u23DD",
  "Union":"\u22C3",
  "UnionPlus":"\u228E",
  "Uogon":"\u0172",
  "uogon":"\u0173",
  "Uopf":"\uD835\uDD4C",
  "uopf":"\uD835\uDD66",
  "UpArrow":"\u2191",
  "Uparrow":"\u21D1",
  "uparrow":"\u2191",
  "UpArrowBar":"\u2912",
  "UpArrowDownArrow":"\u21C5",
  "UpDownArrow":"\u2195",
  "Updownarrow":"\u21D5",
  "updownarrow":"\u2195",
  "UpEquilibrium":"\u296E",
  "upharpoonleft":"\u21BF",
  "upharpoonright":"\u21BE",
  "uplus":"\u228E",
  "UpperLeftArrow":"\u2196",
  "UpperRightArrow":"\u2197",
  "Upsi":"\u03D2",
  "upsi":"\u03C5",
  "upsih":"\u03D2",
  "Upsilon":"\u03A5",
  "upsilon":"\u03C5",
  "UpTee":"\u22A5",
  "UpTeeArrow":"\u21A5",
  "upuparrows":"\u21C8",
  "urcorn":"\u231D",
  "urcorner":"\u231D",
  "urcrop":"\u230E",
  "Uring":"\u016E",
  "uring":"\u016F",
  "urtri":"\u25F9",
  "Uscr":"\uD835\uDCB0",
  "uscr":"\uD835\uDCCA",
  "utdot":"\u22F0",
  "Utilde":"\u0168",
  "utilde":"\u0169",
  "utri":"\u25B5",
  "utrif":"\u25B4",
  "uuarr":"\u21C8",
  "Uuml":"\u00DC",
  "uuml":"\u00FC",
  "uwangle":"\u29A7",
  "vangrt":"\u299C",
  "varepsilon":"\u03F5",
  "varkappa":"\u03F0",
  "varnothing":"\u2205",
  "varphi":"\u03D5",
  "varpi":"\u03D6",
  "varpropto":"\u221D",
  "vArr":"\u21D5",
  "varr":"\u2195",
  "varrho":"\u03F1",
  "varsigma":"\u03C2",
  "varsubsetneq":"\u228A\uFE00",
  "varsubsetneqq":"\u2ACB\uFE00",
  "varsupsetneq":"\u228B\uFE00",
  "varsupsetneqq":"\u2ACC\uFE00",
  "vartheta":"\u03D1",
  "vartriangleleft":"\u22B2",
  "vartriangleright":"\u22B3",
  "Vbar":"\u2AEB",
  "vBar":"\u2AE8",
  "vBarv":"\u2AE9",
  "Vcy":"\u0412",
  "vcy":"\u0432",
  "VDash":"\u22AB",
  "Vdash":"\u22A9",
  "vDash":"\u22A8",
  "vdash":"\u22A2",
  "Vdashl":"\u2AE6",
  "Vee":"\u22C1",
  "vee":"\u2228",
  "veebar":"\u22BB",
  "veeeq":"\u225A",
  "vellip":"\u22EE",
  "Verbar":"\u2016",
  "verbar":"\u007C",
  "Vert":"\u2016",
  "vert":"\u007C",
  "VerticalBar":"\u2223",
  "VerticalLine":"\u007C",
  "VerticalSeparator":"\u2758",
  "VerticalTilde":"\u2240",
  "VeryThinSpace":"\u200A",
  "Vfr":"\uD835\uDD19",
  "vfr":"\uD835\uDD33",
  "vltri":"\u22B2",
  "vnsub":"\u2282\u20D2",
  "vnsup":"\u2283\u20D2",
  "Vopf":"\uD835\uDD4D",
  "vopf":"\uD835\uDD67",
  "vprop":"\u221D",
  "vrtri":"\u22B3",
  "Vscr":"\uD835\uDCB1",
  "vscr":"\uD835\uDCCB",
  "vsubnE":"\u2ACB\uFE00",
  "vsubne":"\u228A\uFE00",
  "vsupnE":"\u2ACC\uFE00",
  "vsupne":"\u228B\uFE00",
  "Vvdash":"\u22AA",
  "vzigzag":"\u299A",
  "Wcirc":"\u0174",
  "wcirc":"\u0175",
  "wedbar":"\u2A5F",
  "Wedge":"\u22C0",
  "wedge":"\u2227",
  "wedgeq":"\u2259",
  "weierp":"\u2118",
  "Wfr":"\uD835\uDD1A",
  "wfr":"\uD835\uDD34",
  "Wopf":"\uD835\uDD4E",
  "wopf":"\uD835\uDD68",
  "wp":"\u2118",
  "wr":"\u2240",
  "wreath":"\u2240",
  "Wscr":"\uD835\uDCB2",
  "wscr":"\uD835\uDCCC",
  "xcap":"\u22C2",
  "xcirc":"\u25EF",
  "xcup":"\u22C3",
  "xdtri":"\u25BD",
  "Xfr":"\uD835\uDD1B",
  "xfr":"\uD835\uDD35",
  "xhArr":"\u27FA",
  "xharr":"\u27F7",
  "Xi":"\u039E",
  "xi":"\u03BE",
  "xlArr":"\u27F8",
  "xlarr":"\u27F5",
  "xmap":"\u27FC",
  "xnis":"\u22FB",
  "xodot":"\u2A00",
  "Xopf":"\uD835\uDD4F",
  "xopf":"\uD835\uDD69",
  "xoplus":"\u2A01",
  "xotime":"\u2A02",
  "xrArr":"\u27F9",
  "xrarr":"\u27F6",
  "Xscr":"\uD835\uDCB3",
  "xscr":"\uD835\uDCCD",
  "xsqcup":"\u2A06",
  "xuplus":"\u2A04",
  "xutri":"\u25B3",
  "xvee":"\u22C1",
  "xwedge":"\u22C0",
  "Yacute":"\u00DD",
  "yacute":"\u00FD",
  "YAcy":"\u042F",
  "yacy":"\u044F",
  "Ycirc":"\u0176",
  "ycirc":"\u0177",
  "Ycy":"\u042B",
  "ycy":"\u044B",
  "yen":"\u00A5",
  "Yfr":"\uD835\uDD1C",
  "yfr":"\uD835\uDD36",
  "YIcy":"\u0407",
  "yicy":"\u0457",
  "Yopf":"\uD835\uDD50",
  "yopf":"\uD835\uDD6A",
  "Yscr":"\uD835\uDCB4",
  "yscr":"\uD835\uDCCE",
  "YUcy":"\u042E",
  "yucy":"\u044E",
  "Yuml":"\u0178",
  "yuml":"\u00FF",
  "Zacute":"\u0179",
  "zacute":"\u017A",
  "Zcaron":"\u017D",
  "zcaron":"\u017E",
  "Zcy":"\u0417",
  "zcy":"\u0437",
  "Zdot":"\u017B",
  "zdot":"\u017C",
  "zeetrf":"\u2128",
  "ZeroWidthSpace":"\u200B",
  "Zeta":"\u0396",
  "zeta":"\u03B6",
  "Zfr":"\u2128",
  "zfr":"\uD835\uDD37",
  "ZHcy":"\u0416",
  "zhcy":"\u0436",
  "zigrarr":"\u21DD",
  "Zopf":"\u2124",
  "zopf":"\uD835\uDD6B",
  "Zscr":"\uD835\uDCB5",
  "zscr":"\uD835\uDCCF",
  "zwj":"\u200D",
  "zwnj":"\u200C"
};


/***/ }),

/***/ "./node_modules/remarkable/lib/common/html_blocks.js":
/*!***********************************************************!*\
  !*** ./node_modules/remarkable/lib/common/html_blocks.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// List of valid html blocks names, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#html-blocks



var html_blocks = {};

[
  'article',
  'aside',
  'button',
  'blockquote',
  'body',
  'canvas',
  'caption',
  'col',
  'colgroup',
  'dd',
  'div',
  'dl',
  'dt',
  'embed',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'header',
  'hgroup',
  'hr',
  'iframe',
  'li',
  'map',
  'object',
  'ol',
  'output',
  'p',
  'pre',
  'progress',
  'script',
  'section',
  'style',
  'table',
  'tbody',
  'td',
  'textarea',
  'tfoot',
  'th',
  'tr',
  'thead',
  'ul',
  'video'
].forEach(function (name) { html_blocks[name] = true; });


module.exports = html_blocks;


/***/ }),

/***/ "./node_modules/remarkable/lib/common/html_re.js":
/*!*******************************************************!*\
  !*** ./node_modules/remarkable/lib/common/html_re.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Regexps to match html elements




function replace(regex, options) {
  regex = regex.source;
  options = options || '';

  return function self(name, val) {
    if (!name) {
      return new RegExp(regex, options);
    }
    val = val.source || val;
    regex = regex.replace(name, val);
    return self;
  };
}


var attr_name     = /[a-zA-Z_:][a-zA-Z0-9:._-]*/;

var unquoted      = /[^"'=<>`\x00-\x20]+/;
var single_quoted = /'[^']*'/;
var double_quoted = /"[^"]*"/;

/*eslint no-spaced-func:0*/
var attr_value  = replace(/(?:unquoted|single_quoted|double_quoted)/)
                    ('unquoted', unquoted)
                    ('single_quoted', single_quoted)
                    ('double_quoted', double_quoted)
                    ();

var attribute   = replace(/(?:\s+attr_name(?:\s*=\s*attr_value)?)/)
                    ('attr_name', attr_name)
                    ('attr_value', attr_value)
                    ();

var open_tag    = replace(/<[A-Za-z][A-Za-z0-9]*attribute*\s*\/?>/)
                    ('attribute', attribute)
                    ();

var close_tag   = /<\/[A-Za-z][A-Za-z0-9]*\s*>/;
var comment     = /<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;
var processing  = /<[?].*?[?]>/;
var declaration = /<![A-Z]+\s+[^>]*>/;
var cdata       = /<!\[CDATA\[[\s\S]*?\]\]>/;

var HTML_TAG_RE = replace(/^(?:open_tag|close_tag|comment|processing|declaration|cdata)/)
  ('open_tag', open_tag)
  ('close_tag', close_tag)
  ('comment', comment)
  ('processing', processing)
  ('declaration', declaration)
  ('cdata', cdata)
  ();


module.exports.HTML_TAG_RE = HTML_TAG_RE;


/***/ }),

/***/ "./node_modules/remarkable/lib/common/url_schemas.js":
/*!***********************************************************!*\
  !*** ./node_modules/remarkable/lib/common/url_schemas.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// List of valid url schemas, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#autolinks




module.exports = [
  'coap',
  'doi',
  'javascript',
  'aaa',
  'aaas',
  'about',
  'acap',
  'cap',
  'cid',
  'crid',
  'data',
  'dav',
  'dict',
  'dns',
  'file',
  'ftp',
  'geo',
  'go',
  'gopher',
  'h323',
  'http',
  'https',
  'iax',
  'icap',
  'im',
  'imap',
  'info',
  'ipp',
  'iris',
  'iris.beep',
  'iris.xpc',
  'iris.xpcs',
  'iris.lwz',
  'ldap',
  'mailto',
  'mid',
  'msrp',
  'msrps',
  'mtqp',
  'mupdate',
  'news',
  'nfs',
  'ni',
  'nih',
  'nntp',
  'opaquelocktoken',
  'pop',
  'pres',
  'rtsp',
  'service',
  'session',
  'shttp',
  'sieve',
  'sip',
  'sips',
  'sms',
  'snmp',
  'soap.beep',
  'soap.beeps',
  'tag',
  'tel',
  'telnet',
  'tftp',
  'thismessage',
  'tn3270',
  'tip',
  'tv',
  'urn',
  'vemmi',
  'ws',
  'wss',
  'xcon',
  'xcon-userid',
  'xmlrpc.beep',
  'xmlrpc.beeps',
  'xmpp',
  'z39.50r',
  'z39.50s',
  'adiumxtra',
  'afp',
  'afs',
  'aim',
  'apt',
  'attachment',
  'aw',
  'beshare',
  'bitcoin',
  'bolo',
  'callto',
  'chrome',
  'chrome-extension',
  'com-eventbrite-attendee',
  'content',
  'cvs',
  'dlna-playsingle',
  'dlna-playcontainer',
  'dtn',
  'dvb',
  'ed2k',
  'facetime',
  'feed',
  'finger',
  'fish',
  'gg',
  'git',
  'gizmoproject',
  'gtalk',
  'hcp',
  'icon',
  'ipn',
  'irc',
  'irc6',
  'ircs',
  'itms',
  'jar',
  'jms',
  'keyparc',
  'lastfm',
  'ldaps',
  'magnet',
  'maps',
  'market',
  'message',
  'mms',
  'ms-help',
  'msnim',
  'mumble',
  'mvn',
  'notes',
  'oid',
  'palm',
  'paparazzi',
  'platform',
  'proxy',
  'psyc',
  'query',
  'res',
  'resource',
  'rmi',
  'rsync',
  'rtmp',
  'secondlife',
  'sftp',
  'sgn',
  'skype',
  'smb',
  'soldat',
  'spotify',
  'ssh',
  'steam',
  'svn',
  'teamspeak',
  'things',
  'udp',
  'unreal',
  'ut2004',
  'ventrilo',
  'view-source',
  'webcal',
  'wtai',
  'wyciwyg',
  'xfire',
  'xri',
  'ymsgr'
];


/***/ }),

/***/ "./node_modules/remarkable/lib/common/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/remarkable/lib/common/utils.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Utility functions
 */

function typeOf(obj) {
  return Object.prototype.toString.call(obj);
}

function isString(obj) {
  return typeOf(obj) === '[object String]';
}

var hasOwn = Object.prototype.hasOwnProperty;

function has(object, key) {
  return object
    ? hasOwn.call(object, key)
    : false;
}

// Extend objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = [].slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) { return; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

////////////////////////////////////////////////////////////////////////////////

var UNESCAPE_MD_RE = /\\([\\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) { return str; }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) { return false; }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }
  // control codes
  if (c >= 0x00 && c <= 0x08) { return false; }
  if (c === 0x0B) { return false; }
  if (c >= 0x0E && c <= 0x1F) { return false; }
  if (c >= 0x7F && c <= 0x9F) { return false; }
  // out of range
  if (c > 0x10FFFF) { return false; }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}

var NAMED_ENTITY_RE   = /&([a-z#][a-z0-9]{1,31});/gi;
var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
var entities = __webpack_require__(/*! ./entities */ "./node_modules/remarkable/lib/common/entities.js");

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  } else if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ?
      parseInt(name.slice(2), 16)
    :
      parseInt(name.slice(1), 10);
    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }
  return match;
}

function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(NAMED_ENTITY_RE, replaceEntityPattern);
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

exports.assign            = assign;
exports.isString          = isString;
exports.has               = has;
exports.unescapeMd        = unescapeMd;
exports.isValidEntityCode = isValidEntityCode;
exports.fromCodePoint     = fromCodePoint;
exports.replaceEntities   = replaceEntities;
exports.escapeHtml        = escapeHtml;


/***/ }),

/***/ "./node_modules/remarkable/lib/configs/commonmark.js":
/*!***********************************************************!*\
  !*** ./node_modules/remarkable/lib/configs/commonmark.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Commonmark default options




module.exports = {
  options: {
    html:         true,         // Enable HTML tags in source
    xhtmlOut:     true,         // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links
    linkTarget:   '',           // set target to open link in

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.
    quotes: '“”‘’',

    // Highlighter function. Should return escaped HTML,
    // or '' if input not changed
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   20            // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: [
        'block',
        'inline',
        'references',
        'abbr2'
      ]
    },

    block: {
      rules: [
        'blockquote',
        'code',
        'fences',
        'heading',
        'hr',
        'htmlblock',
        'lheading',
        'list',
        'paragraph'
      ]
    },

    inline: {
      rules: [
        'autolink',
        'backticks',
        'emphasis',
        'entity',
        'escape',
        'htmltag',
        'links',
        'newline',
        'text'
      ]
    }
  }
};


/***/ }),

/***/ "./node_modules/remarkable/lib/configs/default.js":
/*!********************************************************!*\
  !*** ./node_modules/remarkable/lib/configs/default.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Remarkable default options




module.exports = {
  options: {
    html:         false,        // Enable HTML tags in source
    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links
    linkTarget:   '',           // set target to open link in

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.
    quotes: '“”‘’',

    // Highlighter function. Should return escaped HTML,
    // or '' if input not changed
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   20            // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: [
        'block',
        'inline',
        'references',
        'replacements',
        'linkify',
        'smartquotes',
        'references',
        'abbr2',
        'footnote_tail'
      ]
    },

    block: {
      rules: [
        'blockquote',
        'code',
        'fences',
        'footnote',
        'heading',
        'hr',
        'htmlblock',
        'lheading',
        'list',
        'paragraph',
        'table'
      ]
    },

    inline: {
      rules: [
        'autolink',
        'backticks',
        'del',
        'emphasis',
        'entity',
        'escape',
        'footnote_ref',
        'htmltag',
        'links',
        'newline',
        'text'
      ]
    }
  }
};


/***/ }),

/***/ "./node_modules/remarkable/lib/configs/full.js":
/*!*****************************************************!*\
  !*** ./node_modules/remarkable/lib/configs/full.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Remarkable default options




module.exports = {
  options: {
    html:         false,        // Enable HTML tags in source
    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links
    linkTarget:   '',           // set target to open link in

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.
    quotes:       '“”‘’',

    // Highlighter function. Should return escaped HTML,
    // or '' if input not changed
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight:     null,

    maxNesting:    20            // Internal protection, recursion limit
  },

  components: {
    // Don't restrict core/block/inline rules
    core: {},
    block: {},
    inline: {}
  }
};


/***/ }),

/***/ "./node_modules/remarkable/lib/helpers/normalize_link.js":
/*!***************************************************************!*\
  !*** ./node_modules/remarkable/lib/helpers/normalize_link.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var replaceEntities = __webpack_require__(/*! ../common/utils */ "./node_modules/remarkable/lib/common/utils.js").replaceEntities;

module.exports = function normalizeLink(url) {
  var normalized = replaceEntities(url);
  // We shouldn't care about the result of malformed URIs,
  // and should not throw an exception.
  try {
    normalized = decodeURI(normalized);
  } catch (err) {}
  return encodeURI(normalized);
};


/***/ }),

/***/ "./node_modules/remarkable/lib/helpers/normalize_reference.js":
/*!********************************************************************!*\
  !*** ./node_modules/remarkable/lib/helpers/normalize_reference.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, ' ').toUpperCase();
};


/***/ }),

/***/ "./node_modules/remarkable/lib/helpers/parse_link_destination.js":
/*!***********************************************************************!*\
  !*** ./node_modules/remarkable/lib/helpers/parse_link_destination.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var normalizeLink = __webpack_require__(/*! ./normalize_link */ "./node_modules/remarkable/lib/helpers/normalize_link.js");
var unescapeMd    = __webpack_require__(/*! ../common/utils */ "./node_modules/remarkable/lib/common/utils.js").unescapeMd;

/**
 * Parse link destination
 *
 *   - on success it returns a string and updates state.pos;
 *   - on failure it returns null
 *
 * @param  {Object} state
 * @param  {Number} pos
 * @api private
 */

module.exports = function parseLinkDestination(state, pos) {
  var code, level, link,
      start = pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) === 0x3C /* < */) {
    pos++;
    while (pos < max) {
      code = state.src.charCodeAt(pos);
      if (code === 0x0A /* \n */) { return false; }
      if (code === 0x3E /* > */) {
        link = normalizeLink(unescapeMd(state.src.slice(start + 1, pos)));
        if (!state.parser.validateLink(link)) { return false; }
        state.pos = pos + 1;
        state.linkContent = link;
        return true;
      }
      if (code === 0x5C /* \ */ && pos + 1 < max) {
        pos += 2;
        continue;
      }

      pos++;
    }

    // no closing '>'
    return false;
  }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = state.src.charCodeAt(pos);

    if (code === 0x20) { break; }

    // ascii control chars
    if (code < 0x20 || code === 0x7F) { break; }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
      level++;
      if (level > 1) { break; }
    }

    if (code === 0x29 /* ) */) {
      level--;
      if (level < 0) { break; }
    }

    pos++;
  }

  if (start === pos) { return false; }

  link = unescapeMd(state.src.slice(start, pos));
  if (!state.parser.validateLink(link)) { return false; }

  state.linkContent = link;
  state.pos = pos;
  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/helpers/parse_link_label.js":
/*!*****************************************************************!*\
  !*** ./node_modules/remarkable/lib/helpers/parse_link_label.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Parse link labels
 *
 * This function assumes that first character (`[`) already matches;
 * returns the end of the label.
 *
 * @param  {Object} state
 * @param  {Number} start
 * @api private
 */

module.exports = function parseLinkLabel(state, start) {
  var level, found, marker,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos,
      oldFlag = state.isInLabel;

  if (state.isInLabel) { return -1; }

  if (state.labelUnmatchedScopes) {
    state.labelUnmatchedScopes--;
    return -1;
  }

  state.pos = start + 1;
  state.isInLabel = true;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5B /* [ */) {
      level++;
    } else if (marker === 0x5D /* ] */) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }

    state.parser.skipToken(state);
  }

  if (found) {
    labelEnd = state.pos;
    state.labelUnmatchedScopes = 0;
  } else {
    state.labelUnmatchedScopes = level - 1;
  }

  // restore old state
  state.pos = oldPos;
  state.isInLabel = oldFlag;

  return labelEnd;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/helpers/parse_link_title.js":
/*!*****************************************************************!*\
  !*** ./node_modules/remarkable/lib/helpers/parse_link_title.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var unescapeMd = __webpack_require__(/*! ../common/utils */ "./node_modules/remarkable/lib/common/utils.js").unescapeMd;

/**
 * Parse link title
 *
 *   - on success it returns a string and updates state.pos;
 *   - on failure it returns null
 *
 * @param  {Object} state
 * @param  {Number} pos
 * @api private
 */

module.exports = function parseLinkTitle(state, pos) {
  var code,
      start = pos,
      max = state.posMax,
      marker = state.src.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return false; }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) { marker = 0x29; }

  while (pos < max) {
    code = state.src.charCodeAt(pos);
    if (code === marker) {
      state.pos = pos + 1;
      state.linkContent = unescapeMd(state.src.slice(start + 1, pos));
      return true;
    }
    if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos += 2;
      continue;
    }

    pos++;
  }

  return false;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/remarkable/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Local dependencies
 */

var assign       = __webpack_require__(/*! ./common/utils */ "./node_modules/remarkable/lib/common/utils.js").assign;
var Renderer     = __webpack_require__(/*! ./renderer */ "./node_modules/remarkable/lib/renderer.js");
var ParserCore   = __webpack_require__(/*! ./parser_core */ "./node_modules/remarkable/lib/parser_core.js");
var ParserBlock  = __webpack_require__(/*! ./parser_block */ "./node_modules/remarkable/lib/parser_block.js");
var ParserInline = __webpack_require__(/*! ./parser_inline */ "./node_modules/remarkable/lib/parser_inline.js");
var Ruler        = __webpack_require__(/*! ./ruler */ "./node_modules/remarkable/lib/ruler.js");

/**
 * Preset configs
 */

var config = {
  'default':    __webpack_require__(/*! ./configs/default */ "./node_modules/remarkable/lib/configs/default.js"),
  'full':       __webpack_require__(/*! ./configs/full */ "./node_modules/remarkable/lib/configs/full.js"),
  'commonmark': __webpack_require__(/*! ./configs/commonmark */ "./node_modules/remarkable/lib/configs/commonmark.js")
};

/**
 * The `StateCore` class manages state.
 *
 * @param {Object} `instance` Remarkable instance
 * @param {String} `str` Markdown string
 * @param {Object} `env`
 */

function StateCore(instance, str, env) {
  this.src = str;
  this.env = env;
  this.options = instance.options;
  this.tokens = [];
  this.inlineMode = false;

  this.inline = instance.inline;
  this.block = instance.block;
  this.renderer = instance.renderer;
  this.typographer = instance.typographer;
}

/**
 * The main `Remarkable` class. Create an instance of
 * `Remarkable` with a `preset` and/or `options`.
 *
 * @param {String} `preset` If no preset is given, `default` is used.
 * @param {Object} `options`
 */

function Remarkable(preset, options) {
  if (typeof preset !== 'string') {
    options = preset;
    preset = 'default';
  }

  this.inline   = new ParserInline();
  this.block    = new ParserBlock();
  this.core     = new ParserCore();
  this.renderer = new Renderer();
  this.ruler    = new Ruler();

  this.options  = {};
  this.configure(config[preset]);
  this.set(options || {});
}

/**
 * Set options as an alternative to passing them
 * to the constructor.
 *
 * ```js
 * md.set({typographer: true});
 * ```
 * @param {Object} `options`
 * @api public
 */

Remarkable.prototype.set = function (options) {
  assign(this.options, options);
};

/**
 * Batch loader for components rules states, and options
 *
 * @param  {Object} `presets`
 */

Remarkable.prototype.configure = function (presets) {
  var self = this;

  if (!presets) { throw new Error('Wrong `remarkable` preset, check name/content'); }
  if (presets.options) { self.set(presets.options); }
  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enable(presets.components[name].rules, true);
      }
    });
  }
};

/**
 * Use a plugin.
 *
 * ```js
 * var md = new Remarkable();
 *
 * md.use(plugin1)
 *   .use(plugin2, opts)
 *   .use(plugin3);
 * ```
 *
 * @param  {Function} `plugin`
 * @param  {Object} `options`
 * @return {Object} `Remarkable` for chaining
 */

Remarkable.prototype.use = function (plugin, options) {
  plugin(this, options);
  return this;
};


/**
 * Parse the input `string` and return a tokens array.
 * Modifies `env` with definitions data.
 *
 * @param  {String} `string`
 * @param  {Object} `env`
 * @return {Array} Array of tokens
 */

Remarkable.prototype.parse = function (str, env) {
  var state = new StateCore(this, str, env);
  this.core.process(state);
  return state.tokens;
};

/**
 * The main `.render()` method that does all the magic :)
 *
 * @param  {String} `string`
 * @param  {Object} `env`
 * @return {String} Rendered HTML.
 */

Remarkable.prototype.render = function (str, env) {
  env = env || {};
  return this.renderer.render(this.parse(str, env), this.options, env);
};

/**
 * Parse the given content `string` as a single string.
 *
 * @param  {String} `string`
 * @param  {Object} `env`
 * @return {Array} Array of tokens
 */

Remarkable.prototype.parseInline = function (str, env) {
  var state = new StateCore(this, str, env);
  state.inlineMode = true;
  this.core.process(state);
  return state.tokens;
};

/**
 * Render a single content `string`, without wrapping it
 * to paragraphs
 *
 * @param  {String} `str`
 * @param  {Object} `env`
 * @return {String}
 */

Remarkable.prototype.renderInline = function (str, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(str, env), this.options, env);
};

/**
 * Expose `Remarkable`
 */

module.exports = Remarkable;

/**
 * Expose `utils`, Useful helper functions for custom
 * rendering.
 */

module.exports.utils = __webpack_require__(/*! ./common/utils */ "./node_modules/remarkable/lib/common/utils.js");


/***/ }),

/***/ "./node_modules/remarkable/lib/parser_block.js":
/*!*****************************************************!*\
  !*** ./node_modules/remarkable/lib/parser_block.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Local dependencies
 */

var Ruler      = __webpack_require__(/*! ./ruler */ "./node_modules/remarkable/lib/ruler.js");
var StateBlock = __webpack_require__(/*! ./rules_block/state_block */ "./node_modules/remarkable/lib/rules_block/state_block.js");

/**
 * Parser rules
 */

var _rules = [
  [ 'code',       __webpack_require__(/*! ./rules_block/code */ "./node_modules/remarkable/lib/rules_block/code.js") ],
  [ 'fences',     __webpack_require__(/*! ./rules_block/fences */ "./node_modules/remarkable/lib/rules_block/fences.js"),     [ 'paragraph', 'blockquote', 'list' ] ],
  [ 'blockquote', __webpack_require__(/*! ./rules_block/blockquote */ "./node_modules/remarkable/lib/rules_block/blockquote.js"), [ 'paragraph', 'blockquote', 'list' ] ],
  [ 'hr',         __webpack_require__(/*! ./rules_block/hr */ "./node_modules/remarkable/lib/rules_block/hr.js"),         [ 'paragraph', 'blockquote', 'list' ] ],
  [ 'list',       __webpack_require__(/*! ./rules_block/list */ "./node_modules/remarkable/lib/rules_block/list.js"),       [ 'paragraph', 'blockquote' ] ],
  [ 'footnote',   __webpack_require__(/*! ./rules_block/footnote */ "./node_modules/remarkable/lib/rules_block/footnote.js"),   [ 'paragraph' ] ],
  [ 'heading',    __webpack_require__(/*! ./rules_block/heading */ "./node_modules/remarkable/lib/rules_block/heading.js"),    [ 'paragraph', 'blockquote' ] ],
  [ 'lheading',   __webpack_require__(/*! ./rules_block/lheading */ "./node_modules/remarkable/lib/rules_block/lheading.js") ],
  [ 'htmlblock',  __webpack_require__(/*! ./rules_block/htmlblock */ "./node_modules/remarkable/lib/rules_block/htmlblock.js"),  [ 'paragraph', 'blockquote' ] ],
  [ 'table',      __webpack_require__(/*! ./rules_block/table */ "./node_modules/remarkable/lib/rules_block/table.js"),      [ 'paragraph' ] ],
  [ 'deflist',    __webpack_require__(/*! ./rules_block/deflist */ "./node_modules/remarkable/lib/rules_block/deflist.js"),    [ 'paragraph' ] ],
  [ 'paragraph',  __webpack_require__(/*! ./rules_block/paragraph */ "./node_modules/remarkable/lib/rules_block/paragraph.js") ]
];

/**
 * Block Parser class
 *
 * @api private
 */

function ParserBlock() {
  this.ruler = new Ruler();
  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], {
      alt: (_rules[i][2] || []).slice()
    });
  }
}

/**
 * Generate tokens for the given input range.
 *
 * @param  {Object} `state` Has properties like `src`, `parser`, `options` etc
 * @param  {Number} `startLine`
 * @param  {Number} `endLine`
 * @api private
 */

ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var rules = this.ruler.getRules('');
  var len = rules.length;
  var line = startLine;
  var hasEmptyLines = false;
  var ok, i;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.tShift[line] < state.blkIndent) {
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) {
        break;
      }
    }

    // set state.tight iff we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;

      // two empty lines should stop the parser in list mode
      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) { break; }
      state.line = line;
    }
  }
};

var TABS_SCAN_RE = /[\n\t]/g;
var NEWLINES_RE  = /\r[\n\u0085]|[\u2424\u2028\u0085]/g;
var SPACES_RE    = /\u00a0/g;

/**
 * Tokenize the given `str`.
 *
 * @param  {String} `str` Source string
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @param  {Array} `outTokens`
 * @api private
 */

ParserBlock.prototype.parse = function (str, options, env, outTokens) {
  var state, lineStart = 0, lastTabPos = 0;
  if (!str) { return []; }

  // Normalize spaces
  str = str.replace(SPACES_RE, ' ');

  // Normalize newlines
  str = str.replace(NEWLINES_RE, '\n');

  // Replace tabs with proper number of spaces (1..4)
  if (str.indexOf('\t') >= 0) {
    str = str.replace(TABS_SCAN_RE, function (match, offset) {
      var result;
      if (str.charCodeAt(offset) === 0x0A) {
        lineStart = offset + 1;
        lastTabPos = 0;
        return match;
      }
      result = '    '.slice((offset - lineStart - lastTabPos) % 4);
      lastTabPos = offset - lineStart + 1;
      return result;
    });
  }

  state = new StateBlock(str, this, options, env, outTokens);
  this.tokenize(state, state.line, state.lineMax);
};

/**
 * Expose `ParserBlock`
 */

module.exports = ParserBlock;


/***/ }),

/***/ "./node_modules/remarkable/lib/parser_core.js":
/*!****************************************************!*\
  !*** ./node_modules/remarkable/lib/parser_core.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Local dependencies
 */

var Ruler = __webpack_require__(/*! ./ruler */ "./node_modules/remarkable/lib/ruler.js");

/**
 * Core parser `rules`
 */

var _rules = [
  [ 'block',          __webpack_require__(/*! ./rules_core/block */ "./node_modules/remarkable/lib/rules_core/block.js")          ],
  [ 'abbr',           __webpack_require__(/*! ./rules_core/abbr */ "./node_modules/remarkable/lib/rules_core/abbr.js")           ],
  [ 'references',     __webpack_require__(/*! ./rules_core/references */ "./node_modules/remarkable/lib/rules_core/references.js")     ],
  [ 'inline',         __webpack_require__(/*! ./rules_core/inline */ "./node_modules/remarkable/lib/rules_core/inline.js")         ],
  [ 'footnote_tail',  __webpack_require__(/*! ./rules_core/footnote_tail */ "./node_modules/remarkable/lib/rules_core/footnote_tail.js")  ],
  [ 'abbr2',          __webpack_require__(/*! ./rules_core/abbr2 */ "./node_modules/remarkable/lib/rules_core/abbr2.js")          ],
  [ 'replacements',   __webpack_require__(/*! ./rules_core/replacements */ "./node_modules/remarkable/lib/rules_core/replacements.js")   ],
  [ 'smartquotes',    __webpack_require__(/*! ./rules_core/smartquotes */ "./node_modules/remarkable/lib/rules_core/smartquotes.js")    ],
  [ 'linkify',        __webpack_require__(/*! ./rules_core/linkify */ "./node_modules/remarkable/lib/rules_core/linkify.js")        ]
];

/**
 * Class for top level (`core`) parser rules
 *
 * @api private
 */

function Core() {
  this.options = {};
  this.ruler = new Ruler();
  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}

/**
 * Process rules with the given `state`
 *
 * @param  {Object} `state`
 * @api private
 */

Core.prototype.process = function (state) {
  var i, l, rules;
  rules = this.ruler.getRules('');
  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

/**
 * Expose `Core`
 */

module.exports = Core;


/***/ }),

/***/ "./node_modules/remarkable/lib/parser_inline.js":
/*!******************************************************!*\
  !*** ./node_modules/remarkable/lib/parser_inline.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Local dependencies
 */

var Ruler       = __webpack_require__(/*! ./ruler */ "./node_modules/remarkable/lib/ruler.js");
var StateInline = __webpack_require__(/*! ./rules_inline/state_inline */ "./node_modules/remarkable/lib/rules_inline/state_inline.js");
var utils       = __webpack_require__(/*! ./common/utils */ "./node_modules/remarkable/lib/common/utils.js");

/**
 * Inline Parser `rules`
 */

var _rules = [
  [ 'text',            __webpack_require__(/*! ./rules_inline/text */ "./node_modules/remarkable/lib/rules_inline/text.js") ],
  [ 'newline',         __webpack_require__(/*! ./rules_inline/newline */ "./node_modules/remarkable/lib/rules_inline/newline.js") ],
  [ 'escape',          __webpack_require__(/*! ./rules_inline/escape */ "./node_modules/remarkable/lib/rules_inline/escape.js") ],
  [ 'backticks',       __webpack_require__(/*! ./rules_inline/backticks */ "./node_modules/remarkable/lib/rules_inline/backticks.js") ],
  [ 'del',             __webpack_require__(/*! ./rules_inline/del */ "./node_modules/remarkable/lib/rules_inline/del.js") ],
  [ 'ins',             __webpack_require__(/*! ./rules_inline/ins */ "./node_modules/remarkable/lib/rules_inline/ins.js") ],
  [ 'mark',            __webpack_require__(/*! ./rules_inline/mark */ "./node_modules/remarkable/lib/rules_inline/mark.js") ],
  [ 'emphasis',        __webpack_require__(/*! ./rules_inline/emphasis */ "./node_modules/remarkable/lib/rules_inline/emphasis.js") ],
  [ 'sub',             __webpack_require__(/*! ./rules_inline/sub */ "./node_modules/remarkable/lib/rules_inline/sub.js") ],
  [ 'sup',             __webpack_require__(/*! ./rules_inline/sup */ "./node_modules/remarkable/lib/rules_inline/sup.js") ],
  [ 'links',           __webpack_require__(/*! ./rules_inline/links */ "./node_modules/remarkable/lib/rules_inline/links.js") ],
  [ 'footnote_inline', __webpack_require__(/*! ./rules_inline/footnote_inline */ "./node_modules/remarkable/lib/rules_inline/footnote_inline.js") ],
  [ 'footnote_ref',    __webpack_require__(/*! ./rules_inline/footnote_ref */ "./node_modules/remarkable/lib/rules_inline/footnote_ref.js") ],
  [ 'autolink',        __webpack_require__(/*! ./rules_inline/autolink */ "./node_modules/remarkable/lib/rules_inline/autolink.js") ],
  [ 'htmltag',         __webpack_require__(/*! ./rules_inline/htmltag */ "./node_modules/remarkable/lib/rules_inline/htmltag.js") ],
  [ 'entity',          __webpack_require__(/*! ./rules_inline/entity */ "./node_modules/remarkable/lib/rules_inline/entity.js") ]
];

/**
 * Inline Parser class. Note that link validation is stricter
 * in Remarkable than what is specified by CommonMark. If you
 * want to change this you can use a custom validator.
 *
 * @api private
 */

function ParserInline() {
  this.ruler = new Ruler();
  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  // Can be overridden with a custom validator
  this.validateLink = validateLink;
}

/**
 * Skip a single token by running all rules in validation mode.
 * Returns `true` if any rule reports success.
 *
 * @param  {Object} `state`
 * @api privage
 */

ParserInline.prototype.skipToken = function (state) {
  var rules = this.ruler.getRules('');
  var len = rules.length;
  var pos = state.pos;
  var i, cached_pos;

  if ((cached_pos = state.cacheGet(pos)) > 0) {
    state.pos = cached_pos;
    return;
  }

  for (i = 0; i < len; i++) {
    if (rules[i](state, true)) {
      state.cacheSet(pos, state.pos);
      return;
    }
  }

  state.pos++;
  state.cacheSet(pos, state.pos);
};

/**
 * Generate tokens for the given input range.
 *
 * @param  {Object} `state`
 * @api private
 */

ParserInline.prototype.tokenize = function (state) {
  var rules = this.ruler.getRules('');
  var len = rules.length;
  var end = state.posMax;
  var ok, i;

  while (state.pos < end) {

    // Try all possible rules.
    // On success, the rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true
    for (i = 0; i < len; i++) {
      ok = rules[i](state, false);

      if (ok) {
        break;
      }
    }

    if (ok) {
      if (state.pos >= end) { break; }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};

/**
 * Parse the given input string.
 *
 * @param  {String} `str`
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @param  {Array} `outTokens`
 * @api private
 */

ParserInline.prototype.parse = function (str, options, env, outTokens) {
  var state = new StateInline(str, this, options, env, outTokens);
  this.tokenize(state);
};

/**
 * Validate the given `url` by checking for bad protocols.
 *
 * @param  {String} `url`
 * @return {Boolean}
 */

function validateLink(url) {
  var BAD_PROTOCOLS = [ 'vbscript', 'javascript', 'file', 'data' ];
  var str = url.trim().toLowerCase();
  // Care about digital entities "javascript&#x3A;alert(1)"
  str = utils.replaceEntities(str);
  if (str.indexOf(':') !== -1 && BAD_PROTOCOLS.indexOf(str.split(':')[0]) !== -1) {
    return false;
  }
  return true;
}

/**
 * Expose `ParserInline`
 */

module.exports = ParserInline;


/***/ }),

/***/ "./node_modules/remarkable/lib/renderer.js":
/*!*************************************************!*\
  !*** ./node_modules/remarkable/lib/renderer.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Local dependencies
 */

var utils = __webpack_require__(/*! ./common/utils */ "./node_modules/remarkable/lib/common/utils.js");
var rules = __webpack_require__(/*! ./rules */ "./node_modules/remarkable/lib/rules.js");

/**
 * Expose `Renderer`
 */

module.exports = Renderer;

/**
 * Renderer class. Renders HTML and exposes `rules` to allow
 * local modifications.
 */

function Renderer() {
  this.rules = utils.assign({}, rules);

  // exported helper, for custom rules only
  this.getBreak = rules.getBreak;
}

/**
 * Render a string of inline HTML with the given `tokens` and
 * `options`.
 *
 * @param  {Array} `tokens`
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @return {String}
 * @api public
 */

Renderer.prototype.renderInline = function (tokens, options, env) {
  var _rules = this.rules;
  var len = tokens.length, i = 0;
  var result = '';

  while (len--) {
    result += _rules[tokens[i].type](tokens, i++, options, env, this);
  }

  return result;
};

/**
 * Render a string of HTML with the given `tokens` and
 * `options`.
 *
 * @param  {Array} `tokens`
 * @param  {Object} `options`
 * @param  {Object} `env`
 * @return {String}
 * @api public
 */

Renderer.prototype.render = function (tokens, options, env) {
  var _rules = this.rules;
  var len = tokens.length, i = -1;
  var result = '';

  while (++i < len) {
    if (tokens[i].type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else {
      result += _rules[tokens[i].type](tokens, i, options, env, this);
    }
  }
  return result;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/ruler.js":
/*!**********************************************!*\
  !*** ./node_modules/remarkable/lib/ruler.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Ruler is a helper class for building responsibility chains from
 * parse rules. It allows:
 *
 *   - easy stack rules chains
 *   - getting main chain and named chains content (as arrays of functions)
 *
 * Helper methods, should not be used directly.
 * @api private
 */

function Ruler() {
  // List of added rules. Each element is:
  //
  // { name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ] }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - digital anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

/**
 * Find the index of a rule by `name`.
 *
 * @param  {String} `name`
 * @return {Number} Index of the given `name`
 * @api private
 */

Ruler.prototype.__find__ = function (name) {
  var len = this.__rules__.length;
  var i = -1;

  while (len--) {
    if (this.__rules__[++i].name === name) {
      return i;
    }
  }
  return -1;
};

/**
 * Build the rules lookup cache
 *
 * @api private
 */

Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [ '' ];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return;
    }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }

      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }
      self.__cache__[chain].push(rule.fn);
    });
  });
};

/**
 * Ruler public methods
 * ------------------------------------------------
 */

/**
 * Replace rule function
 *
 * @param  {String} `name` Rule name
 * @param  {Function `fn`
 * @param  {Object} `options`
 * @api private
 */

Ruler.prototype.at = function (name, fn, options) {
  var idx = this.__find__(name);
  var opt = options || {};

  if (idx === -1) {
    throw new Error('Parser rule not found: ' + name);
  }

  this.__rules__[idx].fn = fn;
  this.__rules__[idx].alt = opt.alt || [];
  this.__cache__ = null;
};

/**
 * Add a rule to the chain before given the `ruleName`.
 *
 * @param  {String}   `beforeName`
 * @param  {String}   `ruleName`
 * @param  {Function} `fn`
 * @param  {Object}   `options`
 * @api private
 */

Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var idx = this.__find__(beforeName);
  var opt = options || {};

  if (idx === -1) {
    throw new Error('Parser rule not found: ' + beforeName);
  }

  this.__rules__.splice(idx, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Add a rule to the chain after the given `ruleName`.
 *
 * @param  {String}   `afterName`
 * @param  {String}   `ruleName`
 * @param  {Function} `fn`
 * @param  {Object}   `options`
 * @api private
 */

Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var idx = this.__find__(afterName);
  var opt = options || {};

  if (idx === -1) {
    throw new Error('Parser rule not found: ' + afterName);
  }

  this.__rules__.splice(idx + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Add a rule to the end of chain.
 *
 * @param  {String}   `ruleName`
 * @param  {Function} `fn`
 * @param  {Object}   `options`
 * @return {String}
 */

Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Enable a rule or list of rules.
 *
 * @param  {String|Array} `list` Name or array of rule names to enable
 * @param  {Boolean} `strict` If `true`, all non listed rules will be disabled.
 * @api private
 */

Ruler.prototype.enable = function (list, strict) {
  list = !Array.isArray(list)
    ? [ list ]
    : list;

  // In strict mode disable all existing rules first
  if (strict) {
    this.__rules__.forEach(function (rule) {
      rule.enabled = false;
    });
  }

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);
    if (idx < 0) {
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
  }, this);

  this.__cache__ = null;
};


/**
 * Disable a rule or list of rules.
 *
 * @param  {String|Array} `list` Name or array of rule names to disable
 * @api private
 */

Ruler.prototype.disable = function (list) {
  list = !Array.isArray(list)
    ? [ list ]
    : list;

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);
    if (idx < 0) {
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
  }, this);

  this.__cache__ = null;
};

/**
 * Get a rules list as an array of functions.
 *
 * @param  {String} `chainName`
 * @return {Object}
 * @api private
 */

Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};

/**
 * Expose `Ruler`
 */

module.exports = Ruler;


/***/ }),

/***/ "./node_modules/remarkable/lib/rules.js":
/*!**********************************************!*\
  !*** ./node_modules/remarkable/lib/rules.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Local dependencies
 */

var has             = __webpack_require__(/*! ./common/utils */ "./node_modules/remarkable/lib/common/utils.js").has;
var unescapeMd      = __webpack_require__(/*! ./common/utils */ "./node_modules/remarkable/lib/common/utils.js").unescapeMd;
var replaceEntities = __webpack_require__(/*! ./common/utils */ "./node_modules/remarkable/lib/common/utils.js").replaceEntities;
var escapeHtml      = __webpack_require__(/*! ./common/utils */ "./node_modules/remarkable/lib/common/utils.js").escapeHtml;

/**
 * Renderer rules cache
 */

var rules = {};

/**
 * Blockquotes
 */

rules.blockquote_open = function(/* tokens, idx, options, env */) {
  return '<blockquote>\n';
};

rules.blockquote_close = function(tokens, idx /*, options, env */) {
  return '</blockquote>' + getBreak(tokens, idx);
};

/**
 * Code
 */

rules.code = function(tokens, idx /*, options, env */) {
  if (tokens[idx].block) {
    return '<pre><code>' + escapeHtml(tokens[idx].content) + '</code></pre>' + getBreak(tokens, idx);
  }
  return '<code>' + escapeHtml(tokens[idx].content) + '</code>';
};

/**
 * Fenced code blocks
 */

rules.fence = function(tokens, idx, options, env, instance) {
  var token = tokens[idx];
  var langClass = '';
  var langPrefix = options.langPrefix;
  var langName = '', fences, fenceName;
  var highlighted;

  if (token.params) {

    //
    // ```foo bar
    //
    // Try custom renderer "foo" first. That will simplify overwrite
    // for diagrams, latex, and any other fenced block with custom look
    //

    fences = token.params.split(/\s+/g);
    fenceName = fences.join(' ');

    if (has(instance.rules.fence_custom, fences[0])) {
      return instance.rules.fence_custom[fences[0]](tokens, idx, options, env, instance);
    }

    langName = escapeHtml(replaceEntities(unescapeMd(fenceName)));
    langClass = ' class="' + langPrefix + langName + '"';
  }

  if (options.highlight) {
    highlighted = options.highlight.apply(options.highlight, [ token.content ].concat(fences))
      || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  return '<pre><code' + langClass + '>'
        + highlighted
        + '</code></pre>'
        + getBreak(tokens, idx);
};

rules.fence_custom = {};

/**
 * Headings
 */

rules.heading_open = function(tokens, idx /*, options, env */) {
  return '<h' + tokens[idx].hLevel + '>';
};
rules.heading_close = function(tokens, idx /*, options, env */) {
  return '</h' + tokens[idx].hLevel + '>\n';
};

/**
 * Horizontal rules
 */

rules.hr = function(tokens, idx, options /*, env */) {
  return (options.xhtmlOut ? '<hr />' : '<hr>') + getBreak(tokens, idx);
};

/**
 * Bullets
 */

rules.bullet_list_open = function(/* tokens, idx, options, env */) {
  return '<ul>\n';
};
rules.bullet_list_close = function(tokens, idx /*, options, env */) {
  return '</ul>' + getBreak(tokens, idx);
};

/**
 * List items
 */

rules.list_item_open = function(/* tokens, idx, options, env */) {
  return '<li>';
};
rules.list_item_close = function(/* tokens, idx, options, env */) {
  return '</li>\n';
};

/**
 * Ordered list items
 */

rules.ordered_list_open = function(tokens, idx /*, options, env */) {
  var token = tokens[idx];
  var order = token.order > 1 ? ' start="' + token.order + '"' : '';
  return '<ol' + order + '>\n';
};
rules.ordered_list_close = function(tokens, idx /*, options, env */) {
  return '</ol>' + getBreak(tokens, idx);
};

/**
 * Paragraphs
 */

rules.paragraph_open = function(tokens, idx /*, options, env */) {
  return tokens[idx].tight ? '' : '<p>';
};
rules.paragraph_close = function(tokens, idx /*, options, env */) {
  var addBreak = !(tokens[idx].tight && idx && tokens[idx - 1].type === 'inline' && !tokens[idx - 1].content);
  return (tokens[idx].tight ? '' : '</p>') + (addBreak ? getBreak(tokens, idx) : '');
};

/**
 * Links
 */

rules.link_open = function(tokens, idx, options /* env */) {
  var title = tokens[idx].title ? (' title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '"') : '';
  var target = options.linkTarget ? (' target="' + options.linkTarget + '"') : '';
  return '<a href="' + escapeHtml(tokens[idx].href) + '"' + title + target + '>';
};
rules.link_close = function(/* tokens, idx, options, env */) {
  return '</a>';
};

/**
 * Images
 */

rules.image = function(tokens, idx, options /*, env */) {
  var src = ' src="' + escapeHtml(tokens[idx].src) + '"';
  var title = tokens[idx].title ? (' title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '"') : '';
  var alt = ' alt="' + (tokens[idx].alt ? escapeHtml(replaceEntities(unescapeMd(tokens[idx].alt))) : '') + '"';
  var suffix = options.xhtmlOut ? ' /' : '';
  return '<img' + src + alt + title + suffix + '>';
};

/**
 * Tables
 */

rules.table_open = function(/* tokens, idx, options, env */) {
  return '<table>\n';
};
rules.table_close = function(/* tokens, idx, options, env */) {
  return '</table>\n';
};
rules.thead_open = function(/* tokens, idx, options, env */) {
  return '<thead>\n';
};
rules.thead_close = function(/* tokens, idx, options, env */) {
  return '</thead>\n';
};
rules.tbody_open = function(/* tokens, idx, options, env */) {
  return '<tbody>\n';
};
rules.tbody_close = function(/* tokens, idx, options, env */) {
  return '</tbody>\n';
};
rules.tr_open = function(/* tokens, idx, options, env */) {
  return '<tr>';
};
rules.tr_close = function(/* tokens, idx, options, env */) {
  return '</tr>\n';
};
rules.th_open = function(tokens, idx /*, options, env */) {
  var token = tokens[idx];
  return '<th'
    + (token.align ? ' style="text-align:' + token.align + '"' : '')
    + '>';
};
rules.th_close = function(/* tokens, idx, options, env */) {
  return '</th>';
};
rules.td_open = function(tokens, idx /*, options, env */) {
  var token = tokens[idx];
  return '<td'
    + (token.align ? ' style="text-align:' + token.align + '"' : '')
    + '>';
};
rules.td_close = function(/* tokens, idx, options, env */) {
  return '</td>';
};

/**
 * Bold
 */

rules.strong_open = function(/* tokens, idx, options, env */) {
  return '<strong>';
};
rules.strong_close = function(/* tokens, idx, options, env */) {
  return '</strong>';
};

/**
 * Italicize
 */

rules.em_open = function(/* tokens, idx, options, env */) {
  return '<em>';
};
rules.em_close = function(/* tokens, idx, options, env */) {
  return '</em>';
};

/**
 * Strikethrough
 */

rules.del_open = function(/* tokens, idx, options, env */) {
  return '<del>';
};
rules.del_close = function(/* tokens, idx, options, env */) {
  return '</del>';
};

/**
 * Insert
 */

rules.ins_open = function(/* tokens, idx, options, env */) {
  return '<ins>';
};
rules.ins_close = function(/* tokens, idx, options, env */) {
  return '</ins>';
};

/**
 * Highlight
 */

rules.mark_open = function(/* tokens, idx, options, env */) {
  return '<mark>';
};
rules.mark_close = function(/* tokens, idx, options, env */) {
  return '</mark>';
};

/**
 * Super- and sub-script
 */

rules.sub = function(tokens, idx /*, options, env */) {
  return '<sub>' + escapeHtml(tokens[idx].content) + '</sub>';
};
rules.sup = function(tokens, idx /*, options, env */) {
  return '<sup>' + escapeHtml(tokens[idx].content) + '</sup>';
};

/**
 * Breaks
 */

rules.hardbreak = function(tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
rules.softbreak = function(tokens, idx, options /*, env */) {
  return options.breaks ? (options.xhtmlOut ? '<br />\n' : '<br>\n') : '\n';
};

/**
 * Text
 */

rules.text = function(tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};

/**
 * Content
 */

rules.htmlblock = function(tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
rules.htmltag = function(tokens, idx /*, options, env */) {
  return tokens[idx].content;
};

/**
 * Abbreviations, initialism
 */

rules.abbr_open = function(tokens, idx /*, options, env */) {
  return '<abbr title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '">';
};
rules.abbr_close = function(/* tokens, idx, options, env */) {
  return '</abbr>';
};

/**
 * Footnotes
 */

rules.footnote_ref = function(tokens, idx) {
  var n = Number(tokens[idx].id + 1).toString();
  var id = 'fnref' + n;
  if (tokens[idx].subId > 0) {
    id += ':' + tokens[idx].subId;
  }
  return '<sup class="footnote-ref"><a href="#fn' + n + '" id="' + id + '">[' + n + ']</a></sup>';
};
rules.footnote_block_open = function(tokens, idx, options) {
  var hr = options.xhtmlOut
    ? '<hr class="footnotes-sep" />\n'
    : '<hr class="footnotes-sep">\n';
  return hr + '<section class="footnotes">\n<ol class="footnotes-list">\n';
};
rules.footnote_block_close = function() {
  return '</ol>\n</section>\n';
};
rules.footnote_open = function(tokens, idx) {
  var id = Number(tokens[idx].id + 1).toString();
  return '<li id="fn' + id + '"  class="footnote-item">';
};
rules.footnote_close = function() {
  return '</li>\n';
};
rules.footnote_anchor = function(tokens, idx) {
  var n = Number(tokens[idx].id + 1).toString();
  var id = 'fnref' + n;
  if (tokens[idx].subId > 0) {
    id += ':' + tokens[idx].subId;
  }
  return ' <a href="#' + id + '" class="footnote-backref">↩</a>';
};

/**
 * Definition lists
 */

rules.dl_open = function() {
  return '<dl>\n';
};
rules.dt_open = function() {
  return '<dt>';
};
rules.dd_open = function() {
  return '<dd>';
};
rules.dl_close = function() {
  return '</dl>\n';
};
rules.dt_close = function() {
  return '</dt>\n';
};
rules.dd_close = function() {
  return '</dd>\n';
};

/**
 * Helper functions
 */

function nextToken(tokens, idx) {
  if (++idx >= tokens.length - 2) {
    return idx;
  }
  if ((tokens[idx].type === 'paragraph_open' && tokens[idx].tight) &&
      (tokens[idx + 1].type === 'inline' && tokens[idx + 1].content.length === 0) &&
      (tokens[idx + 2].type === 'paragraph_close' && tokens[idx + 2].tight)) {
    return nextToken(tokens, idx + 2);
  }
  return idx;
}

/**
 * Check to see if `\n` is needed before the next token.
 *
 * @param  {Array} `tokens`
 * @param  {Number} `idx`
 * @return {String} Empty string or newline
 * @api private
 */

var getBreak = rules.getBreak = function getBreak(tokens, idx) {
  idx = nextToken(tokens, idx);
  if (idx < tokens.length && tokens[idx].type === 'list_item_close') {
    return '';
  }
  return '\n';
};

/**
 * Expose `rules`
 */

module.exports = rules;


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_block/blockquote.js":
/*!***************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_block/blockquote.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Block quotes




module.exports = function blockquote(state, startLine, endLine, silent) {
  var nextLine, lastLineEmpty, oldTShift, oldBMarks, oldIndent, oldParentType, lines,
      terminatorRules,
      i, l, terminate,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos > max) { return false; }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }

  if (state.level >= state.options.maxNesting) { return false; }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) { return true; }

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20) { pos++; }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  oldBMarks = [ state.bMarks[startLine] ];
  state.bMarks[startLine] = pos;

  // check if we have an empty blockquote
  pos = pos < max ? state.skipSpaces(pos) : pos;
  lastLineEmpty = pos >= max;

  oldTShift = [ state.tShift[startLine] ];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.parser.ruler.getRules('blockquote');

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E/* > */) {
      // This line is inside the blockquote.

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20) { pos++; }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      pos = pos < max ? state.skipSpaces(pos) : pos;
      lastLineEmpty = pos >= max;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) { break; }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }

    oldBMarks.push(state.bMarks[nextLine]);
    oldTShift.push(state.tShift[nextLine]);

    // A negative number means that this is a paragraph continuation;
    //
    // Any negative number will do the job here, but it's better for it
    // to be large enough to make any bugs obvious.
    state.tShift[nextLine] = -1337;
  }

  oldParentType = state.parentType;
  state.parentType = 'blockquote';
  state.tokens.push({
    type: 'blockquote_open',
    lines: lines = [ startLine, 0 ],
    level: state.level++
  });
  state.parser.tokenize(state, startLine, nextLine);
  state.tokens.push({
    type: 'blockquote_close',
    level: --state.level
  });
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
  }
  state.blkIndent = oldIndent;

  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_block/code.js":
/*!*********************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_block/code.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Code block (4 spaces padded)




module.exports = function code(state, startLine, endLine/*, silent*/) {
  var nextLine, last;

  if (state.tShift[startLine] - state.blkIndent < 4) { return false; }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state.tShift[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = nextLine;
  state.tokens.push({
    type: 'code',
    content: state.getLines(startLine, last, 4 + state.blkIndent, true),
    block: true,
    lines: [ startLine, state.line ],
    level: state.level
  });

  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_block/deflist.js":
/*!************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_block/deflist.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Definition lists




// Search `[:~][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipMarker(state, line) {
  var pos, marker,
      start = state.bMarks[line] + state.tShift[line],
      max = state.eMarks[line];

  if (start >= max) { return -1; }

  // Check bullet
  marker = state.src.charCodeAt(start++);
  if (marker !== 0x7E/* ~ */ && marker !== 0x3A/* : */) { return -1; }

  pos = state.skipSpaces(start);

  // require space after ":"
  if (start === pos) { return -1; }

  // no empty definitions, e.g. "  : "
  if (pos >= max) { return -1; }

  return pos;
}

function markTightParagraphs(state, idx) {
  var i, l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].tight = true;
      state.tokens[i].tight = true;
      i += 2;
    }
  }
}

module.exports = function deflist(state, startLine, endLine, silent) {
  var contentStart,
      ddLine,
      dtLine,
      itemLines,
      listLines,
      listTokIdx,
      nextLine,
      oldIndent,
      oldDDIndent,
      oldParentType,
      oldTShift,
      oldTight,
      prevEmptyEnd,
      tight;

  if (silent) {
    // quirk: validation mode validates a dd block only, not a whole deflist
    if (state.ddIndent < 0) { return false; }
    return skipMarker(state, startLine) >= 0;
  }

  nextLine = startLine + 1;
  if (state.isEmpty(nextLine)) {
    if (++nextLine > endLine) { return false; }
  }

  if (state.tShift[nextLine] < state.blkIndent) { return false; }
  contentStart = skipMarker(state, nextLine);
  if (contentStart < 0) { return false; }

  if (state.level >= state.options.maxNesting) { return false; }

  // Start list
  listTokIdx = state.tokens.length;

  state.tokens.push({
    type: 'dl_open',
    lines: listLines = [ startLine, 0 ],
    level: state.level++
  });

  //
  // Iterate list items
  //

  dtLine = startLine;
  ddLine = nextLine;

  // One definition list can contain multiple DTs,
  // and one DT can be followed by multiple DDs.
  //
  // Thus, there is two loops here, and label is
  // needed to break out of the second one
  //
  /*eslint no-labels:0,block-scoped-var:0*/
  OUTER:
  for (;;) {
    tight = true;
    prevEmptyEnd = false;

    state.tokens.push({
      type: 'dt_open',
      lines: [ dtLine, dtLine ],
      level: state.level++
    });
    state.tokens.push({
      type: 'inline',
      content: state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim(),
      level: state.level + 1,
      lines: [ dtLine, dtLine ],
      children: []
    });
    state.tokens.push({
      type: 'dt_close',
      level: --state.level
    });

    for (;;) {
      state.tokens.push({
        type: 'dd_open',
        lines: itemLines = [ nextLine, 0 ],
        level: state.level++
      });

      oldTight = state.tight;
      oldDDIndent = state.ddIndent;
      oldIndent = state.blkIndent;
      oldTShift = state.tShift[ddLine];
      oldParentType = state.parentType;
      state.blkIndent = state.ddIndent = state.tShift[ddLine] + 2;
      state.tShift[ddLine] = contentStart - state.bMarks[ddLine];
      state.tight = true;
      state.parentType = 'deflist';

      state.parser.tokenize(state, ddLine, endLine, true);

      // If any of list item is tight, mark list as tight
      if (!state.tight || prevEmptyEnd) {
        tight = false;
      }
      // Item become loose if finish with empty line,
      // but we should filter last element, because it means list finish
      prevEmptyEnd = (state.line - ddLine) > 1 && state.isEmpty(state.line - 1);

      state.tShift[ddLine] = oldTShift;
      state.tight = oldTight;
      state.parentType = oldParentType;
      state.blkIndent = oldIndent;
      state.ddIndent = oldDDIndent;

      state.tokens.push({
        type: 'dd_close',
        level: --state.level
      });

      itemLines[1] = nextLine = state.line;

      if (nextLine >= endLine) { break OUTER; }

      if (state.tShift[nextLine] < state.blkIndent) { break OUTER; }
      contentStart = skipMarker(state, nextLine);
      if (contentStart < 0) { break; }

      ddLine = nextLine;

      // go to the next loop iteration:
      // insert DD tag and repeat checking
    }

    if (nextLine >= endLine) { break; }
    dtLine = nextLine;

    if (state.isEmpty(dtLine)) { break; }
    if (state.tShift[dtLine] < state.blkIndent) { break; }

    ddLine = dtLine + 1;
    if (ddLine >= endLine) { break; }
    if (state.isEmpty(ddLine)) { ddLine++; }
    if (ddLine >= endLine) { break; }

    if (state.tShift[ddLine] < state.blkIndent) { break; }
    contentStart = skipMarker(state, ddLine);
    if (contentStart < 0) { break; }

    // go to the next loop iteration:
    // insert DT and DD tags and repeat checking
  }

  // Finilize list
  state.tokens.push({
    type: 'dl_close',
    level: --state.level
  });
  listLines[1] = nextLine;

  state.line = nextLine;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_block/fences.js":
/*!***********************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_block/fences.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// fences (``` lang, ~~~ lang)




module.exports = function fences(state, startLine, endLine, silent) {
  var marker, len, params, nextLine, mem,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos + 3 > max) { return false; }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {
    return false;
  }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) { return false; }

  params = state.src.slice(pos, max).trim();

  if (params.indexOf('`') >= 0) { return false; }

  // Since start is found, we can report success here in validation mode
  if (silent) { return true; }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.tShift[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) { continue; }

    if (state.tShift[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) { continue; }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) { continue; }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.tShift[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);
  state.tokens.push({
    type: 'fence',
    params: params,
    content: state.getLines(startLine + 1, nextLine, len, true),
    lines: [ startLine, state.line ],
    level: state.level
  });

  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_block/footnote.js":
/*!*************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_block/footnote.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process footnote reference list




module.exports = function footnote(state, startLine, endLine, silent) {
  var oldBMark, oldTShift, oldParentType, pos, label,
      start = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // line should be at least 5 chars - "[^x]:"
  if (start + 4 > max) { return false; }

  if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  for (pos = start + 2; pos < max; pos++) {
    if (state.src.charCodeAt(pos) === 0x20) { return false; }
    if (state.src.charCodeAt(pos) === 0x5D /* ] */) {
      break;
    }
  }

  if (pos === start + 2) { return false; } // no empty footnote labels
  if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 0x3A /* : */) { return false; }
  if (silent) { return true; }
  pos++;

  if (!state.env.footnotes) { state.env.footnotes = {}; }
  if (!state.env.footnotes.refs) { state.env.footnotes.refs = {}; }
  label = state.src.slice(start + 2, pos - 2);
  state.env.footnotes.refs[':' + label] = -1;

  state.tokens.push({
    type: 'footnote_reference_open',
    label: label,
    level: state.level++
  });

  oldBMark = state.bMarks[startLine];
  oldTShift = state.tShift[startLine];
  oldParentType = state.parentType;
  state.tShift[startLine] = state.skipSpaces(pos) - pos;
  state.bMarks[startLine] = pos;
  state.blkIndent += 4;
  state.parentType = 'footnote';

  if (state.tShift[startLine] < state.blkIndent) {
    state.tShift[startLine] += state.blkIndent;
    state.bMarks[startLine] -= state.blkIndent;
  }

  state.parser.tokenize(state, startLine, endLine, true);

  state.parentType = oldParentType;
  state.blkIndent -= 4;
  state.tShift[startLine] = oldTShift;
  state.bMarks[startLine] = oldBMark;

  state.tokens.push({
    type: 'footnote_reference_close',
    level: --state.level
  });

  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_block/heading.js":
/*!************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_block/heading.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// heading (#, ##, ...)




module.exports = function heading(state, startLine, endLine, silent) {
  var ch, level, tmp,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos >= max) { return false; }

  ch  = state.src.charCodeAt(pos);

  if (ch !== 0x23/* # */ || pos >= max) { return false; }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23/* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || (pos < max && ch !== 0x20/* space */)) { return false; }

  if (silent) { return true; }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipCharsBack(max, 0x20, pos); // space
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && state.src.charCodeAt(tmp - 1) === 0x20/* space */) {
    max = tmp;
  }

  state.line = startLine + 1;

  state.tokens.push({ type: 'heading_open',
    hLevel: level,
    lines: [ startLine, state.line ],
    level: state.level
  });

  // only if header is not empty
  if (pos < max) {
    state.tokens.push({
      type: 'inline',
      content: state.src.slice(pos, max).trim(),
      level: state.level + 1,
      lines: [ startLine, state.line ],
      children: []
    });
  }
  state.tokens.push({ type: 'heading_close', hLevel: level, level: state.level });

  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_block/hr.js":
/*!*******************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_block/hr.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Horizontal rule




module.exports = function hr(state, startLine, endLine, silent) {
  var marker, cnt, ch,
      pos = state.bMarks[startLine],
      max = state.eMarks[startLine];

  pos += state.tShift[startLine];

  if (pos > max) { return false; }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A/* * */ &&
      marker !== 0x2D/* - */ &&
      marker !== 0x5F/* _ */) {
    return false;
  }

  // markers can be mixed with spaces, but there should be at least 3 one

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && ch !== 0x20/* space */) { return false; }
    if (ch === marker) { cnt++; }
  }

  if (cnt < 3) { return false; }

  if (silent) { return true; }

  state.line = startLine + 1;
  state.tokens.push({
    type: 'hr',
    lines: [ startLine, state.line ],
    level: state.level
  });

  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_block/htmlblock.js":
/*!**************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_block/htmlblock.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HTML block




var block_names = __webpack_require__(/*! ../common/html_blocks */ "./node_modules/remarkable/lib/common/html_blocks.js");


var HTML_TAG_OPEN_RE = /^<([a-zA-Z]{1,15})[\s\/>]/;
var HTML_TAG_CLOSE_RE = /^<\/([a-zA-Z]{1,15})[\s>]/;

function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);
}

module.exports = function htmlblock(state, startLine, endLine, silent) {
  var ch, match, nextLine,
      pos = state.bMarks[startLine],
      max = state.eMarks[startLine],
      shift = state.tShift[startLine];

  pos += shift;

  if (!state.options.html) { return false; }

  if (shift > 3 || pos + 2 >= max) { return false; }

  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

  ch = state.src.charCodeAt(pos + 1);

  if (ch === 0x21/* ! */ || ch === 0x3F/* ? */) {
    // Directive start / comment start / processing instruction start
    if (silent) { return true; }

  } else if (ch === 0x2F/* / */ || isLetter(ch)) {

    // Probably start or end of tag
    if (ch === 0x2F/* \ */) {
      // closing tag
      match = state.src.slice(pos, max).match(HTML_TAG_CLOSE_RE);
      if (!match) { return false; }
    } else {
      // opening tag
      match = state.src.slice(pos, max).match(HTML_TAG_OPEN_RE);
      if (!match) { return false; }
    }
    // Make sure tag name is valid
    if (block_names[match[1].toLowerCase()] !== true) { return false; }
    if (silent) { return true; }

  } else {
    return false;
  }

  // If we are here - we detected HTML block.
  // Let's roll down till empty line (block end).
  nextLine = startLine + 1;
  while (nextLine < state.lineMax && !state.isEmpty(nextLine)) {
    nextLine++;
  }

  state.line = nextLine;
  state.tokens.push({
    type: 'htmlblock',
    level: state.level,
    lines: [ startLine, state.line ],
    content: state.getLines(startLine, nextLine, 0, true)
  });

  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_block/lheading.js":
/*!*************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_block/lheading.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// lheading (---, ===)




module.exports = function lheading(state, startLine, endLine/*, silent*/) {
  var marker, pos, max,
      next = startLine + 1;

  if (next >= endLine) { return false; }
  if (state.tShift[next] < state.blkIndent) { return false; }

  // Scan next line

  if (state.tShift[next] - state.blkIndent > 3) { return false; }

  pos = state.bMarks[next] + state.tShift[next];
  max = state.eMarks[next];

  if (pos >= max) { return false; }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x2D/* - */ && marker !== 0x3D/* = */) { return false; }

  pos = state.skipChars(pos, marker);

  pos = state.skipSpaces(pos);

  if (pos < max) { return false; }

  pos = state.bMarks[startLine] + state.tShift[startLine];

  state.line = next + 1;
  state.tokens.push({
    type: 'heading_open',
    hLevel: marker === 0x3D/* = */ ? 1 : 2,
    lines: [ startLine, state.line ],
    level: state.level
  });
  state.tokens.push({
    type: 'inline',
    content: state.src.slice(pos, state.eMarks[startLine]).trim(),
    level: state.level + 1,
    lines: [ startLine, state.line - 1 ],
    children: []
  });
  state.tokens.push({
    type: 'heading_close',
    hLevel: marker === 0x3D/* = */ ? 1 : 2,
    level: state.level
  });

  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_block/list.js":
/*!*********************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_block/list.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Lists




// Search `[-+*][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  if (pos >= max) { return -1; }

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A/* * */ &&
      marker !== 0x2D/* - */ &&
      marker !== 0x2B/* + */) {
    return -1;
  }

  if (pos < max && state.src.charCodeAt(pos) !== 0x20) {
    // " 1.test " - is not a list item
    return -1;
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos arter marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  if (pos + 1 >= max) { return -1; }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }

  for (;;) {
    // EOL -> fail
    if (pos >= max) { return -1; }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {
      continue;
    }

    // found valid marker
    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {
      break;
    }

    return -1;
  }


  if (pos < max && state.src.charCodeAt(pos) !== 0x20/* space */) {
    // " 1.test " - is not a list item
    return -1;
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i, l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].tight = true;
      state.tokens[i].tight = true;
      i += 2;
    }
  }
}


module.exports = function list(state, startLine, endLine, silent) {
  var nextLine,
      indent,
      oldTShift,
      oldIndent,
      oldTight,
      oldParentType,
      start,
      posAfterMarker,
      max,
      indentAfterMarker,
      markerValue,
      markerCharCode,
      isOrdered,
      contentStart,
      listTokIdx,
      prevEmptyEnd,
      listLines,
      itemLines,
      tight = true,
      terminatorRules,
      i, l, terminate;

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }

  if (state.level >= state.options.maxNesting) { return false; }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) { return true; }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

    state.tokens.push({
      type: 'ordered_list_open',
      order: markerValue,
      lines: listLines = [ startLine, 0 ],
      level: state.level++
    });

  } else {
    state.tokens.push({
      type: 'bullet_list_open',
      lines: listLines = [ startLine, 0 ],
      level: state.level++
    });
  }

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.parser.ruler.getRules('list');

  while (nextLine < endLine) {
    contentStart = state.skipSpaces(posAfterMarker);
    max = state.eMarks[nextLine];

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = contentStart - posAfterMarker;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) { indentAfterMarker = 1; }

    // If indent is less than 1, assume that it's one, example:
    //  "-\n  test"
    if (indentAfterMarker < 1) { indentAfterMarker = 1; }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = (posAfterMarker - state.bMarks[nextLine]) + indentAfterMarker;

    // Run subparser & write tokens
    state.tokens.push({
      type: 'list_item_open',
      lines: itemLines = [ startLine, 0 ],
      level: state.level++
    });

    oldIndent = state.blkIndent;
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldParentType = state.parentType;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.blkIndent = indent;
    state.tight = true;
    state.parentType = 'list';

    state.parser.tokenize(state, startLine, endLine, true);

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = oldIndent;
    state.tShift[startLine] = oldTShift;
    state.tight = oldTight;
    state.parentType = oldParentType;

    state.tokens.push({
      type: 'list_item_close',
      level: --state.level
    });

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) { break; }

    if (state.isEmpty(nextLine)) {
      break;
    }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.tShift[nextLine] < state.blkIndent) { break; }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) { break; }
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) { break; }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }
  }

  // Finilize list
  state.tokens.push({
    type: isOrdered ? 'ordered_list_close' : 'bullet_list_close',
    level: --state.level
  });
  listLines[1] = nextLine;

  state.line = nextLine;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_block/paragraph.js":
/*!**************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_block/paragraph.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Paragraph




module.exports = function paragraph(state, startLine/*, endLine*/) {
  var endLine, content, terminate, i, l,
      nextLine = startLine + 1,
      terminatorRules;

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  if (nextLine < endLine && !state.isEmpty(nextLine)) {
    terminatorRules = state.parser.ruler.getRules('paragraph');

    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
      // this would be a code block normally, but after paragraph
      // it's considered a lazy continuation regardless of what's there
      if (state.tShift[nextLine] - state.blkIndent > 3) { continue; }

      // Some tags can terminate paragraph without empty line.
      terminate = false;
      for (i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) { break; }
    }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;
  if (content.length) {
    state.tokens.push({
      type: 'paragraph_open',
      tight: false,
      lines: [ startLine, state.line ],
      level: state.level
    });
    state.tokens.push({
      type: 'inline',
      content: content,
      level: state.level + 1,
      lines: [ startLine, state.line ],
      children: []
    });
    state.tokens.push({
      type: 'paragraph_close',
      tight: false,
      level: state.level
    });
  }

  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_block/state_block.js":
/*!****************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_block/state_block.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parser state class




function StateBlock(src, parser, options, env, tokens) {
  var ch, s, start, pos, len, indent, indent_found;

  this.src = src;

  // Shortcuts to simplify nested calls
  this.parser = parser;

  this.options = options;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = [];  // line begin offsets for fast jumps
  this.eMarks = [];  // line end offsets for fast jumps
  this.tShift = [];  // indent for each line

  // block parser variables
  this.blkIndent  = 0; // required block content indent
                       // (for example, if we are in list)
  this.line       = 0; // line index in src
  this.lineMax    = 0; // lines count
  this.tight      = false;  // loose/tight mode for lists
  this.parentType = 'root'; // if `list`, block parser stops on two newlines
  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent = 0;
  indent_found = false;

  for (start = pos = indent = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (ch === 0x20/* space */) {
        indent++;
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) { pos++; }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);

      indent_found = false;
      indent = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== 0x20/* space */) { break; }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) { break; }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) { return pos; }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i, first, last, queue, shift,
      line = begin;

  if (begin >= end) {
    return '';
  }

  // Opt: don't use push queue for single line;
  if (line + 1 === end) {
    first = this.bMarks[line] + Math.min(this.tShift[line], indent);
    last = keepLastLF ? this.eMarks[line] + 1 : this.eMarks[line];
    return this.src.slice(first, last);
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    shift = this.tShift[line];
    if (shift > indent) { shift = indent; }
    if (shift < 0) { shift = 0; }

    first = this.bMarks[line] + shift;

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    queue[i] = this.src.slice(first, last);
  }

  return queue.join('');
};


module.exports = StateBlock;


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_block/table.js":
/*!**********************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_block/table.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// GFM table, non-standard




function getLine(state, line) {
  var pos = state.bMarks[line] + state.blkIndent,
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

module.exports = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, nextLine, rows, cell,
      aligns, t, tableLines, tbodyLines;

  // should have at least three lines
  if (startLine + 2 > endLine) { return false; }

  nextLine = startLine + 1;

  if (state.tShift[nextLine] < state.blkIndent) { return false; }

  // first character of the second line should be '|' or '-'

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) { return false; }

  ch = state.src.charCodeAt(pos);
  if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */) { return false; }

  lineText = getLine(state, startLine + 1);
  if (!/^[-:| ]+$/.test(lineText)) { return false; }

  rows = lineText.split('|');
  if (rows <= 2) { return false; }
  aligns = [];
  for (i = 0; i < rows.length; i++) {
    t = rows[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === rows.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) { return false; }
    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {
      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');
    } else if (t.charCodeAt(0) === 0x3A/* : */) {
      aligns.push('left');
    } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) { return false; }
  rows = lineText.replace(/^\||\|$/g, '').split('|');
  if (aligns.length !== rows.length) { return false; }
  if (silent) { return true; }

  state.tokens.push({
    type: 'table_open',
    lines: tableLines = [ startLine, 0 ],
    level: state.level++
  });
  state.tokens.push({
    type: 'thead_open',
    lines: [ startLine, startLine + 1 ],
    level: state.level++
  });

  state.tokens.push({
    type: 'tr_open',
    lines: [ startLine, startLine + 1 ],
    level: state.level++
  });
  for (i = 0; i < rows.length; i++) {
    state.tokens.push({
      type: 'th_open',
      align: aligns[i],
      lines: [ startLine, startLine + 1 ],
      level: state.level++
    });
    state.tokens.push({
      type: 'inline',
      content: rows[i].trim(),
      lines: [ startLine, startLine + 1 ],
      level: state.level,
      children: []
    });
    state.tokens.push({ type: 'th_close', level: --state.level });
  }
  state.tokens.push({ type: 'tr_close', level: --state.level });
  state.tokens.push({ type: 'thead_close', level: --state.level });

  state.tokens.push({
    type: 'tbody_open',
    lines: tbodyLines = [ startLine + 2, 0 ],
    level: state.level++
  });

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.tShift[nextLine] < state.blkIndent) { break; }

    lineText = getLine(state, nextLine).trim();
    if (lineText.indexOf('|') === -1) { break; }
    rows = lineText.replace(/^\||\|$/g, '').split('|');

    state.tokens.push({ type: 'tr_open', level: state.level++ });
    for (i = 0; i < rows.length; i++) {
      state.tokens.push({ type: 'td_open', align: aligns[i], level: state.level++ });
      // 0x7c === '|'
      cell = rows[i].substring(
          rows[i].charCodeAt(0) === 0x7c ? 1 : 0,
          rows[i].charCodeAt(rows[i].length - 1) === 0x7c ? rows[i].length - 1 : rows[i].length
      ).trim();
      state.tokens.push({
        type: 'inline',
        content: cell,
        level: state.level,
        children: []
      });
      state.tokens.push({ type: 'td_close', level: --state.level });
    }
    state.tokens.push({ type: 'tr_close', level: --state.level });
  }
  state.tokens.push({ type: 'tbody_close', level: --state.level });
  state.tokens.push({ type: 'table_close', level: --state.level });

  tableLines[1] = tbodyLines[1] = nextLine;
  state.line = nextLine;
  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_core/abbr.js":
/*!********************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_core/abbr.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse abbreviation definitions, i.e. `*[abbr]: description`
//




var StateInline    = __webpack_require__(/*! ../rules_inline/state_inline */ "./node_modules/remarkable/lib/rules_inline/state_inline.js");
var parseLinkLabel = __webpack_require__(/*! ../helpers/parse_link_label */ "./node_modules/remarkable/lib/helpers/parse_link_label.js");


function parseAbbr(str, parserInline, options, env) {
  var state, labelEnd, pos, max, label, title;

  if (str.charCodeAt(0) !== 0x2A/* * */) { return -1; }
  if (str.charCodeAt(1) !== 0x5B/* [ */) { return -1; }

  if (str.indexOf(']:') === -1) { return -1; }

  state = new StateInline(str, parserInline, options, env, []);
  labelEnd = parseLinkLabel(state, 1);

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }

  max = state.posMax;

  // abbr title is always one line, so looking for ending "\n" here
  for (pos = labelEnd + 2; pos < max; pos++) {
    if (state.src.charCodeAt(pos) === 0x0A) { break; }
  }

  label = str.slice(2, labelEnd);
  title = str.slice(labelEnd + 2, pos).trim();
  if (title.length === 0) { return -1; }
  if (!env.abbreviations) { env.abbreviations = {}; }
  // prepend ':' to avoid conflict with Object.prototype members
  if (typeof env.abbreviations[':' + label] === 'undefined') {
    env.abbreviations[':' + label] = title;
  }

  return pos;
}

module.exports = function abbr(state) {
  var tokens = state.tokens, i, l, content, pos;

  if (state.inlineMode) {
    return;
  }

  // Parse inlines
  for (i = 1, l = tokens.length - 1; i < l; i++) {
    if (tokens[i - 1].type === 'paragraph_open' &&
        tokens[i].type === 'inline' &&
        tokens[i + 1].type === 'paragraph_close') {

      content = tokens[i].content;
      while (content.length) {
        pos = parseAbbr(content, state.inline, state.options, state.env);
        if (pos < 0) { break; }
        content = content.slice(pos).trim();
      }

      tokens[i].content = content;
      if (!content.length) {
        tokens[i - 1].tight = true;
        tokens[i + 1].tight = true;
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_core/abbr2.js":
/*!*********************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_core/abbr2.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Enclose abbreviations in <abbr> tags
//



var PUNCT_CHARS = ' \n()[]\'".,!?-';


// from Google closure library
// http://closure-library.googlecode.com/git-history/docs/local_closure_goog_string_string.js.source.html#line1021
function regEscape(s) {
  return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1');
}


module.exports = function abbr2(state) {
  var i, j, l, tokens, token, text, nodes, pos, level, reg, m, regText,
      blockTokens = state.tokens;

  if (!state.env.abbreviations) { return; }
  if (!state.env.abbrRegExp) {
    regText = '(^|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])'
            + '(' + Object.keys(state.env.abbreviations).map(function (x) {
                      return x.substr(1);
                    }).sort(function (a, b) {
                      return b.length - a.length;
                    }).map(regEscape).join('|') + ')'
            + '($|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])';
    state.env.abbrRegExp = new RegExp(regText, 'g');
  }
  reg = state.env.abbrRegExp;

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline') { continue; }
    tokens = blockTokens[j].children;

    // We scan from the end, to keep position when new tags added.
    for (i = tokens.length - 1; i >= 0; i--) {
      token = tokens[i];
      if (token.type !== 'text') { continue; }

      pos = 0;
      text = token.content;
      reg.lastIndex = 0;
      level = token.level;
      nodes = [];

      while ((m = reg.exec(text))) {
        if (reg.lastIndex > pos) {
          nodes.push({
            type: 'text',
            content: text.slice(pos, m.index + m[1].length),
            level: level
          });
        }

        nodes.push({
          type: 'abbr_open',
          title: state.env.abbreviations[':' + m[2]],
          level: level++
        });
        nodes.push({
          type: 'text',
          content: m[2],
          level: level
        });
        nodes.push({
          type: 'abbr_close',
          level: --level
        });
        pos = reg.lastIndex - m[3].length;
      }

      if (!nodes.length) { continue; }

      if (pos < text.length) {
        nodes.push({
          type: 'text',
          content: text.slice(pos),
          level: level
        });
      }

      // replace current node
      blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));
    }
  }
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_core/block.js":
/*!*********************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_core/block.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function block(state) {

  if (state.inlineMode) {
    state.tokens.push({
      type: 'inline',
      content: state.src.replace(/\n/g, ' ').trim(),
      level: 0,
      lines: [ 0, 1 ],
      children: []
    });

  } else {
    state.block.parse(state.src, state.options, state.env, state.tokens);
  }
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_core/footnote_tail.js":
/*!*****************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_core/footnote_tail.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



module.exports = function footnote_block(state) {
  var i, l, j, t, lastParagraph, list, tokens, current, currentLabel,
      level = 0,
      insideRef = false,
      refTokens = {};

  if (!state.env.footnotes) { return; }

  state.tokens = state.tokens.filter(function(tok) {
    if (tok.type === 'footnote_reference_open') {
      insideRef = true;
      current = [];
      currentLabel = tok.label;
      return false;
    }
    if (tok.type === 'footnote_reference_close') {
      insideRef = false;
      // prepend ':' to avoid conflict with Object.prototype members
      refTokens[':' + currentLabel] = current;
      return false;
    }
    if (insideRef) { current.push(tok); }
    return !insideRef;
  });

  if (!state.env.footnotes.list) { return; }
  list = state.env.footnotes.list;

  state.tokens.push({
    type: 'footnote_block_open',
    level: level++
  });
  for (i = 0, l = list.length; i < l; i++) {
    state.tokens.push({
      type: 'footnote_open',
      id: i,
      level: level++
    });

    if (list[i].tokens) {
      tokens = [];
      tokens.push({
        type: 'paragraph_open',
        tight: false,
        level: level++
      });
      tokens.push({
        type: 'inline',
        content: '',
        level: level,
        children: list[i].tokens
      });
      tokens.push({
        type: 'paragraph_close',
        tight: false,
        level: --level
      });
    } else if (list[i].label) {
      tokens = refTokens[':' + list[i].label];
    }

    state.tokens = state.tokens.concat(tokens);
    if (state.tokens[state.tokens.length - 1].type === 'paragraph_close') {
      lastParagraph = state.tokens.pop();
    } else {
      lastParagraph = null;
    }

    t = list[i].count > 0 ? list[i].count : 1;
    for (j = 0; j < t; j++) {
      state.tokens.push({
        type: 'footnote_anchor',
        id: i,
        subId: j,
        level: level
      });
    }

    if (lastParagraph) {
      state.tokens.push(lastParagraph);
    }

    state.tokens.push({
      type: 'footnote_close',
      level: --level
    });
  }
  state.tokens.push({
    type: 'footnote_block_close',
    level: --level
  });
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_core/inline.js":
/*!**********************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_core/inline.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function inline(state) {
  var tokens = state.tokens, tok, i, l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.inline.parse(tok.content, state.options, state.env, tok.children);
    }
  }
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_core/linkify.js":
/*!***********************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_core/linkify.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Replace link-like texts with link nodes.
//
// Currently restricted by `inline.validateLink()` to http/https/ftp
//



var Autolinker = __webpack_require__(/*! autolinker */ "./node_modules/autolinker/dist/Autolinker.js");


var LINK_SCAN_RE = /www|@|\:\/\//;


function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}

// Stupid fabric to avoid singletons, for thread safety.
// Required for engines like Nashorn.
//
function createLinkifier() {
  var links = [];
  var autolinker = new Autolinker({
    stripPrefix: false,
    url: true,
    email: true,
    twitter: false,
    replaceFn: function (linker, match) {
      // Only collect matched strings but don't change anything.
      switch (match.getType()) {
        /*eslint default-case:0*/
        case 'url':
          links.push({
            text: match.matchedText,
            url: match.getUrl()
          });
          break;
        case 'email':
          links.push({
            text: match.matchedText,
            // normalize email protocol
            url: 'mailto:' + match.getEmail().replace(/^mailto:/i, '')
          });
          break;
      }
      return false;
    }
  });

  return {
    links: links,
    autolinker: autolinker
  };
}


module.exports = function linkify(state) {
  var i, j, l, tokens, token, text, nodes, ln, pos, level, htmlLinkLevel,
      blockTokens = state.tokens,
      linkifier = null, links, autolinker;

  if (!state.options.linkify) { return; }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline') { continue; }
    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      token = tokens[i];

      // Skip content of markdown links
      if (token.type === 'link_close') {
        i--;
        while (tokens[i].level !== token.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (token.type === 'htmltag') {
        if (isLinkOpen(token.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(token.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) { continue; }

      if (token.type === 'text' && LINK_SCAN_RE.test(token.content)) {

        // Init linkifier in lazy manner, only if required.
        if (!linkifier) {
          linkifier = createLinkifier();
          links = linkifier.links;
          autolinker = linkifier.autolinker;
        }

        text = token.content;
        links.length = 0;
        autolinker.link(text);

        if (!links.length) { continue; }

        // Now split string to nodes
        nodes = [];
        level = token.level;

        for (ln = 0; ln < links.length; ln++) {

          if (!state.inline.validateLink(links[ln].url)) { continue; }

          pos = text.indexOf(links[ln].text);

          if (pos) {
            level = level;
            nodes.push({
              type: 'text',
              content: text.slice(0, pos),
              level: level
            });
          }
          nodes.push({
            type: 'link_open',
            href: links[ln].url,
            title: '',
            level: level++
          });
          nodes.push({
            type: 'text',
            content: links[ln].text,
            level: level
          });
          nodes.push({
            type: 'link_close',
            level: --level
          });
          text = text.slice(pos + links[ln].text.length);
        }
        if (text.length) {
          nodes.push({
            type: 'text',
            content: text,
            level: level
          });
        }

        // replace current node
        blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_core/references.js":
/*!**************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_core/references.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var StateInline          = __webpack_require__(/*! ../rules_inline/state_inline */ "./node_modules/remarkable/lib/rules_inline/state_inline.js");
var parseLinkLabel       = __webpack_require__(/*! ../helpers/parse_link_label */ "./node_modules/remarkable/lib/helpers/parse_link_label.js");
var parseLinkDestination = __webpack_require__(/*! ../helpers/parse_link_destination */ "./node_modules/remarkable/lib/helpers/parse_link_destination.js");
var parseLinkTitle       = __webpack_require__(/*! ../helpers/parse_link_title */ "./node_modules/remarkable/lib/helpers/parse_link_title.js");
var normalizeReference   = __webpack_require__(/*! ../helpers/normalize_reference */ "./node_modules/remarkable/lib/helpers/normalize_reference.js");


function parseReference(str, parser, options, env) {
  var state, labelEnd, pos, max, code, start, href, title, label;

  if (str.charCodeAt(0) !== 0x5B/* [ */) { return -1; }

  if (str.indexOf(']:') === -1) { return -1; }

  state = new StateInline(str, parser, options, env, []);
  labelEnd = parseLinkLabel(state, 0);

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return -1; }

  max = state.posMax;

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    code = state.src.charCodeAt(pos);
    if (code !== 0x20 && code !== 0x0A) { break; }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  if (!parseLinkDestination(state, pos)) { return -1; }
  href = state.linkContent;
  pos = state.pos;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (pos = pos + 1; pos < max; pos++) {
    code = state.src.charCodeAt(pos);
    if (code !== 0x20 && code !== 0x0A) { break; }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  if (pos < max && start !== pos && parseLinkTitle(state, pos)) {
    title = state.linkContent;
    pos = state.pos;
  } else {
    title = '';
    pos = start;
  }

  // ensure that the end of the line is empty
  while (pos < max && state.src.charCodeAt(pos) === 0x20/* space */) { pos++; }
  if (pos < max && state.src.charCodeAt(pos) !== 0x0A) { return -1; }

  label = normalizeReference(str.slice(1, labelEnd));
  if (typeof env.references[label] === 'undefined') {
    env.references[label] = { title: title, href: href };
  }

  return pos;
}


module.exports = function references(state) {
  var tokens = state.tokens, i, l, content, pos;

  state.env.references = state.env.references || {};

  if (state.inlineMode) {
    return;
  }

  // Scan definitions in paragraph inlines
  for (i = 1, l = tokens.length - 1; i < l; i++) {
    if (tokens[i].type === 'inline' &&
        tokens[i - 1].type === 'paragraph_open' &&
        tokens[i + 1].type === 'paragraph_close') {

      content = tokens[i].content;
      while (content.length) {
        pos = parseReference(content, state.inline, state.options, state.env);
        if (pos < 0) { break; }
        content = content.slice(pos).trim();
      }

      tokens[i].content = content;
      if (!content.length) {
        tokens[i - 1].tight = true;
        tokens[i + 1].tight = true;
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_core/replacements.js":
/*!****************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_core/replacements.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Simple typographical replacements
//


// TODO:
// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
// - miltiplication 2 x 4 -> 2 × 4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  'c': '©',
  'r': '®',
  'p': '§',
  'tm': '™'
};

function replaceScopedAbbr(str) {
  if (str.indexOf('(') < 0) { return str; }

  return str.replace(SCOPED_ABBR_RE, function(match, name) {
    return SCOPED_ABBR[name.toLowerCase()];
  });
}


module.exports = function replace(state) {
  var i, token, text, inlineTokens, blkIdx;

  if (!state.options.typographer) { return; }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') { continue; }

    inlineTokens = state.tokens[blkIdx].children;

    for (i = inlineTokens.length - 1; i >= 0; i--) {
      token = inlineTokens[i];
      if (token.type === 'text') {
        text = token.content;

        text = replaceScopedAbbr(text);

        if (RARE_RE.test(text)) {
          text = text
            .replace(/\+-/g, '±')
            // .., ..., ....... -> …
            // but ?..... & !..... -> ?.. & !..
            .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..')
            .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
            // em-dash
            .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2')
            // en-dash
            .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2')
            .replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
        }

        token.content = text;
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_core/smartquotes.js":
/*!***************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_core/smartquotes.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Convert straight quotation marks to typographic ones
//



var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var PUNCT_RE = /[-\s()\[\]]/;
var APOSTROPHE = '’';

// This function returns true if the character at `pos`
// could be inside a word.
function isLetter(str, pos) {
  if (pos < 0 || pos >= str.length) { return false; }
  return !PUNCT_RE.test(str[pos]);
}


function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}


module.exports = function smartquotes(state) {
  /*eslint max-depth:0*/
  var i, token, text, t, pos, max, thisLevel, lastSpace, nextSpace, item,
      canOpen, canClose, j, isSingle, blkIdx, tokens,
      stack;

  if (!state.options.typographer) { return; }

  stack = [];

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') { continue; }

    tokens = state.tokens[blkIdx].children;
    stack.length = 0;

    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];

      if (token.type !== 'text' || QUOTE_TEST_RE.test(token.text)) { continue; }

      thisLevel = tokens[i].level;

      for (j = stack.length - 1; j >= 0; j--) {
        if (stack[j].level <= thisLevel) { break; }
      }
      stack.length = j + 1;

      text = token.content;
      pos = 0;
      max = text.length;

      /*eslint no-labels:0,block-scoped-var:0*/
      OUTER:
      while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        t = QUOTE_RE.exec(text);
        if (!t) { break; }

        lastSpace = !isLetter(text, t.index - 1);
        pos = t.index + 1;
        isSingle = (t[0] === "'");
        nextSpace = !isLetter(text, pos);

        if (!nextSpace && !lastSpace) {
          // middle of word
          if (isSingle) {
            token.content = replaceAt(token.content, t.index, APOSTROPHE);
          }
          continue;
        }

        canOpen = !nextSpace;
        canClose = !lastSpace;

        if (canClose) {
          // this could be a closing quote, rewind the stack to get a match
          for (j = stack.length - 1; j >= 0; j--) {
            item = stack[j];
            if (stack[j].level < thisLevel) { break; }
            if (item.single === isSingle && stack[j].level === thisLevel) {
              item = stack[j];
              if (isSingle) {
                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[2]);
                token.content = replaceAt(token.content, t.index, state.options.quotes[3]);
              } else {
                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[0]);
                token.content = replaceAt(token.content, t.index, state.options.quotes[1]);
              }
              stack.length = j;
              continue OUTER;
            }
          }
        }

        if (canOpen) {
          stack.push({
            token: i,
            pos: t.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_inline/autolink.js":
/*!**************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_inline/autolink.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process autolinks '<protocol:...>'



var url_schemas   = __webpack_require__(/*! ../common/url_schemas */ "./node_modules/remarkable/lib/common/url_schemas.js");
var normalizeLink = __webpack_require__(/*! ../helpers/normalize_link */ "./node_modules/remarkable/lib/helpers/normalize_link.js");


/*eslint max-len:0*/
var EMAIL_RE    = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z.\-]{1,25}):([^<>\x00-\x20]*)>/;


module.exports = function autolink(state, silent) {
  var tail, linkMatch, emailMatch, url, fullUrl, pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

  tail = state.src.slice(pos);

  if (tail.indexOf('>') < 0) { return false; }

  linkMatch = tail.match(AUTOLINK_RE);

  if (linkMatch) {
    if (url_schemas.indexOf(linkMatch[1].toLowerCase()) < 0) { return false; }

    url = linkMatch[0].slice(1, -1);
    fullUrl = normalizeLink(url);
    if (!state.parser.validateLink(url)) { return false; }

    if (!silent) {
      state.push({
        type: 'link_open',
        href: fullUrl,
        level: state.level
      });
      state.push({
        type: 'text',
        content: url,
        level: state.level + 1
      });
      state.push({ type: 'link_close', level: state.level });
    }

    state.pos += linkMatch[0].length;
    return true;
  }

  emailMatch = tail.match(EMAIL_RE);

  if (emailMatch) {

    url = emailMatch[0].slice(1, -1);

    fullUrl = normalizeLink('mailto:' + url);
    if (!state.parser.validateLink(fullUrl)) { return false; }

    if (!silent) {
      state.push({
        type: 'link_open',
        href: fullUrl,
        level: state.level
      });
      state.push({
        type: 'text',
        content: url,
        level: state.level + 1
      });
      state.push({ type: 'link_close', level: state.level });
    }

    state.pos += emailMatch[0].length;
    return true;
  }

  return false;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_inline/backticks.js":
/*!***************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_inline/backticks.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse backticks



module.exports = function backticks(state, silent) {
  var start, max, marker, matchStart, matchEnd,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60/* ` */) { return false; }

  start = pos;
  pos++;
  max = state.posMax;

  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }

  marker = state.src.slice(start, pos);

  matchStart = matchEnd = pos;

  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }

    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        state.push({
          type: 'code',
          content: state.src.slice(pos, matchStart)
                              .replace(/[ \n]+/g, ' ')
                              .trim(),
          block: false,
          level: state.level
        });
      }
      state.pos = matchEnd;
      return true;
    }
  }

  if (!silent) { state.pending += marker; }
  state.pos += marker.length;
  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_inline/del.js":
/*!*********************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_inline/del.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ~~deleted text~~



module.exports = function del(state, silent) {
  var found,
      pos,
      stack,
      max = state.posMax,
      start = state.pos,
      lastChar,
      nextChar;

  if (state.src.charCodeAt(start) !== 0x7E/* ~ */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 4 >= max) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x7E/* ~ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;
  nextChar = state.src.charCodeAt(start + 2);

  if (lastChar === 0x7E/* ~ */) { return false; }
  if (nextChar === 0x7E/* ~ */) { return false; }
  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }

  pos = start + 2;
  while (pos < max && state.src.charCodeAt(pos) === 0x7E/* ~ */) { pos++; }
  if (pos > start + 3) {
    // sequence of 4+ markers taking as literal, same as in a emphasis
    state.pos += pos - start;
    if (!silent) { state.pending += state.src.slice(start, pos); }
    return true;
  }

  state.pos = start + 2;
  stack = 1;

  while (state.pos + 1 < max) {
    if (state.src.charCodeAt(state.pos) === 0x7E/* ~ */) {
      if (state.src.charCodeAt(state.pos + 1) === 0x7E/* ~ */) {
        lastChar = state.src.charCodeAt(state.pos - 1);
        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;
        if (nextChar !== 0x7E/* ~ */ && lastChar !== 0x7E/* ~ */) {
          if (lastChar !== 0x20 && lastChar !== 0x0A) {
            // closing '~~'
            stack--;
          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {
            // opening '~~'
            stack++;
          } // else {
            //  // standalone ' ~~ ' indented with spaces
            // }
          if (stack <= 0) {
            found = true;
            break;
          }
        }
      }
    }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 2;

  if (!silent) {
    state.push({ type: 'del_open', level: state.level++ });
    state.parser.tokenize(state);
    state.push({ type: 'del_close', level: --state.level });
  }

  state.pos = state.posMax + 2;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_inline/emphasis.js":
/*!**************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_inline/emphasis.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process *this* and _that_




function isAlphaNum(code) {
  return (code >= 0x30 /* 0 */ && code <= 0x39 /* 9 */) ||
         (code >= 0x41 /* A */ && code <= 0x5A /* Z */) ||
         (code >= 0x61 /* a */ && code <= 0x7A /* z */);
}

// parse sequence of emphasis markers,
// "start" should point at a valid marker
function scanDelims(state, start) {
  var pos = start, lastChar, nextChar, count,
      can_open = true,
      can_close = true,
      max = state.posMax,
      marker = state.src.charCodeAt(start);

  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;

  while (pos < max && state.src.charCodeAt(pos) === marker) { pos++; }
  if (pos >= max) { can_open = false; }
  count = pos - start;

  if (count >= 4) {
    // sequence of four or more unescaped markers can't start/end an emphasis
    can_open = can_close = false;
  } else {
    nextChar = pos < max ? state.src.charCodeAt(pos) : -1;

    // check whitespace conditions
    if (nextChar === 0x20 || nextChar === 0x0A) { can_open = false; }
    if (lastChar === 0x20 || lastChar === 0x0A) { can_close = false; }

    if (marker === 0x5F /* _ */) {
      // check if we aren't inside the word
      if (isAlphaNum(lastChar)) { can_open = false; }
      if (isAlphaNum(nextChar)) { can_close = false; }
    }
  }

  return {
    can_open: can_open,
    can_close: can_close,
    delims: count
  };
}

module.exports = function emphasis(state, silent) {
  var startCount,
      count,
      found,
      oldCount,
      newCount,
      stack,
      res,
      max = state.posMax,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (marker !== 0x5F/* _ */ && marker !== 0x2A /* * */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode

  res = scanDelims(state, start);
  startCount = res.delims;
  if (!res.can_open) {
    state.pos += startCount;
    if (!silent) { state.pending += state.src.slice(start, state.pos); }
    return true;
  }

  if (state.level >= state.options.maxNesting) { return false; }

  state.pos = start + startCount;
  stack = [ startCount ];

  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === marker) {
      res = scanDelims(state, state.pos);
      count = res.delims;
      if (res.can_close) {
        oldCount = stack.pop();
        newCount = count;

        while (oldCount !== newCount) {
          if (newCount < oldCount) {
            stack.push(oldCount - newCount);
            break;
          }

          // assert(newCount > oldCount)
          newCount -= oldCount;

          if (stack.length === 0) { break; }
          state.pos += oldCount;
          oldCount = stack.pop();
        }

        if (stack.length === 0) {
          startCount = oldCount;
          found = true;
          break;
        }
        state.pos += count;
        continue;
      }

      if (res.can_open) { stack.push(count); }
      state.pos += count;
      continue;
    }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + startCount;

  if (!silent) {
    if (startCount === 2 || startCount === 3) {
      state.push({ type: 'strong_open', level: state.level++ });
    }
    if (startCount === 1 || startCount === 3) {
      state.push({ type: 'em_open', level: state.level++ });
    }

    state.parser.tokenize(state);

    if (startCount === 1 || startCount === 3) {
      state.push({ type: 'em_close', level: --state.level });
    }
    if (startCount === 2 || startCount === 3) {
      state.push({ type: 'strong_close', level: --state.level });
    }
  }

  state.pos = state.posMax + startCount;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_inline/entity.js":
/*!************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_inline/entity.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html entity - &#123;, &#xAF;, &quot;, ...



var entities          = __webpack_require__(/*! ../common/entities */ "./node_modules/remarkable/lib/common/entities.js");
var has               = __webpack_require__(/*! ../common/utils */ "./node_modules/remarkable/lib/common/utils.js").has;
var isValidEntityCode = __webpack_require__(/*! ../common/utils */ "./node_modules/remarkable/lib/common/utils.js").isValidEntityCode;
var fromCodePoint     = __webpack_require__(/*! ../common/utils */ "./node_modules/remarkable/lib/common/utils.js").fromCodePoint;


var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;


module.exports = function entity(state, silent) {
  var ch, code, match, pos = state.pos, max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
      match = state.src.slice(pos).match(DIGITAL_RE);
      if (match) {
        if (!silent) {
          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
        }
        state.pos += match[0].length;
        return true;
      }
    } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) { state.pending += entities[match[1]]; }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) { state.pending += '&'; }
  state.pos++;
  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_inline/escape.js":
/*!************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_inline/escape.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Proceess escaped chars and hardbreaks



var ESCAPED = [];

for (var i = 0; i < 256; i++) { ESCAPED.push(0); }

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'
  .split('').forEach(function(ch) { ESCAPED[ch.charCodeAt(0)] = 1; });


module.exports = function escape(state, silent) {
  var ch, pos = state.pos, max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C/* \ */) { return false; }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) { state.pending += state.src[pos]; }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push({
          type: 'hardbreak',
          level: state.level
        });
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) { state.pending += '\\'; }
  state.pos++;
  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_inline/footnote_inline.js":
/*!*********************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_inline/footnote_inline.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process inline footnotes (^[...])



var parseLinkLabel = __webpack_require__(/*! ../helpers/parse_link_label */ "./node_modules/remarkable/lib/helpers/parse_link_label.js");


module.exports = function footnote_inline(state, silent) {
  var labelStart,
      labelEnd,
      footnoteId,
      oldLength,
      max = state.posMax,
      start = state.pos;

  if (start + 2 >= max) { return false; }
  if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x5B/* [ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  labelStart = start + 2;
  labelEnd = parseLinkLabel(state, start + 1);

  // parser failed to find ']', so it's not a valid note
  if (labelEnd < 0) { return false; }

  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    if (!state.env.footnotes) { state.env.footnotes = {}; }
    if (!state.env.footnotes.list) { state.env.footnotes.list = []; }
    footnoteId = state.env.footnotes.list.length;

    state.pos = labelStart;
    state.posMax = labelEnd;

    state.push({
      type: 'footnote_ref',
      id: footnoteId,
      level: state.level
    });
    state.linkLevel++;
    oldLength = state.tokens.length;
    state.parser.tokenize(state);
    state.env.footnotes.list[footnoteId] = { tokens: state.tokens.splice(oldLength) };
    state.linkLevel--;
  }

  state.pos = labelEnd + 1;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_inline/footnote_ref.js":
/*!******************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_inline/footnote_ref.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process footnote references ([^...])




module.exports = function footnote_ref(state, silent) {
  var label,
      pos,
      footnoteId,
      footnoteSubId,
      max = state.posMax,
      start = state.pos;

  // should be at least 4 chars - "[^x]"
  if (start + 3 > max) { return false; }

  if (!state.env.footnotes || !state.env.footnotes.refs) { return false; }
  if (state.src.charCodeAt(start) !== 0x5B/* [ */) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x5E/* ^ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  for (pos = start + 2; pos < max; pos++) {
    if (state.src.charCodeAt(pos) === 0x20) { return false; }
    if (state.src.charCodeAt(pos) === 0x0A) { return false; }
    if (state.src.charCodeAt(pos) === 0x5D /* ] */) {
      break;
    }
  }

  if (pos === start + 2) { return false; } // no empty footnote labels
  if (pos >= max) { return false; }
  pos++;

  label = state.src.slice(start + 2, pos - 1);
  if (typeof state.env.footnotes.refs[':' + label] === 'undefined') { return false; }

  if (!silent) {
    if (!state.env.footnotes.list) { state.env.footnotes.list = []; }

    if (state.env.footnotes.refs[':' + label] < 0) {
      footnoteId = state.env.footnotes.list.length;
      state.env.footnotes.list[footnoteId] = { label: label, count: 0 };
      state.env.footnotes.refs[':' + label] = footnoteId;
    } else {
      footnoteId = state.env.footnotes.refs[':' + label];
    }

    footnoteSubId = state.env.footnotes.list[footnoteId].count;
    state.env.footnotes.list[footnoteId].count++;

    state.push({
      type: 'footnote_ref',
      id: footnoteId,
      subId: footnoteSubId,
      level: state.level
    });
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_inline/htmltag.js":
/*!*************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_inline/htmltag.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html tags




var HTML_TAG_RE = __webpack_require__(/*! ../common/html_re */ "./node_modules/remarkable/lib/common/html_re.js").HTML_TAG_RE;


function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);
}


module.exports = function htmltag(state, silent) {
  var ch, match, max, pos = state.pos;

  if (!state.options.html) { return false; }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||
      pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21/* ! */ &&
      ch !== 0x3F/* ? */ &&
      ch !== 0x2F/* / */ &&
      !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) { return false; }

  if (!silent) {
    state.push({
      type: 'htmltag',
      content: state.src.slice(pos, pos + match[0].length),
      level: state.level
    });
  }
  state.pos += match[0].length;
  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_inline/ins.js":
/*!*********************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_inline/ins.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ++inserted text++



module.exports = function ins(state, silent) {
  var found,
      pos,
      stack,
      max = state.posMax,
      start = state.pos,
      lastChar,
      nextChar;

  if (state.src.charCodeAt(start) !== 0x2B/* + */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 4 >= max) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x2B/* + */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;
  nextChar = state.src.charCodeAt(start + 2);

  if (lastChar === 0x2B/* + */) { return false; }
  if (nextChar === 0x2B/* + */) { return false; }
  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }

  pos = start + 2;
  while (pos < max && state.src.charCodeAt(pos) === 0x2B/* + */) { pos++; }
  if (pos !== start + 2) {
    // sequence of 3+ markers taking as literal, same as in a emphasis
    state.pos += pos - start;
    if (!silent) { state.pending += state.src.slice(start, pos); }
    return true;
  }

  state.pos = start + 2;
  stack = 1;

  while (state.pos + 1 < max) {
    if (state.src.charCodeAt(state.pos) === 0x2B/* + */) {
      if (state.src.charCodeAt(state.pos + 1) === 0x2B/* + */) {
        lastChar = state.src.charCodeAt(state.pos - 1);
        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;
        if (nextChar !== 0x2B/* + */ && lastChar !== 0x2B/* + */) {
          if (lastChar !== 0x20 && lastChar !== 0x0A) {
            // closing '++'
            stack--;
          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {
            // opening '++'
            stack++;
          } // else {
            //  // standalone ' ++ ' indented with spaces
            // }
          if (stack <= 0) {
            found = true;
            break;
          }
        }
      }
    }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 2;

  if (!silent) {
    state.push({ type: 'ins_open', level: state.level++ });
    state.parser.tokenize(state);
    state.push({ type: 'ins_close', level: --state.level });
  }

  state.pos = state.posMax + 2;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_inline/links.js":
/*!***********************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_inline/links.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process [links](<to> "stuff")



var parseLinkLabel       = __webpack_require__(/*! ../helpers/parse_link_label */ "./node_modules/remarkable/lib/helpers/parse_link_label.js");
var parseLinkDestination = __webpack_require__(/*! ../helpers/parse_link_destination */ "./node_modules/remarkable/lib/helpers/parse_link_destination.js");
var parseLinkTitle       = __webpack_require__(/*! ../helpers/parse_link_title */ "./node_modules/remarkable/lib/helpers/parse_link_title.js");
var normalizeReference   = __webpack_require__(/*! ../helpers/normalize_reference */ "./node_modules/remarkable/lib/helpers/normalize_reference.js");


module.exports = function links(state, silent) {
  var labelStart,
      labelEnd,
      label,
      href,
      title,
      pos,
      ref,
      code,
      isImage = false,
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (marker === 0x21/* ! */) {
    isImage = true;
    marker = state.src.charCodeAt(++start);
  }

  if (marker !== 0x5B/* [ */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  labelStart = start + 1;
  labelEnd = parseLinkLabel(state, start);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) { return false; }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
    //
    // Inline link
    //

    // [link](  <href>  "title"  )
    //        ^^ skipping these spaces
    pos++;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (code !== 0x20 && code !== 0x0A) { break; }
    }
    if (pos >= max) { return false; }

    // [link](  <href>  "title"  )
    //          ^^^^^^ parsing link destination
    start = pos;
    if (parseLinkDestination(state, pos)) {
      href = state.linkContent;
      pos = state.pos;
    } else {
      href = '';
    }

    // [link](  <href>  "title"  )
    //                ^^ skipping these spaces
    start = pos;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (code !== 0x20 && code !== 0x0A) { break; }
    }

    // [link](  <href>  "title"  )
    //                  ^^^^^^^ parsing link title
    if (pos < max && start !== pos && parseLinkTitle(state, pos)) {
      title = state.linkContent;
      pos = state.pos;

      // [link](  <href>  "title"  )
      //                         ^^ skipping these spaces
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (code !== 0x20 && code !== 0x0A) { break; }
      }
    } else {
      title = '';
    }

    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    //
    // Link reference
    //

    // do not allow nested reference links
    if (state.linkLevel > 0) { return false; }

    // [foo]  [bar]
    //      ^^ optional whitespace (can include newlines)
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (code !== 0x20 && code !== 0x0A) { break; }
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
      start = pos + 1;
      pos = parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = start - 1;
      }
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) {
      if (typeof label === 'undefined') {
        pos = labelEnd + 1;
      }
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    if (isImage) {
      state.push({
        type: 'image',
        src: href,
        title: title,
        alt: state.src.substr(labelStart, labelEnd - labelStart),
        level: state.level
      });
    } else {
      state.push({
        type: 'link_open',
        href: href,
        title: title,
        level: state.level++
      });
      state.linkLevel++;
      state.parser.tokenize(state);
      state.linkLevel--;
      state.push({ type: 'link_close', level: --state.level });
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_inline/mark.js":
/*!**********************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_inline/mark.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ==highlighted text==



module.exports = function del(state, silent) {
  var found,
      pos,
      stack,
      max = state.posMax,
      start = state.pos,
      lastChar,
      nextChar;

  if (state.src.charCodeAt(start) !== 0x3D/* = */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 4 >= max) { return false; }
  if (state.src.charCodeAt(start + 1) !== 0x3D/* = */) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;
  nextChar = state.src.charCodeAt(start + 2);

  if (lastChar === 0x3D/* = */) { return false; }
  if (nextChar === 0x3D/* = */) { return false; }
  if (nextChar === 0x20 || nextChar === 0x0A) { return false; }

  pos = start + 2;
  while (pos < max && state.src.charCodeAt(pos) === 0x3D/* = */) { pos++; }
  if (pos !== start + 2) {
    // sequence of 3+ markers taking as literal, same as in a emphasis
    state.pos += pos - start;
    if (!silent) { state.pending += state.src.slice(start, pos); }
    return true;
  }

  state.pos = start + 2;
  stack = 1;

  while (state.pos + 1 < max) {
    if (state.src.charCodeAt(state.pos) === 0x3D/* = */) {
      if (state.src.charCodeAt(state.pos + 1) === 0x3D/* = */) {
        lastChar = state.src.charCodeAt(state.pos - 1);
        nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;
        if (nextChar !== 0x3D/* = */ && lastChar !== 0x3D/* = */) {
          if (lastChar !== 0x20 && lastChar !== 0x0A) {
            // closing '=='
            stack--;
          } else if (nextChar !== 0x20 && nextChar !== 0x0A) {
            // opening '=='
            stack++;
          } // else {
            //  // standalone ' == ' indented with spaces
            // }
          if (stack <= 0) {
            found = true;
            break;
          }
        }
      }
    }

    state.parser.skipToken(state);
  }

  if (!found) {
    // parser failed to find ending tag, so it's not valid emphasis
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 2;

  if (!silent) {
    state.push({ type: 'mark_open', level: state.level++ });
    state.parser.tokenize(state);
    state.push({ type: 'mark_close', level: --state.level });
  }

  state.pos = state.posMax + 2;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_inline/newline.js":
/*!*************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_inline/newline.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Proceess '\n'



module.exports = function newline(state, silent) {
  var pmax, max, pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A/* \n */) { return false; }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        // Strip out all trailing spaces on this line.
        for (var i = pmax - 2; i >= 0; i--) {
          if (state.pending.charCodeAt(i) !== 0x20) {
            state.pending = state.pending.substring(0, i + 1);
            break;
          }
        }
        state.push({
          type: 'hardbreak',
          level: state.level
        });
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push({
          type: 'softbreak',
          level: state.level
        });
      }

    } else {
      state.push({
        type: 'softbreak',
        level: state.level
      });
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && state.src.charCodeAt(pos) === 0x20) { pos++; }

  state.pos = pos;
  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_inline/state_inline.js":
/*!******************************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_inline/state_inline.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Inline parser state



function StateInline(src, parserInline, options, env, outTokens) {
  this.src = src;
  this.env = env;
  this.options = options;
  this.parser = parserInline;
  this.tokens = outTokens;
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  this.cache = [];        // Stores { start: end } pairs. Useful for backtrack
                          // optimization of pairs parse (emphasis, strikes).

  // Link parser state vars

  this.isInLabel = false; // Set true when seek link label - we should disable
                          // "paired" rules (emphasis, strikes) to not skip
                          // tailing `]`

  this.linkLevel = 0;     // Increment for each nesting link. Used to prevent
                          // nesting in definitions

  this.linkContent = '';  // Temporary storage for link url

  this.labelUnmatchedScopes = 0; // Track unpaired `[` for link labels
                                 // (backtrack optimization)
}

// Flush pending text
//
StateInline.prototype.pushPending = function () {
  this.tokens.push({
    type: 'text',
    content: this.pending,
    level: this.pendingLevel
  });
  this.pending = '';
};

// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (token) {
  if (this.pending) {
    this.pushPending();
  }

  this.tokens.push(token);
  this.pendingLevel = this.level;
};

// Store value to cache.
// !!! Implementation has parser-specific optimizations
// !!! keys MUST be integer, >= 0; values MUST be integer, > 0
//
StateInline.prototype.cacheSet = function (key, val) {
  for (var i = this.cache.length; i <= key; i++) {
    this.cache.push(0);
  }

  this.cache[key] = val;
};

// Get cache value
//
StateInline.prototype.cacheGet = function (key) {
  return key < this.cache.length ? this.cache[key] : 0;
};

module.exports = StateInline;


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_inline/sub.js":
/*!*********************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_inline/sub.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ~subscript~



// same as UNESCAPE_MD_RE plus a space
var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;

module.exports = function sub(state, silent) {
  var found,
      content,
      max = state.posMax,
      start = state.pos;

  if (state.src.charCodeAt(start) !== 0x7E/* ~ */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 2 >= max) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  state.pos = start + 1;

  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === 0x7E/* ~ */) {
      found = true;
      break;
    }

    state.parser.skipToken(state);
  }

  if (!found || start + 1 === state.pos) {
    state.pos = start;
    return false;
  }

  content = state.src.slice(start + 1, state.pos);

  // don't allow unescaped spaces/newlines inside
  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 1;

  if (!silent) {
    state.push({
      type: 'sub',
      level: state.level,
      content: content.replace(UNESCAPE_RE, '$1')
    });
  }

  state.pos = state.posMax + 1;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_inline/sup.js":
/*!*********************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_inline/sup.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ^superscript^



// same as UNESCAPE_MD_RE plus a space
var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;

module.exports = function sup(state, silent) {
  var found,
      content,
      max = state.posMax,
      start = state.pos;

  if (state.src.charCodeAt(start) !== 0x5E/* ^ */) { return false; }
  if (silent) { return false; } // don't run any pairs in validation mode
  if (start + 2 >= max) { return false; }
  if (state.level >= state.options.maxNesting) { return false; }

  state.pos = start + 1;

  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === 0x5E/* ^ */) {
      found = true;
      break;
    }

    state.parser.skipToken(state);
  }

  if (!found || start + 1 === state.pos) {
    state.pos = start;
    return false;
  }

  content = state.src.slice(start + 1, state.pos);

  // don't allow unescaped spaces/newlines inside
  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start;
    return false;
  }

  // found!
  state.posMax = state.pos;
  state.pos = start + 1;

  if (!silent) {
    state.push({
      type: 'sup',
      level: state.level,
      content: content.replace(UNESCAPE_RE, '$1')
    });
  }

  state.pos = state.posMax + 1;
  state.posMax = max;
  return true;
};


/***/ }),

/***/ "./node_modules/remarkable/lib/rules_inline/text.js":
/*!**********************************************************!*\
  !*** ./node_modules/remarkable/lib/rules_inline/text.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Skip text characters for text token, place those to pending buffer
// and increment current pos



// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A/* \n */:
    case 0x5C/* \ */:
    case 0x60/* ` */:
    case 0x2A/* * */:
    case 0x5F/* _ */:
    case 0x5E/* ^ */:
    case 0x5B/* [ */:
    case 0x5D/* ] */:
    case 0x21/* ! */:
    case 0x26/* & */:
    case 0x3C/* < */:
    case 0x3E/* > */:
    case 0x7B/* { */:
    case 0x7D/* } */:
    case 0x24/* $ */:
    case 0x25/* % */:
    case 0x40/* @ */:
    case 0x7E/* ~ */:
    case 0x2B/* + */:
    case 0x3D/* = */:
    case 0x3A/* : */:
      return true;
    default:
      return false;
  }
}

module.exports = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) { return false; }

  if (!silent) { state.pending += state.src.slice(state.pos, pos); }

  state.pos = pos;

  return true;
};


/***/ }),

/***/ "./node_modules/sanitize-filename/index.js":
/*!*************************************************!*\
  !*** ./node_modules/sanitize-filename/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*jshint node:true*/


/**
 * Replaces characters in strings that are illegal/unsafe for filenames.
 * Unsafe characters are either removed or replaced by a substitute set
 * in the optional `options` object.
 *
 * Illegal Characters on Various Operating Systems
 * / ? < > \ : * | "
 * https://kb.acronis.com/content/39790
 *
 * Unicode Control codes
 * C0 0x00-0x1f & C1 (0x80-0x9f)
 * http://en.wikipedia.org/wiki/C0_and_C1_control_codes
 *
 * Reserved filenames on Unix-based systems (".", "..")
 * Reserved filenames in Windows ("CON", "PRN", "AUX", "NUL", "COM1",
 * "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9",
 * "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", and
 * "LPT9") case-insesitively and with or without filename extensions.
 *
 * Capped at 255 characters in length.
 * http://unix.stackexchange.com/questions/32795/what-is-the-maximum-allowed-filename-and-folder-size-with-ecryptfs
 *
 * @param  {String} input   Original filename
 * @param  {Object} options {replacement: String | Function }
 * @return {String}         Sanitized filename
 */

var truncate = __webpack_require__(/*! truncate-utf8-bytes */ "./node_modules/truncate-utf8-bytes/browser.js");

var illegalRe = /[\/\?<>\\:\*\|"]/g;
var controlRe = /[\x00-\x1f\x80-\x9f]/g;
var reservedRe = /^\.+$/;
var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
var windowsTrailingRe = /[\. ]+$/;

function sanitize(input, replacement) {
  if (typeof input !== 'string') {
    throw new Error('Input must be string');
  }
  var sanitized = input
    .replace(illegalRe, replacement)
    .replace(controlRe, replacement)
    .replace(reservedRe, replacement)
    .replace(windowsReservedRe, replacement)
    .replace(windowsTrailingRe, replacement);
  return truncate(sanitized, 255);
}

module.exports = function (input, options) {
  var replacement = (options && options.replacement) || '';
  var output = sanitize(input, replacement);
  if (replacement === '') {
    return output;
  }
  return sanitize(output, '');
};


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target) {
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./node_modules/truncate-utf8-bytes/browser.js":
/*!*****************************************************!*\
  !*** ./node_modules/truncate-utf8-bytes/browser.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var truncate = __webpack_require__(/*! ./lib/truncate */ "./node_modules/truncate-utf8-bytes/lib/truncate.js");
var getLength = __webpack_require__(/*! utf8-byte-length/browser */ "./node_modules/utf8-byte-length/browser.js");
module.exports = truncate.bind(null, getLength);


/***/ }),

/***/ "./node_modules/truncate-utf8-bytes/lib/truncate.js":
/*!**********************************************************!*\
  !*** ./node_modules/truncate-utf8-bytes/lib/truncate.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function isHighSurrogate(codePoint) {
  return codePoint >= 0xd800 && codePoint <= 0xdbff;
}

function isLowSurrogate(codePoint) {
  return codePoint >= 0xdc00 && codePoint <= 0xdfff;
}

// Truncate string by size in bytes
module.exports = function truncate(getLength, string, byteLength) {
  if (typeof string !== "string") {
    throw new Error("Input must be string");
  }

  var charLength = string.length;
  var curByteLength = 0;
  var codePoint;
  var segment;

  for (var i = 0; i < charLength; i += 1) {
    codePoint = string.charCodeAt(i);
    segment = string[i];

    if (isHighSurrogate(codePoint) && isLowSurrogate(string.charCodeAt(i + 1))) {
      i += 1;
      segment += string[i];
    }

    curByteLength += getLength(segment);

    if (curByteLength === byteLength) {
      return string.slice(0, i + 1);
    }
    else if (curByteLength > byteLength) {
      return string.slice(0, i - segment.length + 1);
    }
  }

  return string;
};



/***/ }),

/***/ "./node_modules/utf8-byte-length/browser.js":
/*!**************************************************!*\
  !*** ./node_modules/utf8-byte-length/browser.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function isHighSurrogate(codePoint) {
  return codePoint >= 0xd800 && codePoint <= 0xdbff;
}

function isLowSurrogate(codePoint) {
  return codePoint >= 0xdc00 && codePoint <= 0xdfff;
}

// Truncate string by size in bytes
module.exports = function getByteLength(string) {
  if (typeof string !== "string") {
    throw new Error("Input must be string");
  }

  var charLength = string.length;
  var byteLength = 0;
  var codePoint = null;
  var prevCodePoint = null;
  for (var i = 0; i < charLength; i++) {
    codePoint = string.charCodeAt(i);
    // handle 4-byte non-BMP chars
    // low surrogate
    if (isLowSurrogate(codePoint)) {
      // when parsing previous hi-surrogate, 3 is added to byteLength
      if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
        byteLength += 1;
      }
      else {
        byteLength += 3;
      }
    }
    else if (codePoint <= 0x7f ) {
      byteLength += 1;
    }
    else if (codePoint >= 0x80 && codePoint <= 0x7ff) {
      byteLength += 2;
    }
    else if (codePoint >= 0x800 && codePoint <= 0xffff) {
      byteLength += 3;
    }
    prevCodePoint = codePoint;
  }

  return byteLength;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ })

/******/ });
});
//# sourceMappingURL=bundle.js.map