{"version":3,"sources":["webpack://skill_invocation_client/webpack/universalModuleDefinition","webpack://skill_invocation_client/./app/frontend/designer/js/Application.js","webpack://skill_invocation_client/./app/frontend/designer/js/Configuration.js","webpack://skill_invocation_client/./app/frontend/designer/js/FilterPane.js","webpack://skill_invocation_client/./app/frontend/designer/js/Hardware.js","webpack://skill_invocation_client/./app/frontend/designer/js/LabelInplaceEditor.js","webpack://skill_invocation_client/./app/frontend/designer/js/Layer.js","webpack://skill_invocation_client/./app/frontend/designer/js/Toolbar.js","webpack://skill_invocation_client/./app/frontend/designer/js/View.js","webpack://skill_invocation_client/./app/frontend/designer/js/dialog/FigureCodeEdit.js","webpack://skill_invocation_client/./app/frontend/designer/js/dialog/FigureMarkdownEdit.js","webpack://skill_invocation_client/./app/frontend/designer/js/dialog/FigureTest.js","webpack://skill_invocation_client/./app/frontend/designer/js/dialog/FileOpen.js","webpack://skill_invocation_client/./app/frontend/designer/js/dialog/FileSave.js","webpack://skill_invocation_client/./app/frontend/designer/js/dialog/FileSaveAs.js","webpack://skill_invocation_client/./app/frontend/designer/js/figure/CircuitFigure.js","webpack://skill_invocation_client/./app/frontend/designer/js/figure/DecoratedInputPort.js","webpack://skill_invocation_client/./app/frontend/designer/js/figure/ExtLabel.js","webpack://skill_invocation_client/./app/frontend/designer/js/figure/ExtLine.js","webpack://skill_invocation_client/./app/frontend/designer/js/figure/ExtPolygon.js","webpack://skill_invocation_client/./app/frontend/designer/js/figure/ExtPort.js","webpack://skill_invocation_client/./app/frontend/designer/js/figure/MarkerFigure.js","webpack://skill_invocation_client/./app/frontend/designer/js/figure/MarkerStateAFigure.js","webpack://skill_invocation_client/./app/frontend/designer/js/figure/MarkerStateBFigure.js","webpack://skill_invocation_client/./app/frontend/designer/js/figure/PolyCircle.js","webpack://skill_invocation_client/./app/frontend/designer/js/figure/PolyRect.js","webpack://skill_invocation_client/./app/frontend/designer/js/figure/TestSwitch.js","webpack://skill_invocation_client/./app/frontend/designer/js/figure/index.js","webpack://skill_invocation_client/./app/frontend/designer/js/filter/BlurFilter.js","webpack://skill_invocation_client/./app/frontend/designer/js/filter/FanoutFilter.js","webpack://skill_invocation_client/./app/frontend/designer/js/filter/FillColorFilter.js","webpack://skill_invocation_client/./app/frontend/designer/js/filter/Filter.js","webpack://skill_invocation_client/./app/frontend/designer/js/filter/FontColorFilter.js","webpack://skill_invocation_client/./app/frontend/designer/js/filter/FontSizeFilter.js","webpack://skill_invocation_client/./app/frontend/designer/js/filter/LinearGradientFilter.js","webpack://skill_invocation_client/./app/frontend/designer/js/filter/OpacityFilter.js","webpack://skill_invocation_client/./app/frontend/designer/js/filter/OutlineStrokeFilter.js","webpack://skill_invocation_client/./app/frontend/designer/js/filter/PortDirectionFilter.js","webpack://skill_invocation_client/./app/frontend/designer/js/filter/PortTypeFilter.js","webpack://skill_invocation_client/./app/frontend/designer/js/filter/PositionFilter.js","webpack://skill_invocation_client/./app/frontend/designer/js/filter/RadiusFilter.js","webpack://skill_invocation_client/./app/frontend/designer/js/filter/SizeFilter.js","webpack://skill_invocation_client/./app/frontend/designer/js/filter/StrokeFilter.js","webpack://skill_invocation_client/./app/frontend/designer/js/filter/TextLinearGradientFilter.js","webpack://skill_invocation_client/./app/frontend/designer/js/filter/index.js","webpack://skill_invocation_client/./app/frontend/designer/js/global.js","webpack://skill_invocation_client/./app/frontend/designer/js/index.js","webpack://skill_invocation_client/./app/frontend/designer/js/io/BackendSkills.js","webpack://skill_invocation_client/./app/frontend/designer/js/io/BackendStorage.js","webpack://skill_invocation_client/./app/frontend/designer/js/io/FigureWriter.js","webpack://skill_invocation_client/./app/frontend/designer/js/policy/AbstractGeoToolPolicy.js","webpack://skill_invocation_client/./app/frontend/designer/js/policy/AbstractToolPolicy.js","webpack://skill_invocation_client/./app/frontend/designer/js/policy/CircleToolPolicy.js","webpack://skill_invocation_client/./app/frontend/designer/js/policy/GeoDifferenceToolPolicy.js","webpack://skill_invocation_client/./app/frontend/designer/js/policy/GeoIntersectionToolPolicy.js","webpack://skill_invocation_client/./app/frontend/designer/js/policy/GeoUnionToolPolicy.js","webpack://skill_invocation_client/./app/frontend/designer/js/policy/LineToolPolicy.js","webpack://skill_invocation_client/./app/frontend/designer/js/policy/PortToolPolicy.js","webpack://skill_invocation_client/./app/frontend/designer/js/policy/RectangleToolPolicy.js","webpack://skill_invocation_client/./app/frontend/designer/js/policy/SelectionToolPolicy.js","webpack://skill_invocation_client/./app/frontend/designer/js/policy/TextToolPolicy.js","webpack://skill_invocation_client/./app/frontend/designer/js/util/ValueParserValidator.js","webpack://skill_invocation_client/./app/frontend/designer/js/util/mousetrap-global.js","webpack://skill_invocation_client/./app/frontend/designer/js/util/mousetrap-pause.js","webpack://skill_invocation_client/./app/frontend/designer/js/widget/jscolor/jscolor.js","webpack://skill_invocation_client/./app/frontend/designer/js/widget/ui.anglepicker.js","webpack://skill_invocation_client/./app/frontend/designer/lib/inlineSVG.js","webpack://skill_invocation_client/./node_modules/font-awesome/css/font-awesome.css","webpack://skill_invocation_client/./app/frontend/designer/less/index.less","webpack://skill_invocation_client/./node_modules/css-loader/dist/runtime/api.js","webpack://skill_invocation_client/./node_modules/css-loader/dist/runtime/getUrl.js","webpack://skill_invocation_client/./app/frontend/designer/images/cursors/cursor_circle.png","webpack://skill_invocation_client/./app/frontend/designer/images/cursors/cursor_line.png","webpack://skill_invocation_client/./app/frontend/designer/images/cursors/cursor_port.png","webpack://skill_invocation_client/./app/frontend/designer/images/cursors/cursor_rectangle.png","webpack://skill_invocation_client/./app/frontend/designer/images/cursors/cursor_text.png","webpack://skill_invocation_client/./app/frontend/designer/images/layer_circle.svg","webpack://skill_invocation_client/./app/frontend/designer/images/layer_line.svg","webpack://skill_invocation_client/./app/frontend/designer/images/layer_port.svg","webpack://skill_invocation_client/./app/frontend/designer/images/layer_rect.svg","webpack://skill_invocation_client/./app/frontend/designer/images/layer_text.svg","webpack://skill_invocation_client/./app/frontend/designer/js/widget/jscolor/arrow.gif","webpack://skill_invocation_client/./app/frontend/designer/js/widget/jscolor/cross.gif","webpack://skill_invocation_client/./app/frontend/designer/js/widget/jscolor/hs.png","webpack://skill_invocation_client/./app/frontend/designer/js/widget/jscolor/hv.png","webpack://skill_invocation_client/./node_modules/font-awesome/fonts/fontawesome-webfont.eot","webpack://skill_invocation_client/./node_modules/font-awesome/fonts/fontawesome-webfont.eot?baed","webpack://skill_invocation_client/./node_modules/font-awesome/fonts/fontawesome-webfont.svg","webpack://skill_invocation_client/./node_modules/font-awesome/fonts/fontawesome-webfont.ttf","webpack://skill_invocation_client/./node_modules/font-awesome/fonts/fontawesome-webfont.woff2","webpack://skill_invocation_client/./node_modules/font-awesome/fonts/fontawesome-webfont.woff","webpack://skill_invocation_client/./node_modules/hogan.js/lib/compiler.js","webpack://skill_invocation_client/./node_modules/hogan.js/lib/hogan.js","webpack://skill_invocation_client/./node_modules/hogan.js/lib/template.js","webpack://skill_invocation_client/./node_modules/jsts/dist/jsts.js","webpack://skill_invocation_client/./node_modules/linkify-it/index.js","webpack://skill_invocation_client/./node_modules/linkify-it/lib/re.js","webpack://skill_invocation_client/./node_modules/markdown-it/index.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/common/entities.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/common/html_blocks.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/common/html_re.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/common/utils.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/helpers/index.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/helpers/parse_link_destination.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/helpers/parse_link_label.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/helpers/parse_link_title.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/index.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/parser_block.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/parser_core.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/parser_inline.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/presets/commonmark.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/presets/default.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/presets/zero.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/renderer.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/ruler.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_block/blockquote.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_block/code.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_block/fence.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_block/heading.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_block/hr.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_block/html_block.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_block/lheading.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_block/list.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_block/paragraph.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_block/reference.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_block/state_block.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_block/table.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_core/block.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_core/inline.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_core/linkify.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_core/normalize.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_core/replacements.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_core/smartquotes.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_core/state_core.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_inline/autolink.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_inline/backticks.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_inline/balance_pairs.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_inline/emphasis.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_inline/entity.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_inline/escape.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_inline/html_inline.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_inline/image.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_inline/link.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_inline/newline.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_inline/state_inline.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_inline/strikethrough.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_inline/text.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/rules_inline/text_collapse.js","webpack://skill_invocation_client/./node_modules/markdown-it/lib/token.js","webpack://skill_invocation_client/./node_modules/mdurl/decode.js","webpack://skill_invocation_client/./node_modules/mdurl/encode.js","webpack://skill_invocation_client/./node_modules/mdurl/format.js","webpack://skill_invocation_client/./node_modules/mdurl/index.js","webpack://skill_invocation_client/./node_modules/mdurl/parse.js","webpack://skill_invocation_client/./node_modules/mousetrap/mousetrap.js","webpack://skill_invocation_client/./node_modules/punycode/punycode.es6.js","webpack://skill_invocation_client/./node_modules/sanitize-filename/index.js","webpack://skill_invocation_client/./node_modules/font-awesome/css/font-awesome.css?b474","webpack://skill_invocation_client/./app/frontend/designer/less/index.less?7615","webpack://skill_invocation_client/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js","webpack://skill_invocation_client/./node_modules/truncate-utf8-bytes/browser.js","webpack://skill_invocation_client/./node_modules/truncate-utf8-bytes/lib/truncate.js","webpack://skill_invocation_client/./node_modules/uc.micro/categories/Cc/regex.js","webpack://skill_invocation_client/./node_modules/uc.micro/categories/Cf/regex.js","webpack://skill_invocation_client/./node_modules/uc.micro/categories/P/regex.js","webpack://skill_invocation_client/./node_modules/uc.micro/categories/Z/regex.js","webpack://skill_invocation_client/./node_modules/uc.micro/index.js","webpack://skill_invocation_client/./node_modules/uc.micro/properties/Any/regex.js","webpack://skill_invocation_client/./node_modules/utf8-byte-length/browser.js","webpack://skill_invocation_client/webpack/bootstrap","webpack://skill_invocation_client/webpack/runtime/compat get default export","webpack://skill_invocation_client/webpack/runtime/define property getters","webpack://skill_invocation_client/webpack/runtime/global","webpack://skill_invocation_client/webpack/runtime/hasOwnProperty shorthand","webpack://skill_invocation_client/webpack/runtime/make namespace object","webpack://skill_invocation_client/webpack/startup"],"names":["Application","documentConfigurationTempl","baseClass","code","$","text","trim","localStorage","window","e","delegate","Mousetrap","pause","unpause","documentConfiguration","extend","storage","Storage","view","View","toolbar","Toolbar","layer","Layer","filter","FilterPane","installEditPolicy","SelectionToolPolicy","file","getParam","_load","fileNew","addEventListener","event","state","id","loadFile","then","content","clear","centerDocument","reader","draw2d","io","json","Reader","unmarshal","getConfiguration","fileName","getCommandStack","markSaveLocation","name","replace","regexS","regex","RegExp","results","exec","location","href","hash","shapeTemplate","currentFile","FileOpen","show","setConfiguration","FileSaveAs","FileSave","key","figures","getExtFigures","getSize","first","getUserData","conf","setUserData","fileSuffix","serverless","backend","list","get","save","app","elementId","DEFAULT_LABEL","html","currentFigure","on","onSelectionChanged","bind","canvas","figure","addClass","isExtFigure","filters","each","i","removePane","insertPane","removeClass","getPotentialFilters","append","impl","label","_this","$this","filterName","data","eval","addFilter","raspi","set","pin","value","callback","connected","arduino","ui","LabelInplaceEditor","NAME","init","attr","setter","getter","_super","onStart","onCancel","onCommit","emitter","_updateSelection","figureToCSS","isVisible","inlineSVG","tooltip","placement","container","delay","hide","sortable","axis","update","toArray","reverse","forEach","getExtFigure","toFront","proxy","currentTarget","bootbox","prompt","title","className","result","stackChanged","setTimeout","focus","select","setVisible","setCurrentSelection","parent","ripple","selection","getSelection","rect","getBoundingBox","p","getCenter","circle","paper","x","y","Math","max","w","h","fill","stroke","anim","Raphael","animation","transform","opacity","remove","animate","split","slice","buttonGroup","openButton","fileOpen","bindGlobal","click","saveButton","fileSave","undoButton","undo","redoButton","redo","deleteButton","startTransaction","Configuration","i18n","command","deleteShape","index","cmd","createCommand","CommandType","DELETE","execute","commitTransaction","selectButton","shapeButton","RectangleToolPolicy","executed","CircleToolPolicy","LineToolPolicy","TextToolPolicy","PortToolPolicy","unionButton","getAll","GeoUnionToolPolicy","differenceButton","GeoDifferenceToolPolicy","intersectionButton","GeoIntersectionToolPolicy","testButton","FigureTest","exc","console","log","FigureCodeEdit","codeButton","markdownButton","FigureMarkdownEdit","getStack","canUndo","canRedo","Canvas","clippboardFigure","grid","policy","ShowGridEditPolicy","setScrollArea","FadeoutDecorationPolicy","SnapToGeometryEditPolicy","SnapToCenterEditPolicy","SnapToInBetweenEditPolicy","diff","getZoom","f","translate","primarySelection","getPrimary","clone","cloneToAdd","CommandAdd","getPosition","zoom","WheelZoomPolicy","setZoom","newZoom","bb","c","scrollTop","height","scrollLeft","width","prop","uninstallEditPolicy","stopPropagation","reset","setCursor","cursor","css","parseInt","getFigures","grep","lines","getLines","line","addAll","xCoords","yCoords","shape_designer","ExtPort","b","push","minX","min","minY","geo","Rectangle","hideDecoration","unselect","showDecoration","getWidth","find","getHeight","centerView","dx","dy","splash","fadeIn","before","obj","method","wrapper","orig","args","Array","prototype","call","arguments","apply","intersects","range","editor","getSelectionRange","preventReadonly","next","last","length","findIndex","element","array","startsWith","ace","edit","session","getSession","Range","require","range2","addMarker","setMode","setUseWrapMode","moveCursorTo","keyBinding","addKeyboardHandler","handleKeyboard","keyString","keyCode","passEvent","start","doc","createAnchor","end","$insertRight","getValue","fadeOut","MarkdownIt","mdHtml","scrollMap","lineHeight","defaults","xhtmlOut","breaks","langPrefix","linkify","linkTarget","typographer","markdown","removeDialog","renderer","rules","paragraph_open","tokens","idx","level","heading_open","hLevel","$preview","$source","_debounce","syncScroll","updateResult","source","render","offset","nonEmptyList","pos","a","lineHeightMap","linesCount","acc","sourceLikeDiv","_scrollMap","position","visibility","clientWidth","appendTo","top","str","lh","parseFloat","round","n","el","$el","t","scrollHeight","scroll","lineNo","posTo","floor","buildScrollMap","stop","func","wait","immediate","timeout","context","later","callNow","clearTimeout","simulationContext","animationFrameFunc","_calculate","writer","FigureWriter","testShape","marshal","js","alert","ShowDotEditPolicy","router","layout","connection","InteractiveManhattanConnectionRouter","ComposedConnectionCreatePolicy","DragConnectionCreatePolicy","createConnection","Connection","radius","color","outlineStroke","outlineColor","OrthogonalConnectionCreatePolicy","test","add","shape","node","Start","toggle1","TestSwitch","toggle2","End","simulate","onStop","requestAnimationFrame","calculate","outPort","getSource","inPort","getTarget","setValue","setColor","modal","fetchPathContent","currentDir","newPath","getFiles","files","endsWith","compiled","Hogan","compile","parentPath","dirname","output","rootDir","icon","type","path","preventDefault","png","Writer","imageDataUrl","val","off","newName","saveFile","scale","pop","SetFigure","tooltipTimer","bgColor","persistPorts","zoomCallback","positionTooltip","hideTooltip","showTooltip","setCanvas","fast","outerWidth","fromCanvasToDocumentCoordinate","getAbsoluteX","getAbsoluteY","applyAlpha","layerGet","attributes","svgNodes","found","layerAttr","layerShow","flag","duration","getParameterSettings","getRequiredHardware","onDrop","dropTarget","shiftKey","ctrlKey","getPersistentAttributes","memento","labels","children","labelJSON","locator","setPersistentAttributes","resetChildren","DecoratedInputPort","InputPort","hasChanged","decoration","MarkerFigure","LeftLocator","margin","useDefaultValue","setStick","hasChangedValue","hasRisingEdge","hasFallingEdge","ExtLabel","basic","Label","blur","util","ArrayList","PositionFilter","FontSizeFilter","FontColorFilter","installEditor","setBlur","repaint","getBlur","removeFilter","alreadyIn","onInstall","lattr","bold","fontSize","fontFamily","fontColor","padding","left","filterMemento","ExtLine","PolyLine","StrokeFilter","setRouter","VertexRouter","VertexSelectionFeedbackPolicy","ExtPolygon","Polygon","SizeFilter","FillColorFilter","RectangleSelectionFeedbackPolicy","onDoubleClick","svgPathString","calculatePath","sizeFilterAdded","insertElementAt","Circle","diameter","direction","fanout","FanoutFilter","PortDirectionFilter","PortTypeFilter","AntSelectionFeedbackPolicy","setInputType","getInputType","setMaxFanOut","count","getMaxFanOut","setConnectionDirection","updateDecoration","getConnectionDirection","ArrowUp","TopLocator","ArrowRight","RightLocator","ArrowDown","BottomLocator","ArrowLeft","fanoutFilterAdded","VerticalLayout","isMouseOver","stick","defaultValue","stateA","MarkerStateAFigure","stateB","MarkerStateBFigure","onMouseOver","getStickTickFigure","hitTest","getStick","getLabelFigure","contextMenu","selector","trigger","events","options","setDefaultValue","items","visible","setTick","setText","bottom","right","HorizontalLayout","gap","stickTick","resizeable","addCssClass","repaintBlocked","createShapeElement","arrowLength","vertices","getAbsolutePosition","Point","getRadius","equals","begin","Util","insetPoint","modStart","modEnd","join","PolyCircle","Oval","center","setCenter","getVertices","w2","h2","sides","radian","PI","cos","sin","PolyRect","topLeft","bottomRight","addVertex","createPort","toggleValue","getOutputPort","getConnections","BlurFilter","$parent","containerId","cssScope","svgSelector","TouchSpin","step","Filter","maxboostedstep","postfix","colorPicker","picker","jscolor","document","getElementById","fromString","getBackgroundColor","onImmediateChange","setBackgroundColor","toString","hidePicker","relatedFigure","getFontColor","setFontColor","getFontSize","boostat","setFontSize","LinearGradientFilter","colorPicker1","colorPicker2","startColor","endColor","angle","anglepicker","change","picker1","picker2","setStroke","OpacityFilter","getAlpha","setAlpha","OutlineStrokeFilter","getOutlineStroke","setOutlineStroke","getOutlineColor","setOutlineColor","dir","block","setPosition","RadiusFilter","setRadius","setWidth","setHeight","getStroke","getColor","TextLinearGradientFilter","hardware","CircuitFigure","skillproxy","ValueParserValidator","widget","bridge","button","jQuery","uaMatch","ua","toLowerCase","match","indexOf","browser","version","matched","navigator","userAgent","chrome","webkit","safari","load","k","global","socket","sanitize","BackendSkills","skillList","Object","preventExtensions","ip","port","self","ajax","url","skill","connect","xhrFields","withCredentials","resp","err","skills","browse","skillObject","_machineName","async","filePath","skill_name","getDescription","skill_descp","JSON","parse","_ip","_port","_skill_name","_parameters","skillName","parameters","BackendStorage","response","sort","stringify","image","undefined","fail","error","segments","basename","history","pushState","resultCallback","customCode","ports","shapes","constructor","extra","getText","template","tags","Base64","encode","jsts","AbstractToolPolicy","firstFigure","operation","setToolHeader","setToolMessage","contains","setPrimary","fireEvent","executeGeometryOperation","figure1","figure2","operationFunc","p1","getGeometry","p2","union","GeoJSONWriter","write","CommandCollection","CommandDelete","coordinates","poly","vertex","getX","getY","WKTReader","v","asArray","read","map","SelectionPolicy","setToolText","message","TITLE","boundingBoxFigure1","boundingBoxFigure2","onUninstall","onMouseDown","onMouseDrag","dx2","dy2","r","sqrt","abs","Color","onMouseUp","AbstractGeoToolPolicy","getBestFigure","getParent","Port","isSelectable","MESSAGE_STEP1","MESSAGE_STEP2","lineFigure","onMouseMove","setEndPoint","onClick","beforeLast","removeVertexAt","setStartPoint","mouseDownElement","topLeftPoint","alpha","dash","setDimension","distance","BoundingboxSelectionPolicy","heading","cloneOnDrag","mouseDraggingElement","ResizeHandle","onDragEnd","onDragStart","newFigure","setPadding","reg","_str","_value","isNaN","isArray","parseFunc","_txt","txt","_tmp","_iter","_index","_rslt","Date","getTime","toDateString","_localizedText","locale","dataType","value_input","_dtype","_isArray","ListOf","Buffer","from","localizedText_parser","ListOfNumbers","ListOfDates","module","exports","_globalCallbacks","_originalStopCallback","stopCallback","combo","sequence","paused","keys","action","bindClass","binding","preloading","install","addEvent","preload","matchClass","getElementsByTagName","m","Function","eInvalidProp","fn","imgRequire","hasOwnProperty","loadImage","images","pad","sld","cross","arrow","imgLoaded","requireImage","filename","Image","src","fetchElement","mixed","evnt","attachEvent","createEvent","ev","initEvent","dispatchEvent","createEventObject","getElementPos","e1","e2","offsetParent","offsetLeft","offsetTop","parentNode","nodeName","toUpperCase","getElementSize","offsetWidth","offsetHeight","getRelMousePos","offsetX","offsetY","layerX","layerY","getViewPos","pageYOffset","pageXOffset","body","documentElement","getViewSize","innerWidth","innerHeight","clientHeight","URI","uri","scheme","authority","query","fragment","toAbsolute","base","removeDotSegments","substr","out","rm","target","required","adjust","caps","slider","valueElement","styleElement","hsv","rgb","minH","maxH","minS","maxS","minV","maxV","pickerOnfocus","pickerMode","pickerPosition","pickerSmartPosition","pickerButtonHeight","pickerClosable","pickerCloseText","pickerButtonColor","pickerFace","pickerFaceColor","pickerBorder","pickerBorderColor","pickerInset","pickerInsetColor","pickerZIndex","isPickerOwner","removePicker","showPicker","tp","ts","vp","vs","ps","getPickerDims","l","pp","drawPicker","importColor","exportColor","leaveValue","style","backgroundImage","jscStyle","backgroundColor","leaveStyle","flags","leavePad","redrawPad","leaveSld","redrawSld","fromHSV","s","HSV_RGB","fromRGB","g","RGB_HSV","hex","charAt","owner","removeChild","boxB","box","createElement","padB","padM","sldB","sldM","btn","btnS","btnT","createTextNode","THIS","segSize","seg","appendChild","onmouseup","onmouseout","onmousedown","abortBlur","onmousemove","holdPad","holdSld","setPad","setSld","empty","removeAllRanges","dispatchImmediateChange","handle_touchmove","touches","pageX","touchOffset","X","pageY","Y","removeEventListener","modeID","dims","zIndex","border","borderColor","background","overflow","display","eOldIE","setBtnBorder","insetColors","pickerOutsetColor","font","textAlign","padImg","hsImg","hvImg","crossImg","backgroundRepeat","arrowImg","backgroundPosition","o","yComponent","childNodes","blurTarget","blurValue","mpos","updateField","setAttribute","mouse","widgetEventPrefix","_init","_mouseInit","pointer","setDegrees","_propagate","_trigger","_create","destroy","_mouseDestroy","_mouseStart","myOffset","startOffset","setDegreesFromEvent","_mouseStop","_mouseDrag","_setOption","newValue","oldValue","drawRotation","clockwise","rotation","degrees","clamp","opposite","adjacent","radians","atan","roundToMultiple","shiftSnap","snap","number","multiple","integer","rest","root","factory","define","supports","querySelector","settings","initClass","after","times","extended","deep","merge","svgs","querySelectorAll","inliner","cb","svg","getAttribute","request","XMLHttpRequest","open","onload","status","parser","DOMParser","parseFromString","responseText","inlinedSVG","titles","descs","removeAttribute","attribute","classList","longdesc","description","createElementNS","descriptionText","insertBefore","firstChild","alt","titleText","replaceChild","onerror","send"],"mappings":"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AM,KAAK,UAAU,MAAM,KAAK,UAAU,MAAM,KAAK,UAAU,MAAM,KAAK,YAAY,aAAa,MAAM,KAAK,UAAU,YAAY,aAAa,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,aAAa,aAAa,aAAa,aAAa,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,aAAa,aAAa,MAAM,KAAK,UAAU,KAAK,KAAK,UAAU,KAAK,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,YAAY,MAAM,UAAU,KAAK,KAAK,UAAU,KAAK,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,aAAa,MAAM,KAAK,YAAY,aAAa,MAAM,KAAK,KAAK,YAAY,aAAa,MAAM,KAAK,YAAY,aAAa,MAAM,KAAK,KAAK,KAAK,YAAY,aAAa,MAAM,KAAK,YAAY,aAAa,MAAM,KAAK,KAAK,YAAY,aAAa,aAAa,aAAa,MAAM,KAAK,YAAY,aAAa,aAAa,aAAa,MAAM,KAAK,YAAY,aAAa,aAAa,aAAa,MAAM,KAAK,YAAY,aAAa,aAAa,aAAa,MAAM,KAAK,YAAY,aAAa,aAAa,aAAa,MAAM,SAAS,UAAU,KAAK,KAAK,YAAY,aAAa,WAAW,UAAU,YAAY,aAAa,MAAM,MAAM,YAAY,WAAW,UAAU,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,UAAU,MAAM,KAAK,UAAU,MAAM,KAAK,OAAO,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,OAAO,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,OAAO,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,OAAO,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,OAAO,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,QAAQ,YAAY,MAAM,OAAO,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,OAAO,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,OAAO,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,SAAS,YAAY,MAAM,KAAK,YAAY,MAAM,OAAO,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,OAAO,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,OAAO,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,OAAO,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,OAAO,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,OAAO,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,OAAO,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,MAAM,YAAY,MAAM,MAAM,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MA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AM,WAAW,WAAW,UAAU,UAAU,UAAU,WAAW,WAAW,WAAW,UAAU,UAAU,WAAW,KAAK,MAAM,WAAW,WAAW,UAAU,UAAU,UAAU,WAAW,WAAW,WAAW,UAAU,UAAU,WAAW,KAAK,MAAM,YAAY,WAAW,UAAU,KAAK,KAAK,UAAU,KAAK,KAAK,UAAU,KAAK,KAAK,WAAW,KAAK,MAAM,UAAU,WAAW,WAAW,MAAM,MAAM,WAAW,WAAW,WAAW,MAAM,MAAM,WAAW,WAAW,WAAW,MAAM,MAAM,UAAU,WAAW,MAAM,MAAM,YAAY,WAAW,WAAW,WAAW,WAAW,UAAU,UAAU,UAAU,WAAW,UAAU,WAAW,WAAW,UAAU,UAAU,MAAM,MAAM,WAAW,MAAM,MAAM,YAAY,WAAW,MAAM,MAAM,YAAY,UAAU,MAAM,OAAO,WAAW,WAAW,UAAU,MAAM,MAAM,YAAY,WAAW,MAAM,MAAM,WAAW,MAAM,MAAM,WAAW,UAAU,WAAW,MAAM,MAAM,WAAW,MAAM,MAAM,YAAY,UAAU,MAAM,MAAM,WAAW,WAAW,WAAW,UAAU,WAAW,MAAM,MAAM,WAAW,WAAW,MAAM,MAAM,YAAY,MAAM,MAAM,UAAU,MAAM,MAAM,WAAW,WAAW,MAAM,MAAM,UAAU,MAAM,MAAM,WAAW,WAAW,MAAM,MAAM,UAAU,MAAM,MAAM,UAAU,UAAU,UAAU,WAAW,WAAW,MAAM,MAAM,WAAW,WAAW,UAAU,WAAW,WAAW,WAAW,UAAU,WAAW,MAAM,MAAM,WAAW,MAAM,YAAY,OAAO,WAAW,MAAM,MAAM,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,MAAM,UAAU,MAAM,WAAW,WAAW,WAAW,MAAM,MAAM,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,UAAU,UAAU,WAAW,MAAM,MAAM,UAAU,UAAU,WAAW,MAAM,MAAM,WAAW,WAAW,MAAM,MAAM,OAAO,OAAO,UAAU,UAAU,UAAU,WAAW,MAAM,MAAM,WAAW,MAAM,UAAU,MAAM,WAAW,UAAU,UAAU,UAAU,UAAU,UAAU,WAAW,UAAU,WAAW,WAAW,WAAW,WAAW,MAAM,MAAM,WAAW,UAAU,WAAW,WAAW,WAAW,WAAW,MAAM,MAAM,WAAW,UAAU,UAAU,WAAW,MAAM,MAAM,UAAU,UAAU,UAAU,WAAW,UAAU,UAAU,UAAU,UAAU,WAAW,WAAW,MAAM,MAAM,UAAU,UAAU,UAAU,UAAU,UAAU,WAAW,WAAW,MAAM,MAAM,WAAW,MAAM,MAAM,UAAU,MAAM,MAAM,UAAU,UAAU,UAAU,UAAU,UAAU,WAAW,WAAW,MAAM,MAAM,WAAW,MAAM,MAAM,UAAU,MAAM,MAAM,WAAW,MAAM,MAAM,WAAW,WAAW,WAAW,WAAW,WAAW,MAAM,MAAM,WAAW,MAAM,MAAM,YAAY,UAAU,MAAM,MAAM,WAAW,MAAM,MAAM,UAAU,UAAU,UAAU,WAAW,UAAU,UAAU,UAAU,UAAU,WAAW,WAAW,WAAW,UAAU,MAAM,MAAM,UAAU,UAAU,UAAU,WAAW,MAAM,MAAM,YAAY,WAAW,UAAU,WAAW,MAAM,MAAM,YAAY,UAAU,MAAM,MAAM,WAAW,WAAW,WAAW,UAAU,UAAU,WAAW,MAAM,MAAM,WAAW,WAAW,UAAU,UAAU,WAAW,MAAM,MAAM,WAAW,UAAU,UAAU,UAAU,WAAW,WAAW,UAAU,WAAW,WAAW,WAAW,UAAU,WAAW,MAAM,MAAM,WAAW,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,MAAM,MAAM,YAAY,UAAU,UAAU,WAAW,UAAU,WAAW,WAAW,WAAW,WAAW,WAAW,MAAM,MAAM,UAAU,UAAU,UAAU,UAAU,UAAU,WAAW,MAAM,MAAM,WAAW,WAAW,MAAM,MAAM,WAAW,WAAW,MAAM,MAAM,WAAW,WAAW,MAAM,MAAM,WAAW,WAAW,MAAM,MAAM,WAAW,WAAW,MAAM,MAAM,UAAU,WAAW,MAAM,MAAM,WAAW,WAAW,UAAU,UAAU,MAAM,MAAM,YAAY,MAAM,MAAM,WAAW,MAAM,MAAM,YAAY,UAAU,WAAW,WAAW,WAAW,WAAW,MAAM,MAAM,WAAW,UAAU,UAAU,UAAU,UAAU,WAAW,UAAU,MAAM,MAAM,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,MAAM,MAAM,UAAU,MAAM,MAAM,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,MAAM,MAAM,UAAU,MAAM,MAAM,WAAW,UAAU,UAAU,UAAU,UAAU,WAAW,UAAU,WAAW,WAAW,MAAM,MAAM,WAAW,UAAU,UAAU,UAAU,UAAU,WAAW,UAAU,MAAM,MAAM,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,MAAM,MAAM,UAAU,MAAM,MAAM,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,MAAM,MAAM,UAAU,MAAM,OAAO,UAAU,WAAW,OAAO,OAAO,YAAY,YAAY,OAAO,OAAO,cAAc,YAAY,WAAW,WAAW,OAAO,OAAO,cAAc,cAAc,OAAO,OAAO,UAAU,WAAW,OAAO,OAAO,YAAY,YAAY,OAAO,OAAO,cAAc,YAAY,WAAW,WAAW,WAAW,UAAU,OAAO,OAAO,WAAW,OAAO,OAAO,cAAc,cAAc,OAAO,OAAO,YAAY,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,WAAW,UAAU,WAAW,MAAM,OAAO,WAAW,UAAU,UAAU,UAAU,UAAU,WAAW,WAAW,WAAW,UAAU,WAAW,WAAW,WAAW,UAAU,OAAO,OAAO,YAAY,UAAU,UAAU,WAAW,WAAW,UAAU,UAAU,UAAU,UAAU,WAAW,OAAO,OAAO,WAAW,UAAU,UAAU,UAAU,UAAU,UAAU,WAAW,OAAO,OAAO,WAAW,UAAU,OAAO,OAAO,YAAY,OAAO,OAAO,YAAY,OAAO,OAAO,YAAY,OAAO,OAAO,WAAW,UAAU,UAAU,WAAW,OAAO,OAAO,UAAU,OAAO,OAAO,YAAY,UAAU,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,UAAU,UAAU,WAAW,OAAO,OAAO,WAAW,OAAO,OAAO,YAAY,OAAO,OAAO,WAAW,OAAO,OAAO,YAAY,WAAW,WAAW,WAAW,OAAO,OAAO,WAAW,WAAW,WAAW,WAAW,WAAW,UAAU,WAAW,WAAW,WAAW,UAAU,OAAO,OAAO,WAAW,WAAW,WAAW,UAAU,WAAW,WAAW,UAAU,OAAO,OAAO,UAAU,WAAW,UAAU,UAAU,WAAW,UAAU,WAAW,WAAW,OAAO,OAAO,UAAU,WAAW,UAAU,UAAU,UAAU,UAAU,WAAW,WAAW,OAAO,OAAO,WAAW,OAAO,OAAO,WAAW,WAAW,UAAU,UAAU,UAAU,UAAU,WAAW,WAAW,OAAO,OAAO,WAAW,WAAW,WAAW,UAAU,UAAU,UAAU,UAAU,WAAW,OAAO,OAAO,WAAW,WAAW,UAAU,UAAU,WAAW,WAAW,UAAU,UAAU,UAAU,UAAU,OAAO,OAAO,WAAW,OAAO,OAAO,YAAY,UAAU,UAAU,WAAW,WAAW,UAAU,UAAU,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,OAAO,OAAO,YAAY,WAAW,WAAW,OAAO,OAAO,YAAY,WAAW,OAAO,OAAO,YAAY,WAAW,WAAW,OAAO,OAAO,YAAY,WAAW,WAAW,OAAO,OAAO,YAAY,WAAW,OAAO,OAAO,YAAY,WAAW,UAAU,OAAO,OAAO,WAAW,WAAW,WAAW,WAAW,OAAO,OAAO,YAAY,OAAO,OAAO,YAAY,OAAO,OAAO,YAAY,OAAO,OAAO,YAAY,WAAW,WAAW,OAAO,OAAO,YAAY,WAAW,WAAW,OAAO,OAAO,UAAU,UAAU,WAAW,YAAY,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,OAAO,OAAO,WAAW,UAAU,UAAU,UAAU,WAAW,WAAW,WAAW,WAAW,WAAW,WAAW,OAAO,QAAQ,WAAW,OAAO,UAAU,WAAW,OAAO,OAAO,UAAU,UAAU,WAAW,WAAW,WAAW,WAAW,WAAW,OAAO,OAAO,WAAW,WAAW,UAAU,WAAW,OAAO,OAAO,WAAW,UAAU,WAAW,OAAO,OAAO,UAAU,WAAW,WAAW,WAAW,UAAU,WAAW,OAAO,OAAO,YAAY,OAAO,OAAO,WAAW,WAAW,OAAO,OAAO,WAAW,WAAW,OAAO,OAAO,YAAY,yDAAyD,aAAa,kBAAkB,uBAAuB,UAAU,YAAY,wBAAwB,0BAA0B,sBAAsB,2BAA2B,sBAAsB,wCAAwC,4BAA4B,SAAS,mBAAmB,KAAK,aAAa,yBAAyB,4BAA4B,0BAA0B,sBAAsB,8BAA8B,YAAY,sBAAsB,0BAA0B,qBAAqB,qCAAqC,sCAAsC,6BAA6B,gCAAgC,6BAA6B,qBAAqB,yBAAyB,+BAA+B,SAAS,kBAAkB,sBAAsB,0BAA0B,qBAAqB,qCAAqC,sCAAsC,6BAA6B,gCAAgC,6BAA6B,qBAAqB,yBAAyB,+BAA+B,SAAS,cAAc,wCAAwC,6BAA6B,0BAA0B,SAAS,mBAAmB,sBAAsB,SAAS,yBAAyB,eAAe,2BAA2B,oBAAoB,iFAAiF,aAAa,WAAW,SAAS,OAAO,KAAK,GAAG,eAAe,cAAc,mBAAmB,wBAAwB,WAAW,aAAa,gBAAgB,iBAAiB,sBAAsB,4BAA4B,uBAAuB,8BAA8B,4BAA4B,GAAG,cAAc,kBAAkB,GAAG,mBAAmB,wBAAwB,0BAA0B,wBAAwB,GAAG,iCAAiC,0BAA0B,GAAG,qCAAqC,gBAAgB,qBAAqB,eAAe,gBAAgB,iBAAiB,uBAAuB,0BAA0B,uBAAuB,gBAAgB,oBAAoB,yBAAyB,GAAG,2CAA2C,gBAAgB,qBAAqB,eAAe,gBAAgB,iBAAiB,uBAAuB,0BAA0B,uBAAuB,gBAAgB,oBAAoB,yBAAyB,GAAG,qCAAqC,8BAA8B,uBAAuB,oBAAoB,GAAG,0CAA0C,iBAAiB,GAAG,oDAAoD,oBAAoB,GAAG,0DAA0D,6EAA6E,GAAG,sBAAsB,iBAAiB,4BAA4B,oCAAoC,GAAG,iCAAiC,uBAAuB,gFAAgF,8BAA8B,GAAG,+CAA+C,qBAAqB,qBAAqB,gDAAgD,GAAG,6CAA6C,iBAAiB,sBAAsB,GAAG,2DAA2D,6BAA6B,0BAA0B,qBAAqB,2BAA2B,uBAAuB,cAAc,eAAe,mBAAmB,0BAA0B,kBAAkB,8BAA8B,qBAAqB,iBAAiB,mBAAmB,GAAG,iEAAiE,8BAA8B,GAAG,yDAAyD,qBAAqB,qBAAqB,GAAG,iFAAiF,sBAAsB,mBAAmB,GAAG,gIAAgI,oBAAoB,wBAAwB,mBAAmB,GAAG,0EAA0E,kCAAkC,qBAAqB,GAAG,gFAAgF,+BAA+B,GAAG,sGAAsG,gBAAgB,oBAAoB,qCAAqC,GAAG,0GAA0G,gBAAgB,GAAG,+CAA+C,kCAAkC,kBAAkB,GAAG,oDAAoD,cAAc,8BAA8B,kCAAkC,mBAAmB,yBAAyB,GAAG,0DAA0D,+CAA+C,yBAAyB,GAAG,4DAA4D,sBAAsB,GAAG,+BAA+B,gBAAgB,GAAG,gCAAgC,qBAAqB,sBAAsB,GAAG,sCAAsC,kBAAkB,GAAG,wCAAwC,qBAAqB,sBAAsB,GAAG,uCAAuC,kBAAkB,GAAG,gBAAgB,oBAAoB,iBAAiB,iBAAiB,+CAA+C,uBAAuB,GAAG,uBAAuB,kCAAkC,qBAAqB,iBAAiB,uBAAuB,wBAAwB,kCAAkC,kBAAkB,yBAAyB,GAAG,6BAA6B,8BAA8B,GAAG,4BAA4B,gCAAgC,GAAG,kBAAkB,gCAAgC,6BAA6B,gCAAgC,mCAAmC,iDAAiD,gCAAgC,+BAA+B,8BAA8B,GAAG,oBAAoB,qBAAqB,iDAAiD,qBAAqB,GAAG,SAAS,+CAA+C,0CAA0C,mCAAmC,gCAAgC,sBAAsB,yBAAyB,sBAAsB,2BAA2B,iBAAiB,oBAAoB,sBAAsB,GAAG,sBAAsB,mBAAmB,gBAAgB,qBAAqB,GAAG,kBAAkB,sCAAsC,qBAAqB,GAAG,mOAAmO,gBAAgB,iBAAiB,iBAAiB,gCAAgC,GAAG,YAAY,qBAAqB,GAAG,iCAAiC,uBAAuB,WAAW,YAAY,gBAAgB,iBAAiB,mBAAmB,uBAAuB,eAAe,kCAAkC,0BAA0B,iCAAiC,yBAAyB,GAAG,uBAAuB,wBAAwB,eAAe,gCAAgC,wBAAwB,iCAAiC,yBAAyB,GAAG,uBAAuB,6CAA6C,iBAAiB,oBAAoB,uBAAuB,GAAG,WAAW,eAAe,cAAc,cAAc,uBAAuB,cAAc,iBAAiB,gBAAgB,cAAc,qBAAqB,8BAA8B,GAAG,kBAAkB,oBAAoB,gBAAgB,cAAc,gBAAgB,oBAAoB,kCAAkC,+CAA+C,GAAG,wBAAwB,yCAAyC,GAAG,wBAAwB,mBAAmB,GAAG,wBAAwB,oBAAoB,cAAc,gBAAgB,oBAAoB,kBAAkB,wBAAwB,qBAAqB,GAAG,mCAAmC,qBAAqB,GAAG,oCAAoC,cAAc,GAAG,oCAAoC,qCAAqC,GAAG,4BAA4B,6BAA6B,yCAAyC,iCAAiC,qDAAqD,kCAAkC,GAAG,kCAAkC,8BAA8B,GAAG,mCAAmC,8BAA8B,cAAc,GAAG,yCAAyC,8BAA8B,GAAG,UAAU,eAAe,cAAc,cAAc,uBAAuB,WAAW,YAAY,cAAc,iBAAiB,8BAA8B,uBAAuB,uDAAuD,eAAe,GAAG,iBAAiB,eAAe,eAAe,cAAc,uBAAuB,GAAG,qBAAqB,wBAAwB,uBAAuB,eAAe,qBAAqB,GAAG,qBAAqB,uBAAuB,eAAe,GAAG,wBAAwB,oBAAoB,qBAAqB,sBAAsB,cAAc,eAAe,qBAAqB,GAAG,wBAAwB,oBAAoB,qBAAqB,cAAc,eAAe,qBAAqB,GAAG,qBAAqB,oBAAoB,iBAAiB,iBAAiB,cAAc,qCAAqC,qBAAqB,oBAAoB,8BAA8B,wBAAwB,qBAAqB,mBAAmB,sDAAsD,GAAG,0BAA0B,eAAe,cAAc,cAAc,oBAAoB,cAAc,YAAY,cAAc,iBAAiB,mBAAmB,GAAG,wCAAwC,8BAA8B,iBAAiB,iBAAiB,qBAAqB,oBAAoB,wBAAwB,6BAA6B,qBAAqB,kCAAkC,qCAAqC,GAAG,gDAAgD,kBAAkB,mBAAmB,gBAAgB,iBAAiB,gBAAgB,sBAAsB,GAAG,wDAAwD,4DAA4D,2BAA2B,GAAG,yDAAyD,4DAA4D,2BAA2B,GAAG,2DAA2D,8DAA8D,2BAA2B,GAAG,yDAAyD,4DAA4D,2BAA2B,GAAG,wDAAwD,4DAA4D,2BAA2B,GAAG,mEAAmE,iBAAiB,uBAAuB,GAAG,8CAA8C,oBAAoB,uBAAuB,gBAAgB,iBAAiB,GAAG,gDAAgD,6BAA6B,GAAG,sDAAsD,+BAA+B,GAAG,gDAAgD,8BAA8B,iBAAiB,yBAAyB,sBAAsB,0BAA0B,qBAAqB,GAAG,iBAAiB,uBAAuB,aAAa,cAAc,gBAAgB,iBAAiB,4BAA4B,mBAAmB,GAAG,eAAe,oBAAoB,gBAAgB,cAAc,gBAAgB,iBAAiB,mBAAmB,oBAAoB,oBAAoB,GAAG,qBAAqB,mBAAmB,GAAG,aAAa,oBAAoB,gBAAgB,cAAc,gBAAgB,iBAAiB,mBAAmB,oBAAoB,oBAAoB,GAAG,mBAAmB,mBAAmB,GAAG,cAAc,uBAAuB,iBAAiB,mBAAmB,cAAc,eAAe,gCAAgC,iBAAiB,4BAA4B,uBAAuB,GAAG,gBAAgB,uBAAuB,aAAa,cAAc,gBAAgB,iBAAiB,4BAA4B,mBAAmB,GAAG,eAAe,oBAAoB,gBAAgB,cAAc,gBAAgB,iBAAiB,mBAAmB,oBAAoB,oBAAoB,GAAG,qBAAqB,mBAAmB,GAAG,mBAAmB,oBAAoB,iBAAiB,cAAc,gBAAgB,iBAAiB,mBAAmB,oBAAoB,oBAAoB,GAAG,yBAAyB,mBAAmB,GAAG,wBAAwB,iBAAiB,uBAAuB,GAAG,sCAAsC,sCAAsC,GAAG,6CAA6C,0CAA0C,2BAA2B,uBAAuB,GAAG,qDAAqD,8DAA8D,GAAG,mBAAmB,iBAAiB,uBAAuB,GAAG,iCAAiC,sCAAsC,GAAG,wCAAwC,0CAA0C,2BAA2B,uBAAuB,qBAAqB,oBAAoB,GAAG,+CAA+C,wBAAwB,GAAG,gDAAgD,8DAA8D,GAAG,WAAW,uBAAuB,cAAc,aAAa,cAAc,iBAAiB,eAAe,cAAc,qBAAqB,cAAc,8BAA8B,GAAG,0BAA0B,+CAA+C,oBAAoB,iBAAiB,iBAAiB,cAAc,qCAAqC,kCAAkC,qBAAqB,oBAAoB,qBAAqB,wBAAwB,uBAAuB,mBAAmB,GAAG,2BAA2B,sBAAsB,cAAc,iBAAiB,uBAAuB,uBAAuB,cAAc,aAAa,iBAAiB,iBAAiB,+CAA+C,GAAG,2BAA2B,oBAAoB,cAAc,iBAAiB,iBAAiB,cAAc,eAAe,qBAAqB,GAAG,uCAAuC,iBAAiB,mBAAmB,GAAG,uCAAuC,kCAAkC,GAAG,sDAAsD,wBAAwB,GAAG,iEAAiE,uBAAuB,GAAG,iCAAiC,mBAAmB,eAAe,cAAc,qCAAqC,GAAG,uCAAuC,mBAAmB,GAAG,2CAA2C,8BAA8B,oBAAoB,mCAAmC,gCAAgC,iCAAiC,6CAA6C,sCAAsC,yBAAyB,oBAAoB,oBAAoB,qBAAqB,GAAG,iDAAiD,gBAAgB,GAAG,mDAAmD,6BAA6B,GAAG,yBAAyB,iBAAiB,GAAG,gBAAgB,sBAAsB,uBAAuB,qBAAqB,wBAAwB,GAAG,8BAA8B,eAAe,sBAAsB,uBAAuB,8BAA8B,4BAA4B,mBAAmB,qBAAqB,qBAAqB,8BAA8B,oBAAoB,GAAG,0BAA0B,cAAc,qBAAqB,+CAA+C,cAAc,kCAAkC,qCAAqC,oBAAoB,GAAG,+BAA+B,gBAAgB,uBAAuB,aAAa,cAAc,0BAA0B,iBAAiB,4BAA4B,qBAAqB,GAAG,qCAAqC,eAAe,0BAA0B,iBAAiB,oBAAoB,iBAAiB,mBAAmB,yCAAyC,wBAAwB,GAAG,2CAA2C,oBAAoB,GAAG,sCAAsC,eAAe,0BAA0B,iBAAiB,oBAAoB,iBAAiB,mBAAmB,0CAA0C,wBAAwB,GAAG,+BAA+B,eAAe,0BAA0B,qEAAqE,oBAAoB,iBAAiB,cAAc,gBAAgB,uBAAuB,GAAG,gCAAgC,eAAe,0BAA0B,aAAa,cAAc,uBAAuB,4BAA4B,kBAAkB,mBAAmB,cAAc,gBAAgB,GAAG,oCAAoC,mBAAmB,GAAG,sCAAsC,8CAA8C,gBAAgB,oBAAoB,kCAAkC,wBAAwB,iBAAiB,mBAAmB,2BAA2B,4BAA4B,+BAA+B,uBAAuB,uCAAuC,0CAA0C,kCAAkC,GAAG,yCAAyC,iCAAiC,kCAAkC,qCAAqC,GAAG,qDAAqD,qBAAqB,uBAAuB,GAAG,oEAAoE,oCAAoC,wCAAwC,gCAAgC,GAAG,mEAAmE,qCAAqC,yCAAyC,iCAAiC,GAAG,yCAAyC,uBAAuB,uBAAuB,GAAG,wDAAwD,qBAAqB,uBAAuB,mBAAmB,GAAG,4CAA4C,kBAAkB,kCAAkC,qCAAqC,mCAAmC,GAAG,wDAAwD,wBAAwB,GAAG,yDAAyD,wBAAwB,GAAG,uDAAuD,qBAAqB,GAAG,mEAAmE,uCAAuC,2CAA2C,mCAAmC,GAAG,kEAAkE,wCAAwC,4CAA4C,oCAAoC,GAAG,mBAAmB,gBAAgB,iBAAiB,wBAAwB,uCAAuC,qtBAAqtB,iFAAiF,8IAA8I,oFAAoF,+EAA+E,gFAAgF,kFAAkF,2BAA2B,qEAAqE,wEAAwE,gEAAgE,4BAA4B,+BAA+B,uBAAuB,uBAAuB,0BAA0B,GAAG,2BAA2B,uBAAuB,aAAa,cAAc,eAAe,0BAA0B,mCAAmC,sCAAsC,kCAAkC,iCAAiC,8BAA8B,GAAG,mEAAmE,0BAA0B,GAAG,yLAAyL,wBAAwB,GAAG,uBAAuB,gBAAgB,eAAe,uBAAuB,wBAAwB,4BAA4B,+BAA+B,uBAAuB,GAAG,wBAAwB,sBAAsB,uBAAuB,gBAAgB,wBAAwB,GAAG,mCAAmC,mCAAmC,eAAe,2BAA2B,GAAG,8BAA8B,iBAAiB,kCAAkC,2BAA2B,2BAA2B,mBAAmB,8BAA8B,GAAG,iCAAiC,qBAAqB,GAAG,qCAAqC,iBAAiB,wBAAwB,GAAG,6CAA6C,oBAAoB,0BAA0B,GAAG,gDAAgD,8BAA8B,GAAG,wBAAwB,iBAAiB,4BAA4B,mCAAmC,GAAG,oBAAoB,mBAAmB,wBAAwB,6EAA6E,yCAAyC,sBAAsB,wBAAwB,wBAAwB,oDAAoD,OAAO,qBAAqB,qBAAqB,yBAAyB,wBAAwB,oCAAoC,gCAAgC,2BAA2B,iCAAiC,6BAA6B,oBAAoB,qBAAqB,yBAAyB,gCAAgC,wBAAwB,oCAAoC,2BAA2B,uBAAuB,yBAAyB,kBAAkB,+CAA+C,WAAW,SAAS,uBAAuB,2BAA2B,2BAA2B,qCAAqC,8BAA8B,8BAA8B,WAAW,6BAA6B,4BAA4B,gCAAgC,8BAA8B,WAAW,8BAA8B,0CAA0C,6BAA6B,uBAAuB,yCAAyC,aAAa,WAAW,0DAA0D,wBAAwB,4BAA4B,6CAA6C,iBAAiB,0BAA0B,aAAa,WAAW,SAAS,OAAO,uBAAuB,sCAAsC,qBAAqB,eAAe,mBAAmB,oCAAoC,uCAAuC,2BAA2B,+BAA+B,oBAAoB,qDAAqD,iCAAiC,WAAW,SAAS,uBAAuB,4BAA4B,SAAS,OAAO,KAAK,GAAG,0BAA0B,kBAAkB,iBAAiB,KAAK,GAAG,wBAAwB,mBAAmB,uBAAuB,wBAAwB,KAAK,mBAAmB,cAAc,sBAAsB,OAAO,KAAK,GAAG,gCAAgC,mBAAmB,uBAAuB,wBAAwB,KAAK,oBAAoB,mBAAmB,KAAK,GAAG,kBAAkB,oBAAoB,iBAAiB,kCAAkC,qDAAqD,sBAAsB,cAAc,mCAAmC,sBAAsB,kBAAkB,wBAAwB,yBAAyB,mCAAmC,mBAAmB,2BAA2B,eAAe,oCAAoC,OAAO,KAAK,GAAG,8BAA8B,iCAAiC,GAAG,mBAAmB,8BAA8B,2BAA2B,8BAA8B,iCAAiC,gDAAgD,+BAA+B,6BAA6B,4BAA4B,GAAG,yBAAyB,mBAAmB,iDAAiD,oBAAoB,GAAG,UAAU,8CAA8C,yCAAyC,kCAAkC,+BAA+B,oBAAoB,wBAAwB,qBAAqB,0BAA0B,eAAe,kBAAkB,oBAAoB,GAAG,0BAA0B,mBAAmB,gBAAgB,qBAAqB,yEAAyE,qBAAqB,qCAAqC,oBAAoB,GAAG,wOAAwO,cAAc,eAAe,eAAe,+BAA+B,GAAG,sBAAsB,qBAAqB,GAAG,qCAAqC,sBAAsB,UAAU,WAAW,eAAe,gBAAgB,kBAAkB,yBAAyB,eAAe,kCAAkC,0BAA0B,iCAAiC,yBAAyB,GAAG,yBAAyB,wBAAwB,eAAe,gCAAgC,wBAAwB,iCAAiC,yBAAyB,GAAG,6BAA6B,0CAA0C,iBAAiB,mBAAmB,uBAAuB,GAAG,eAAe,cAAc,aAAa,aAAa,uBAAuB,wBAAwB,4BAA4B,yBAAyB,cAAc,qBAAqB,6BAA6B,GAAG,qBAAqB,oBAAoB,eAAe,yBAAyB,4BAA4B,mBAAmB,iCAAiC,qDAAqD,aAAa,8CAA8C,KAAK,GAAG,yBAAyB,qBAAqB,GAAG,2BAA2B,oBAAoB,0BAA0B,4BAA4B,mBAAmB,iBAAiB,uBAAuB,oBAAoB,GAAG,yBAAyB,iBAAiB,sBAAsB,KAAK,kBAAkB,eAAe,KAAK,kBAAkB,yCAAyC,KAAK,YAAY,8BAA8B,2CAA2C,mCAAmC,oDAAoD,oCAAoC,cAAc,oCAAoC,OAAO,KAAK,iBAAiB,kCAAkC,eAAe,gBAAgB,gDAAgD,OAAO,KAAK,GAAG,YAAY,eAAe,cAAc,cAAc,uBAAuB,WAAW,YAAY,cAAc,0BAA0B,wCAAwC,uBAAuB,uDAAuD,eAAe,cAAc,iBAAiB,gBAAgB,gBAAgB,yBAAyB,WAAW,2BAA2B,2BAA2B,kBAAkB,yBAAyB,OAAO,UAAU,2BAA2B,kBAAkB,WAAW,0BAA0B,0BAA0B,4BAA4B,mBAAmB,oBAAoB,2BAA2B,SAAS,WAAW,0BAA0B,0BAA0B,mBAAmB,oBAAoB,2BAA2B,SAAS,OAAO,KAAK,kBAAkB,sBAAsB,oCAAoC,4BAA4B,6BAA6B,uCAAuC,uBAAuB,sBAAsB,gCAAgC,0BAA0B,uBAAuB,wBAAwB,wDAAwD,KAAK,uBAAuB,iBAAiB,gBAAgB,gBAAgB,sBAAsB,qDAAqD,cAAc,gBAAgB,4BAA4B,qBAAqB,uBAAuB,uDAAuD,+BAA+B,qBAAqB,yBAAyB,wBAAwB,4BAA4B,iCAAiC,yBAAyB,sCAAsC,yCAAyC,qBAAqB,wBAAwB,yBAAyB,sBAAsB,uBAAuB,sBAAsB,4BAA4B,SAAS,6BAA6B,kEAAkE,iCAAiC,SAAS,4BAA4B,kEAAkE,iCAAiC,SAAS,gCAAgC,oEAAoE,iCAAiC,SAAS,8BAA8B,kEAAkE,iCAAiC,SAAS,6BAA6B,kEAAkE,iCAAiC,SAAS,uCAAuC,uBAAuB,6BAA6B,SAAS,eAAe,0BAA0B,6BAA6B,sBAAsB,uBAAuB,aAAa,+CAA+C,WAAW,mBAAmB,eAAe,4CAA4C,aAAa,WAAW,SAAS,OAAO,+BAA+B,wDAAwD,+BAA+B,6BAA6B,0BAA0B,iCAAiC,yBAAyB,OAAO,KAAK,GAAG,qBAAqB,sBAAsB,YAAY,aAAa,eAAe,gBAAgB,2BAA2B,kBAAkB,GAAG,gBAAgB,oBAAoB,gBAAgB,cAAc,gBAAgB,iBAAiB,mBAAmB,oBAAoB,oBAAoB,GAAG,sBAAsB,qBAAqB,GAAG,cAAc,oBAAoB,gBAAgB,cAAc,gBAAgB,iBAAiB,mBAAmB,oBAAoB,oBAAoB,GAAG,oBAAoB,qBAAqB,GAAG,oBAAoB,uBAAuB,iBAAiB,mBAAmB,cAAc,eAAe,gCAAgC,iBAAiB,4BAA4B,uBAAuB,GAAG,iBAAiB,sBAAsB,YAAY,aAAa,eAAe,gBAAgB,2BAA2B,kBAAkB,GAAG,gBAAgB,oBAAoB,gBAAgB,cAAc,gBAAgB,iBAAiB,mBAAmB,oBAAoB,oBAAoB,GAAG,sBAAsB,qBAAqB,GAAG,sBAAsB,oBAAoB,iBAAiB,cAAc,gBAAgB,iBAAiB,mBAAmB,oBAAoB,oBAAoB,GAAG,0BAA0B,qBAAqB,GAAG,8BAA8B,iBAAiB,uBAAuB,sBAAsB,oCAAoC,KAAK,6BAA6B,wCAAwC,4BAA4B,yBAAyB,KAAK,qCAAqC,+DAA+D,KAAK,GAAG,0BAA0B,iBAAiB,sBAAsB,sBAAsB,oCAAoC,eAAe,0CAA0C,8BAA8B,2BAA2B,wBAAwB,uBAAuB,iBAAiB,6BAA6B,SAAS,OAAO,KAAK,qCAAqC,+DAA+D,KAAK,GAAG,aAAa,mBAAmB,gDAAgD,sBAAsB,qCAAqC,8BAA8B,yBAAyB,uCAAuC,oCAAoC,uBAAuB,sBAAsB,uBAAuB,0BAA0B,yBAAyB,uBAAuB,KAAK,sBAAsB,uBAAuB,eAAe,kBAAkB,wBAAwB,wBAAwB,eAAe,cAAc,6BAA6B,kBAAkB,gDAAgD,KAAK,wBAAwB,qBAAqB,4BAA4B,kBAAkB,6BAA6B,eAAe,gBAAgB,uBAAuB,oBAAoB,oBAAoB,sBAAsB,OAAO,sBAAsB,sCAAsC,yBAAyB,8BAA8B,SAAS,oCAAoC,6BAA6B,SAAS,OAAO,eAAe,uBAAuB,kBAAkB,kBAAkB,qCAAqC,gBAAgB,2BAA2B,SAAS,OAAO,wBAAwB,kCAAkC,wBAAwB,sCAAsC,mCAAmC,oCAAoC,iDAAiD,0CAA0C,6BAA6B,uBAAuB,uBAAuB,wBAAwB,eAAe,sBAAsB,aAAa,sCAAsC,WAAW,SAAS,OAAO,OAAO,0BAA0B,uBAAuB,YAAY,aAAa,2BAA2B,gBAAgB,aAAa,oBAAoB,aAAa,4CAA4C,oBAAoB,kBAAkB,KAAK,SAAS,uBAAuB,wBAAwB,uBAAuB,0BAA0B,KAAK,uBAAuB,gBAAgB,uBAAuB,wBAAwB,4BAA4B,8BAA8B,qBAAqB,sBAAsB,uBAAuB,gCAAgC,sBAAsB,KAAK,oBAAoB,gBAAgB,uBAAuB,6CAA6C,gBAAgB,oCAAoC,uCAAuC,sBAAsB,KAAK,GAAG,0BAA0B,0BAA0B,cAAc,kBAAkB,yBAAyB,eAAe,gBAAgB,4BAA4B,4BAA4B,6BAA6B,sBAAsB,YAAY,mBAAmB,8BAA8B,8BAA8B,wBAAwB,qBAAqB,uBAAuB,0CAA0C,4BAA4B,cAAc,yBAAyB,SAAS,OAAO,aAAa,mBAAmB,8BAA8B,8BAA8B,wBAAwB,qBAAqB,uBAAuB,2CAA2C,4BAA4B,OAAO,KAAK,cAAc,gBAAgB,2BAA2B,uEAAuE,sBAAsB,mBAAmB,wBAAwB,iBAAiB,wBAAwB,KAAK,eAAe,iBAAiB,4BAA4B,eAAe,eAAe,yBAAyB,8BAA8B,oBAAoB,qBAAqB,wBAAwB,iBAAiB,WAAW,uBAAuB,OAAO,eAAe,iDAAiD,mBAAmB,uBAAuB,sCAAsC,2BAA2B,oBAAoB,sBAAsB,8BAA8B,+BAA+B,kCAAkC,0BAA0B,6CAA6C,8CAA8C,sCAAsC,OAAO,gBAAgB,oCAAoC,qCAAqC,wCAAwC,OAAO,6BAA6B,yBAAyB,0BAA0B,OAAO,0CAA0C,uCAAuC,2CAA2C,mCAAmC,OAAO,yCAAyC,wCAAwC,4CAA4C,oCAAoC,OAAO,eAAe,2BAA2B,0BAA0B,OAAO,8BAA8B,yBAAyB,0BAA0B,uBAAuB,OAAO,mBAAmB,qBAAqB,sCAAsC,wCAAwC,uCAAuC,OAAO,iCAAiC,4BAA4B,OAAO,kCAAkC,4BAA4B,OAAO,+BAA+B,wBAAwB,OAAO,2CAA2C,0CAA0C,8CAA8C,sCAAsC,OAAO,0CAA0C,2CAA2C,+CAA+C,uCAAuC,OAAO,KAAK,GAAG,sBAAsB,kBAAkB,mBAAmB,4BAA4B,yCAAyC,qtBAAqtB,mFAAmF,6IAA6I,oFAAoF,+EAA+E,gFAAgF,kFAAkF,+BAA+B,yEAAyE,0EAA0E,kEAAkE,gCAAgC,iCAAiC,yBAAyB,yBAAyB,4BAA4B,GAAG,6BAA6B,yBAAyB,eAAe,gBAAgB,iBAAiB,8BAA8B,qCAAqC,wCAAwC,oCAAoC,mCAAmC,gCAAgC,GAAG,oEAAoE,4BAA4B,GAAG,yLAAyL,0BAA0B,GAAG,yBAAyB,kBAAkB,iBAAiB,yBAAyB,0BAA0B,8BAA8B,iCAAiC,yBAAyB,GAAG,0BAA0B,sBAAsB,uBAAuB,gBAAgB,wBAAwB,GAAG,sBAAsB,aAAa,OAAO,aAAa,sBAAsB,uCAAuC,kBAAkB,+BAA+B,OAAO,KAAK,sBAAsB,kBAAkB,oCAAoC,6BAA6B,6BAA6B,qBAAqB,gCAAgC,KAAK,yBAAyB,uBAAuB,YAAY,oBAAoB,2BAA2B,OAAO,oBAAoB,uBAAuB,6BAA6B,OAAO,uBAAuB,iCAAiC,OAAO,KAAK,GAAG,OAAO;AACvz2E;AACA,iEAAe,uBAAuB,EAAC;;;;;;;;;;;;;;;ACjB1B;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;;AAEA;AACA,4CAA4C,qBAAqB;AACjE;;AAEA;AACA,KAAK;AACL,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB,iBAAiB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,qBAAqB;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8BAA8B;;AAE9B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,CAAC;;;AAGD;AACA;AACA;AACA,qDAAqD,cAAc;AACnE;AACA,C;;;;;;;;;;;;;;AC7Fa;;AAEb;AACA;AACA;AACA;AACA,GAAG;;;AAGH;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;;AAEA;AACA,E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjCA,iEAAe,iDAAiD,E;;;;;;;;;;;;;;;;;;;ACAhE,iEAAe,iDAAiD,E;;;;;;;;;;;;;;;;;;;ACAhE,iEAAe,iDAAiD,E;;;;;;;;;;;;;;;;;;;ACAhE,iEAAe,iDAAiD,E;;;;;;;;;;;;;;;;;;;ACAhE,iEAAe,iDAAiD,E;;;;;;;;;;;;;;;;;;;ACAhE,iEAAe,iDAAiD,E;;;;;;;;;;;;;;;;;;;ACAhE,iEAAe,iDAAiD,E;;;;;;;;;;;;;;;;;;;ACAhE,iEAAe,iDAAiD,E;;;;;;;;;;;;;;;;;;;ACAhE,iEAAe,iDAAiD,E;;;;;;;;;;;;;;;;;;;ACAhE,iEAAe,iDAAiD,E;;;;;;;;;;;;;;;;;;;ACAhE,iEAAe,iDAAiD,E;;;;;;;;;;;;;;;;;;;ACAhE,iEAAe,iDAAiD,E;;;;;;;;;;;;;;;;;;;ACAhE,iEAAe,iDAAiD,E;;;;;;;;;;;;;;;;;;;ACAhE,iEAAe,iDAAiD,E;;;;;;;;;;;;;;;;;;;ACAhE,iEAAe,iDAAiD,E;;;;;;;;;;;;;;;;;;;ACAhE,iEAAe,iDAAiD,E;;;;;;;;;;;;;;;;;;;ACAhE,iEAAe,iDAAiD,E;;;;;;;;;;;;;;;;;;;ACAhE,iEAAe,iDAAiD,E;;;;;;;;;;;;;;;;;;;ACAhE,iEAAe,mDAAmD,E;;;;;;;;;;;;;;;;;;;ACAlE,iEAAe,kDAAkD,E;;;;;;;;;;;;;ACAjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,kBAAkB;;AAElB;AACA;AACA,qBAAqB,iCAAiC;AACtD;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC,mBAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,qBAAqB,SAAS;AAC9B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,uBAAuB;AACvB,qFAAqF;AACrF;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yDAAyD,iBAAiB;AAC1E;AACA,aAAa,0BAA0B;AACvC;;AAEA;AACA;AACA;AACA,yCAAyC,iGAAiG;AAC1I;AACA,uBAAuB,2BAA2B;AAClD;;AAEA;AACA,aAAa,wBAAwB,uCAAuC,qCAAqC;AACjH;;AAEA;AACA;AACA;AACA,mBAAmB,mBAAmB,cAAc;AACpD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,aAAa,0BAA0B;AAC9D;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B,sFAAsF;AACtF;AACA;;AAEA;AACA;AACA;AACA,qGAAqG;AACrG,qDAAqD;AACrD;AACA,wBAAwB,EAAE,SAAS;AACnC,KAAK;;AAEL;AACA,0GAA0G;AAC1G;AACA,yBAAyB;AACzB,KAAK;;AAEL;AACA;AACA,iBAAiB,YAAY,oBAAoB;AACjD;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA,4DAA4D;AAC5D;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA,6FAA6F;AAC7F,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL,MAAM;;AAEN;AACA;;AAEA;AACA,2FAA2F;AAC3F;;AAEA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC,EAAE,KAA8B,aAAa,CAAK;;;;;;;;;;;;;;ACtanD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,YAAY,mBAAO,CAAC,2DAAY;AAChC,iBAAiB,yFAA8B;AAC/C;AACA;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,WAAW,EAAE;;AAE1D;AACA;;AAEA;AACA;;AAEA;AACA,8CAA8C;AAC9C,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,oBAAoB,eAAe,EAAE;;AAErC,oBAAoB,kBAAkB,eAAe,UAAU,EAAE;;AAEjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,2BAA2B;AAC3B,2BAA2B;AAC3B,8BAA8B;AAC9B,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA,CAAC,EAAE,KAA8B,aAAa,CAAK;;;;;;;;;;;;;;;ACpVnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,KAA4D;AAC9D,EAAE,CACqG;AACvG,CAAC,4BAA4B;;AAE7B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6BAA6B,UAAU;;AAEvC,6BAA6B,UAAU;;AAEvC;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;;;AAGT;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA,SAAS;AACT;;;AAGA;AACA,oBAAoB;;AAEpB,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA,wCAAwC;;AAExC;AACA;AACA;AACA;AACA,WAAW;;AAEX,0BAA0B;AAC1B;AACA;;AAEA,uBAAuB;;AAEvB,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA,SAAS;;;AAGT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;;AAE7B,6CAA6C;;AAE7C,iDAAiD;AACjD;;AAEA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA,SAAS;;;AAGT;;AAEA,oBAAoB,SAAS;AAC7B;AACA;AACA,SAAS;AACT;;;AAGA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,mFAAmF;AACnF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2BAA2B;AAC5C,kBAAkB;AAClB;;;AAGA;AACA;AACA;AACA,kBAAkB;AAClB;;;AAGA;AACA;AACA;AACA,kBAAkB;AAClB;;;AAGA;AACA;AACA;AACA,kBAAkB;AAClB;;;AAGA;AACA;AACA;AACA,kBAAkB;AAClB;;;AAGA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,kBAAkB;AAClB;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,kBAAkB;AAClB;;;AAGA;AACA;AACA;AACA,kBAAkB;AAClB;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,qDAAqD;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0EAA0E;AAC1E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8CAA8C,SAAS;;AAEvD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,aAAa;AAClD;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,iBAAiB;;AAEtC;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,uBAAuB,UAAU;;AAEjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,wCAAwC,kBAAkB,wCAAwC,mCAAmC,QAAQ;AAC7I;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,WAAW;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX,yIAAyI;AACzI,WAAW;;AAEX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,SAAS;;AAE9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,kEAAkE;AAClE,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D,OAAO;AACP,+DAA+D;AAC/D,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA,yDAAyD;AACzD;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,WAAW;AAClC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;;AAEA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,WAAW;AAClC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,4CAA4C;AAC5C,OAAO,mCAAmC;AAC1C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,uBAAuB;;AAE5C;AACA;;AAEA;AACA,qBAAqB,kBAAkB;;AAEvC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,uBAAuB,cAAc;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,UAAU,qBAAqB,wBAAwB;;AAE9E,uCAAuC,wBAAwB;AAC/D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,aAAa,qBAAqB,SAAS;AAChE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,SAAS;AACnC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,UAAU;AAC/B;;AAEA;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,YAAY;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,gBAAgB;;AAErC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,UAAU;;AAE/B;AACA;;AAEA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,yBAAyB;;AAEhD;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,qBAAqB,yCAAyC;AAC9D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,yBAAyB;AAChD,OAAO;AACP;AACA;;AAEA,uBAAuB,yBAAyB;AAChD;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,yBAAyB;;AAE9C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB;AAChB;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;;AAEA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;;AAE7C;AACA;;AAEA;AACA;;AAEA;;AAEA,qBAAqB,wBAAwB;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;;AAE/C;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;;AAE/C;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;;AAEvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;;AAE7C;AACA;;AAEA;AACA;;AAEA,qBAAqB,wBAAwB;;AAE7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAuB,wBAAwB;AAC/C,OAAO;AACP;;AAEA;;AAEA,6CAA6C,wBAAwB;AACrE;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;;AAE7C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,8CAA8C,SAAS;AACvD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,6BAA6B;;AAElD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;;AAEA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB,6BAA6B;;AAElD;AACA;;AAEA;AACA;;AAEA,qBAAqB,uBAAuB;;AAE5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,6BAA6B;;AAEpD;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,qBAAqB,6BAA6B;;AAElD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,6BAA6B;;AAElD;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,mBAAmB;;AAExC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,6BAA6B;;AAElD;AACA;;AAEA;AACA;;AAEA,qBAAqB,6BAA6B;;AAElD;AACA;;AAEA;AACA;;AAEA,qBAAqB,6BAA6B;;AAElD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,6BAA6B;AACpD,OAAO;AACP;AACA;;AAEA,uBAAuB,6BAA6B;AACpD;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA,uBAAuB,6BAA6B;AACpD,OAAO;AACP;AACA;;AAEA,uBAAuB,6BAA6B;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,6BAA6B;;AAElD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,mBAAmB;;AAExC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uDAAuD,uDAAuD,wDAAwD;AACtK;AACA;;AAEA;AACA,uDAAuD,uDAAuD,wDAAwD;AACtK;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,uDAAuD,oEAAoE,uEAAuE;AAClM;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;;AAE1C;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;;AAE1C;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,wBAAwB;;AAE7C;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,qBAAqB,kBAAkB;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,kBAAkB;;AAEvC;AACA;AACA;;AAEA,qBAAqB,kBAAkB;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;;AAE/C;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,YAAY;AACnC;AACA;;AAEA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB,wBAAwB;;AAE7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,wBAAwB;;AAE7C;AACA;;AAEA;AACA,qBAAqB,gCAAgC;AACrD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,wBAAwB;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,UAAU;;AAEnC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,yBAAyB,UAAU;AACnC,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,8BAA8B;AACvD;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,yBAAyB,UAAU;AACnC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,UAAU;AACnC;AACA;AACA;;AAEA;AACA,8DAA8D;AAC9D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,8DAA8D;AAC9D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,8BAA8B;;AAEnD;AACA;;AAEA;AACA;;AAEA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,8BAA8B;AACrD;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,qBAAqB;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;;AAEA,uBAAuB,8BAA8B;AACrD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,kBAAkB;AAClB;;;AAGA;AACA;AACA;AACA,kBAAkB;AAClB;;;AAGA;AACA;AACA;AACA,kBAAkB;AAClB;;;AAGA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,IAAI;AACtB;;;AAGA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gFAAgF,6FAA6F;AAC7K;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yEAAyE,8EAA8E;AACvJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,wBAAwB;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,6BAA6B;;AAElD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+GAA+G;AAC/G;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+GAA+G,qHAAqH;AACpO;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0GAA0G;AAC1G;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+GAA+G;AAC/G;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,oEAAoE;AACpE;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,QAAQ;AACxB;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,gBAAgB,cAAc;AAC9B,gBAAgB,OAAO;AACvB;;AAEA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,QAAQ;AACxB;AACA;;;AAGA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA,gBAAgB,QAAQ;AACxB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,QAAQ;AACxB;AACA;;;AAGA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;;;AAGA;AACA;AACA;AACA,iBAAiB,cAAc;;AAE/B;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;;;AAGA;AACA;AACA;;AAEA,8BAA8B;;AAE9B;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,QAAQ;AACxB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,QAAQ;AACxB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAsC;AACtD;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAA4C;AAC5D;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,oDAAoD;AAC3G;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,8CAA8C;AAC9D;AACA;;;AAGA;AACA;AACA;;AAEA,kDAAkD;;AAElD;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;;;AAGA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;;;AAGA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;;;AAGA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;;;AAGA;AACA;AACA;AACA,+FAA+F;AAC/F;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD;AACA;;;AAGA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;;;AAGA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA,mBAAmB,OAAO;AAC1B,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;;;AAGA;AACA;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA,qFAAqF;AACrF;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB,cAAc,OAAO;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,cAAc,OAAO;AACrB;;;AAGA;AACA;;AAEA,iDAAiD,QAAQ;;AAEzD;AACA;AACA;AACA,aAAa,mBAAmB;AAChC,cAAc,OAAO;AACrB;;;AAGA;AACA;;AAEA,iDAAiD,QAAQ;;AAEzD;AACA;AACA;AACA,aAAa,mDAAmD;AAChE,cAAc,OAAO;AACrB;;;AAGA;AACA;AACA;;AAEA,4CAA4C,QAAQ;;AAEpD;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,cAAc,OAAO;AACrB;;;AAGA;AACA;;AAEA,iDAAiD,QAAQ;;AAEzD;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,OAAO;AACrB;;;AAGA;AACA;AACA;;AAEA,mDAAmD,QAAQ;;AAE3D;AACA;AACA;AACA,aAAa,aAAa;AAC1B,cAAc,OAAO;AACrB;;;AAGA;AACA;;AAEA,iDAAiD,QAAQ;;AAEzD;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,OAAO;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uCAAuC;AACpD,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,SAAS;AACzB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,gBAAgB,OAAO;AACvB;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,iBAAiB;AAC1E;AACA;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,gBAAgB,OAAO;AACvB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,QAAQ,iBAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,+BAA+B;AAC/B,OAAO;AACP;AACA;AACA,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,uBAAuB,kBAAkB;;AAEzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,kBAAkB;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oEAAoE,iEAAiE,wDAAwD,wDAAwD,wDAAwD;AAC7S,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,oCAAoC;AAC3D;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,QAAQ,uBAAuB,QAAQ;;AAE7D;AACA;;AAEA;AACA,sBAAsB,QAAQ,uBAAuB,QAAQ;AAC7D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,QAAQ,uBAAuB,QAAQ;;AAE7D;AACA;;AAEA;AACA,qBAAqB,OAAO,qBAAqB,OAAO;AACxD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,mEAAmE;AACnE,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;;AAEA,2BAA2B,OAAO;;AAElC;AACA;AACA;;AAEA,2BAA2B,OAAO;AAClC;;AAEA,6BAA6B,QAAQ;;AAErC;AACA;AACA;;AAEA;;AAEA,yBAAyB,QAAQ;AACjC;;AAEA,2BAA2B,OAAO;;AAElC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,aAAa;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,0CAA0C;AAC/D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,qCAAqC;AAC1D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sGAAsG;AACtG,sGAAsG;AACtG,wHAAwH;AACxH;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,6BAA6B;AACpD;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA,sCAAsC,aAAa;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,+BAA+B;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,wDAAwD;AACxD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,wCAAwC,aAAa;AACrD;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0DAA0D;AAC1D;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,wCAAwC,aAAa;AACrD;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B;AAC/B;;AAEA,wCAAwC,YAAY;AACpD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,kDAAkD;AAClD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,oDAAoD;AACpD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,8CAA8C;AACnE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,iBAAiB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;;AAEA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;;AAEA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;;AAEA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,uBAAuB,+BAA+B;AACtD,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;;AAEA,yBAAyB,2BAA2B;AACpD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;;AAEA;AACA;;AAEA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qIAAqI;AACrI;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,+BAA+B;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,oBAAoB;;AAEzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,oBAAoB;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,+BAA+B;AACtD,OAAO;AACP;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA,yBAAyB,2BAA2B;AACpD;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ,kDAAkD;AAC1E;AACA;;;AAGA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB,iCAAiC;AACjC;AACA;;;AAGA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;AAGA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,mBAAmB;;AAExC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,oBAAoB;;AAEzC,qBAAqB,qBAAqB;;AAE1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,gBAAgB,0CAA0C;;AAE/E;AACA;;AAEA;AACA;;AAEA,qBAAqB,gBAAgB;;AAErC,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,cAAc;AACnC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,wCAAwC;;AAE7D;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,qCAAqC;;AAE1D;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA,yBAAyB,2BAA2B;AACpD;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA,yBAAyB,2BAA2B;AACpD;AACA,OAAO;AACP;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA,yBAAyB,2BAA2B;AACpD;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA,OAAO;AACP;;AAEA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,+BAA+B;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB,gBAAgB;;AAErC;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,6GAA6G;;AAE7G;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,gCAAgC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,SAAS,wCAAwC;AACjD,OAAO;AACP;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,SAAS,2CAA2C;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC;;AAExC;;AAEA,sDAAsD;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,SAAS;AACT,OAAO;AACP;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,uBAAuB,gBAAgB;AACvC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,SAAS;AAClC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC,aAAa;AACnD;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,sCAAsC,aAAa;AACnD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0CAA0C,0BAA0B;AACpE;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,0BAA0B;AAC/C;;AAEA;AACA,qBAAqB,0BAA0B;;AAE/C;AACA;;AAEA;AACA,qBAAqB,0BAA0B;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,0BAA0B;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,0BAA0B;;AAE/C;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,0BAA0B;;AAE/C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,OAAO;;AAE5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,OAAO,sGAAsG;AAClI;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gCAAgC,8BAA8B;AAC9D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gDAAgD;AAC7F;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,kDAAkD;AAC/F;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gCAAgC,8BAA8B;AAC9D;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,uBAAuB;;AAE/D;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,gCAAgC,qBAAqB,+BAA+B;AACzG;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,OAAO,qBAAqB,OAAO;AACxD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,OAAO,qBAAqB,OAAO;;AAE1D;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,OAAO,qBAAqB,OAAO;AAC1D;AACA,4IAA4I;AAC5I;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,QAAQ;;AAE/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,qBAAqB;;AAE1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,6BAA6B;AAClD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D,cAAc;AACxE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gFAAgF;AAChF,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,uBAAuB,OAAO;AAC9B;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC,aAAa;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6FAA6F;AAC7F;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,OAAO;;AAE5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD;AACjD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,kBAAkB;AAC3D;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C,kBAAkB;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,kBAAkB;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,wBAAwB;AAC7C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iDAAiD,aAAa;AAC9D;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0CAA0C,cAAc;AACxD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,wBAAwB;AAC7C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qHAAqH;AACrH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mEAAmE;AACnE;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,aAAa;AACvD;AACA;;AAEA,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qDAAqD,wDAAwD,8CAA8C,wDAAwD,6DAA6D,0DAA0D,gEAAgE;AAC1Y,OAAO;AACP;AACA;AACA;;AAEA;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,yCAAyC,cAAc;AACvD;AACA;;AAEA,yBAAyB,WAAW;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D;AAC9D;AACA,4DAA4D;AAC5D;AACA;;AAEA;AACA;AACA,6CAA6C;AAC7C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,OAAO;;AAE5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,OAAO;;AAE5B;AACA;;AAEA;AACA;;AAEA,qBAAqB,OAAO;;AAE5B;AACA;;AAEA;AACA;;AAEA,qBAAqB,OAAO;;AAE5B;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;;AAEA;AACA,0CAA0C,aAAa;AACvD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kDAAkD,oBAAoB,OAAO;AAC7E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,cAAc,OAAO;AACrB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,YAAY,wBAAwB;AACpC;AACA;AACA,qGAAqG;AACrG;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,YAAY,wDAAwD;;AAEpE;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,aAAa;AACpD;AACA;AACA,mFAAmF;AACnF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,4BAA4B;AACnD;AACA;AACA,gHAAgH,8FAA8F;AAC9M;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,uBAAuB,4BAA4B;AACnD;AACA;AACA,gHAAgH,wFAAwF;AACxM;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,0DAA0D,aAAa;AACvE;AACA,wFAAwF;AACxF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,wDAAwD,aAAa;AACrE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,0DAA0D,aAAa;AACvE;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yDAAyD,aAAa;AACtE;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,0DAA0D,aAAa;AACvE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,0DAA0D,aAAa;AACvE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,aAAa;AACjE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,2BAA2B;;AAEhD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+DAA+D;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,gEAAgE;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wDAAwD,aAAa;AACrE;AACA,+EAA+E;AAC/E;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;;AAGA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA,6FAA6F,sFAAsF;;AAEnL;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,gBAAgB,OAAO;AACvB;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,yBAAyB;AAChD;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf,kCAAkC,OAAO;AACzC;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;;AAEA,qBAAqB,kBAAkB;;AAEvC;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;;AAEA,qBAAqB,kBAAkB;;AAEvC;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA,qBAAqB,mCAAmC;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA,qBAAqB,wCAAwC;AAC7D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA,qBAAqB,qCAAqC;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;;AAEA,qBAAqB,mCAAmC;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,eAAe;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,eAAe,cAAc;AAC7B,gBAAgB,gBAAgB;AAChC;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C,eAAe;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,gBAAgB,OAAO;AACvB;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,yDAAyD,eAAe;AACxE;AACA;AACA,kBAAkB,aAAa,MAAM,aAAa;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,eAAe;AACf;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,gBAAgB;AAChB;AACA;;;AAGA;AACA;AACA,oFAAoF,6FAA6F,6FAA6F,uFAAuF,6FAA6F,uGAAuG,iGAAiG;AAC1oB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA,wCAAwC;AACxC;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;;;AAGA;AACA,uGAAuG,gGAAgG,gGAAgG,0FAA0F,gGAAgG,0GAA0G,oGAAoG;AAC/qB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB,2BAA2B;;AAEhD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,wCAAwC;;AAE7D;AACA;;AAEA;AACA;;AAEA,qBAAqB,qCAAqC;;AAE1D;AACA;;AAEA;AACA;;AAEA,qBAAqB,2CAA2C;AAChE;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sDAAsD,cAAc;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,uBAAuB;;AAE/D;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,2BAA2B;AAChD;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,WAAW,+BAA+B;AAC1C,SAAS;AACT,mCAAmC;AACnC,SAAS,+BAA+B;AACxC,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,qBAAqB,6BAA6B;AAClD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,gBAAgB;;AAE/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,wCAAwC,aAAa;AACrD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,aAAa;;AAE3D;AACA;;AAEA;AACA;;AAEA,+CAA+C,aAAa;AAC5D;;AAEA;;AAEA,8CAA8C,aAAa;AAC3D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA,OAAO;AACP;;AAEA,uBAAuB,gBAAgB;AACvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA,uBAAuB,gBAAgB;;AAEvC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kEAAkE;AAClE;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA;;AAEA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oCAAoC,aAAa;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,aAAa;AAC9D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,aAAa;AACxD;AACA;;AAEA,+DAA+D,gBAAgB;AAC/E;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mIAAmI;AACnI;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;;AAEA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD,cAAc;AAC/D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,2CAA2C,aAAa;AACxD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,iDAAiD,cAAc;AAC/D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mDAAmD,cAAc;AACjE;AACA;;AAEA,yBAAyB,oBAAoB;AAC7C;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,8CAA8C,aAAa;AAC3D;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,sBAAsB;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC,oBAAoB;AACpD,OAAO;AACP;AACA;;AAEA,gCAAgC,QAAQ;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,aAAa;AACvD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,wBAAwB;;AAE7C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,cAAc;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yCAAyC,cAAc;AACvD;AACA,8CAA8C;AAC9C;AACA;;AAEA;AACA;;AAEA,yCAAyC,cAAc;AACvD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4CAA4C,cAAc;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4CAA4C,cAAc;AAC1D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4CAA4C,cAAc;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C,cAAc;AAC1D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qDAAqD;AACrD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,QAAQ;;AAE9B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qDAAqD;;AAErD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,4BAA4B;;AAEjD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,oCAAoC,eAAe,wBAAwB,gCAAgC,QAAQ;AACnH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,8DAA8D,sEAAsE;AACpI;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,WAAW;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,iBAAiB;;AAEtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,QAAQ;AACpC,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,SAAS;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,QAAQ;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,SAAS;;AAE9B;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,QAAQ;;AAElC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,QAAQ;AACpC,OAAO;AACP;AACA;AACA;AACA;;AAEA,uBAAuB,SAAS;AAChC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gDAAgD,aAAa;AAC7D;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD,wDAAwD,8CAA8C,wDAAwD,6DAA6D,0DAA0D,gEAAgE;AACxY;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;;AAEA,2BAA2B,WAAW;AACtC;;AAEA,oCAAoC,cAAc;AAClD;AACA;;AAEA,2BAA2B,WAAW;AACtC;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,qCAAqC;AAC1D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,0CAA0C;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,gCAAgC,cAAc;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uDAAuD,QAAQ;AAC/D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC,cAAc;AACpD;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA,sCAAsC,cAAc;AACpD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;;AAEA;AACA;AACA;;AAEA,uBAAuB,gBAAgB;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC,aAAa;AACpD;;AAEA;AACA,qBAAqB,wBAAwB;;AAE7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,aAAa;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8CAA8C,aAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,aAAa;AAC9D;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;;AAEA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,aAAa;AAC9D;;AAEA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,wBAAwB,sBAAsB,uBAAuB,sBAAsB;AAC3F,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,aAAa;AAC9D;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;;AAEA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,8BAA8B,0CAA0C;;AAExE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,0DAA0D;AAC1D,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,cAAc;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4DAA4D,iBAAiB;AAC7E;AACA;AACA,WAAW;AACX,0EAA0E;AAC1E,WAAW;;AAEX;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,qFAAqF;AACrF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,qEAAqE;AACrE,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,yBAAyB,iBAAiB;AAC1C;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,kBAAkB;AACvC;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,uBAAuB;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,uBAAuB;AAChD;AACA;;AAEA,2BAA2B,uBAAuB;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,oBAAoB;AACzC;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAmB;AACxC;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,aAAa;AACjE;AACA,sEAAsE;AACtE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,aAAa;;AAEpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,2BAA2B;AAClD;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA,uBAAuB,2BAA2B;AAClD;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,aAAa;AACpD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA,yCAAyC,aAAa;AACtD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qDAAqD,aAAa;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qDAAqD,aAAa;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD,aAAa;AAC9D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,aAAa;AAC7D;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,iCAAiC;AACxD;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8CAA8C,aAAa;AAC3D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iDAAiD,aAAa;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iDAAiD,aAAa;AAC9D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC,aAAa;AACrD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,SAAS;;AAE9B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,wCAAwC,aAAa;AACrD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wCAAwC,aAAa;AACrD;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC,aAAa;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC,cAAc;AACvD;;AAEA,qCAAqC,cAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,0BAA0B;AAC/C;AACA;AACA,8HAA8H;;AAE9H;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;;AAErC;AACA;;AAEA;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,aAAa;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAiE,cAAc;AAC/E;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kEAAkE,kBAAkB;AACpF;AACA;AACA;;AAEA,iEAAiE,cAAc;AAC/E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,cAAc;AACvD;AACA;AACA,8EAA8E;AAC9E;AACA;;AAEA;AACA,mDAAmD,cAAc;AACjE;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kEAAkE,kBAAkB;AACpF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,sBAAsB,QAAQ;AAC9B;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,gEAAgE;AAChE,OAAO;;AAEP;AACA;AACA,OAAO;AACP,iEAAiE;AACjE,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,gIAAgI;AAChI;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yDAAyD,cAAc;AACvE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D,kBAAkB;AAC5E;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,cAAc;AACtD;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,8CAA8C,cAAc;AAC5D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0DAA0D,kBAAkB;AAC5E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,yDAAyD,aAAa;AACtE;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,OAAO;AAChC;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D,kBAAkB;AAC5E;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sDAAsD,cAAc;AACpE;AACA;AACA,gFAAgF;AAChF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,kBAAkB;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mDAAmD,cAAc;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA,wCAAwC,cAAc;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,aAAa;AACxC;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC,cAAc;AAClD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;;AAEA,uFAAuF;;AAEvF,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,aAAa;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oDAAoD,kBAAkB;AACtE;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD,kBAAkB;AACtE;AACA;;AAEA,+DAA+D,gBAAgB;AAC/E;;AAEA;;AAEA,uEAAuE;AACvE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D,kBAAkB;AAC5E;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0DAA0D,kBAAkB;AAC5E;;AAEA,gDAAgD,aAAa;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;;AAEA;;AAEA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qCAAqC,aAAa;AAClD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,mDAAmD,qDAAqD,qDAAqD,qDAAqD,kDAAkD,uDAAuD,6DAA6D;AACxX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,+BAA+B;AACpD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,2BAA2B;AAChD;AACA;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA,oCAAoC,mBAAmB,sCAAsC,oCAAoC,QAAQ;AACzI;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,yBAAyB;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,uEAAuE;AACvE,OAAO;;AAEP;AACA;;AAEA;AACA;;AAEA,qBAAqB,yBAAyB;AAC9C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC,aAAa;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gDAAgD,aAAa;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC,aAAa;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6CAA6C,aAAa;AAC1D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wCAAwC,aAAa;AACrD;AACA;AACA;AACA;;AAEA,6CAA6C,iBAAiB;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4CAA4C,aAAa;;AAEzD;AACA;AACA;AACA;;AAEA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wCAAwC,aAAa;AACrD;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wCAAwC,aAAa;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,aAAa;AACxD;AACA,oDAAoD;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,mHAAmH;AACnH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,aAAa;AACtD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA,gDAAgD;AAChD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,aAAa;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,2DAA2D,cAAc;AACzE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;;AAEA;AACA,yDAAyD,aAAa;AACtE;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,yDAAyD,aAAa;AACtE;AACA;;AAEA,+DAA+D,gBAAgB;AAC/E;;AAEA;;AAEA,0GAA0G;AAC1G;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,yDAAyD,aAAa;AACtE;AACA;;AAEA,+DAA+D,gBAAgB;AAC/E;;AAEA;;AAEA,uEAAuE;AACvE;AACA;AACA;;AAEA;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;;AAEA;AACA,mDAAmD,cAAc;AACjE;AACA;AACA;;AAEA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+FAA+F;AAC/F;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,iBAAiB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,2BAA2B,qBAAqB,2BAA2B;;AAElG;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,wCAAwC;AAC7D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,2FAA2F;AAC3F,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,aAAa;AACpD;AACA;AACA,4DAA4D;AAC5D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,aAAa;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,aAAa;AACjD;AACA,6CAA6C;AAC7C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD,+CAA+C;AAC/F;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,OAAO;AAChC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,OAAO;AAClC,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,sBAAsB;;AAE3C;AACA;;AAEA,qBAAqB,sBAAsB;;AAE3C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,iBAAiB;AACtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,wCAAwC,aAAa;AACrD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,OAAO;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,SAAS;AAClC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,wCAAwC,aAAa;AACrD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,aAAa;;AAEvD,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+CAA+C;;AAE/C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4EAA4E;AAC5E,OAAO;AACP;AACA;AACA,0EAA0E;AAC1E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+FAA+F;AAC/F;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;;AAEA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,aAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,2CAA2C,cAAc;AACzD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8CAA8C,aAAa;AAC3D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,4DAA4D,mCAAmC,8CAA8C,8CAA8C;AAC3L;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,aAAa;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0CAA0C,cAAc;AACxD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wEAAwE;AACxE;;AAEA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,aAAa;AACpD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oDAAoD,aAAa;AACjE;AACA;AACA;;AAEA,iDAAiD,cAAc;AAC/D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wFAAwF;AACxF;AACA,OAAO;AACP;AACA;AACA;AACA,uFAAuF;AACvF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC,aAAa;AAClD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC,aAAa;AAClD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,aAAa;AACnD;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;;AAEA;AACA;;AAEA,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,mBAAmB;AACxC;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,6BAA6B;AAClD;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB;;AAErB;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0DAA0D,cAAc;AACxE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,uBAAuB;;AAE5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA,mCAAmC,aAAa;;AAEhD;AACA;;AAEA;AACA;;AAEA,yCAAyC,aAAa;AACtD;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mCAAmC,aAAa;AAChD;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC;AACrC;;AAEA;AACA;;AAEA,kEAAkE;AAClE;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,qBAAqB,OAAO;;AAE5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,WAAW;AAClC;AACA,SAAS;AACT,sEAAsE;AACtE,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,gBAAgB;;AAErC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wDAAwD,wDAAwD;AAChH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,cAAc;;AAE9D,CAAC;AACD;;;;;;;;;;;;;;;ACjr/Ba;;;AAGb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,QAAQ;;AAE1B;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA,sBAAsB,4CAA4C;AAClE,wBAAwB,0CAA0C;AAClE,wBAAwB,0CAA0C;AAClE,wBAAwB,0CAA0C;AAClE,0BAA0B,4CAA4C;;;AAGtE,wBAAwB,qCAAqC,eAAe;;AAE5E;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA,8BAA8B;AAC9B;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,UAAU;AAC1D,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,qDAAU;;AAEvC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,2CAA2C;;AAElE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,yBAAyB;;AAEzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,QAAQ;;AAE/B,oBAAoB;;AAEpB;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA,+BAA+B;AAC/B;AACA;;AAEA,qCAAqC;AACrC;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,cAAc;;AAEnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,mCAAmC;;AAEzD;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;;;;AC3nBa;;;AAGb;AACA;;AAEA;AACA,eAAe,kHAA+C;AAC9D,eAAe,gHAA8C;AAC7D,eAAe,8GAA6C;AAC5D,eAAe,8GAA6C;;AAE5D,QAAQ,WAAW;AACnB;;AAEA,QAAQ,MAAM;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;;AAEA;;AAEA;;AAEA,mDAAmD,EAAE;;AAErD;AACA;;AAEA;;AAEA,yBAAyB,EAAE,cAAc,EAAE,kCAAkC,IAAI;;AAEjF;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA,cAAc,2BAA2B,QAAQ;AACjD;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU,6BAA6B;;AAEvC;;AAEA,qBAAqB,KAAK;;AAE1B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,KAAK;AACpC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,yEAAyE,KAAK;AAC9E;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;AACA;;AAEA,6BAA6B,IAAI;;AAEjC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACnLa;;;AAGb,6FAAkC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHlC,wBAAwB;AACxB;AACa;;AAEb;AACA,6HAA2D;;;;;;;;;;;;;;;ACL3D;AACA;;AAEa;;;AAGb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtEA;;AAEa;;AAEb;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B;AAC1B,qCAAqC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3BrC;AACA;AACa;;;AAGb,sBAAsB,4CAA4C;;AAElE,wBAAwB,0CAA0C;;AAElE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,QAAQ;;AAE1B;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA,mCAAmC,cAAc;AACjD,2DAA2D,cAAc;AACzE;AACA,+BAA+B,cAAc;AAC7C,mBAAmB,cAAc;AACjC,+BAA+B,cAAc;AAC7C,+BAA+B,cAAc;AAC7C;AACA,qBAAqB,cAAc;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA,8CAA8C,cAAc,EAAE;AAC9D,wCAAwC,KAAK,EAAE;AAC/C;;AAEA,8CAA8C,IAAI,OAAO,IAAI;;AAE7D,eAAe,mBAAO,CAAC,qEAAY;;AAEnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,YAAY;;AAEzC;AACA,CAAC;;AAED;AACA,8BAA8B,YAAY;AAC1C;AACA;;AAEA;AACA,sDAAsD,YAAY;;AAElE;AACA,kBAAkB,gBAAgB;AAClC;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ,YAAY;AACZ,cAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wCAAwC;;AAExC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,aAAa;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uBAAuB,mBAAO,CAAC,kFAA6B;;AAE5D;AACA;AACA;AACA;;;AAGA;AACA;AACA,oDAAoD,oCAAoC,MAAM;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2BAA2B,GAAG,EAAE,MAAM,KAAK;AACrD,UAAU,yBAAyB,GAAG,EAAE,MAAM,IAAI,MAAM;AACxD,UAAU,mBAAmB,GAAG,EAAE,EAAE,iBAAiB,EAAE,iCAAiC,MAAM;AAC9F,UAAU,2BAA2B,GAAG,EAAE,EAAE,iBAAiB,KAAK;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,qFAA8C;AAC9C,6FAAiD;;AAEjD,cAAc;AACd,gBAAgB;AAChB,WAAW;AACX,kBAAkB;AAClB,mBAAmB;AACnB,yBAAyB;AACzB,qBAAqB;AACrB;AACA,kBAAkB;AAClB,sBAAsB;AACtB,eAAe;AACf,oBAAoB;AACpB,sBAAsB;AACtB,mBAAmB;AACnB,gBAAgB;AAChB,0BAA0B;;;;;;;;;;;;;;;;;;;;;AC5T1B;AACa;;;AAGb,oIAA4D;AAC5D,sJAAkE;AAClE,oIAA4D;;;;;;;;;;;;;;;ACN5D;AACA;AACa;;;AAGb,kBAAkB,wGAAsC;;;AAGxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,OAAO;;AAEhC;AACA;AACA;;AAEA,wBAAwB,OAAO;;AAE/B;AACA,uCAAuC,OAAO;;AAE9C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,OAAO;AAC/B;AACA;;AAEA;AACA;;AAEA,sBAAsB,eAAe;AACrC,oBAAoB,eAAe;;AAEnC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;AC/CA;AACA;AACa;;;AAGb,kBAAkB,wGAAsC;;;AAGxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,eAAe;;AAElC;;AAEA,sFAAsF,eAAe;;AAErG;;AAEA;AACA,wBAAwB,eAAe;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACpDA;;AAEa;;;AAGb,mBAAmB,mBAAO,CAAC,sEAAgB;AAC3C,mBAAmB,mBAAO,CAAC,kEAAW;AACtC,mBAAmB,mBAAO,CAAC,8DAAY;AACvC,mBAAmB,mBAAO,CAAC,oEAAe;AAC1C,mBAAmB,mBAAO,CAAC,sEAAgB;AAC3C,mBAAmB,mBAAO,CAAC,wEAAiB;AAC5C,mBAAmB,mBAAO,CAAC,sDAAY;AACvC,mBAAmB,mBAAO,CAAC,4CAAO;AAClC,mBAAmB,mBAAO,CAAC,yDAAU;;;AAGrC;AACA,WAAW,mBAAO,CAAC,4EAAmB;AACtC,QAAQ,mBAAO,CAAC,sEAAgB;AAChC,cAAc,mBAAO,CAAC,kFAAsB;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qDAAqD;;AAErD;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,aAAa;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,aAAa;AACpB;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,iBAAiB;AACjB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;;;AAGhC;AACA;;AAEA,gBAAgB,mBAAmB;AACnC;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2BAA2B;AAChD,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,gFAAgF;AACnG;;AAEA,iBAAiB,gEAAgE;;AAEjF,wBAAwB,2BAA2B;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,iBAAiB;;AAE9C;AACA;AACA,GAAG;;AAEH;;AAEA,4CAA4C,iCAAiC,EAAE;;AAE/E;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,iBAAiB;;AAE9C;AACA;AACA,GAAG;;AAEH;;AAEA,4CAA4C,iCAAiC,EAAE;;AAE/E;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA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ACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,aAAa;AACzB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS;AAC1B;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA,6BAA6B,OAAO;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA;AACA;;;AAGA,+BAA+B,mBAAO,CAAC,gGAA6B;;;AAGpE;;;;;;;;;;;;;;;AChLA;;AAEa;;;AAGb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;;AAEA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/EA;;AAEa;;;AAGb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;;AAEA;AACA,GAAG;;AAEH;;AAEA,YAAY;AACZ,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;;;ACxCA;AACA;;AAEa;;;AAGb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;;AAEA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;;;AAGb,sBAAsB,kGAAgC;AACtD,sBAAsB,uGAAqC;AAC3D,sBAAsB,sGAAoC;;;AAG1D;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,cAAc;AACjE,mDAAmD,eAAe;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,WAAW;;AAEhC;;AAEA,qCAAqC,OAAO;AAC5C;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,SAAS;AAC/C;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,SAAS;AAC/C;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,SAAS;AAC3C;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;;ACjVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;;;AAGb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,iBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,QAAQ;;AAEhC;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,0BAA0B,QAAQ;;AAElC,iDAAiD,QAAQ;;AAEzD;AACA,KAAK;AACL,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,mDAAmD;;AAExE;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,yDAAyD;;AAE9E;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,wDAAwD;;AAE7E;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;;AAE9C;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;;AAE9C,0CAA0C,sBAAsB,EAAE;;AAElE;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;;AAE9C;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;AC/VA;;AAEa;;AAEb,cAAc,oGAAkC;;;AAGhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,cAAc;;AAErE;AACA,oDAAoD,cAAc;;AAElE;AACA;AACA,eAAe,aAAa;;AAE5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,OAAO;;AAE/B;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;AC3RA;;AAEa;;;AAGb;AACA;;AAEA,sDAAsD,cAAc;;AAEpE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACjCA;;AAEa;;;AAGb;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,cAAc;;AAErE,sBAAsB,cAAc;;AAEpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,gBAAgB,cAAc;;AAE9B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,aAAa;;AAE5B;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,UAAU;;AAEzD;AACA;AACA;AACA;;AAEA;;AAEA;AACA,0BAA0B,UAAU;;AAEpC;AACA;;AAEA,oBAAoB,UAAU;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACjGA;;AAEa;;AAEb,cAAc,oGAAkC;;;AAGhD;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,cAAc;;AAErE;;AAEA,yCAAyC,cAAc;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,cAAc;;AAE/D,eAAe,aAAa;;AAE5B;;AAEA;AACA,4CAA4C;AAC5C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACtDA;;AAEa;;AAEb,cAAc,oGAAkC;;;AAGhD;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,cAAc;;AAErE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,wCAAwC,cAAc;AACtD,wBAAwB,OAAO;AAC/B;;AAEA,gBAAgB,cAAc;;AAE9B,eAAe,aAAa;;AAE5B;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;AC5CA;;AAEa;;;AAGb,kBAAkB,mBAAO,CAAC,mFAAuB;AACjD,6BAA6B,uHAAmD;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,cAAc;;AAErE,+BAA+B,cAAc;;AAE7C,kDAAkD,cAAc;;AAEhE;;AAEA,aAAa,2BAA2B;AACxC,8CAA8C,OAAO;AACrD;;AAEA,oCAAoC,cAAc;;AAElD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU,oBAAoB;AAC9B,qDAAqD,OAAO;;AAE5D;AACA;AACA;;AAEA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACzEA;;AAEa;;;AAGb;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,cAAc;;AAErE;AACA,iCAAiC;;AAEjC;AACA,QAAQ,gDAAgD;AACxD;AACA;AACA,uDAAuD,UAAU;;AAEjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,UAAU;;AAE/C;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;;;;;AClFA;;AAEa;;AAEb,cAAc,oGAAkC;;;AAGhD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,WAAW;;AAElC;;AAEA,6CAA6C,WAAW;;AAExD,SAAS;AACT;AACA,qBAAqB,WAAW;;AAEhC;;AAEA;;AAEA;AACA;AACA,8BAA8B,WAAW;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,cAAc;;AAErE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;AACH;;AAEA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,aAAa;;AAE5B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,gCAAgC,uBAAuB;;AAEvD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B,OAAO;;AAErC;AACA;AACA;AACA,mDAAmD,OAAO;;AAE1D;AACA,yDAAyD,OAAO;;AAEhE;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;;AAE3B;AACA;AACA;AACA,+BAA+B,OAAO;AACtC,KAAK;AACL;AACA,+BAA+B,OAAO;AACtC;;AAEA,sEAAsE,OAAO;AAC7E;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACvWA;;AAEa;;;AAGb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ,gDAAgD;AACxD;AACA;AACA,uDAAuD,UAAU;;AAEjE;AACA,qCAAqC,UAAU;;AAE/C;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;;;;;;;;;;;;;ACnDa;;;AAGb,2BAA2B,+GAA6C;AACxE,2BAA2B,oGAAkC;;;AAG7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,cAAc;;AAErE,kDAAkD,cAAc;;AAEhE;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C,0DAA0D,cAAc;AACxE;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,QAAQ,gDAAgD;AACxD;AACA;AACA,uDAAuD,UAAU;;AAEjE;AACA,qCAAqC,UAAU;;AAE/C;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;;AAEA;AACA;;AAEA,eAAe,WAAW;AAC1B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,qEAAqE,cAAc;;AAEnF;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,cAAc;;AAE9B;AACA,qCAAqC,cAAc;;AAEnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,WAAW;AACnB;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;;AAE5B;AACA;AACA;AACA;AACA,mCAAmC;AACnC;;AAEA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;ACrMA;;AAEa;;AAEb,YAAY,mBAAO,CAAC,yDAAU;AAC9B,cAAc,oGAAkC;;;AAGhD;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB,sBAAsB;AACtB,0BAA0B;AAC1B,uBAAuB;AACvB,uBAAuB;;AAEvB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yDAAyD,WAAW;AACpE;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC;AACxC;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA,gCAAgC;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAiC,WAAW;AAC5C;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,YAAY;;AAE/B;AACA,+CAA+C,gBAAgB;AAC/D;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,WAAW;AAC5C,4CAA4C,OAAO;AACnD;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,YAAY;;AAE/B;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa,YAAY;AACzB;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;;;;;;;;;;;;;;;ACtOA;;AAEa;;AAEb,cAAc,oGAAkC;;;AAGhD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,cAAc;;AAE9C;;AAEA,iDAAiD,cAAc;;AAE/D;AACA,sDAAsD,cAAc;;AAEpE;AACA;AACA;;AAEA;AACA,sCAAsC,cAAc;;AAEpD;AACA,uEAAuE,cAAc;;AAErF;AACA;;AAEA,yFAAyF,cAAc;;AAEvG;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,8BAA8B,cAAc;AAC5C;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,qCAAqC,cAAc;AACnD,uDAAuD,cAAc;AACrE;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,cAAc;;AAEpD,eAAe,aAAa;;AAE5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,gCAAgC,oBAAoB;AACpD,mDAAmD,OAAO;;AAE1D;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;AACA,oBAAoB,OAAO;AAC3B,wDAAwD,OAAO;AAC/D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjNa;;;AAGb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;;;ACfa;;AAEb;AACA;;AAEA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACa;;;AAGb,qBAAqB,2GAAyC;;;AAG9D;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,QAAQ;;AAE1C,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,+BAA+B,QAAQ;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,UAAU;;AAExC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;;AAEvC;AACA;AACA,gDAAgD,UAAU;;AAE1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpIA;;AAEa;;;AAGb;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACa;;AAEb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC,QAAQ;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC,QAAQ;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,GAAG;AAC1B,2BAA2B,GAAG,yBAAyB,GAAG;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,sCAAsC,QAAQ;;AAE9C,wCAAwC,aAAa;;AAErD,iDAAiD,UAAU;;AAE3D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;AC1GA;AACA;AACa;;;AAGb,qBAAqB,yGAAuC;AAC5D,qBAAqB,wGAAsC;AAC3D,qBAAqB,2GAAyC;;AAE9D;AACA;AACA,0BAA0B;;;AAG1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,aAAa,mBAAmB;AAChC;;AAEA;;AAEA,8BAA8B,QAAQ;AACtC,wCAAwC,OAAO;AAC/C;AACA;;AAEA,gCAAgC,UAAU;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;;AAEtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,uBAAuB,QAAQ;AAC/B,sFAAsF;AACtF,2CAA2C;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,uBAAuB,mBAAmB;AAC1C,sFAAsF;AACtF,2CAA2C;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA,2CAA2C,OAAO;AAClD;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,6BAA6B;;AAEhE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,sCAAsC,QAAQ;;AAE9C,wCAAwC,aAAa;;AAErD;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;ACxMA;AACA;AACa;;AAEb,YAAY,mBAAO,CAAC,yDAAU;;;AAG9B;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;;;AAGA;;;;;;;;;;;;;;;ACnBA;;AAEa;;;AAGb;AACA,iDAAiD,EAAE,gCAAgC,KAAK,6CAA6C,KAAK;AAC1I,8CAA8C,KAAK;;;AAGnD;AACA;AACA;;AAEA,kDAAkD,cAAc;;AAEhE;;AAEA,8BAA8B,cAAc;;AAE5C;AACA;;AAEA;AACA;AACA,0CAA0C,cAAc;;AAExD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0CAA0C,cAAc;;AAExD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACvEA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA,2BAA2B,cAAc;;AAEzC;AACA;AACA;;AAEA,kEAAkE,OAAO;;AAEzE;;AAEA;;AAEA;AACA;;AAEA,8EAA8E,YAAY;;AAE1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,yBAAyB;AACzC;AACA;AACA;;;;;;;;;;;;;;;AC1CA;AACA;AACa;;;AAGb;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA,qBAAqB,iBAAiB;AACtC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,UAAU,0BAA0B;AACpC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzGA;AACA;AACa;;;AAGb;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA,eAAe,cAAc;;AAE7B,2DAA2D,cAAc;;AAEzE;;AAEA,aAAa,oBAAoB;AACjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;;AAEA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxIA,+BAA+B,QAAQ,QAAQ;;AAElC;;AAEb,wBAAwB,mBAAO,CAAC,6EAAoB;AACpD,wBAAwB,gGAA8B;AACtD,wBAAwB,8GAA4C;AACpE,wBAAwB,0GAAwC;;;AAGhE,mCAAmC,IAAI,OAAO,IAAI,GAAG;AACrD,mCAAmC,KAAK,EAAE;;;AAG1C;AACA;;AAEA,kDAAkD,cAAc;;AAEhE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,sBAAsB;AACtC;AACA;AACA;;;;;;;;;;;;;;;AC/CA;;AAEa;;AAEb,cAAc,oGAAkC;;AAEhD;;AAEA,eAAe,SAAS,OAAO,iBAAiB;;AAEhD,oBAAoB,WAAW,EAAE;AACjC,oCAAoC,+BAA+B,EAAE;;;AAGrE;AACA;;AAEA,kDAAkD,cAAc;;AAEhE;;AAEA;AACA;;AAEA;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,uBAAuB;AACvC;AACA;AACA;;;;;;;;;;;;;;;ACnDA;;AAEa;;;AAGb,kBAAkB,4GAAwC;;;AAG1D;AACA;AACA,qBAAqB;AACrB;AACA;;;AAGA;AACA;AACA;;AAEA,+BAA+B,cAAc;;AAE7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,cAAc;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC9CA;;AAEa;;AAEb,2BAA2B,+GAA6C;AACxE,2BAA2B,oGAAkC;;;AAG7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD,cAAc;AACtE,4DAA4D,cAAc;;AAE1E;AACA;;AAEA;AACA,qBAAqB,cAAc;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,WAAW;AACrB;AACA,4CAA4C,OAAO;AACnD;AACA,qBAAqB,cAAc;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,WAAW;AACrB;AACA,4CAA4C,OAAO;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,WAAW;AACvB;AACA,8CAA8C,OAAO;AACrD;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,sDAAsD,cAAc;;AAEpE;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,iBAAiB,+CAA+C;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvJA;;AAEa;;AAEb,2BAA2B,+GAA6C;AACxE,2BAA2B,oGAAkC;;;AAG7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD,cAAc;;AAEtE;AACA;;AAEA;AACA,qBAAqB,cAAc;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU,WAAW;AACrB;AACA,4CAA4C,OAAO;AACnD;AACA,qBAAqB,cAAc;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,WAAW;AACrB;AACA,4CAA4C,OAAO;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,WAAW;AACvB;AACA,8CAA8C,OAAO;AACrD;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sDAAsD,cAAc;;AAEpE;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,iBAAiB,+CAA+C;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrJA;;AAEa;;AAEb,cAAc,oGAAkC;;;AAGhD;AACA;;AAEA,mDAAmD,cAAc;;AAEjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA,2DAA2D,OAAO;;AAElE;AACA;AACA;;;;;;;;;;;;;;;ACzCA;;AAEa;;;AAGb,qBAAqB,mBAAO,CAAC,yDAAU;AACvC,qBAAqB,yGAAuC;AAC5D,qBAAqB,wGAAsC;AAC3D,qBAAqB,2GAAyC;;;AAG9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa,aAAa;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4DAA4D,OAAO;;AAEnE;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;;;;;;;;;;;;;;;;;ACrJA;AACA;AACa;;;AAGb;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA,eAAe,cAAc;;AAE7B,+BAA+B,cAAc;;AAE7C;AACA;AACA;;AAEA,gBAAgB,cAAc;;AAE9B;AACA;AACA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;;AAEA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClIA;AACA;;AAEa;;;AAGb;AACA,MAAM;;AAEN,oDAAoD,oCAAoC,MAAM;;AAE9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B,cAAc;;AAExC,gBAAgB,kDAAkD;;AAElE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD;;AAEhD;AACA;AACA;;AAEA;AACA,kBAAkB,cAAc;;AAEhC;AACA;AACA,kBAAkB,uCAAuC;AACzD;AACA;AACA;;AAEA,gBAAgB,kDAAkD;;AAElE;;AAEA;AACA,EAAE;;;;;;;;;;;;;;;ACxFF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;;;AAGb;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,YAAY;AACnC;AACA;AACA,0CAA0C;AAC1C;AACA,0CAA0C;;AAE1C;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,0BAA0B,6BAA6B;;AAEvD;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxCA;;AAEa;;;AAGb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,SAAS;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,WAAW;;AAE/B;;AAEA,iCAAiC,SAAS;AAC1C,+BAA+B,UAAU;AACzC;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;;;;;;;;;;;;;;;;ACnMa;;;AAGb;;AAEA;;AAEA;AACA;AACA,cAAc,cAAc;;AAE5B;;AAEA,aAAa,SAAS;AACtB;AACA;AACA;;AAEA,aAAa,oBAAoB;AACjC;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oCAAoC,EAAE;AACtC;AACA;;AAEA,+BAA+B,OAAO;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;;;AAGA,0BAA0B;AAC1B;;;AAGA;;;;;;;;;;;;;;;;ACxHa;;;AAGb;;;AAGA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;;AAE5B;;AAEA,aAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,aAAa,oBAAoB;AACjC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,gCAAgC,OAAO;AACvC;;AAEA;AACA,qBAAqB,EAAE;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,0BAA0B;AAC1B;;;AAGA;;;;;;;;;;;;;;;;AChGa;;;AAGb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACxBa;;;AAGb,6FAA2C;AAC3C,6FAA2C;AAC3C,6FAA2C;AAC3C,0FAA0C;;;;;;;;;;;;;;;ACN1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,KAAK;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,2CAA2C,KAAK;AAChD,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,YAAY;;AAE9C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,WAAW;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC;;AAEA;;;;;;;;;;;;;;;ACvTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA,8CAA8C,EAAE;AAChD;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,MAAM;AACzB,mBAAmB,aAAa;AAChC,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,uCAAuC;AAC9D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,MAAM;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,MAAM;AACzB,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,sBAAsB;;AAE7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,MAAM;AACzB,mBAAmB,SAAS;AAC5B,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,SAAS;AAC5B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,mDAAmD,kBAAkB;;AAErE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,SAAS;AAC5B,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,uDAAuD;AACvD;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,QAAQ,KAA6B;AACrC;AACA;;AAEA;AACA,QAAQ,IAA0C;AAClD,QAAQ,mCAAO;AACf;AACA,SAAS;AAAA,kGAAC;AACV;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjiCY;;AAEb;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,sBAAsB;;AAEtB;AACA;AACA,mCAAmC;AACnC,oDAAoD;;AAEpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,IAAI;AACJ,mCAAmC;AACnC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mCAAmC;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;;AAEvB,4CAA4C,qBAAqB;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;;AAE/C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEsE;AACtE,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;ACxbxB;AACa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO,UAAU;AAC7B,YAAY,OAAO;AACnB;;AAEA,eAAe,mBAAO,CAAC,0EAAqB;;AAE5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1DA,UAAU,mBAAO,CAAC,0IAA8D;AAChF,0BAA0B,mBAAO,CAAC,iJAAmD;;AAErF;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;AAIA,sC;;;;;;;;;;;;;AClBA,UAAU,mBAAO,CAAC,6JAAiF;AACnG,0BAA0B,mBAAO,CAAC,6OAAiH;;AAEnJ;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;AAIA,sC;;;;;;;;;;;;;;AClBa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,uDAAuD;;AAEvD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,KAAwC,GAAG,sBAAiB,GAAG,CAAI;;AAEnF;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,qEAAqE,qBAAqB,aAAa;;AAEvG;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,yDAAyD;AACzD,GAAG;;AAEH;;;AAGA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,6BAA6B;AACjD;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,E;;;;;;;;;;;;;;AC5Qa;;AAEb,eAAe,mBAAO,CAAC,0EAAgB;AACvC,gBAAgB,mBAAO,CAAC,4EAA0B;AAClD;;;;;;;;;;;;;;;ACJa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACzCA,mC;;;;;;;;;;;;;ACAA,sO;;;;;;;;;;;;;ACAA,8BAA8B,WAAW,EAAE,w0D;;;;;;;;;;;;;ACA3C,yE;;;;;;;;;;;;;;;;;;;;;;;;ACAa;;AAEb,kHAA+C;AAC/C,+GAA8C;AAC9C,+GAA8C;AAC9C,4GAA6C;AAC7C,4GAA6C;;;;;;;;;;;;;;ACN7C,iJ;;;;;;;;;;;;;;ACAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;UC9CA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCrBA;WACA;WACA;WACA;WACA;WACA,gCAAgC,YAAY;WAC5C;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,EAAE;WACF;WACA;WACA,CAAC,I;;;;;WCPD,sF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;UCNA;UACA;UACA;UACA","file":"bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, function() {\nreturn ","\r\nimport View from \"./View\"\r\nimport Toolbar from \"./Toolbar\"\r\nimport Layer from \"./Layer\"\r\nimport FilterPane from \"./FilterPane\"\r\nimport Storage from \"./io/BackendStorage\"\r\nimport SelectionToolPolicy from './policy/SelectionToolPolicy'\r\nimport FileOpen from \"./dialog/FileOpen\"\r\nimport FileSave from \"./dialog/FileSave\"\r\nimport FileSaveAs from \"./dialog/FileSaveAs\"\r\n\r\n/**\r\n *\r\n * The **GraphicalEditor** is responsible for layout and dialog handling.\r\n *\r\n * @author Jupiter Bakakeu\r\n */\r\n\r\nexport default class Application {\r\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {String} canvasId the id of the DOM element to use as paint container\r\n   */\r\n  constructor() {\r\n\r\n    this.documentConfigurationTempl = {\r\n      baseClass: \"draw2d.SetFigure\",\r\n      code: $(\"#shape-edit-template\").text().trim()\r\n    }\r\n\r\n    this.localStorage = []\r\n    try {\r\n      if ('localStorage' in window && window.localStorage !== null) {\r\n        this.localStorage = localStorage\r\n      }\r\n    } catch (e) {\r\n\r\n    }\r\n\r\n    $( \"body\" )\r\n      .delegate( \".mousetrap-pause\", \"focus\", function() {\r\n        Mousetrap.pause();\r\n      })\r\n      .delegate(\".mousetrap-pause\", \"blur\", function (){\r\n        Mousetrap.unpause();\r\n      });\r\n\r\n    // automatic add the configuration to the very first shape\r\n    // in the document as userData\r\n    //\r\n    this.documentConfiguration = $.extend({}, this.documentConfigurationTempl)\r\n\r\n    this.storage = new Storage()\r\n    this.view = new View(this, \"canvas\")\r\n    this.toolbar = new Toolbar(this, \".toolbar\", this.view)\r\n    this.layer = new Layer(this, \"layer_elements\", this.view)\r\n    this.filter = new FilterPane(this, \"#filter .filter_actions\", this.view)\r\n\r\n    this.view.installEditPolicy(new SelectionToolPolicy())\r\n\r\n    // check if the user has added a \"file\" parameter. In this case we load the shape from\r\n    // the draw2d.shape github repository\r\n    //\r\n    let file = this.getParam(\"file\")\r\n    if (file) {\r\n      this._load(file);\r\n    }\r\n    else {\r\n      this.fileNew();\r\n    }\r\n\r\n    // listen on the history object to load files\r\n    //\r\n    window.addEventListener('popstate', (event) => {\r\n      if (event.state && event.state.id === 'editor') {\r\n        // Render new content for the hompage\r\n        this._load(event.state.file);\r\n      }\r\n    });\r\n  }\r\n\r\n  _load(file){\r\n     this.storage.loadFile(file)\r\n      .then((content) => {\r\n        this.view.clear()\r\n        this.view.centerDocument()\r\n        let reader = new draw2d.io.json.Reader()\r\n        reader.unmarshal(this.view, content)\r\n        this.getConfiguration()\r\n        this.storage.fileName = file\r\n        this.view.getCommandStack().markSaveLocation()\r\n        this.view.centerDocument()\r\n        return content\r\n      })\r\n  }\r\n\r\n  getParam(name) {\r\n    name = name.replace(/[\\[]/, \"\\\\\\[\").replace(/[\\]]/, \"\\\\\\]\")\r\n    let regexS = \"[\\\\?&]\" + name + \"=([^&#]*)\"\r\n    let regex = new RegExp(regexS)\r\n    let results = regex.exec(window.location.href)\r\n    // the param isn't part of the normal URL pattern...\r\n    //\r\n    if (results === null) {\r\n      // maybe it is part in the hash.\r\n      //\r\n      regexS = \"[\\\\#]\" + name + \"=([^&#]*)\"\r\n      regex = new RegExp(regexS)\r\n      results = regex.exec(window.location.hash)\r\n      if (results === null) {\r\n        return null\r\n      }\r\n    }\r\n    return results[1]\r\n  }\r\n\r\n  fileNew(shapeTemplate) {\r\n    this.view.clear()\r\n    this.storage.currentFile = null\r\n    this.documentConfiguration = $.extend({}, this.documentConfigurationTempl)\r\n\r\n    if (shapeTemplate) {\r\n      new draw2d.io.json.Reader().unmarshal(this.view, shapeTemplate)\r\n      this.view.getCommandStack().markSaveLocation()\r\n      this.view.centerDocument()\r\n    }\r\n  }\r\n\r\n  fileOpen() {\r\n    new FileOpen().show(this.storage, this.view)\r\n  }\r\n\r\n  fileSave() {\r\n    this.setConfiguration()\r\n    if (this.storage.currentFile === null) {\r\n      new FileSaveAs().show(this.storage,this.view)\r\n    }\r\n    else {\r\n      new FileSave().show(this.storage,this.view)\r\n    }\r\n  }\r\n\r\n\r\n  getConfiguration(key) {\r\n    let figures = this.view.getExtFigures()\r\n    if (figures.getSize() > 0) {\r\n      this.documentConfiguration = $.extend({}, this.documentConfiguration, figures.first().getUserData())\r\n    }\r\n\r\n    if (key) {\r\n      return this.documentConfiguration[key]\r\n    }\r\n    return this.documentConfiguration\r\n  }\r\n\r\n  setConfiguration(conf) {\r\n    this.documentConfiguration = $.extend({}, this.documentConfiguration, conf)\r\n    let figures = this.view.getExtFigures()\r\n    if (figures.getSize() > 0) {\r\n      figures.first().setUserData(this.documentConfiguration)\r\n    }\r\n  }\r\n}\r\n","export default {\r\n  fileSuffix: \".shape\",\r\n  serverless: false,\r\n  backend: {\r\n    file: {\r\n      list: \"/backend/shape/list\",\r\n      get:  file=>`../backend/shape/get?filePath=${file}`,\r\n      save:\"/backend/shape/save\"\r\n    }\r\n  }\r\n}\r\n","export default class FilterPane {\r\n\r\n\r\n  constructor(app, elementId, view) {\r\n    this.DEFAULT_LABEL = \"Properties\"\r\n    this.html = $(elementId)\r\n    this.view = view\r\n    this.currentFigure = null\r\n\r\n    // Register a Selection listener for the state handling\r\n    // of the Delete Button\r\n    //\r\n    view.on(\"select\", this.onSelectionChanged.bind(this))\r\n  }\r\n\r\n  /**\r\n   * @method\r\n   * Called if the selection in the canvas has been changed. You must register this\r\n   * class on the canvas to receive this event.\r\n   *\r\n   * @param {draw2d.Canvas} canvas the emitter of the event. In this case it is the canvas.\r\n   * @param {draw2d.Figure} figure\r\n   */\r\n  onSelectionChanged(canvas, event = {figure: null}) {\r\n    var figure = event.figure\r\n\r\n    this.html.html('')\r\n    $('#add_filter_button').addClass('disabled')\r\n\r\n    if (this.currentFigure !== null && typeof this.currentFigure.isExtFigure !== \"undefined\") {\r\n      this.currentFigure.filters.each((i, filter) => {\r\n        filter.removePane()\r\n      })\r\n    }\r\n    $(\"#add_filter_action_menu\").html(\"\")\r\n\r\n    if (figure !== null && typeof figure.isExtFigure !== \"undefined\") {\r\n      figure.filters.each((i, filter) => {\r\n        filter.insertPane(figure, this.html)\r\n      })\r\n      $('#add_filter_button').removeClass('disabled')\r\n\r\n      $.each(figure.getPotentialFilters(), function (i, e) {\r\n        $(\"#add_filter_action_menu\").append(\"<li><a href='#' data-filter='\" + e.impl + \"' >\" + e.label + \"</a></li>\")\r\n      })\r\n\r\n      var _this = this\r\n      $(\"#add_filter_action_menu a\").on(\"click\", function () {\r\n        var $this = $(this)\r\n        var filterName = $this.data(\"filter\")\r\n        var filter = eval(\"new \" + filterName + \"()\")\r\n        _this.currentFigure.addFilter(filter)\r\n        _this.onSelectionChanged(_this.view, {figure: _this.currentFigure})\r\n      })\r\n    }\r\n\r\n    this.currentFigure = figure\r\n  }\r\n}\r\n","// just a simple mock object for the brainbox\r\n// Hardware binding\r\n//\r\nexport default {\r\n\r\n  raspi: {\r\n    set: function (pin, value) {\r\n    },\r\n    get: function (pin) {\r\n      return false\r\n    },\r\n    on: function(event, callback){\r\n    },\r\n    connected: false\r\n  },\r\n\r\n  arduino: {\r\n    set: function (pin, value) {\r\n    },\r\n    get: function (pin) {\r\n      return false\r\n    },\r\n    on: function(event, callback){\r\n    },\r\n    connected: false\r\n  }\r\n}\r\n","export default draw2d.ui.LabelInplaceEditor.extend({\r\n\r\n    NAME : \"LabelInplaceEditor\",\r\n\r\n    /**\r\n     * @constructor\r\n     *\r\n     */\r\n    init: function(attr, setter, getter)\r\n    {\r\n        this._super({\r\n          onStart: function(){\r\n            Mousetrap.pause()\r\n          },\r\n          onCancel: function(){\r\n            Mousetrap.unpause()\r\n          },\r\n          onCommit: function(){\r\n            Mousetrap.unpause()\r\n          }\r\n        }, setter, getter);\r\n    }\r\n});\r\n","export default class Layer {\r\n\r\n\r\n  constructor(app, elementId, view) {\r\n    this.html = $(\"#\" + elementId)\r\n    this.view = view\r\n\r\n    // register this class as event listener for the canvas\r\n    // CommandStack. This is required to update the state of\r\n    // the Undo/Redo Buttons.\r\n    //\r\n    view.getCommandStack().addEventListener(this)\r\n\r\n    // Register a Selection listener for the state hnadling\r\n    // of the Delete Button\r\n    //\r\n    view.on(\"select\", this.onSelectionChanged.bind(this))\r\n  }\r\n\r\n  /**\r\n   * @method\r\n   * Called if the selection in the cnavas has been changed. You must register this\r\n   * class on the canvas to receive this event.\r\n   *\r\n   * @param {draw2d.Figure} emitter\r\n   */\r\n  onSelectionChanged(emitter, event) {\r\n    this._updateSelection()\r\n  }\r\n\r\n  /**\r\n   * @method\r\n   * Sent when an event occurs on the command stack. draw2d.command.CommandStackEvent.getDetail()\r\n   * can be used to identify the type of event which has occurred.\r\n   *\r\n   * @template\r\n   *\r\n   * @param {draw2d.command.CommandStackEvent} event\r\n   **/\r\n  stackChanged(event) {\r\n    this.html.html('')\r\n    let figures = this.view.getExtFigures()\r\n    figures.each((i, figure) => {\r\n      this.html.append(\r\n        '<div class=\"layerElement '+this.figureToCSS(figure)+'\" data-figure=\"' + figure.id + '\"  data-visibility=\"' + figure.isVisible() + '\" id=\"layerElement_' + figure.id + '\" >' +\r\n        figure.getUserData().name +\r\n        '<span data-figure=\"' + figure.id + '\"  data-toggle=\"tooltip\" title=\"Toggle Visibility of the Layer\"  class=\"layer_visibility pull-right\"><img class=\"icon svg\" src=\"' + (figure.isVisible() ? './images/layer_visible.svg' : './images/layer_hidden.svg') + '\"/></span>' +\r\n        '<span data-figure=\"' + figure.id + '\"  data-toggle=\"tooltip\" title=\"Edit Name of Layer\" class=\"layer_edit pull-right\" ><img class=\"icon svg\" src=\"./images/layer_edit.svg\"/></span>' +\r\n        '</div>')\r\n    }, true)\r\n\r\n    inlineSVG.init()\r\n\r\n    $('*[data-toggle=\"tooltip\"]').tooltip({\r\n      placement: \"bottom\",\r\n      container: \"body\",\r\n      delay: {show: 1000, hide: 100},\r\n      html: true\r\n    })\r\n\r\n    this.html.sortable({\r\n      axis: \"y\",\r\n      update: () => {\r\n        $(\".layerElement\").toArray().reverse().forEach((e) => {\r\n          this.view.getExtFigure($(e).data(\"figure\")).toFront()\r\n        })\r\n      }\r\n    })\r\n\r\n    $(\".layerElement .layer_edit\").on(\"click\", $.proxy(function (event) {\r\n      let figure = this.view.getExtFigure($(event.currentTarget).data(\"figure\"))\r\n      Mousetrap.pause()\r\n      bootbox.prompt({\r\n        title: \"Layer Name\",\r\n        className: \"layer-name-prompt\",\r\n        value: figure.getUserData().name,\r\n        callback: $.proxy(function (result) {\r\n          Mousetrap.unpause()\r\n          if (result !== null) {\r\n            figure.getUserData().name = result\r\n            this.stackChanged(null)\r\n          }\r\n        }, this)\r\n      })\r\n\r\n      // autoselect text for fast edit\r\n      setTimeout(function () {\r\n        $(\".bootbox-input\").focus().select()\r\n      }, 200)\r\n    }, this))\r\n\r\n\r\n    $(\".layerElement .layer_visibility\").on(\"click\", $.proxy(function (event) {\r\n      let figure = this.view.getExtFigure($(event.currentTarget).data(\"figure\"))\r\n      figure.setVisible(!figure.isVisible())\r\n      this.view.setCurrentSelection(null)\r\n      $(event.currentTarget).html('<img class=\"icon svg\" src=\"' + (figure.isVisible() ? './images/layer_visible.svg' : './images/layer_hidden.svg') + '\"/>')\r\n      inlineSVG.init()\r\n\r\n      // set the \"data\" with attr and not with \"data()\". Otherwise the css selector won't work\r\n      //\r\n      $(event.currentTarget).parent().attr({\"data-visibility\": figure.isVisible()})\r\n\r\n      this.ripple(figure)\r\n      return false\r\n    }, this))\r\n\r\n    $(\".layerElement\").on(\"click\", $.proxy(function (event) {\r\n      let figure = this.view.getExtFigure($(event.currentTarget).data(\"figure\"))\r\n      if (figure.isVisible()) {\r\n        this.view.setCurrentSelection(figure)\r\n        this.ripple(figure)\r\n      }\r\n    }, this))\r\n\r\n    this._updateSelection()\r\n  }\r\n\r\n  _updateSelection() {\r\n    $(\".layerElement\").removeClass(\"layerSelectedElement\")\r\n    let selection = this.view.getSelection()\r\n    selection.each(function (i, e) {\r\n      $(\"#layerElement_\" + e.id).addClass(\"layerSelectedElement\")\r\n    })\r\n  }\r\n\r\n  ripple(figure) {\r\n    let rect = figure.getBoundingBox()\r\n    let p = rect.getCenter()\r\n    let circle = this.view.paper.circle(p.x, p.y, Math.max(3, rect.w / 4), Math.max(3, rect.h / 4)).attr({\r\n      fill: null,\r\n      stroke: \"#d0d0ff\"\r\n    })\r\n    let anim = Raphael.animation(\r\n      {\r\n        transform: \"s6\",\r\n        opacity: 0.0,\r\n        \"stroke-width\": 5\r\n      },\r\n      500,\r\n      \"linear\",\r\n      function () {\r\n        circle.remove()\r\n      }\r\n    )\r\n    circle.animate(anim)\r\n  }\r\n\r\n  figureToCSS(figure){\r\n    return figure.NAME.split(\".\").slice(-1)[0]\r\n  }\r\n}\r\n","import RectangleToolPolicy from \"./policy/RectangleToolPolicy\"\r\nimport CircleToolPolicy from \"./policy/CircleToolPolicy\"\r\nimport LineToolPolicy from \"./policy/LineToolPolicy\"\r\nimport TextToolPolicy from \"./policy/TextToolPolicy\"\r\nimport PortToolPolicy from \"./policy/PortToolPolicy\"\r\nimport SelectionToolPolicy from \"./policy/SelectionToolPolicy\"\r\nimport GeoUnionToolPolicy from \"./policy/GeoUnionToolPolicy\"\r\nimport GeoIntersectionToolPolicy from \"./policy/GeoIntersectionToolPolicy\"\r\nimport GeoDifferenceToolPolicy from \"./policy/GeoDifferenceToolPolicy\"\r\n\r\nimport FigureCodeEdit from \"./dialog/FigureCodeEdit\"\r\nimport FigureMarkdownEdit from \"./dialog/FigureMarkdownEdit\"\r\nimport FigureTest from \"./dialog/FigureTest\"\r\nimport conf from \"./Configuration\"\r\n\r\n\r\nexport default class Toolbar {\r\n\r\n  constructor(app, elementId, view) {\r\n    this.html = $(elementId)\r\n    this.view = view\r\n    this.app = app\r\n\r\n    // register this class as event listener for the canvas\r\n    // CommandStack. This is required to update the state of\r\n    // the Undo/Redo Buttons.\r\n    //\r\n    view.getCommandStack().addEventListener(this)\r\n\r\n    // Register a Selection listener for the state handling\r\n    // of the Delete Button\r\n    //\r\n    view.on(\"select\", this.onSelectionChanged.bind(this))\r\n    view.on(\"unselect\", this.onSelectionChanged.bind(this))\r\n\r\n    this.fileName = null\r\n    let buttonGroup = null\r\n\r\n    if (conf.serverless === false) {\r\n      buttonGroup = $(\"<div id='fileOperationGroup' class='group'></div>\")\r\n      this.html.append(buttonGroup)\r\n\r\n      this.openButton = $('<div class=\"image-button\" id=\"fileOpen\" data-toggle=\"tooltip\" title=\"Load File <span class=\\'highlight\\'> [ Ctrl+O ]</span>\" ><img src=\"./images/toolbar_download.svg\"/><div>Open</div></div>')\r\n      buttonGroup.append(this.openButton)\r\n      this.openButton.on(\"click\", () => {\r\n        this.openButton.tooltip(\"hide\")\r\n        app.fileOpen()\r\n      })\r\n      Mousetrap.bindGlobal(\"ctrl+o\", () => {\r\n        this.openButton.click()\r\n        return false\r\n      })\r\n\r\n      this.saveButton = $('<div class=\"image-button\"  id=\"fileSave\" data-toggle=\"tooltip\" title=\"Save File <span class=\\'highlight\\'> [ Ctrl+S ]</span>\"  ><img src=\"./images/toolbar_upload.svg\"/><div>Save</div></div>')\r\n      buttonGroup.append(this.saveButton)\r\n      this.saveButton.on(\"click\", () => {\r\n        this.saveButton.tooltip(\"hide\")\r\n        app.fileSave()\r\n      })\r\n      Mousetrap.bindGlobal(\"ctrl+s\", (event) => {\r\n        this.saveButton.click()\r\n        return false\r\n      })\r\n    }\r\n\r\n\r\n    // Inject the UNDO Button and the callbacks\r\n    //\r\n    buttonGroup = $('<div class=\"group\"></div>')\r\n    this.html.append(buttonGroup)\r\n    this.undoButton = $('<div class=\"image-button\" id=\"editUndo\" data-toggle=\"tooltip\" title=\"Undo <span class=\\'highlight\\'> [ Ctrl+Z ]</span>\"  ><img class=\"icon disabled\"  src=\"./images/toolbar_undo.svg\"/><div>Undo</div></div>')\r\n    buttonGroup.append(this.undoButton)\r\n    this.html .delegate(\"#editUndo:not(.disabled)\", \"click\", () => {\r\n      this.view.getCommandStack().undo()\r\n    })\r\n    Mousetrap.bindGlobal(\"ctrl+z\", () => {\r\n      this.undoButton.click()\r\n      return false\r\n    })\r\n\r\n\r\n    // Inject the REDO Button and the callback\r\n    //\r\n    this.redoButton = $('<div class=\"image-button\" id=\"editRedo\" data-toggle=\"tooltip\" title=\"Redo <span class=\\'highlight\\'> [ Ctrl+Y ]</span>\"  ><img  class=\"icon disabled\" src=\"./images/toolbar_redo.svg\"/><div>Redo</div></div>')\r\n    buttonGroup.append(this.redoButton)\r\n    this.html .delegate(\"#editRedo:not(.disabled)\", \"click\", () => {\r\n      this.view.getCommandStack().redo()\r\n    })\r\n    Mousetrap.bindGlobal(\"ctrl+y\", () => {\r\n      this.redoButton.click()\r\n      return false\r\n    })\r\n\r\n    // Inject the DELETE Button\r\n    //\r\n    this.deleteButton = $('<div class=\"image-button\" id=\"editDelete\" data-toggle=\"tooltip\" title=\"Delete <span class=\\'highlight\\'> [ Del ]</span>\"  ><img class=\"icon disabled\" src=\"./images/toolbar_delete.svg\"/><div>Delete</div></div>')\r\n    buttonGroup.append(this.deleteButton)\r\n    this.html .delegate(\"#editDelete:not(.disabled)\", \"click\", function () {\r\n      view.getCommandStack().startTransaction(draw2d.Configuration.i18n.command.deleteShape)\r\n      view.getSelection().each(function (index, figure) {\r\n        let cmd = figure.createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.DELETE))\r\n        if (cmd !== null) {\r\n          view.getCommandStack().execute(cmd)\r\n        }\r\n      })\r\n      // execute all single commands at once.\r\n      view.getCommandStack().commitTransaction()\r\n    })\r\n    Mousetrap.bindGlobal([\"del\", \"backspace\"], () => {\r\n      this.deleteButton.click()\r\n      return false\r\n    })\r\n\r\n\r\n    buttonGroup = $('<div class=\"group\"></div>')\r\n    this.html.append(buttonGroup)\r\n\r\n    this.selectButton = $('<div class=\"image-button\" id=\"editSelect\" data-toggle=\"tooltip\" title=\"Select mode <span class=\\'highlight\\'> [ spacebar ]</span>\" ><img src=\"./images/toolbar_select.svg\"/><div>Select</div></div>')\r\n    buttonGroup.append(this.selectButton)\r\n    this.selectButton.on(\"click\", () => {\r\n      this.view.installEditPolicy(new SelectionToolPolicy())\r\n    })\r\n    Mousetrap.bindGlobal(\"space\", () => {\r\n      this.selectButton.click()\r\n      return false\r\n    })\r\n\r\n    this.shapeButton = $(\r\n      '<label id=\"tool_shape\" class=\"dropdown\" >' +\r\n      '    <div class=\"image-button\" data-toggle=\"dropdown\"  id=\"tool_shape_image\" ><img  src=\"./images/toolbar_insert.svg\"><div>Add</div></div>' +\r\n      '    <ul class=\"dropdown-menu\" role=\"menu\" >' +\r\n      '       <li class=\"tool_shape_entry policyRectangleToolPolicy\" ><a href=\"#\"><img  src=\"./images/toolbar_rectangle.svg\"><span class=\"tool_label\">Rectangle</span><span class=\"tool_shortcut\">R</span></a></li>' +\r\n      '       <li class=\"tool_shape_entry policyCircleToolPolicy\"    ><a href=\"#\"><img  src=\"./images/toolbar_circle.svg\"><span class=\"tool_label\">Circle</span><span class=\"tool_shortcut\">C</span></a></li>' +\r\n      '       <li class=\"tool_shape_entry policyLineToolPolicy\"      ><a href=\"#\"><img  src=\"./images/toolbar_line.svg\"><span class=\"tool_label\">Line</span><span class=\"tool_shortcut\">L</span></a></li>' +\r\n      '       <li class=\"tool_shape_entry policyTextToolPolicy\"      ><a href=\"#\"><img  src=\"./images/toolbar_text.svg\"><span class=\"tool_label\">Text</span><span class=\"tool_shortcut\">T</span></a></li>' +\r\n      '       <li class=\"tool_shape_entry policyPortToolPolicy\"      ><a href=\"#\"><img  src=\"./images/toolbar_rectangle.svg\"><span class=\"tool_label\">Port</span><span class=\"tool_shortcut\">P</span></a></li>' +\r\n      '    </ul>' +\r\n      '</label>'\r\n    )\r\n    buttonGroup.append(this.shapeButton)\r\n\r\n    $(\".policyRectangleToolPolicy\").on(\"click\", () => {\r\n      let p = new RectangleToolPolicy()\r\n      p.executed = () => {\r\n        this.selectButton.click()\r\n      }\r\n      this.view.installEditPolicy(p)\r\n    })\r\n    $(\".policyCircleToolPolicy\").on(\"click\", () => {\r\n      let p = new CircleToolPolicy()\r\n      p.executed = () => {\r\n        this.selectButton.click()\r\n      }\r\n      this.view.installEditPolicy(p)\r\n    })\r\n    $(\".policyLineToolPolicy\").on(\"click\", () => {\r\n      let p = new LineToolPolicy()\r\n      p.executed = () => {\r\n        this.selectButton.click()\r\n      }\r\n      this.view.installEditPolicy(p)\r\n    })\r\n    $(\".policyTextToolPolicy\").on(\"click\", () => {\r\n      let p = new TextToolPolicy()\r\n      p.executed = () => {\r\n        this.selectButton.click()\r\n      }\r\n      this.view.installEditPolicy(p)\r\n    })\r\n    $(\".policyPortToolPolicy\").on(\"click\", () => {\r\n      let p = new PortToolPolicy()\r\n      p.executed = () => {\r\n        this.selectButton.click()\r\n      }\r\n      this.view.installEditPolicy(p)\r\n    })\r\n\r\n    Mousetrap.bindGlobal([\"R\", \"r\"], () => {\r\n      $('.policyRectangleToolPolicy').click()\r\n      return false\r\n    })\r\n    Mousetrap.bindGlobal([\"C\", \"c\"], () => {\r\n      $('.policyCircleToolPolicy').click()\r\n      return false\r\n    })\r\n    Mousetrap.bindGlobal([\"T\", \"t\"], () => {\r\n      $('.policyTextToolPolicy').click()\r\n      return false\r\n    })\r\n    Mousetrap.bindGlobal([\"P\", \"p\"], () => {\r\n      $('.policyPortToolPolicy').click()\r\n      return false\r\n    })\r\n    Mousetrap.bindGlobal([\"L\", \"l\"], () => {\r\n      $('.policyLineToolPolicy').click()\r\n      return false\r\n    })\r\n\r\n    this.unionButton = $('<div class=\"image-button disabled\" id=\"toolUnion\" data-toggle=\"tooltip\" title=\"Polygon Union <span class=\\'highlight\\'> [ U ]</span>\" ><img src=\"./images/toolbar_geo_union.svg\"/><div>Union</div></div>')\r\n    buttonGroup.append(this.unionButton)\r\n    this.html.delegate(\"#toolUnion:not(.disabled)\", \"click\", () => {\r\n      let selection = this.view.getSelection().getAll()\r\n      let p = new GeoUnionToolPolicy()\r\n      p.executed = () => {\r\n        this.selectButton.click()\r\n      }\r\n      this.view.installEditPolicy(p)\r\n      p.execute(this.view, selection)\r\n    })\r\n    Mousetrap.bindGlobal([\"U\", \"u\"], () => {\r\n      this.unionButton.click()\r\n      return false\r\n    })\r\n\r\n    this.differenceButton = $('<div class=\"image-button disabled\" id=\"toolDifference\" data-toggle=\"tooltip\"  title=\"Polygon Difference <span class=\\'highlight\\'> [ D ]</span>\" ><img src=\"./images/toolbar_geo_subtract.svg\"/><div>Subtract</div></div>')\r\n    buttonGroup.append(this.differenceButton)\r\n    this.html.delegate(\"#toolDifference:not(.disabled)\", \"click\", () => {\r\n      this.view.installEditPolicy(new GeoDifferenceToolPolicy())\r\n    })\r\n    Mousetrap.bindGlobal([\"D\", \"d\"], () => {\r\n      this.differenceButton.click()\r\n      return false\r\n    })\r\n\r\n    this.intersectionButton = $('<div class=\"image-button disabled\" id=\"toolIntersection\" data-toggle=\"tooltip\" title=\"Polygon Intersection <span class=\\'highlight\\'> [ I ]</span>\" ><img src=\"./images/toolbar_geo_intersect.svg\"/><div>Intersect</div></div>')\r\n    buttonGroup.append(this.intersectionButton)\r\n    this.html.delegate(\"#toolIntersection:not(.disabled)\", \"click\", () => {\r\n      this.view.installEditPolicy(new GeoIntersectionToolPolicy())\r\n    })\r\n    Mousetrap.bindGlobal([\"I\", \"i\"], () => {\r\n      this.intersectionButton.click()\r\n      return false\r\n    })\r\n\r\n\r\n    buttonGroup = $('<div class=\"group\" style=\"float:right\"></div>')\r\n    this.html.append(buttonGroup)\r\n    this.testButton = $('<div class=\"image-button\" data-toggle=\"tooltip\" title=\"Test your shape\"><img src=\"./images/toolbar_element_test.svg\"/><div>Test</div></div>')\r\n    buttonGroup.append(this.testButton)\r\n    this.testButton.on(\"click\", () => {\r\n      // if any error happens during the shape code create/execute -> goto the the JS editor\r\n      try {\r\n        new FigureTest().show()\r\n      }\r\n      catch (exc) {\r\n        console.log(exc)\r\n        new FigureCodeEdit().show()\r\n      }\r\n    })\r\n\r\n    this.codeButton = $('<div class=\"image-button\" data-toggle=\"tooltip\" title=\"Edit JavaScript code</span>\"><img src=\"./images/toolbar_element_js.svg\"/><div>Code</div></div>')\r\n    buttonGroup.append(this.codeButton)\r\n    this.codeButton.on(\"click\", () => {\r\n      new FigureCodeEdit().show()\r\n    })\r\n\r\n    this.markdownButton = $('<div class=\"image-button\" data-toggle=\"tooltip\" title=\"Write documentation for your shape</span>\"><img src=\"./images/toolbar_element_doc.svg\"/><div>Doku</div></div>')\r\n    buttonGroup.append(this.markdownButton)\r\n    this.markdownButton.on(\"click\", () => {\r\n      new FigureMarkdownEdit().show()\r\n    })\r\n\r\n    // enable the tooltip for all buttons\r\n    //\r\n    $('*[data-toggle=\"tooltip\"]').tooltip({\r\n      placement: \"bottom\",\r\n      container: \"body\",\r\n      delay: {show: 1000, hide: 10},\r\n      html: true\r\n    })\r\n  }\r\n\r\n\r\n  /**\r\n   * @method\r\n   * Called if the selection in the cnavas has been changed. You must register this\r\n   * class on the canvas to receive this event.\r\n   *\r\n   * @param {draw2d.Figure} figure\r\n   */\r\n  onSelectionChanged(emitter, event) {\r\n    if (event.figure === null) {\r\n      $(\"#editDelete\").addClass(\"disabled\")\r\n    }\r\n    else {\r\n      $(\"#editDelete\").removeClass(\"disabled\")\r\n    }\r\n\r\n    // available in BoundBox selection event\r\n    if (event.selection) {\r\n      if (event.selection.getSize() >= 2) {\r\n        $(\"#toolUnion\").removeClass(\"disabled\")\r\n        $(\"#toolDifference\").removeClass(\"disabled\")\r\n        $(\"#toolIntersection\").removeClass(\"disabled\")\r\n      }\r\n      else {\r\n        $(\"#toolUnion\").addClass(\"disabled\")\r\n        $(\"#toolDifference\").addClass(\"disabled\")\r\n        $(\"#toolIntersection\").addClass(\"disabled\")\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @method\r\n   * Sent when an event occurs on the command stack. draw2d.command.CommandStackEvent.getDetail()\r\n   * can be used to identify the type of event which has occurred.\r\n   *\r\n   * @template\r\n   *\r\n   * @param {draw2d.command.CommandStackEvent} event\r\n   **/\r\n  stackChanged(event) {\r\n    $(\"#editUndo\").addClass(\"disabled\")\r\n    $(\"#editRedo\").addClass(\"disabled\")\r\n\r\n    if (event.getStack().canUndo()) {\r\n      $(\"#editUndo\").removeClass(\"disabled\")\r\n    }\r\n\r\n    if (event.getStack().canRedo()) {\r\n      $(\"#editRedo\").removeClass(\"disabled\")\r\n    }\r\n  }\r\n}\r\n","\r\nexport default draw2d.Canvas.extend({\r\n\r\n  init: function (app, id) {\r\n    this._super(id, 16000, 16000)\r\n    this.clippboardFigure = null\r\n    this.app = app\r\n    this.grid = new draw2d.policy.canvas.ShowGridEditPolicy(20)\r\n\r\n    this.setScrollArea(\"#\" + id)\r\n\r\n    this.installEditPolicy(this.grid)\r\n    this.installEditPolicy(new draw2d.policy.canvas.FadeoutDecorationPolicy())\r\n    this.installEditPolicy(new draw2d.policy.canvas.SnapToGeometryEditPolicy())\r\n    this.installEditPolicy(new draw2d.policy.canvas.SnapToCenterEditPolicy())\r\n    this.installEditPolicy(new draw2d.policy.canvas.SnapToInBetweenEditPolicy())\r\n\r\n    Mousetrap.bindGlobal(['left'], () => {\r\n      let diff = this.getZoom() < 0.5 ? 0.5 : 1\r\n      this.getSelection().each((i, f) => {\r\n        f.translate(-diff, 0)\r\n      })\r\n      return false\r\n    })\r\n    Mousetrap.bindGlobal(['up'], () => {\r\n      let diff = this.getZoom() < 0.5 ? 0.5 : 1\r\n      this.getSelection().each((i, f) => {\r\n        f.translate(0, -diff)\r\n      })\r\n      return false\r\n    })\r\n    Mousetrap.bindGlobal(['right'], () => {\r\n      let diff = this.getZoom() < 0.5 ? 0.5 : 1\r\n      this.getSelection().each((i, f) => {\r\n        f.translate(diff, 0)\r\n      })\r\n      return false\r\n    })\r\n    Mousetrap.bindGlobal(['down'], () => {\r\n      let diff = this.getZoom() < 0.5 ? 0.5 : 1\r\n      this.getSelection().each((i, f) => {\r\n        f.translate(0, diff)\r\n      })\r\n      return false\r\n    })\r\n\r\n    Mousetrap.bindGlobal(['ctrl+c', 'command+c'], () => {\r\n      let primarySelection = this.getSelection().getPrimary()\r\n      if (primarySelection !== null) {\r\n        this.clippboardFigure = primarySelection.clone()\r\n        this.clippboardFigure.translate(5, 5)\r\n      }\r\n      return false\r\n    })\r\n\r\n    Mousetrap.bindGlobal(['ctrl+v', 'command+v'], () => {\r\n      if (this.clippboardFigure !== null) {\r\n        let cloneToAdd = this.clippboardFigure.clone()\r\n        let command = new draw2d.command.CommandAdd(this, cloneToAdd, cloneToAdd.getPosition())\r\n        this.getCommandStack().execute(command)\r\n        this.setCurrentSelection(cloneToAdd)\r\n      }\r\n      return false\r\n    })\r\n\r\n    let zoom = new draw2d.policy.canvas.WheelZoomPolicy()\r\n    this.installEditPolicy(zoom)\r\n\r\n    let setZoom = (newZoom) => {\r\n      let bb = this.getBoundingBox().getCenter()\r\n      let c = $(\"#canvas\")\r\n      this.setZoom(newZoom)\r\n      c.scrollTop((bb.y / newZoom - c.height() / 2))\r\n      c.scrollLeft((bb.x / newZoom - c.width() / 2))\r\n    }\r\n\r\n    // Inject the ZoomIn Button and the callbacks\r\n    //\r\n    $(\"#canvas_zoom_in\").on(\"click\", () => {\r\n      setZoom(this.getZoom() * 1.2)\r\n    })\r\n\r\n    // Inject the OneToOne Button\r\n    //\r\n    $(\"#canvas_zoom_normal\").on(\"click\", () => {\r\n      setZoom(1.0)\r\n    })\r\n\r\n    // Inject the ZoomOut Button and the callback\r\n    //\r\n    $(\"#canvas_zoom_out\").on(\"click\", () => {\r\n      setZoom(this.getZoom() * 0.8)\r\n    })\r\n\r\n    $('#canvas_config_grid').on('change', () => {\r\n      if ($('#canvas_config_grid').prop('checked')) {\r\n        this.installEditPolicy(this.grid)\r\n      }\r\n      else {\r\n        this.uninstallEditPolicy(this.grid)\r\n      }\r\n    })\r\n\r\n    $(\"#canvas_config_items\").on(\"click\", (e) => {\r\n      e.stopPropagation()\r\n    })\r\n\r\n    this.reset()\r\n  },\r\n\r\n  setCursor: function (cursor) {\r\n    if (cursor !== null) {\r\n      this.html.css(\"cursor\", \"url(\" + cursor + \") 0 0, default\")\r\n    }\r\n    else {\r\n      this.html.css(\"cursor\", \"default\")\r\n    }\r\n  },\r\n\r\n\r\n  /**\r\n   * @method\r\n   * Reset the view/canvas and starts with a clean and new document with default decorations\r\n   *\r\n   *\r\n   */\r\n  reset: function () {\r\n    this.clear()\r\n  },\r\n\r\n  setZoom: function (newZoom) {\r\n    $(\"#canvas_zoom_normal\").text((parseInt((1.0 / newZoom) * 100)) + \"%\")\r\n    this._super(newZoom)\r\n  },\r\n\r\n\r\n  getExtFigure: function (id) {\r\n    let figure = null\r\n    this.getExtFigures().each((i, e) => {\r\n      if (e.id === id) {\r\n        figure = e\r\n        return false\r\n      }\r\n    })\r\n    return figure\r\n  },\r\n\r\n  getExtFigures: function () {\r\n    let figures = this.getFigures().clone()\r\n\r\n    // the export rectangles are not part of the document itself. In this case we\r\n    // filter them out\r\n    //\r\n    figures.grep((figure) => {\r\n      return (typeof figure.isExtFigure !== \"undefined\")\r\n    })\r\n\r\n    let lines = this.getLines().clone()\r\n    lines.grep((line) => {\r\n      return (typeof line.isExtFigure !== \"undefined\")\r\n    })\r\n\r\n    figures.addAll(lines)\r\n\r\n    return figures\r\n  },\r\n\r\n\r\n  getBoundingBox: function () {\r\n    let xCoords = []\r\n    let yCoords = []\r\n    this.getExtFigures().each((i, f) => {\r\n      if (f instanceof shape_designer.figure.ExtPort) {\r\n        return\r\n      }\r\n      let b = f.getBoundingBox()\r\n      xCoords.push(b.x, b.x + b.w)\r\n      yCoords.push(b.y, b.y + b.h)\r\n    })\r\n    let minX = Math.min(...xCoords)\r\n    let minY = Math.min(...yCoords)\r\n    let width = Math.max(10, Math.max(...xCoords) - minX)\r\n    let height = Math.max(10, Math.max(...yCoords) - minY)\r\n\r\n    return new draw2d.geo.Rectangle(minX, minY, width, height)\r\n  },\r\n\r\n  hideDecoration: function () {\r\n    this.uninstallEditPolicy(this.grid)\r\n    this.getFigures().each((index, figure) => {\r\n      figure.unselect()\r\n    })\r\n  },\r\n\r\n  showDecoration: function () {\r\n    this.installEditPolicy(this.grid)\r\n  },\r\n\r\n  /**\r\n   * @method\r\n   * Return the width of the canvas\r\n   *\r\n   * @return {Number}\r\n   **/\r\n  getWidth: function () {\r\n    return this.html.find(\"svg\").width()\r\n  },\r\n\r\n\r\n  /**\r\n   * @method\r\n   * Return the height of the canvas.\r\n   *\r\n   * @return {Number}\r\n   **/\r\n  getHeight: function () {\r\n    return this.html.find(\"svg\").height()\r\n  },\r\n\r\n  centerView: function(){\r\n    let bb = this.getBoundingBox().getCenter()\r\n    let c = $(\"#canvas\")\r\n    c.scrollTop((bb.y / this.getZoom() - c.height() / 2))\r\n    c.scrollLeft((bb.x /this.getZoom() - c.width() / 2))\r\n  },\r\n\r\n  centerDocument: function () {\r\n    this.setZoom(1.0)\r\n    // get the bounding box of the document and translate the complete document\r\n    // into the center of the canvas. Scroll to the top left corner after them\r\n    //\r\n    let bb = this.getBoundingBox()\r\n\r\n    let dx = (this.getWidth() / 2) - (bb.x + bb.w / 2)\r\n    let dy = (this.getHeight() / 2) - (bb.y + bb.h / 2)\r\n\r\n    this.getFigures().each((i, f) => {\r\n      f.translate(dx, dy)\r\n    })\r\n    this.getLines().each((i, f) => {\r\n      f.translate(dx, dy)\r\n    })\r\n    this.centerView()\r\n  }\r\n\r\n})\r\n\r\n","import FigureTest from \"./FigureTest\"\r\n\r\nexport default class FigureCodeEdit {\r\n  constructor() {\r\n  }\r\n\r\n  show() {\r\n    Mousetrap.pause()\r\n    let code = shape_designer.app.getConfiguration(\"code\")\r\n    let splash = $(\r\n      '<pre id=\"code_overlay\">' +\r\n      code +\r\n      '</pre>' +\r\n      '<img title=\"Run\"   id=\"test_run\"   class=\"icon\" src=\"./images/dialog_run.svg\"/>' +\r\n      '<img title=\"Close\" id=\"code_close\" class=\"icon\" src=\"./images/dialog_close.svg\"/>'\r\n    )\r\n    splash.hide()\r\n    $(\"body\").append(splash)\r\n    splash.fadeIn()\r\n\r\n    let before = function (obj, method, wrapper) {\r\n      let orig = obj[method]\r\n      obj[method] = function () {\r\n        let args = Array.prototype.slice.call(arguments)\r\n        return wrapper.call(this, function () {\r\n          return orig.apply(obj, args)\r\n        }, args)\r\n      }\r\n\r\n      return obj[method]\r\n    }\r\n\r\n    let intersects = function (range) {\r\n      return editor.getSelectionRange().intersects(range)\r\n    }\r\n\r\n    let preventReadonly = function (next, args) {\r\n      if (intersects(range)) return\r\n      next()\r\n    }\r\n\r\n    let lines = code.split(\"\\n\")\r\n    let last = lines.length - 1\r\n    let first = lines.findIndex(function (element, index, array) {\r\n      return element.startsWith(\"testShape\")\r\n    })\r\n\r\n    let editor = ace.edit(\"code_overlay\"),\r\n      session = editor.getSession(),\r\n      Range = ace.require(\"ace/range\").Range,\r\n      range = new Range(0, 0, first, lines[first].length),\r\n      range2 = new Range(last, 0, last, lines[last].length)\r\n\r\n    session.addMarker(range, \"readonly-highlight\")\r\n    session.addMarker(range2, \"readonly-highlight\")\r\n    session.setMode(\"ace/mode/javascript\")\r\n    session.setUseWrapMode(true)\r\n    editor.moveCursorTo(first + 1, 0)\r\n    editor.focus()\r\n\r\n    editor.keyBinding.addKeyboardHandler({\r\n      handleKeyboard: function (data, hash, keyString, keyCode, event) {\r\n        if (hash === -1 || (keyCode <= 40 && keyCode >= 37)) return false\r\n\r\n        if (intersects(range) || intersects(range2)) {\r\n          return {command: \"null\", passEvent: false}\r\n        }\r\n      }\r\n    })\r\n\r\n    before(editor, 'onPaste', preventReadonly)\r\n    before(editor, 'onCut', preventReadonly)\r\n\r\n    range.start = session.doc.createAnchor(range.start)\r\n    range.end = session.doc.createAnchor(range.end)\r\n    range.end.$insertRight = true\r\n\r\n    range2.start = session.doc.createAnchor(range2.start)\r\n    range2.end = session.doc.createAnchor(range2.end)\r\n    range2.end.$insertRight = true\r\n\r\n    $(\"#code_close\").on(\"click\", function () {\r\n      let code = editor.getValue()\r\n      shape_designer.app.setConfiguration({code: code})\r\n      Mousetrap.unpause()\r\n      splash.fadeOut(function () {\r\n        splash.remove()\r\n      })\r\n    })\r\n\r\n    $(\"#test_run\").on(\"click\", function () {\r\n      let code = editor.getValue()\r\n      shape_designer.app.setConfiguration({code: code})\r\n      new FigureTest().show()\r\n    })\r\n  }\r\n}\r\n","var MarkdownIt = require('markdown-it');\r\n\r\nexport default class FigureMarkdownEdit {\r\n\r\n  constructor() {\r\n    this.mdHtml = null\r\n    this.scrollMap = null\r\n\r\n    this.lineHeight = 1.45\r\n    this.defaults = {\r\n      html: true,               // Enable HTML tags in source\r\n      xhtmlOut: false,          // Use '/' to close single tags (<br />)\r\n      breaks: false,            // Convert '\\n' in paragraphs into <br>\r\n      langPrefix: 'language-',  // CSS language prefix for fenced blocks\r\n      linkify: true,            // autoconvert URL-like texts to links\r\n      linkTarget: '_blank',     // set target to open link in\r\n      typographer: true         // Enable smartypants and other sweet transforms\r\n    }\r\n  }\r\n\r\n  /**\r\n   */\r\n  show() {\r\n    Mousetrap.pause()\r\n    var _this = this\r\n    this.mdHtml = new MarkdownIt(this.defaults)\r\n\r\n    var markdown = shape_designer.app.getConfiguration(\"markdown\")\r\n    markdown = markdown ? markdown : \"# Header \\n## Subheader \\nbe nice and write a help file for your new \\ncreated ***DigitalTrainingStudion*** shape. \\n\\n  - point 1\\n  - point 2\\n  - point 3\"\r\n    var splash = $(\r\n      '<div id=\"FigureMarkdownEdit\" class=\"overlay-scale\">' +\r\n      '<pre class=\"source full-height\">' +\r\n      markdown +\r\n      '</pre>' +\r\n      '<div class=\"preview full-height\" >' +\r\n      '' +\r\n      '</div>' +\r\n      ' <div class=\"header\">' +\r\n      '<span class=\"left\">Documentation Editor (<a target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Markdown\">markdown syntax </a>)</span>' +\r\n      '<span class=\"right\">HTML Preview</span></div>' +\r\n      ' <img title=\"Close\" id=\"test_close\" class=\"icon\" src=\"./images/dialog_close.svg\"/>' +\r\n      '<div>')\r\n\r\n    // fadeTo MUSS leider sein. Man kann mit raphael keine paper.text elemente einfügen\r\n    // wenn das canvas nicht sichtbar ist. In diesen Fall mach ich das Canvas \"leicht\" sichtbar und raphael ist\r\n    // zufrieden.\r\n    $(\"body\").append(splash)\r\n\r\n    var removeDialog = function () {\r\n      Mousetrap.unpause()\r\n      shape_designer.app.setConfiguration({markdown: _this.editor.getValue()})\r\n      splash.removeClass(\"open\")\r\n      setTimeout(function () {\r\n        splash.remove()\r\n      }, 400)\r\n    }\r\n\r\n    $(\"#test_close\").on(\"click\", removeDialog)\r\n    setTimeout(function () {\r\n      splash.addClass(\"open\")\r\n    }, 100)\r\n\r\n\r\n    // Inject line numbers for sync scroll.\r\n    //\r\n    this.mdHtml.renderer.rules.paragraph_open = function (tokens, idx) {\r\n      var line\r\n      if (tokens[idx].lines && tokens[idx].level === 0) {\r\n        line = tokens[idx].lines[0]\r\n        return '<p class=\"line\" data-line=\"' + line + '\">'\r\n      }\r\n      return '<p>'\r\n    }\r\n\r\n    this.mdHtml.renderer.rules.heading_open = function (tokens, idx) {\r\n      var line\r\n      if (tokens[idx].lines && tokens[idx].level === 0) {\r\n        line = tokens[idx].lines[0]\r\n        return '<h' + tokens[idx].hLevel + ' class=\"line\" data-line=\"' + line + '\">'\r\n      }\r\n      return '<h' + tokens[idx].hLevel + '>'\r\n    }\r\n\r\n    this.$preview = $(\"#FigureMarkdownEdit .preview\")\r\n    this.$source = $('#FigureMarkdownEdit .source')\r\n\r\n    var editor = ace.edit(this.$source[0]),\r\n      session = editor.getSession()\r\n    this.editor = editor\r\n    editor.moveCursorTo(5, 0)\r\n    editor.focus()\r\n\r\n    session.setMode(\"ace/mode/markdown\")\r\n\r\n    session.on('changeScrollTop', _this._debounce($.proxy(_this.syncScroll, _this), 50, false))\r\n\r\n    editor.keyBinding.addKeyboardHandler({handleKeyboard: _this._debounce($.proxy(_this.updateResult, _this), 300, false)})\r\n\r\n    this.updateResult()\r\n  }\r\n\r\n  updateResult() {\r\n    var source = this.editor.getValue()\r\n    this.$preview.html(this.mdHtml.render(source))\r\n    // reset lines mapping cache on content update\r\n    this.scrollMap = null\r\n  }\r\n\r\n\r\n  // Build offsets for each line (lines can be wrapped)\r\n  // That's a bit dirty to process each line everytime, but ok for demo.\r\n  // Optimizations are required only for big texts.\r\n  buildScrollMap() {\r\n    var _this = this\r\n\r\n    var i, offset, nonEmptyList, pos, a, b, lineHeightMap, linesCount,\r\n      acc, sourceLikeDiv,\r\n      _scrollMap\r\n\r\n    sourceLikeDiv = $('<div />').css({\r\n      position: 'absolute',\r\n      visibility: 'hidden',\r\n      height: 'auto',\r\n      width: $(\"#FigureMarkdownEdit .left\")[0].clientWidth,\r\n      'font-size': '10pt',\r\n      'font-family': 'tahoma',\r\n      'line-height': this.lineHeight,\r\n      'white-space': 'nowrap'\r\n    }).appendTo('body')\r\n\r\n    offset = this.$preview.scrollTop() - this.$preview.offset().top - 40\r\n    _scrollMap = []\r\n    nonEmptyList = []\r\n    lineHeightMap = []\r\n\r\n    acc = 0\r\n    this.editor.getValue().split('\\n').forEach(function (str) {\r\n      var h, lh\r\n\r\n      lineHeightMap.push(acc)\r\n\r\n      if (str.length === 0) {\r\n        acc++\r\n        return\r\n      }\r\n\r\n      sourceLikeDiv.text(str)\r\n      h = parseFloat(sourceLikeDiv.css('height'))\r\n      lh = parseFloat(_this.lineHeight)\r\n      acc += Math.round(h / lh)\r\n    })\r\n    sourceLikeDiv.remove()\r\n    lineHeightMap.push(acc)\r\n    linesCount = acc\r\n\r\n    for (i = 0; i < linesCount; i++) {\r\n      _scrollMap.push(-1)\r\n    }\r\n\r\n    nonEmptyList.push(0)\r\n    _scrollMap[0] = 0\r\n\r\n    $('.line').each(function (n, el) {\r\n      var $el = $(el), t = $el.data('line')\r\n      if (t === '') {\r\n        return\r\n      }\r\n      t = lineHeightMap[t]\r\n      if (t !== 0) {\r\n        nonEmptyList.push(t)\r\n      }\r\n      _scrollMap[t] = Math.round($el.offset().top + offset)\r\n    })\r\n\r\n    nonEmptyList.push(linesCount)\r\n    _scrollMap[linesCount] = this.$preview[0].scrollHeight\r\n\r\n    pos = 0\r\n    for (i = 1; i < linesCount; i++) {\r\n      if (_scrollMap[i] !== -1) {\r\n        pos++\r\n        continue\r\n      }\r\n\r\n      a = nonEmptyList[pos]\r\n      b = nonEmptyList[pos + 1]\r\n      _scrollMap[i] = Math.round((_scrollMap[b] * (i - a) + _scrollMap[a] * (b - i)) / (b - a))\r\n    }\r\n\r\n    return _scrollMap\r\n  }\r\n\r\n\r\n  syncScroll(scroll) {\r\n    var lineNo, posTo\r\n    lineNo = Math.floor(scroll / this.lineHeight)\r\n    if (!this.scrollMap) {\r\n      this.scrollMap = this.buildScrollMap()\r\n    }\r\n    posTo = this.scrollMap[lineNo]\r\n    this.$preview.stop(true).animate({\r\n      scrollTop: posTo\r\n    }, 400, 'linear')\r\n  }\r\n\r\n  // Returns a function, that, as long as it continues to be invoked, will not\r\n  // be triggered. The function will be called after it stops being called for\r\n  // N milliseconds. If `immediate` is passed, trigger the function on the\r\n  // leading edge, instead of the trailing.\r\n  _debounce(func, wait, immediate) {\r\n    var timeout\r\n    return function () {\r\n      var context = this, args = arguments\r\n      var later = function () {\r\n        timeout = null\r\n        if (!immediate) func.apply(context, args)\r\n      }\r\n      var callNow = immediate && !timeout\r\n      clearTimeout(timeout)\r\n      timeout = setTimeout(later, wait)\r\n      if (callNow) func.apply(context, args)\r\n    }\r\n  }\r\n}\r\n","import FigureWriter from \"./../io/FigureWriter\"\r\n\r\nexport default class FigureTest {\r\n\r\n  constructor() {\r\n    this.simulationContext = {}\r\n  }\r\n\r\n  show() {\r\n    var _this = this\r\n    this.animationFrameFunc = this._calculate.bind(this)\r\n\r\n    this.simulationContext = {}\r\n\r\n    var writer = new FigureWriter()\r\n    var testShape = null\r\n    writer.marshal(shape_designer.app.view, \"testShape\", function (js) {\r\n      try {\r\n        js = $(\"#decoratedport-template\").text().trim() + js\r\n        testShape = eval(js)\r\n      }\r\n      catch (exc) {\r\n        alert(\"Error in shape code. \\nRemove error and try it again:\\n\\n>>    \" + exc)\r\n        throw exc\r\n      }\r\n      var splash = $(\r\n        '<div class=\"overlay-scale\">' +\r\n        '<div id=\"test_canvas\">' +\r\n        '</div>' +\r\n        ' <div               id=\"test_info\" >Test page for your designed and coded draw2d shape.</div>' +\r\n        ' <img title=\"Close\" id=\"test_close\" class=\"icon\" src=\"./images/dialog_close.svg\"/>' +\r\n        '<div>')\r\n\r\n      // fadeTo MUSS leider sein. Man kann mit raphael keine paper.text elemente einfügen\r\n      // wenn das canvas nicht sichtbar ist. In diesen Fall mach ich das Canvas \"leicht\" sichtbar und raphael ist\r\n      // zufrieden.\r\n      $(\"body\").append(splash)\r\n\r\n      var canvas = new draw2d.Canvas(\"test_canvas\")\r\n      _this.canvas = canvas\r\n      canvas.installEditPolicy(new draw2d.policy.canvas.ShowDotEditPolicy(20, 1, \"#FF4981\"))\r\n      var router = new draw2d.layout.connection.InteractiveManhattanConnectionRouter()\r\n      canvas.installEditPolicy(new draw2d.policy.connection.ComposedConnectionCreatePolicy(\r\n        [\r\n          // create a connection via Drag&Drop of ports\r\n          //\r\n          new draw2d.policy.connection.DragConnectionCreatePolicy({\r\n            createConnection: function () {\r\n              return new draw2d.Connection({\r\n                radius: 3,\r\n                stroke: 2,\r\n                color: \"#129CE4\",\r\n                outlineStroke: 1,\r\n                outlineColor: \"#ffffff\",\r\n                router: router\r\n              })\r\n            }\r\n          }),\r\n          // or via click and point\r\n          //\r\n          new draw2d.policy.connection.OrthogonalConnectionCreatePolicy({\r\n            createConnection: function () {\r\n              return new draw2d.Connection({\r\n                radius: 3,\r\n                stroke: 2,\r\n                color: \"#129CE4\",\r\n                outlineStroke: 1,\r\n                outlineColor: \"#ffffff\",\r\n                router: router\r\n              })\r\n            }\r\n          })\r\n        ])\r\n      )\r\n      var test = new testShape()\r\n      canvas.add(test, 400, 160)\r\n\r\n      // create and add two nodes which contains Ports (In and OUT)\r\n      //\r\n      var start = new draw2d.shape.node.Start()\r\n      var toggle1 = new shape_designer.figure.TestSwitch()\r\n      var toggle2 = new shape_designer.figure.TestSwitch()\r\n      var end = new draw2d.shape.node.End()\r\n\r\n      // ...add it to the canvas\r\n      canvas.add(toggle1, 50, 150)\r\n      canvas.add(toggle2, 50, 200)\r\n      canvas.add(start, 50, 250)\r\n      canvas.add(end, 630, 250)\r\n\r\n      canvas.setCurrentSelection(test)\r\n      var removeDialog = function () {\r\n        _this.simulate = false\r\n        splash.removeClass(\"open\")\r\n        setTimeout(function () {\r\n          splash.remove()\r\n          test.onStop(_this.simulationContext)\r\n        }, 400)\r\n      }\r\n\r\n      $(\"#test_close\").on(\"click\", removeDialog)\r\n      splash.addClass(\"open\")\r\n\r\n      test.onStart(_this.simulationContext)\r\n\r\n      _this.simulate = true\r\n      requestAnimationFrame(_this.animationFrameFunc)\r\n    })\r\n\r\n  }\r\n\r\n  _calculate() {\r\n    // call the \"calculate\" method if given to calculate the output-port values\r\n    //\r\n    var _this = this\r\n    var figures = this.canvas.getFigures().clone().grep(function (f) {\r\n      return f.calculate\r\n    })\r\n    figures.each(function (i, figure) {\r\n      figure.calculate(_this.simulationContext)\r\n    })\r\n\r\n    // transport the value from oututPort to inputPort\r\n    //\r\n    this.canvas.getLines().each(function (i, line) {\r\n      var outPort = line.getSource()\r\n      var inPort = line.getTarget()\r\n      inPort.setValue(outPort.getValue())\r\n      line.setColor(outPort.getValue() ? \"#ff5252\" : \"#0000ff\")\r\n    })\r\n\r\n    if (this.simulate === true) {\r\n      requestAnimationFrame(this.animationFrameFunc)\r\n    }\r\n  }\r\n}\r\n","import conf from \"../Configuration\"\r\nimport Hogan from \"hogan.js\"\r\n\r\nexport default class FileOpen {\r\n\r\n  /**\r\n   * @constructor\r\n   *\r\n   */\r\n  constructor() {\r\n  }\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * Open the file picker and load the selected file.<br>\r\n   *\r\n   * @param {Function} successCallback callback method if the user select a file and the content is loaded\r\n   * @param {Function} errorCallback method to call if any error happens\r\n   *\r\n   * @since 4.0.0\r\n   */\r\n  show(storage, view) {\r\n    $('#fileOpenDialog').modal('show')\r\n    this.fetchPathContent(storage, storage.currentDir, view)\r\n  }\r\n\r\n  fetchPathContent(storage, newPath, view) {\r\n    storage.getFiles(newPath).then((files) => {\r\n      files = files.filter( file => file.name.endsWith(conf.fileSuffix))\r\n      let compiled = Hogan.compile(\r\n        `\r\n               {{^rootDir}}     \r\n               <a href=\"#\" class=\"list-group-item githubPath\" data-type=\"dir\" data-path=\"{{parentPath}}\" >\r\n                   <span class=\"glyphicon glyphicon-menu-left\"></span>\r\n                   ..\r\n               </a>\r\n               {{/rootDir}}\r\n               {{#files}}\r\n                 <a href=\"#\" data-draw2d=\"{{draw2d}}\" class=\"list-group-item githubPath text-nowrap\" data-type=\"{{type}}\" data-path=\"{{currentDir}}{{name}}\" data-id=\"{{id}}\">\r\n                    <span class=\"glyphicon {{icon}}\"></span>\r\n                    {{{name}}}\r\n                 </a>\r\n               {{/files}}\r\n          `\r\n      )\r\n\r\n      let parentPath = storage.dirname(newPath)\r\n      let output = compiled.render({\r\n        parentPath: parentPath,\r\n        currentDir: storage.currentDir,\r\n        files: files,\r\n        rootDir: newPath === null,\r\n        draw2d: function () {\r\n          return this.name.endsWith(conf.fileSuffix)\r\n        },\r\n        icon: function () {\r\n          if (this.name.endsWith(conf.fileSuffix)) {\r\n            return \"fa fa-object-group\"\r\n          }\r\n          return this.type === \"dir\" ? \"fa fa-folder-o\" : \"fa fa-file-o\"\r\n        }\r\n      })\r\n\r\n      $(\"#fileOpenDialog .list-group\").html($(output))\r\n      $(\"#fileOpenDialog .list-group\").scrollTop(0)\r\n\r\n\r\n      $(\".githubPath[data-type='dir']\").on(\"click\", (event) => {\r\n        this.fetchPathContent(storage, $(event.currentTarget).data(\"path\"), view)\r\n      })\r\n\r\n      $('.githubPath*[data-draw2d=\"true\"][data-type=\"file\"]').on(\"click\", (event) => {\r\n        let path = $(event.currentTarget).data(\"path\")\r\n        storage.loadFile(path)\r\n          .then((content) => {\r\n            $('#fileOpenDialog').modal('hide')\r\n            storage.currentFile = path\r\n            view.clear()\r\n            new draw2d.io.json.Reader().unmarshal(view, content)\r\n            view.app.getConfiguration()\r\n            view.getCommandStack().markSaveLocation()\r\n            view.centerDocument()\r\n            return content\r\n          })\r\n        event.preventDefault()\r\n      })\r\n    })\r\n  }\r\n}\r\n","import conf from \"./../Configuration\"\r\n\r\nexport default class FileSave {\r\n\r\n  /**\r\n   * @constructor\r\n   *\r\n   */\r\n  constructor() {\r\n  }\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * Open the file picker and load the selected file.<br>\r\n   *\r\n   * @param {Function} successCallback callback method if the user select a file and the content is loaded\r\n   * @param {Function} errorCallback method to call if any error happens\r\n   *\r\n   * @since 4.0.0\r\n   */\r\n  show(storage, canvas) {\r\n\r\n    new draw2d.io.png.Writer().marshal(canvas, imageDataUrl => {\r\n      $(\"#fileSaveDialog .filePreview\").attr(\"src\", imageDataUrl)\r\n      $(\"#fileSaveDialog .githubFileName\").val(storage.currentFile?storage.currentFile:\"NewDocument\"+conf.fileSuffix)\r\n\r\n      $('#fileSaveDialog').on('shown.bs.modal', (event) => {\r\n        $(event.currentTarget).find('input:first').focus()\r\n      })\r\n      $(\"#fileSaveDialog\").modal(\"show\")\r\n      Mousetrap.pause()\r\n\r\n      // Button: Commit to GitHub\r\n      //\r\n      $(\"#fileSaveDialog .okButton\").off('click').on(\"click\", () => {\r\n        Mousetrap.unpause()\r\n        let writer = new draw2d.io.json.Writer()\r\n        writer.marshal(canvas, json => {\r\n          let newName = $(\"#fileSaveDialog .githubFileName\").val()\r\n          storage.saveFile(json, imageDataUrl, newName)\r\n            .then(() => {\r\n              storage.currentFile = newName\r\n              $('#fileSaveDialog').modal('hide')\r\n            });\r\n        })\r\n      })\r\n    }, canvas.getBoundingBox().scale(20, 20))\r\n  }\r\n}\r\n","import conf from \"./../Configuration\"\r\nimport Hogan from \"hogan.js\"\r\n\r\nexport default class FileSaveAs {\r\n\r\n  /**\r\n   * @constructor\r\n   *\r\n   */\r\n  constructor() {\r\n  }\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * Open the file picker and load the selected file.\r\n   *\r\n   * @since 4.0.0\r\n   */\r\n  show(storage, canvas) {\r\n    if (storage.currentFile === null) {\r\n      storage.currentFile = \"DocumentName\" + conf.fileSuffix\r\n    }\r\n\r\n    new draw2d.io.png.Writer().marshal(canvas, (imageDataUrl) => {\r\n      // else reopen the already selected directory\r\n      $(\"#githubFileSaveAsDialog .okButton\").prop(\"disabled\", false)\r\n      this.fetchPathContent(storage, storage.currentDir)\r\n\r\n      $(\"#githubFileSaveAsDialog .filePreview\").attr(\"src\", imageDataUrl)\r\n      $(\"#githubFileSaveAsDialog .githubFileName\").val(storage.currentFile)\r\n\r\n      $('#githubFileSaveAsDialog').off('shown.bs.modal').on('shown.bs.modal', (event) =>{\r\n        $(event.currentTarget).find('input:first').focus()\r\n      })\r\n      $(\"#githubFileSaveAsDialog\").modal(\"show\")\r\n      Mousetrap.pause()\r\n\r\n      // Button: Commit to GitHub\r\n      //\r\n      $(\"#githubFileSaveAsDialog .okButton\").off('click').on(\"click\",  () => {\r\n        Mousetrap.unpause()\r\n        let writer = new draw2d.io.json.Writer()\r\n        writer.marshal(canvas, (json) => {\r\n          var title = $(\"#githubFileSaveAsDialog .githubFileName\").val()\r\n          storage.saveFile(json, imageDataUrl, title)\r\n          .then( () => {\r\n            storage.currentFile = name\r\n            $('#githubFileSaveAsDialog').modal('hide')\r\n          })\r\n        })\r\n      })\r\n    }, canvas.getBoundingBox().scale(20, 20))\r\n  }\r\n\r\n  fetchPathContent(storage, newPath) {\r\n    storage.getFiles(newPath).then( (files) => {\r\n        storage.currentFile = newPath\r\n        let compiled = Hogan.compile(\r\n          '         <a href=\"#\" class=\"list-group-item githubPath\" data-type=\"{{parentType}}\" data-path=\"{{parentPath}}\" >' +\r\n          '             <span class=\"glyphicon glyphicon-menu-left\"></span>' +\r\n          '             ..' +\r\n          '         </a>' +\r\n          '         {{#files}}' +\r\n          '           <a href=\"#\" data-draw2d=\"{{draw2d}}\" class=\"list-group-item githubPath text-nowrap\" data-type=\"{{type}}\" data-path=\"{{currentDir}}{{name}}\" data-title=\"{{name}}\" data-id=\"{{id}}\" data-sha=\"{{sha}}\">' +\r\n          '              <span class=\"glyphicon {{icon}}\"></span>' +\r\n          '              {{{name}}}' +\r\n          '           </a>' +\r\n          '         {{/files}}'\r\n        )\r\n\r\n\r\n        let parentPath = storage.dirname(newPath)\r\n        let output = compiled.render({\r\n          parentPath: parentPath,\r\n          currentDir: storage.currentDir,\r\n          files: files,\r\n          draw2d: function () {\r\n            return this.name.endsWith(conf.fileSuffix)\r\n          },\r\n          icon: function () {\r\n            if (this.name.endsWith(conf.fileSuffix)) {\r\n              return \"fa fa-object-group\"\r\n            }\r\n            return this.type === \"dir\" ? \"fa fa-folder-o\" : \"fa fa-file-o\"\r\n          }\r\n        })\r\n        $(\"#githubFileSaveAsDialog .list-group\").html($(output))\r\n        $(\"#githubFileSaveAsDialog .list-group\").scrollTop(0)\r\n\r\n        //we are in a folder. Create of a file is possible now\r\n        //\r\n        $(\"#githubFileSaveAsDialog .okButton\").prop(\"disabled\", false)\r\n\r\n\r\n        $(\".githubPath[data-type='dir']\").on(\"click\",  (event) =>{\r\n          this.fetchPathContent(storage, $(event.currentTarget).data(\"path\"))\r\n        })\r\n\r\n        $('.githubPath*[data-draw2d=\"true\"][data-type=\"file\"]').on(\"click\",  (event) => {\r\n          let path = $(event.currentTarget).data(\"path\")\r\n          let title = path.split(/[\\\\/]/).pop() // basename\r\n          $(\"#githubFileSaveAsDialog .githubFileName\").val(title)\r\n        })\r\n      })\r\n  }\r\n}\r\n","export default draw2d.SetFigure.extend({\r\n\r\n  NAME: \"CircuitFigure\",\r\n\r\n  init: function (attr, setter, getter) {\r\n    this.tooltip = null\r\n    this.tooltipTimer = -1\r\n\r\n    this._super($.extend({stroke: 0, bgColor: null, width: 30, height: 32}, attr), setter, getter)\r\n\r\n    this.persistPorts = false\r\n    this.zoomCallback = $.proxy(this.positionTooltip, this)\r\n\r\n    this.on(\"dragstart\", () => {\r\n      this.hideTooltip(true)\r\n    })\r\n\r\n    this.on(\"mouseenter\", () => {\r\n      this.tooltipTimer = window.setTimeout( () =>{\r\n        this.tooltipTimer = -1\r\n        this.showTooltip()\r\n      }, 500)\r\n    })\r\n\r\n    this.on(\"mouseleave\", () => {\r\n      this.hideTooltip()\r\n    })\r\n\r\n    this.on(\"move\", () => {\r\n      this.positionTooltip()\r\n    })\r\n  },\r\n\r\n  setCanvas: function (canvas) {\r\n    if (this.canvas !== null) this.canvas.off(this.zoomCallback)\r\n    this._super(canvas)\r\n    if (this.canvas !== null) this.canvas.on(\"zoom\", this.zoomCallback)\r\n  },\r\n\r\n  hideTooltip: function (fast) {\r\n    if (this.tooltipTimer !== -1) {\r\n      window.clearTimeout(this.tooltipTimer)\r\n      this.tooltipTimer = -1\r\n    }\r\n    else if (this.tooltip !== null) {\r\n      if (fast) {\r\n        this.tooltip.remove()\r\n      }\r\n      else {\r\n        this.tooltip.fadeOut(500, function () {\r\n          $(this).remove()\r\n        })\r\n      }\r\n      this.tooltip = null\r\n    }\r\n  },\r\n\r\n  showTooltip: function () {\r\n    this.tooltip = $('<div class=\"draw2d_tooltip\">'+this.NAME+'</div>')\r\n      .appendTo('body')\r\n      .hide()\r\n      .fadeIn(1000)\r\n    this.positionTooltip()\r\n  },\r\n\r\n\r\n  positionTooltip: function () {\r\n    if (this.tooltip === null) {\r\n      return\r\n    }\r\n\r\n    let width = this.tooltip.outerWidth(true)\r\n    let pos = this.canvas.fromCanvasToDocumentCoordinate(\r\n      this.getAbsoluteX() + this.getWidth() / 2 - width / 2 + 8,\r\n      this.getAbsoluteY() + this.getHeight() + 10)\r\n\r\n    this.tooltip.css({'top': pos.y, 'left': pos.x})\r\n  },\r\n\r\n  applyAlpha: function () {\r\n  },\r\n\r\n  layerGet: function (name, attributes) {\r\n      if (this.svgNodes === null) return null\r\n      let found = null\r\n      this.svgNodes.forEach(function (shape) {\r\n        if (found ===null && shape.data(\"name\") === name) {\r\n          found = shape\r\n        }\r\n      })\r\n      return found\r\n  },\r\n\r\n  layerAttr: function (name, attributes) {\r\n    if (this.svgNodes === null) return\r\n\r\n    this.svgNodes.forEach(function (shape) {\r\n      if (shape.data(\"name\") === name) {\r\n        shape.attr(attributes)\r\n      }\r\n    })\r\n  },\r\n\r\n  layerShow: function (name, flag, duration) {\r\n    if (this.svgNodes === null) return\r\n\r\n    if (duration) {\r\n      this.svgNodes.forEach(function (node) {\r\n        if (node.data(\"name\") === name) {\r\n          if (flag) {\r\n            node.attr({opacity: 0}).show().animate({opacity: 1}, duration)\r\n          }\r\n          else {\r\n            node.animate({opacity: 0}, duration, function () {\r\n              this.hide()\r\n            })\r\n          }\r\n        }\r\n      })\r\n    }\r\n    else {\r\n      this.svgNodes.forEach(function (node) {\r\n        if (node.data(\"name\") === name) {\r\n          if (flag) {\r\n            node.show()\r\n          }\r\n          else {\r\n            node.hide()\r\n          }\r\n        }\r\n      })\r\n    }\r\n  },\r\n\r\n  calculate: function (context) {\r\n  },\r\n\r\n  onStart: function (context) {\r\n  },\r\n\r\n  onStop: function (context) {\r\n  },\r\n\r\n  getParameterSettings: function () {\r\n    return []\r\n  },\r\n\r\n\r\n  getRequiredHardware: function(){\r\n    return {\r\n      raspi: false,\r\n      arduino: false\r\n    }\r\n  },\r\n  \r\n  onDrop: function (dropTarget, x, y, shiftKey, ctrlKey) {\r\n    // Activate a \"smart insert\" If the user drop this figure on connection\r\n    //\r\n    /*\r\n    if (dropTarget instanceof draw2d.Connection) {\r\n      let additionalConnection = dropTarget.getCanvas().createConnection()\r\n      let oldSource = dropTarget.getSource()\r\n      let oldTarget = dropTarget.getTarget()\r\n      if (oldSource instanceof draw2d.InputPort) {\r\n        oldSource = dropTarget.getTarget()\r\n        oldTarget = dropTarget.getSource()\r\n      }\r\n\r\n      let stack = this.getCanvas().getCommandStack()\r\n      let cmd = new draw2d.command.CommandReconnect(dropTarget)\r\n      cmd.setNewPorts(oldSource, this.getInputPort(0))\r\n      stack.execute(cmd)\r\n\r\n      cmd = new draw2d.command.CommandConnect(oldTarget, this.getOutputPort(0))\r\n      cmd.setConnection(additionalConnection)\r\n      stack.execute(cmd)\r\n    }\r\n    */\r\n  },\r\n\r\n\r\n  /**\r\n   * @method\r\n   * Return an objects with all important attributes for XML or JSON serialization\r\n   *\r\n   * @returns {Object}\r\n   */\r\n  getPersistentAttributes: function () {\r\n    let memento = this._super()\r\n\r\n    // add all decorations to the memento\r\n    //\r\n    memento.labels = []\r\n    this.children.each(function (i, e) {\r\n      let labelJSON = e.figure.getPersistentAttributes()\r\n      labelJSON.locator = e.locator.NAME\r\n      memento.labels.push(labelJSON)\r\n    })\r\n\r\n    return memento\r\n  },\r\n\r\n  /**\r\n   * @method\r\n   * Read all attributes from the serialized properties and transfer them into the shape.\r\n   *\r\n   * @param {Object} memento\r\n   * @returns\r\n   */\r\n  setPersistentAttributes: function (memento) {\r\n    this._super(memento)\r\n\r\n    // remove all decorations created in the constructor of this element\r\n    //\r\n    this.resetChildren()\r\n\r\n    // and add all children of the JSON document.\r\n    //\r\n    $.each(memento.labels, $.proxy(function (i, json) {\r\n      // create the figure stored in the JSON\r\n      let figure = eval(\"new \" + json.type + \"()\")\r\n\r\n      // apply all attributes\r\n      figure.attr(json)\r\n\r\n      // instantiate the locator\r\n      let locator = eval(\"new \" + json.locator + \"()\")\r\n\r\n      // add the new figure as child to this figure\r\n      this.add(figure, locator)\r\n    }, this))\r\n  }\r\n})\r\n\r\n","export default shape_designer.figure.DecoratedInputPort = draw2d.InputPort.extend({\r\n\r\n  init: function (attr, setter, getter) {\r\n    this.hasChanged = true\r\n\r\n    this._super(attr, setter, getter)\r\n\r\n    this.decoration = new shape_designer.figure.MarkerFigure()\r\n\r\n    this.add(this.decoration, new draw2d.layout.locator.LeftLocator({margin: 8}))\r\n\r\n\r\n    // a port can have a value. Useful for workflow engines or circuit diagrams\r\n    this.setValue(true)\r\n  },\r\n\r\n  useDefaultValue: function () {\r\n    this.decoration.setStick(true)\r\n  },\r\n\r\n  setValue: function (value) {\r\n    this.hasChanged = this.value !== value\r\n    this._super(value)\r\n  },\r\n\r\n  hasChangedValue: function () {\r\n    return this.hasChanged\r\n  },\r\n\r\n  hasRisingEdge: function () {\r\n    return this.hasChangedValue() && this.getValue()\r\n  },\r\n\r\n  hasFallingEdge: function () {\r\n    return this.hasChangedValue() && !this.getValue()\r\n  }\r\n})\r\n","\r\nexport default shape_designer.figure.ExtLabel = draw2d.shape.basic.Label.extend({\r\n\r\n  NAME: \"shape_designer.figure.ExtLabel\",\r\n\r\n\r\n  init: function () {\r\n    this.blur = 0\r\n    this.isExtFigure = true\r\n\r\n    this._super()\r\n\r\n\r\n    this.setUserData({name: \"Label\"})\r\n\r\n    this.filters = new draw2d.util.ArrayList()\r\n    this.filters.add(new shape_designer.filter.PositionFilter())\r\n    this.filters.add(new shape_designer.filter.FontSizeFilter())\r\n    this.filters.add(new shape_designer.filter.FontColorFilter())\r\n\r\n    this.installEditor(new LabelInplaceEditor())\r\n  },\r\n\r\n  getPotentialFilters: function () {\r\n    return [\r\n      {label: \"Opacity\", impl: \"shape_designer.filter.OpacityFilter\"},\r\n      {label: \"Blur\", impl: \"shape_designer.filter.BlurFilter\"},\r\n      {label: \"Outline\", impl: \"shape_designer.filter.OutlineStrokeFilter\"},\r\n      {label: \"Gradient\", impl: \"shape_designer.filter.TextLinearGradientFilter\"},\r\n      {label: \"Font Size\", impl: \"shape_designer.filter.FontSizeFilter\"},\r\n      {label: \"Font Color\", impl: \"shape_designer.filter.FontColorFilter\"}\r\n    ]\r\n  },\r\n\r\n  setBlur: function (value) {\r\n    this.blur = value\r\n    this.repaint()\r\n  },\r\n\r\n  getBlur: function () {\r\n    return this.blur\r\n  },\r\n\r\n  removeFilter: function (filter) {\r\n    this.filters.remove(filter)\r\n\r\n    return this\r\n  },\r\n\r\n  addFilter: function (filter) {\r\n    var alreadyIn = false\r\n\r\n    this.filters.each($.proxy(function (i, e) {\r\n      alreadyIn = alreadyIn || (e.NAME === filter.NAME)\r\n    }, this))\r\n    if (alreadyIn === true) {\r\n      return // silently\r\n    }\r\n\r\n    this.filters.add(filter)\r\n    filter.onInstall(this)\r\n    this.repaint()\r\n\r\n    return this\r\n  },\r\n\r\n/*\r\n  setPosition: function(x, y) {\r\n    if (x instanceof draw2d.geo.Point) {\r\n      return this._super(\r\n        parseFloat(x.x.toFixed(1)),\r\n        parseFloat(x.y.toFixed(1)))\r\n    }\r\n\r\n    return this._super(\r\n      parseFloat(x.toFixed(1)),\r\n      parseFloat(y.toFixed(1)))\r\n  },\r\n*/\r\n\r\n    /**\r\n   * @method\r\n   * Trigger the repaint of the element.\r\n   *\r\n   */\r\n  repaint: function (attributes) {\r\n    if (this.shape === null) {\r\n      return\r\n    }\r\n\r\n    if (typeof attributes === \"undefined\") {\r\n      attributes = {}\r\n    }\r\n\r\n    // style the label\r\n    var lattr = {}\r\n    lattr.text = this.text\r\n    lattr[\"font-weight\"] = (this.bold === true) ? \"bold\" : \"normal\"\r\n    lattr[\"text-anchor\"] = \"start\"\r\n    lattr[\"font-size\"] = this.fontSize\r\n    if (this.fontFamily !== null) {\r\n      lattr[\"font-family\"] = this.fontFamily\r\n    }\r\n    lattr.fill = this.fontColor.hash()\r\n    // since 4.2.1\r\n    lattr.stroke = this.outlineColor.hash()\r\n    lattr[\"stroke-width\"] = this.outlineStroke\r\n\r\n    this.filters.each($.proxy(function (i, filter) {\r\n      filter.apply(this, attributes, lattr)\r\n    }, this))\r\n\r\n    this.svgNodes.attr(lattr)\r\n    // set of the x/y must be done AFTER the font-size and bold has been set.\r\n    // Reason: the getHeight method needs the font-size for calculation because\r\n    //         it redirects the calculation to the SVG element.\r\n    this.svgNodes.attr({x: this.padding.left, y: this.getHeight() / 2})\r\n\r\n    // jump over the normal Label implementation\r\n    draw2d.SetFigure.prototype.repaint.call(this, attributes)\r\n  },\r\n\r\n  getPersistentAttributes: function () {\r\n    var memento = this._super()\r\n\r\n    memento.filters = []\r\n    this.filters.each($.proxy(function (i, e) {\r\n      var filterMemento = e.getPersistentAttributes(this)\r\n      memento.filters.push(filterMemento)\r\n    }, this))\r\n\r\n    return memento\r\n  },\r\n\r\n  setPersistentAttributes: function (memento) {\r\n    this._super(memento)\r\n\r\n\r\n    if (typeof memento.filters !== \"undefined\") {\r\n      this.filters = new draw2d.util.ArrayList()\r\n      $.each(memento.filters, $.proxy(function (i, e) {\r\n        var filter = eval(\"new \" + e.name + \"()\")\r\n        filter.setPersistentAttributes(this, e)\r\n        this.filters.add(filter)\r\n      }, this))\r\n    }\r\n  }\r\n})\r\n","export default shape_designer.figure.ExtLine = draw2d.shape.basic.PolyLine.extend({\r\n\r\n  NAME: \"shape_designer.figure.ExtLine\",\r\n\r\n\r\n  init: function () {\r\n    this._super()\r\n\r\n    this.blur = 0\r\n    this.isExtFigure = true\r\n\r\n    this.setUserData({name: \"Line\"})\r\n\r\n    this.filters = new draw2d.util.ArrayList()\r\n    this.filters.add(new shape_designer.filter.StrokeFilter())\r\n\r\n    this.setRouter(new draw2d.layout.connection.VertexRouter())\r\n    this.installEditPolicy(new draw2d.policy.line.VertexSelectionFeedbackPolicy())\r\n  },\r\n\r\n  setBlur: function (value) {\r\n    this.blur = parseInt(value)\r\n    this.repaint()\r\n  },\r\n\r\n  getBlur: function () {\r\n    return this.blur\r\n  },\r\n\r\n  getPotentialFilters: function () {\r\n    return [\r\n      {label: \"Opacity\", impl: \"shape_designer.filter.OpacityFilter\"},\r\n      {label: \"Blur\", impl: \"shape_designer.filter.BlurFilter\"},\r\n      {label: \"Outline\", impl: \"shape_designer.filter.OutlineStrokeFilter\"},\r\n      {label: \"Corner Radius\", impl: \"shape_designer.filter.RadiusFilter\"},\r\n      {label: \"Stroke\", impl: \"shape_designer.filter.StrokeFilter\"}\r\n    ]\r\n  },\r\n\r\n  removeFilter: function (filter) {\r\n    this.filters.remove(filter)\r\n\r\n    return this\r\n  },\r\n\r\n  addFilter: function (filter) {\r\n    var alreadyIn = false\r\n\r\n    this.filters.each($.proxy(function (i, e) {\r\n      alreadyIn = alreadyIn || (e.NAME === filter.NAME)\r\n    }, this))\r\n    if (alreadyIn === true) {\r\n      return // silently\r\n    }\r\n\r\n    this.filters.add(filter)\r\n    filter.onInstall(this)\r\n    this.repaint()\r\n\r\n    return this\r\n  },\r\n\r\n\r\n  /**\r\n   * @method\r\n   * Trigger the repaint of the element.\r\n   *\r\n   */\r\n  repaint: function (attributes) {\r\n    if (this.shape === null) {\r\n      return\r\n    }\r\n\r\n    if (typeof attributes === \"undefined\") {\r\n      attributes = {}\r\n    }\r\n\r\n    this.filters.each($.proxy(function (i, filter) {\r\n      filter.apply(this, attributes)\r\n    }, this))\r\n\r\n//        this.shape.blur(this.blur);\r\n    this._super(attributes)\r\n  },\r\n\r\n  getPersistentAttributes: function () {\r\n    var memento = this._super()\r\n\r\n    memento.filters = []\r\n    this.filters.each($.proxy(function (i, e) {\r\n      var filterMemento = e.getPersistentAttributes(this)\r\n      memento.filters.push(filterMemento)\r\n    }, this))\r\n\r\n    return memento\r\n  },\r\n\r\n  setPersistentAttributes: function (memento) {\r\n    this._super(memento)\r\n\r\n\r\n    if (typeof memento.filters !== \"undefined\") {\r\n      this.filters = new draw2d.util.ArrayList()\r\n      $.each(memento.filters, $.proxy(function (i, e) {\r\n        var filter = eval(\"new \" + e.name + \"()\")\r\n        filter.setPersistentAttributes(this, e)\r\n        this.filters.add(filter)\r\n      }, this))\r\n    }\r\n  }\r\n})\r\n","import PositionFilter from \"../filter/PositionFilter\"\r\nimport SizeFilter from \"../filter/SizeFilter\"\r\nimport StrokeFilter from \"../filter/StrokeFilter\"\r\nimport FillColorFilter from \"../filter/FillColorFilter\"\r\n\r\n/* jshint evil:true */\r\n// required for serialie/deserialize of JSON\r\nexport default shape_designer.figure.ExtPolygon = draw2d.shape.basic.Polygon.extend({\r\n\r\n  NAME: \"shape_designer.figure.ExtPolygon\",\r\n\r\n\r\n  init: function (attr, setter, getter) {\r\n    this.blur = 0\r\n\r\n    this.isExtFigure = true\r\n\r\n    this._super(attr, setter, getter)\r\n\r\n    this.setUserData({name: \"Polygon\"})\r\n\r\n    this.filters = new draw2d.util.ArrayList()\r\n    this.filters.add(new PositionFilter())\r\n    this.filters.add(new SizeFilter())\r\n    this.filters.add(new StrokeFilter())\r\n    this.filters.add(new FillColorFilter())\r\n\r\n    this.installEditPolicy(new draw2d.policy.figure.RectangleSelectionFeedbackPolicy())\r\n  },\r\n\r\n  setBlur: function (value) {\r\n    this.blur = parseInt(value)\r\n    this.repaint()\r\n  },\r\n\r\n  getBlur: function () {\r\n    return this.blur\r\n  },\r\n\r\n  getPotentialFilters: function () {\r\n    return [\r\n      {label: \"Stroke\", impl: \"shape_designer.filter.StrokeFilter\"},\r\n      {label: \"Opacity\", impl: \"shape_designer.filter.OpacityFilter\"},\r\n      {label: \"Blur\", impl: \"shape_designer.filter.BlurFilter\"},\r\n      {label: \"Corner Radius\", impl: \"shape_designer.filter.RadiusFilter\"},\r\n      {label: \"Linear Gradient\", impl: \"shape_designer.filter.LinearGradientFilter\"},\r\n      {label: \"Fill Color\", impl: \"shape_designer.filter.FillColorFilter\"}\r\n    ]\r\n  },\r\n\r\n  removeFilter: function (filter) {\r\n    this.filters.remove(filter)\r\n  },\r\n\r\n  addFilter: function (filter) {\r\n    var alreadyIn = false\r\n\r\n    this.filters.each($.proxy(function (i, e) {\r\n      alreadyIn = alreadyIn || (e.NAME === filter.NAME)\r\n    }, this))\r\n\r\n    if (alreadyIn === true) {\r\n      return // silently\r\n    }\r\n\r\n    this.filters.add(filter)\r\n    filter.onInstall(this)\r\n    this.repaint()\r\n  },\r\n\r\n  onDoubleClick: function () {\r\n    this.installEditPolicy(new draw2d.policy.figure.VertexSelectionFeedbackPolicy())\r\n  },\r\n\r\n  /**\r\n   * @method\r\n   * Unselect the figure and propagete this event to all edit policies.\r\n   *\r\n   * @final\r\n   * @private\r\n   **/\r\n  unselect: function () {\r\n    this._super()\r\n\r\n    this.installEditPolicy(new draw2d.policy.figure.RectangleSelectionFeedbackPolicy())\r\n    return this\r\n  },\r\n\r\n\r\n  /**\r\n   * @method\r\n   * Trigger the repaint of the element.\r\n   *\r\n   */\r\n  repaint: function (attributes) {\r\n    if (this.shape === null) {\r\n      return\r\n    }\r\n\r\n    if (this.svgPathString === null) {\r\n      this.calculatePath()\r\n    }\r\n\r\n    if (typeof attributes === \"undefined\") {\r\n      attributes = {}\r\n    }\r\n\r\n\r\n    attributes.path = this.svgPathString\r\n\r\n    this.filters.each($.proxy(function (i, filter) {\r\n      filter.apply(this, attributes)\r\n    }, this))\r\n\r\n    //this.shape.blur(this.blur===0?-1:this.blur);\r\n    /*\r\n            if(this.filter)\r\n            this.filter = this.canvas.paper.createFilter();\r\n            filter.addShiftToColor(\"red\");\r\n            filter.addBlur(7);\r\n            this.shape.filter(filter);\r\n    */\r\n    this._super(attributes)\r\n  },\r\n\r\n  getPersistentAttributes: function () {\r\n    var memento = this._super()\r\n\r\n    memento.blur = this.blur\r\n    memento.filters = []\r\n    this.filters.each($.proxy(function (i, e) {\r\n      var filterMemento = e.getPersistentAttributes(this)\r\n      memento.filters.push(filterMemento)\r\n    }, this))\r\n\r\n    return memento\r\n  },\r\n\r\n  setPersistentAttributes: function (memento) {\r\n    this._super(memento)\r\n\r\n    if (typeof memento.blur !== \"undefined\")\r\n      this.setBlur(memento.blur)\r\n\r\n    if (typeof memento.filters !== \"undefined\") {\r\n      this.filters = new draw2d.util.ArrayList()\r\n      var sizeFilterAdded = false\r\n      $.each(memento.filters, $.proxy(function (i, e) {\r\n\r\n        var filter = eval(\"new \" + e.name + \"()\")\r\n        if (filter instanceof shape_designer.filter.SizeFilter) {\r\n          sizeFilterAdded = true\r\n        }\r\n        filter.setPersistentAttributes(this, e)\r\n        this.filters.add(filter)\r\n      }, this))\r\n      if (!sizeFilterAdded) {\r\n        this.filters.insertElementAt(new shape_designer.filter.SizeFilter(), 1)\r\n      }\r\n    }\r\n  }\r\n})\r\n","export default shape_designer.figure.ExtPort = draw2d.shape.basic.Circle.extend({\r\n\r\n  NAME: \"shape_designer.figure.ExtPort\",\r\n\r\n\r\n  init: function () {\r\n    this.isExtFigure = true\r\n    this.decoration = null\r\n    this._super({\r\n      bgColor: \"#37B1DE\",\r\n      diameter: 10\r\n    })\r\n\r\n\r\n    this.setUserData({\r\n      name: \"Port\",\r\n      type: \"Hybrid\",\r\n      direction: null,\r\n      fanout: 20\r\n    })\r\n\r\n    this.filters = new draw2d.util.ArrayList()\r\n    this.filters.add(new shape_designer.filter.PositionFilter())\r\n    this.filters.add(new shape_designer.filter.FanoutFilter())\r\n    this.filters.add(new shape_designer.filter.PortDirectionFilter())\r\n    this.filters.add(new shape_designer.filter.PortTypeFilter())\r\n\r\n    this.installEditPolicy(new draw2d.policy.figure.AntSelectionFeedbackPolicy())\r\n  },\r\n\r\n\r\n  setInputType: function (type) {\r\n    this.getUserData().type = type\r\n  },\r\n\r\n  getInputType: function () {\r\n    return this.getUserData().type\r\n  },\r\n\r\n  setMaxFanOut: function (count) {\r\n    this.getUserData().fanout = parseInt(count)\r\n  },\r\n\r\n  getMaxFanOut: function () {\r\n    return this.getUserData().fanout ? this.getUserData().fanout : 20\r\n  },\r\n\r\n\r\n  setConnectionDirection: function (direction) {\r\n    this.getUserData().direction = direction\r\n    this.updateDecoration()\r\n  },\r\n\r\n  getConnectionDirection: function () {\r\n    return this.getUserData().direction\r\n  },\r\n\r\n\r\n  updateDecoration: function () {\r\n    if (this.decoration !== null) {\r\n      this.remove(this.decoration)\r\n      this.decoration = null\r\n    }\r\n    var figure = null\r\n    var locator = null\r\n    switch (this.getConnectionDirection()) {\r\n      case 0:\r\n        figure = new draw2d.shape.icon.ArrowUp({width: 8, height: 8, opacity: 0.5})\r\n        locator = new draw2d.layout.locator.TopLocator()\r\n        break\r\n      case 1:\r\n        figure = new draw2d.shape.icon.ArrowRight({width: 8, height: 8, opacity: 0.5})\r\n        locator = new draw2d.layout.locator.RightLocator()\r\n        break\r\n      case 2:\r\n        figure = new draw2d.shape.icon.ArrowDown({width: 8, height: 8, opacity: 0.5})\r\n        locator = new draw2d.layout.locator.BottomLocator()\r\n        break\r\n      case 3:\r\n        figure = new draw2d.shape.icon.ArrowLeft({width: 8, height: 8, opacity: 0.5})\r\n        locator = new draw2d.layout.locator.LeftLocator()\r\n        break\r\n    }\r\n    if (figure !== null) {\r\n      this.add(figure, locator)\r\n      this.decoration = figure\r\n    }\r\n  },\r\n\r\n  getPotentialFilters: function () {\r\n    return [\r\n      {label: \"Port Type\", impl: \"shape_designer.filter.PortTypeFilter\"},\r\n      {label: \"Port Direction\", impl: \"shape_designer.filter.PortDirectionFilter\"},\r\n      {label: \"Color\", impl: \"shape_designer.filter.FillColorFilter\"}\r\n\r\n    ]\r\n  },\r\n\r\n  removeFilter: function (filter) {\r\n    this.filters.remove(filter)\r\n  },\r\n\r\n  addFilter: function (filter) {\r\n    var alreadyIn = false\r\n\r\n    this.filters.each($.proxy(function (i, e) {\r\n      alreadyIn = alreadyIn || (e.NAME === filter.NAME)\r\n    }, this))\r\n    if (alreadyIn === true) {\r\n      return // silently\r\n    }\r\n\r\n    this.filters.add(filter)\r\n    filter.onInstall(this)\r\n    this.repaint()\r\n  },\r\n\r\n\r\n  /**\r\n   * @method\r\n   * Trigger the repaint of the element.\r\n   *\r\n   */\r\n  repaint: function (attributes) {\r\n    if (this.shape === null) {\r\n      return\r\n    }\r\n\r\n    if (typeof attributes === \"undefined\") {\r\n      attributes = {}\r\n    }\r\n\r\n    this.filters.each($.proxy(function (i, filter) {\r\n      filter.apply(this, attributes)\r\n    }, this))\r\n\r\n    this._super(attributes)\r\n  },\r\n\r\n  getPersistentAttributes: function () {\r\n    var memento = this._super()\r\n\r\n    memento.filters = []\r\n    this.filters.each($.proxy(function (i, e) {\r\n      var filterMemento = e.getPersistentAttributes(this)\r\n      memento.filters.push(filterMemento)\r\n    }, this))\r\n\r\n    return memento\r\n  },\r\n\r\n  setPersistentAttributes: function (memento) {\r\n    this._super(memento)\r\n\r\n\r\n    if (typeof memento.filters !== \"undefined\") {\r\n      this.filters = new draw2d.util.ArrayList()\r\n      var fanoutFilterAdded = false\r\n      $.each(memento.filters, $.proxy(function (i, e) {\r\n        var filter = eval(\"new \" + e.name + \"()\")\r\n        if (filter instanceof shape_designer.filter.FanoutFilter) {\r\n          fanoutFilterAdded = true\r\n        }\r\n        filter.setPersistentAttributes(this, e)\r\n        this.filters.add(filter)\r\n      }, this))\r\n      if (!fanoutFilterAdded) {\r\n        this.filters.insertElementAt(new shape_designer.filter.FanoutFilter(), 1)\r\n      }\r\n\r\n    }\r\n    this.updateDecoration()\r\n  }\r\n})\r\n","/**\r\n * The markerFigure is the left hand side annotation for a DecoratedPort.\r\n *\r\n * It contains two children\r\n *\r\n * StateAFigure: if the mouse hover and the figure isn't permanent visible\r\n * StateBFigure: either the mouse is over or the user pressed the checkbox to stick the figure on the port\r\n *\r\n * This kind of decoration is usefull for defualt values on workflwos enginges or circuit diagrams\r\n *\r\n */\r\n\r\n\r\n\r\nexport default shape_designer.figure.MarkerFigure = draw2d.shape.layout.VerticalLayout.extend({\r\n\r\n  NAME: \"MarkerFigure\",\r\n\r\n  init: function (attr, setter, getter) {\r\n    var _this = this\r\n\r\n    this.isMouseOver = false        // indicator if the mouse is over the element\r\n    this.stick = false        // indicator if the stateBFigure should always be visible\r\n    this.defaultValue = true         // current selected default value for the decoration\r\n\r\n    this._super($.extend({\r\n        stroke: 0\r\n      }, attr),\r\n      setter,\r\n      getter)\r\n\r\n\r\n    // figure if the decoration is not permanent visible (sticky note)\r\n    this.add(this.stateA = new shape_designer.figure.MarkerStateAFigure({text: \"X\"}))\r\n    // figure if the decoration permanent visible\r\n    this.add(this.stateB = new shape_designer.figure.MarkerStateBFigure({text: \"X\"}))\r\n\r\n\r\n    this.on(\"mouseenter\", function (emitter, event) {\r\n      _this.onMouseOver(true)\r\n    })\r\n\r\n    this.on(\"mouseleave\", function (emitter, event) {\r\n      _this.onMouseOver(false)\r\n    })\r\n\r\n    this.on(\"click\", function (emitter, event) {\r\n      if (_this.isVisible() === false) {\r\n        return//silently\r\n      }\r\n\r\n      if (_this.stateB.getStickTickFigure().getBoundingBox().hitTest(event.x, event.y) === true) {\r\n        _this.setStick(!_this.getStick())\r\n      }\r\n      else if (_this.stateB.getLabelFigure().getBoundingBox().hitTest(event.x, event.y) === true) {\r\n        $.contextMenu({\r\n          selector: 'body',\r\n          trigger: \"left\",\r\n          events:\r\n            {\r\n              hide: function () {\r\n                $.contextMenu('destroy')\r\n              }\r\n            },\r\n          callback: $.proxy(function (key, options) {\r\n            // propagate the default value to the port\r\n            //\r\n            switch (key) {\r\n              case \"high\":\r\n                _this.setDefaultValue(true)\r\n                break\r\n              case \"low\":\r\n                _this.setDefaultValue(false)\r\n                break\r\n              default:\r\n                break\r\n            }\r\n\r\n          }, this),\r\n          x: event.x,\r\n          y: event.y,\r\n          items: {\r\n            \"high\": {name: \"High\"},\r\n            \"low\": {name: \"Low\"}\r\n          }\r\n        })\r\n\r\n      }\r\n    })\r\n\r\n    this.setDefaultValue(true)\r\n    this.onMouseOver(false)\r\n  },\r\n\r\n\r\n  onMouseOver: function (flag) {\r\n    this.isMouseOver = flag\r\n\r\n    if (this.visible === false) {\r\n      return // silently\r\n    }\r\n\r\n    if (this.stick === true) {\r\n      this.stateA.setVisible(false)\r\n      this.stateB.setVisible(true)\r\n    }\r\n    else {\r\n      this.stateA.setVisible(!this.isMouseOver)\r\n      this.stateB.setVisible(this.isMouseOver)\r\n    }\r\n\r\n    return this\r\n  },\r\n\r\n\r\n  setVisible: function (flag) {\r\n    this._super(flag)\r\n\r\n    // update the hover/stick state of the figure\r\n    this.onMouseOver(this.isMouseOver)\r\n\r\n    return this\r\n  },\r\n\r\n\r\n  setStick: function (flag) {\r\n    this.stick = flag\r\n    this.onMouseOver(this.isMouseOver)\r\n\r\n\r\n    // the port has only a default value if the decoration is visible\r\n    this.parent.setValue(flag ? this.defaultValue : null)\r\n\r\n    this.stateB.setTick(this.getStick())\r\n\r\n    return this\r\n  },\r\n\r\n\r\n  getStick: function () {\r\n    return this.stick\r\n  },\r\n\r\n\r\n  setText: function (text) {\r\n    this.stateB.setText(text)\r\n\r\n    return this\r\n  },\r\n\r\n  setDefaultValue: function (value) {\r\n    this.defaultValue = value\r\n    this.setText((this.defaultValue === true) ? \"High\" : \"Low\")\r\n\r\n    // only propagate the value to the parent if the decoration permanent visible\r\n    //\r\n    if (this.stick === true) {\r\n      this.parent.setValue(this.defaultValue)\r\n    }\r\n  }\r\n})\r\n","/**\r\n * This is only the mouseover reactive shape. A little bit smaller than the visible shape\r\n *\r\n * Or you can display this shape with opacity of 0.2 to indicate that this is a reactive area.\r\n */\r\n\r\n\r\n\r\n\r\nexport default shape_designer.figure.MarkerStateAFigure = draw2d.shape.basic.Label.extend({\r\n\r\n  NAME: \"MarkerStateAFigure\",\r\n\r\n  /**\r\n   * @param attr\r\n   */\r\n  init: function (attr, setter, getter) {\r\n    this._super($.extend({\r\n        padding: {left: 5, top: 2, bottom: 2, right: 10},\r\n        bgColor: null,\r\n        stroke: 1,\r\n        color: null,\r\n        fontColor: null,\r\n        fontSize: 10\r\n      }, attr),\r\n      setter,\r\n      getter)\r\n\r\n    // we must override the hitTest method to ensure that the parent can receive the mouseenter/mouseleave events.\r\n    // Unfortunately draw2D didn't provide event bubbling like HTML. The first shape in queue consumes the event.\r\n    //\r\n    // now this shape is \"dead\" for any mouse events and the parent must/can handle this.\r\n    this.hitTest = function () {\r\n      return false\r\n    }\r\n  }\r\n})\r\n","export default shape_designer.figure.MarkerStateBFigure = draw2d.shape.layout.HorizontalLayout.extend({\r\n\r\n  NAME: \"MarkerStateBFigure\",\r\n\r\n  /**\r\n   * @param attr\r\n   */\r\n  init: function (attr, setter, getter) {\r\n    this._super($.extend({\r\n        bgColor: \"#FFFFFF\",\r\n        stroke: 1,\r\n        color: \"#00bcd4\",\r\n        radius: 2,\r\n        padding: {left: 3, top: 3, bottom: 3, right: 8},\r\n        gap: 5\r\n      }, attr),\r\n      setter,\r\n      getter)\r\n\r\n    this.stickTick = new draw2d.shape.basic.Circle({\r\n      diameter: 10,\r\n      bgColor: \"#f0f0f0\",\r\n      stroke: 1,\r\n      resizeable: false\r\n    })\r\n    this.add(this.stickTick)\r\n    this.stickTick.hitTest = function () {\r\n      return false\r\n    }\r\n    this.stickTick.addCssClass(\"cursorPointer\")\r\n\r\n    this.label = new draw2d.shape.basic.Label({\r\n      text: attr.text,\r\n      resizeable: false,\r\n      stroke: 0,\r\n      padding: 0,\r\n      fontSize: 10,\r\n      fontColor: \"#303030\"\r\n    })\r\n    this.add(this.label)\r\n    // don't catch the mouse events. This is done by the parent container\r\n    this.label.hitTest = function () {\r\n      return false\r\n    }\r\n    this.label.addCssClass(\"cursorPointer\")\r\n\r\n    // we must override the hitTest method to ensure that the parent can receive the mouseenter/mouseleave events.\r\n    // Unfortunately draw2D didn't provide event bubbling like HTML. The first shape in queue consumes the event.\r\n    //\r\n    // now this shape is \"dead\" for any mouse events and the parent must/can handle this.\r\n    this.hitTest = function () {\r\n      return false\r\n    }\r\n  },\r\n\r\n  setText: function (text) {\r\n    this.label.setText(text)\r\n  },\r\n\r\n  setTick: function (flag) {\r\n    this.stickTick.attr({bgColor: flag ? \"#00bcd4\" : \"#f0f0f0\"})\r\n  },\r\n\r\n  getStickTickFigure: function () {\r\n    return this.stickTick\r\n  },\r\n\r\n  getLabelFigure: function () {\r\n    return this.label\r\n  },\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   *\r\n   * @template\r\n   **/\r\n  repaint: function (attributes) {\r\n    if (this.repaintBlocked === true || this.shape === null) {\r\n      return\r\n    }\r\n\r\n    attributes = attributes || {}\r\n\r\n    attributes.path = this.calculatePath()\r\n\r\n    this._super(attributes)\r\n  },\r\n\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * Override the default rendering of the HorizontalLayout, which is a simple\r\n   * rectangle. We want an arrow.\r\n   */\r\n  createShapeElement: function () {\r\n    return this.canvas.paper.path(this.calculatePath())\r\n  },\r\n\r\n  /**\r\n   * stupid copy&paste the code from the Polygon shape...unfortunately the LayoutFigure isn't a polygon.\r\n   *\r\n   * @returns {string}\r\n   */\r\n  calculatePath: function () {\r\n    var arrowLength = 8\r\n\r\n    this.vertices = new draw2d.util.ArrayList()\r\n\r\n    var w = this.width\r\n    var h = this.height\r\n    var pos = this.getAbsolutePosition()\r\n    var i = 0\r\n    var length = 0\r\n    this.vertices.add(new draw2d.geo.Point(pos.x, pos.y))\r\n    this.vertices.add(new draw2d.geo.Point(pos.x + w - arrowLength, pos.y))\r\n\r\n    this.vertices.add(new draw2d.geo.Point(pos.x + w, pos.y + h / 2))\r\n\r\n    this.vertices.add(new draw2d.geo.Point(pos.x + w - arrowLength, pos.y + h))\r\n    this.vertices.add(new draw2d.geo.Point(pos.x, pos.y + h))\r\n\r\n    var radius = this.getRadius()\r\n    var path = []\r\n    // hard corners\r\n    //\r\n    if (radius === 0) {\r\n      length = this.vertices.getSize()\r\n      var p = this.vertices.get(0)\r\n      path.push(\"M\", (p.x | 0) + 0.5, \" \", (p.y | 0) + 0.5)\r\n      for (i = 1; i < length; i++) {\r\n        p = this.vertices.get(i)\r\n        path.push(\"L\", (p.x | 0) + 0.5, \" \", (p.y | 0) + 0.5)\r\n      }\r\n      path.push(\"Z\")\r\n    }\r\n    // soften/round corners\r\n    //\r\n    else {\r\n      length = this.vertices.getSize()\r\n      var start = this.vertices.first()\r\n      var end = this.vertices.last()\r\n      if (start.equals(end)) {\r\n        length = length - 1\r\n        end = this.vertices.get(length - 1)\r\n      }\r\n      var begin = draw2d.geo.Util.insetPoint(start, end, radius)\r\n      path.push(\"M\", (begin.x | 0) + 0.5, \",\", (begin.y | 0) + 0.5)\r\n      for (i = 0; i < length; i++) {\r\n        start = this.vertices.get(i)\r\n        end = this.vertices.get((i + 1) % length)\r\n        let modStart = draw2d.geo.Util.insetPoint(start, end, radius)\r\n        let modEnd = draw2d.geo.Util.insetPoint(end, start, radius)\r\n        path.push(\"Q\", start.x, \",\", start.y, \" \", (modStart.x | 0) + 0.5, \", \", (modStart.y | 0) + 0.5)\r\n        path.push(\"L\", (modEnd.x | 0) + 0.5, \",\", (modEnd.y | 0) + 0.5)\r\n      }\r\n    }\r\n    return path.join(\"\")\r\n  }\r\n\r\n\r\n})\r\n","export default shape_designer.figure.PolyCircle = draw2d.shape.basic.Oval.extend({\r\n\r\n  NAME: \"shape_designer.figure.PolyCircle\",\r\n\r\n\r\n  init: function (center, radius) {\r\n    this.blur = 0\r\n    this.isExtFigure = true\r\n\r\n    // set some good defaults\r\n    if (typeof radius === \"undefined\") {\r\n      radius = 10\r\n    }\r\n\r\n    this._super({stroke: 0, bgColor: \"95C06A\", width: radius * 2, height: radius * 2})\r\n\r\n    // center must be set after the width/height...bug\r\n    if (typeof center !== \"undefined\") {\r\n      this.setCenter(center)\r\n    }\r\n\r\n    this.setUserData({name: \"Circle\"})\r\n\r\n    this.filters = new draw2d.util.ArrayList()\r\n    this.filters.add(new shape_designer.filter.PositionFilter())\r\n    this.filters.add(new shape_designer.filter.SizeFilter())\r\n    this.filters.add(new shape_designer.filter.FillColorFilter())\r\n  },\r\n\r\n  getPotentialFilters: function () {\r\n    return [\r\n      {label: \"Stroke\", impl: \"shape_designer.filter.StrokeFilter\"},\r\n      {label: \"Opacity\", impl: \"shape_designer.filter.OpacityFilter\"},\r\n      {label: \"Blur\", impl: \"shape_designer.filter.BlurFilter\"},\r\n      {label: \"Linear Gradient\", impl: \"shape_designer.filter.LinearGradientFilter\"},\r\n      {label: \"Fill Color\", impl: \"shape_designer.filter.FillColorFilter\"}\r\n    ]\r\n  },\r\n\r\n  removeFilter: function (filter) {\r\n    this.filters.remove(filter)\r\n  },\r\n\r\n  addFilter: function (filter) {\r\n    var alreadyIn = false\r\n\r\n    this.filters.each($.proxy(function (i, e) {\r\n      alreadyIn = alreadyIn || (e.NAME === filter.NAME)\r\n    }, this))\r\n\r\n    if (alreadyIn === true) {\r\n      return // silently\r\n    }\r\n\r\n    this.filters.add(filter)\r\n    filter.onInstall(this)\r\n    this.repaint()\r\n  },\r\n\r\n\r\n  setBlur: function (value) {\r\n    this.blur = parseInt(value)\r\n    this.repaint()\r\n  },\r\n\r\n  getBlur: function () {\r\n    return this.blur\r\n  },\r\n\r\n  /**\r\n   * @method\r\n   * Trigger the repaint of the element.\r\n   *\r\n   */\r\n  repaint: function (attributes) {\r\n    if (this.shape === null) {\r\n      return\r\n    }\r\n\r\n    this.filters.each($.proxy(function (i, filter) {\r\n      filter.apply(this, attributes)\r\n    }, this))\r\n\r\n//        this.shape.blur(this.blur);\r\n    this._super(attributes)\r\n  },\r\n\r\n  getVertices: function () {\r\n\r\n    var w2 = this.getWidth() / 2\r\n    var h2 = this.getHeight() / 2\r\n    var center = this.getCenter()\r\n    var sides = 36\r\n\r\n    var vertices = new draw2d.util.ArrayList()\r\n    for (var i = 0; i < sides; i++) {\r\n      var radian = 2 * Math.PI * i / sides\r\n      var x = Math.cos(radian) * w2 + center.x\r\n      var y = Math.sin(radian) * h2 + center.y\r\n      vertices.add(new draw2d.geo.Point(x, y))\r\n    }\r\n    return vertices\r\n  },\r\n\r\n  getPersistentAttributes: function () {\r\n    var memento = this._super()\r\n\r\n    memento.blur = this.blur\r\n    memento.filters = []\r\n    this.filters.each($.proxy(function (i, e) {\r\n      var filterMemento = e.getPersistentAttributes(this)\r\n      memento.filters.push(filterMemento)\r\n    }, this))\r\n\r\n    return memento\r\n  },\r\n\r\n  setPersistentAttributes: function (memento) {\r\n    this._super(memento)\r\n\r\n    if (typeof memento.blur !== \"undefined\")\r\n      this.setBlur(memento.blur)\r\n\r\n    if (typeof memento.filters !== \"undefined\") {\r\n      this.filters = new draw2d.util.ArrayList()\r\n      $.each(memento.filters, $.proxy(function (i, e) {\r\n        var filter = eval(\"new \" + e.name + \"()\")\r\n        filter.setPersistentAttributes(this, e)\r\n        this.filters.add(filter)\r\n      }, this))\r\n    }\r\n  }\r\n})\r\n","import ExtPolygon from \"./ExtPolygon\"\r\n\r\nexport default shape_designer.figure.PolyRect = ExtPolygon.extend({\r\n\r\n  NAME: \"shape_designer.figure.PolyRect\",\r\n\r\n  init: function (topLeft, bottomRight) {\r\n    this._super()\r\n    if (typeof topLeft === \"undefined\") {\r\n      this.vertices = new draw2d.util.ArrayList()\r\n      this.addVertex(new draw2d.geo.Point(100, 100))\r\n      this.addVertex(new draw2d.geo.Point(140, 100))\r\n      this.addVertex(new draw2d.geo.Point(140, 140))\r\n      this.addVertex(new draw2d.geo.Point(100, 140))\r\n    }\r\n    else {\r\n      this.vertices = new draw2d.util.ArrayList()\r\n      this.addVertex(new draw2d.geo.Point(topLeft.x, topLeft.y))\r\n      this.addVertex(new draw2d.geo.Point(bottomRight.x, topLeft.y))\r\n      this.addVertex(new draw2d.geo.Point(bottomRight.x, bottomRight.y))\r\n      this.addVertex(new draw2d.geo.Point(topLeft.x, bottomRight.y))\r\n    }\r\n\r\n    this.setUserData({name: \"Rectangle\"})\r\n  }\r\n})\r\n","export default shape_designer.figure.TestSwitch = draw2d.shape.basic.Label.extend({\r\n\r\n  NAME: \"shape_designer.figure.TestSwitch\",\r\n\r\n  init: function (attr, setter, getter) {\r\n    this._super({text: \"Low\"}, setter, getter)\r\n\r\n    this.createPort(\"output\")\r\n\r\n    var _this = this\r\n\r\n    this.value = false\r\n    this.on(\"click\", function () {\r\n      _this.toggleValue()\r\n      _this.getOutputPort(0).setValue(_this.value)\r\n      _this.getOutputPort(0).getConnections().each(function (i, c) {\r\n        c.getTarget().setValue(_this.value)\r\n      })\r\n    })\r\n  },\r\n\r\n  toggleValue: function () {\r\n    this.value = !this.value\r\n    this.attr({text: this.value ? \"High\" : \"Low\"})\r\n  }\r\n})\r\n\r\n","// required to register them for JSON serialize/deserialize\r\n//\r\nexport default [\r\n  require(\"./ExtLabel\"),\r\n  require(\"./DecoratedInputPort\"),\r\n  require(\"./ExtLine\"),\r\n  require(\"./ExtPolygon\"),\r\n  require(\"./ExtPort\"),\r\n  require(\"./MarkerFigure\"),\r\n  require(\"./MarkerStateAFigure\"),\r\n  require(\"./MarkerStateBFigure\"),\r\n  require(\"./PolyCircle\"),\r\n  require(\"./PolyRect\"),\r\n  require(\"./TestSwitch\")\r\n]\r\n\r\n","import Filter from \"./Filter\"\r\n\r\n\r\nexport default shape_designer.filter.BlurFilter = class BlurFilter extends Filter {\r\n\r\n  constructor() {\r\n    super(\"shape_designer.filter.BlurFilter\")\r\n  }\r\n\r\n  insertPane(figure, $parent) {\r\n    $parent.append('<div id=\"' + this.containerId + '\" class=\"panel panel-default\">' +\r\n      ' <div class=\"panel-heading filter-heading\" data-toggle=\"collapse\" data-target=\"#' + this.cssScope + '_width_panel\">' +\r\n      '     Blur' +\r\n      '    <span id=\"button_remove_' + this.cssScope + '\"><img class=\"svg icon pull-right\" src=\"./images/dialog_close.svg\"/></span></span>' +\r\n      '</div>' +\r\n\r\n      ' <div class=\"panel-body collapse in\" id=\"' + this.cssScope + '_blur_panel\">' +\r\n      '   <div class=\"form-group\">' +\r\n      '      <div class=\"input-group\" ></div> ' + // required to ensure the correct width of the siblings\r\n      '       <input id=\"filter_blur\" type=\"text\" value=\"' + figure.getBlur() + '\"  name=\"filter_blur\" class=\"mousetrap-pause form-control\" />' +\r\n      '   </div>' +\r\n      ' </div>' +\r\n      '</div>')\r\n    inlineSVG.init({svgSelector:\"#\"+this.containerId + \" img.svg\"})\r\n\r\n    $(\"#filter_blur\").TouchSpin({\r\n      min: 0,\r\n      max: 5,\r\n      step: 1\r\n    })\r\n\r\n    $(\"#filter_blur\").on(\"change\", $.proxy(function () {\r\n      this.setBlur(parseInt($(\"#filter_blur\").val()))\r\n    }, figure))\r\n\r\n\r\n    $(\"#button_remove_\" + this.cssScope).on(\"click\", $.proxy(function () {\r\n      figure.removeFilter(this)\r\n      figure.setBlur(0)\r\n      $('#' + this.containerId).animate({\r\n        \"height\": \"0\",\r\n        \"opacity\": 0,\r\n        \"margin-bottom\": 0\r\n      }, 500, function () {\r\n        $('#' + this.containerId).remove()\r\n      })\r\n    }, this))\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n","import Filter from \"./Filter\"\r\n\r\nexport default shape_designer.filter.FanoutFilter = class FanoutFilter extends Filter {\r\n\r\n  constructor() {\r\n    super(\"shape_designer.filter.FanoutFilter\")\r\n  }\r\n\r\n  insertPane(figure, $parent) {\r\n    $parent.append('<div id=\"' + this.containerId + '\" class=\"panel panel-default\">' +\r\n      ' <div class=\"panel-heading filter-heading\" data-toggle=\"collapse\" data-target=\"#' + this.cssScope + '_width_panel\">' +\r\n      '     Maximal fan out' +\r\n      '</div>' +\r\n\r\n      ' <div class=\"panel-body collapse in\" id=\"' + this.cssScope + '_width_panel\">' +\r\n      '   <div class=\"form-group\">' +\r\n      '      <div class=\"input-group\" ></div> ' + // required to ensure the correct width of the siblings\r\n      '       <input id=\"filter_' + this.cssScope + '_fanout\" type=\"text\" value=\"' + figure.getMaxFanOut() + '\" name=\"filter_' + this.cssScope + '_fanout\" class=\"mousetrap-pause form-control\" />' +\r\n      '   </div>' +\r\n      ' </div>' +\r\n      '</div>')\r\n    inlineSVG.init({svgSelector:\"#\"+this.containerId + \" img.svg\"})\r\n\r\n    $(\"input[name='filter_\" + this.cssScope + \"_fanout']\").TouchSpin({\r\n      min: 0,\r\n      max: 50,\r\n      step: 1,\r\n      maxboostedstep: 1,\r\n      postfix: 'px'\r\n    })\r\n    $(\"input[name='filter_\" + this.cssScope + \"_fanout']\").on(\"change\", $.proxy(function () {\r\n      this.setMaxFanOut(parseInt($(\"input[name='filter_\" + this.cssScope + \"_fanout']\").val()))\r\n    }, figure))\r\n\r\n\r\n  }\r\n\r\n  removePane() {\r\n  }\r\n\r\n  onInstall(figure) {\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n","import Filter from \"./Filter\"\r\nimport jscolor from \"../widget/jscolor/jscolor\"\r\n\r\nexport default shape_designer.filter.FillColorFilter = class FillColorFilter extends Filter {\r\n\r\n  constructor() {\r\n    super(\"shape_designer.filter.FillColorFilter\")\r\n    this.colorPicker = null\r\n  }\r\n\r\n  insertPane(figure, $parent) {\r\n\r\n    $parent.append('<div id=\"' + this.containerId + '\" class=\"panel panel-default\">' +\r\n      ' <div class=\"panel-heading filter-heading\" data-toggle=\"collapse\" data-target=\"#color_fill_panel\">' +\r\n      '    Color Fill' +\r\n      '    <span id=\"button_remove_FillColorFilter\"><img class=\"svg icon pull-right\" src=\"./images/dialog_close.svg\"/><span>' +\r\n      ' </div>' +\r\n\r\n      ' <div class=\"panel-body collapse in\" id=\"color_fill_panel\">' +\r\n      '   <div class=\"form-group\">' +\r\n      '      <div class=\"input-group\" ></div> ' + // required to ensure the correct width of the siblings\r\n      '      <div class=\"input-group\">' +\r\n      '          <span class=\"input-group-addon\">#</span>' +\r\n      '          <input id=\"filter_color_fill\" type=\"text\" value=\"\" name=\"filter_color_fill\" class=\"mousetrap-pause form-control color\"/>' +\r\n      '       </div>' +\r\n      '    </div>' +\r\n      ' </div>' +\r\n      '</div>')\r\n    inlineSVG.init({svgSelector:\"#\"+this.containerId + \" img.svg\"})\r\n\r\n    var picker = this.colorPicker = new jscolor.color(document.getElementById('filter_color_fill'), {})\r\n    this.colorPicker.fromString(figure.getBackgroundColor().hash())\r\n    this.colorPicker.onImmediateChange = $.proxy(function () {\r\n      this.setBackgroundColor(\"#\" + picker.toString())\r\n    }, figure)\r\n\r\n    $(\"#button_remove_FillColorFilter\").on(\"click\", $.proxy(function () {\r\n      figure.removeFilter(this)\r\n      figure.setBackgroundColor(null)\r\n      $(\"#\"+this.containerId).animate({\"height\": \"0\", \"opacity\": 0, \"margin-bottom\": 0}, 500, function () {\r\n        $('#'+this.containerId).remove()\r\n      })\r\n    }, this))\r\n  }\r\n\r\n  onInstall(figure) {\r\n    figure.setBackgroundColor(\"#f0f3f3\")\r\n  }\r\n\r\n  removePane() {\r\n    if (this.colorPicker !== null) {\r\n      this.colorPicker.hidePicker()\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n","export default class Filter {\r\n\r\n  constructor(name) {\r\n    this.NAME = name\r\n    this.colorPicker = null\r\n    this.cssScope = this.NAME.replace(/[.]/g, \"_\")\r\n    this.containerId= this.cssScope+\"_container\"\r\n  }\r\n\r\n  /**\r\n   * @method\r\n   * Sent when an event occurs on the command stack. draw2d.command.CommandStackEvent.getDetail()\r\n   * can be used to identify the type of event which has occurred.\r\n   *\r\n   * @template\r\n   *\r\n   **/\r\n  apply(figure, attributes) {\r\n  }\r\n\r\n  onInstall(figure) {\r\n  }\r\n\r\n  insertPane(figure, $parent) {\r\n\r\n  }\r\n\r\n  removePane() {\r\n  }\r\n\r\n  getPersistentAttributes(relatedFigure) {\r\n    var memento = {}\r\n    memento.name = this.NAME\r\n\r\n    return memento\r\n  }\r\n\r\n  setPersistentAttributes(relatedFigure, memento) {\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n","import jscolor from \"../widget/jscolor/jscolor\"\r\n\r\nimport Filter from \"./Filter\"\r\n\r\nexport default shape_designer.filter.FontColorFilter = class FontColorFilter extends Filter {\r\n\r\n  constructor() {\r\n    super(\"shape_designer.filter.FontColorFilter\")\r\n    this.colorPicker = null\r\n  }\r\n\r\n  insertPane(figure, $parent) {\r\n\r\n    $parent.append('<div id=\"' + this.containerId + '\" class=\"panel panel-default\">' +\r\n      ' <div class=\"panel-heading filter-heading\" data-toggle=\"collapse\" data-target=\"#color_fill_panel\">' +\r\n      '    Font Color' +\r\n      '    <span id=\"button_remove_FillColorFilter\"><img class=\"svg icon pull-right\" src=\"./images/dialog_close.svg\"/></span>' +\r\n      ' </div>' +\r\n\r\n      ' <div class=\"panel-body collapse in\" id=\"color_fill_panel\">' +\r\n      '   <div class=\"form-group\">' +\r\n      '      <div class=\"input-group\" ></div> ' + // required to ensure the correct width of the siblings\r\n      '      <div class=\"input-group\">' +\r\n      '          <span class=\"input-group-addon\">#</span>' +\r\n      '          <input id=\"filter_color_fill\" type=\"text\" value=\"\" name=\"filter_color_fill\" class=\"mousetrap-pause form-control color\"/>' +\r\n      '       </div>' +\r\n      '    </div>' +\r\n      ' </div>' +\r\n      '</div>')\r\n    inlineSVG.init({svgSelector:\"#\"+this.containerId + \" img.svg\"})\r\n\r\n    var picker = this.colorPicker = new jscolor.color(document.getElementById('filter_color_fill'), {})\r\n    this.colorPicker.fromString(figure.getFontColor().hash())\r\n    this.colorPicker.onImmediateChange = $.proxy(function () {\r\n      this.setFontColor(\"#\" + picker.toString())\r\n    }, figure)\r\n\r\n    $(\"#button_remove_FillColorFilter\").on(\"click\", () => {\r\n      figure.removeFilter(this)\r\n      figure.setFontColor(null)\r\n      $(\"#\"+this.containerId).animate({\"height\": \"0\", \"opacity\": 0, \"margin-bottom\": 0}, 500, () => {\r\n        $('#'+this.containerId).remove()\r\n      })\r\n    })\r\n  }\r\n\r\n  onInstall(figure) {\r\n    figure.setFontColor(\"#000000\")\r\n  }\r\n\r\n  removePane() {\r\n    if (this.colorPicker !== null) {\r\n      this.colorPicker.hidePicker()\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n","import Filter from \"./Filter\"\r\n\r\nexport default shape_designer.filter.FontSizeFilter = class FontSizeFilter extends Filter {\r\n\r\n  constructor() {\r\n    super(\"shape_designer.filter.FontSizeFilter\")\r\n  }\r\n\r\n  insertPane(figure, $parent) {\r\n\r\n    $parent.append('<div id=\"' + this.containerId + '\" class=\"panel panel-default\">' +\r\n      ' <div class=\"panel-heading filter-heading\" data-toggle=\"collapse\" data-target=\"#fontsize_width_panel\">' +\r\n      '     Font Size' +\r\n      '    <span id=\"button_remove_FontSizeFilter\"><img  class=\"svg icon pull-right\" src=\"./images/dialog_close.svg\"/></span>' +\r\n      '</div>' +\r\n\r\n      ' <div class=\"panel-body collapse in\" id=\"fontsize_width_panel\">' +\r\n      '   <div class=\"form-group\">' +\r\n      '      <div class=\"input-group\" ></div> ' + // required to ensure the correct width of the siblings\r\n      '       <input id=\"filter_fontsize\" type=\"text\" value=\"' + figure.getFontSize() + '\" name=\"filter_fontsize\" class=\"mousetrap-pause form-control\" />' +\r\n      '   </div>' +\r\n      ' </div>' +\r\n      '</div>')\r\n    inlineSVG.init({svgSelector:\"#\"+this.containerId + \" img.svg\"})\r\n\r\n    $(\"#filter_fontsize\").TouchSpin({\r\n      min: 4,\r\n      max: 300,\r\n      step: 1,\r\n      boostat: figure.getFontSize(),\r\n      maxboostedstep: 10,\r\n      postfix: 'px'\r\n    })\r\n\r\n    $(\"input[name='filter_fontsize']\").on(\"change\", $.proxy(function () {\r\n      this.setFontSize(parseInt($(\"input[name='filter_fontsize']\").val()))\r\n    }, figure))\r\n\r\n\r\n    $(\"#button_remove_FontSizeFilter\").on(\"click\", () => {\r\n      figure.removeFilter(this)\r\n      figure.setFontSize(12)\r\n      $(\"#\"+this.containerId).animate({\"height\": \"0\", \"opacity\": 0, \"margin-bottom\": 0}, 500, () => {\r\n        $('#'+this.containerId).remove()\r\n      })\r\n    })\r\n  }\r\n\r\n  removePane() {\r\n  }\r\n\r\n  onInstall(figure) {\r\n    //   figure.setFontSize(1);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n","import jscolor from \"../widget/jscolor/jscolor\"\r\n\r\nimport Filter from \"./Filter\"\r\nimport \"../widget/ui.anglepicker\"\r\n\r\nexport default shape_designer.filter.LinearGradientFilter = class LinearGradientFilter extends Filter {\r\n\r\n  constructor() {\r\n    super(\"shape_designer.filter.LinearGradientFilter\")\r\n    this.colorPicker1 = null\r\n    this.colorPicker2 = null\r\n\r\n    this.startColor = \"#f0f0f0\"\r\n    this.endColor = \"#3f3f3f\"\r\n    this.angle = 0\r\n  }\r\n\r\n  insertPane(figure, $parent) {\r\n\r\n    $parent.append('<div id=\"' + this.containerId + '\" class=\"panel panel-default\">' +\r\n      ' <div class=\"panel-heading filter-heading\" data-toggle=\"collapse\" data-target=\"#' + this.cssScope + '_panel\">' +\r\n      '     Linear Gradient' +\r\n      '    <span id=\"button_remove_' + this.cssScope + '\"><img  class=\"svg icon pull-right\" src=\"./images/dialog_close.svg\"/></span>' +\r\n      '</div>' +\r\n\r\n      ' <div class=\"panel-body collapse in\" id=\"' + this.cssScope + '_panel\">' +\r\n      '   <div class=\"form-group\">' +\r\n      '      <div class=\"input-group\" ></div> ' + // required to ensure the correct width of the siblings\r\n      '      <div class=\"input-group text-center\" style=\"width:100%\" >' +\r\n      '           <div id=\"' + this.cssScope + '_angle\" />' +\r\n      '      </div> ' +\r\n      '       <div class=\"input-group\">' +\r\n      '          <span class=\"input-group-addon\">#</span>' +\r\n      '          <input id=\"' + this.cssScope + '_color1\" type=\"text\" value=\"' + this.startColor + '\" class=\"mousetrap-pause form-control color\"/>' +\r\n      '       </div>' +\r\n      '       <div class=\"input-group\">' +\r\n      '          <span class=\"input-group-addon\">#</span>' +\r\n      '          <input id=\"' + this.cssScope + '_color2\" type=\"text\" value=\"' + this.endColor + '\" class=\"mousetrap-pause form-control color\"/>' +\r\n      '       </div>' +\r\n      '   </div>' +\r\n      ' </div>' +\r\n      '</div>')\r\n    inlineSVG.init({svgSelector:\"#\"+this.containerId + \" img.svg\"})\r\n\r\n    $('#' + this.cssScope + '_angle').anglepicker({\r\n      start: function (e, ui) {\r\n\r\n      },\r\n      change: (e, ui) => {\r\n        this.angle = ui.value\r\n        figure.repaint()\r\n      },\r\n      stop: (e, ui) => {\r\n      },\r\n      value: this.angle\r\n    })\r\n\r\n    let picker1 = this.colorPicker1 = new jscolor.color($(\"#\" + this.cssScope + '_color1')[0], {})\r\n    this.colorPicker1.fromString(this.startColor)\r\n    this.colorPicker1.onImmediateChange = () => {\r\n      this.startColor = \"#\" + picker1.toString()\r\n      figure.repaint()\r\n    }\r\n\r\n    let picker2 = this.colorPicker2 = new jscolor.color($(\"#\" + this.cssScope + '_color2')[0], {})\r\n    this.colorPicker2.fromString(this.endColor)\r\n    this.colorPicker2.onImmediateChange = () => {\r\n      this.endColor = \"#\" + picker2.toString()\r\n      figure.repaint()\r\n    }\r\n\r\n\r\n    $(\"#button_remove_\" + this.cssScope).on(\"click\", () => {\r\n      figure.removeFilter(this)\r\n      $('#' + this.containerId ).animate({\r\n        \"height\": \"0\",\r\n        \"opacity\": 0,\r\n        \"margin-bottom\": 0\r\n      }, 500, () => {\r\n        $('#' + this.containerId ).remove()\r\n      })\r\n    })\r\n  }\r\n\r\n  apply(figure, attributes) {\r\n    attributes.fill = this.angle + \"-\" + this.endColor + \"-\" + this.startColor\r\n  }\r\n\r\n  removePane() {\r\n    if (this.colorPicker1 !== null) {\r\n      this.colorPicker1.hidePicker()\r\n    }\r\n    if (this.colorPicker2 !== null) {\r\n      this.colorPicker2.hidePicker()\r\n    }\r\n  }\r\n\r\n  onInstall(figure) {\r\n    figure.setStroke(1)\r\n  }\r\n\r\n  getPersistentAttributes(relatedFigure) {\r\n    let memento = super.getPersistentAttributes(relatedFigure)\r\n\r\n    memento.startColor = this.startColor\r\n    memento.endColor = this.endColor\r\n    memento.angle = this.angle\r\n\r\n    return memento\r\n  }\r\n\r\n  setPersistentAttributes(relatedFigure, memento) {\r\n    super.setPersistentAttributes(relatedFigure, memento)\r\n\r\n    this.startColor = memento.startColor\r\n    this.endColor = memento.endColor\r\n    this.angle = memento.angle\r\n\r\n    return memento\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n","import Filter from \"./Filter\"\r\n\r\nexport default shape_designer.filter.OpacityFilter = class OpacityFilter extends Filter {\r\n\r\n  constructor() {\r\n    super(\"shape_designer.filter.OpacityFilter\")\r\n  }\r\n\r\n  insertPane(figure, $parent) {\r\n\r\n    $parent.append('<div id=\"' + this.containerId + '\" class=\"panel panel-default\">' +\r\n      ' <div class=\"panel-heading filter-heading\" data-toggle=\"collapse\" data-target=\"#opacity_panel\">' +\r\n      '    Opacity' +\r\n      '    <span id=\"button_remove_OpacityFilter\"><img  class=\"svg icon pull-right\" src=\"./images/dialog_close.svg\"/></span>' +\r\n      '</div>' +\r\n      ' <div class=\"panel-body collapse in\" id=\"opacity_panel\">' +\r\n      '   <div class=\"form-group\">' +\r\n      '      <div class=\"input-group\" ></div> ' + // required to ensure the correct width of the siblings\r\n      '      <div class=\"input-group\">' +\r\n      '         <input class=\"mousetrap-pause form-control\" id=\"filter_opacity\" type=\"text\" value=\"' + parseInt(figure.getAlpha() * 100) + '\" />' +\r\n      '      </div>' +\r\n      '   </div>' +\r\n      ' </div>' +\r\n      '</div>')\r\n    inlineSVG.init({svgSelector:\"#\"+this.containerId + \" img.svg\"})\r\n\r\n    $(\"#filter_opacity\").TouchSpin({\r\n      min: 0,\r\n      max: 100,\r\n      step: 5,\r\n      boostat: parseInt(figure.getAlpha() * 100),\r\n      maxboostedstep: 10,\r\n      postfix: '%'\r\n    })\r\n    $(\"#filter_opacity\").on(\"change\", $.proxy(function () {\r\n      this.setAlpha(parseInt($(\"#filter_opacity\").val()) / 100.0)\r\n    }, figure))\r\n\r\n    $(\"#button_remove_OpacityFilter\").on(\"click\", () => {\r\n      figure.removeFilter(this)\r\n      figure.setAlpha(1)\r\n      $(\"#\"+this.containerId).animate({\"height\": \"0\", \"opacity\": 0, \"margin-bottom\": 0}, 500, () => {\r\n        $('#'+this.containerId).remove()\r\n      })\r\n    })\r\n  }\r\n\r\n  removePane() {\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n","import jscolor from \"../widget/jscolor/jscolor\"\r\n\r\nimport Filter from \"./Filter\"\r\n\r\nexport default shape_designer.filter.OutlineStrokeFilter = class OutlineStrokeFilter extends Filter {\r\n\r\n  constructor() {\r\n    super(\"shape_designer.filter.OutlineStrokeFilter\")\r\n    this.colorPicker = null\r\n  }\r\n\r\n  insertPane(figure, $parent) {\r\n\r\n    $parent.append('<div id=\"' + this.containerId + '\" class=\"panel panel-default\">' +\r\n      ' <div class=\"panel-heading filter-heading\" data-toggle=\"collapse\" data-target=\"#outlinestroke_width_panel\">' +\r\n      '     Outline Stroke' +\r\n      '    <img id=\"button_remove_OutlineStrokeFilter\" class=\"icon pull-right\" src=\"./images/dialog_close.svg\"/>' +\r\n      '</div>' +\r\n\r\n      ' <div class=\"panel-body collapse in\" id=\"outlinestroke_width_panel\">' +\r\n      '   <div class=\"form-group\">' +\r\n      '      <div class=\"input-group\" ></div> ' + // required to ensure the correct width of the siblings\r\n      '       <input id=\"filter_outlinestroke\" type=\"text\" value=\"' + figure.getOutlineStroke() + '\" name=\"filter_outlinestroke\" class=\"mousetrap-pause form-control\" />' +\r\n      '       <div class=\"input-group\">' +\r\n      '          <span class=\"input-group-addon\">#</span>' +\r\n      '          <input id=\"filter_outlinestroke_color\" type=\"text\" value=\"\" name=\"outlinestroke-color\" class=\"mousetrap-pause form-control color\"/>' +\r\n      '       </div>' +\r\n      '   </div>' +\r\n      ' </div>' +\r\n      '</div>')\r\n\r\n    inlineSVG.init({svgSelector:\"#\"+this.containerId + \" img.svg\"})\r\n\r\n    $(\"input[name='filter_outlinestroke']\")\r\n      .TouchSpin({\r\n        min: 0,\r\n        max: 50,\r\n        step: 1,\r\n        boostat: figure.getOutlineStroke(),\r\n        maxboostedstep: 10,\r\n        postfix: 'px'\r\n      })\r\n      .on(\"change\", $.proxy(function () {\r\n        this.setOutlineStroke(parseFloat($(\"input[name='filter_outlinestroke']\").val()))\r\n      }, figure))\r\n\r\n\r\n    let picker = this.colorPicker = new jscolor.color(document.getElementById('filter_outlinestroke_color'), {})\r\n    this.colorPicker.fromString(figure.getOutlineColor().hash())\r\n    this.colorPicker.onImmediateChange = $.proxy(function () {\r\n      this.setOutlineColor(\"#\" + picker.toString())\r\n    }, figure)\r\n\r\n    $(\"#button_remove_OutlineStrokeFilter\").on(\"click\", () => {\r\n      figure.removeFilter(this)\r\n      figure.setOutlineStroke(0)\r\n      $(\"#\"+this.containerId).animate({\"height\": \"0\", \"opacity\": 0, \"margin-bottom\": 0}, 500, () => {\r\n        $('#'+this.containerId).remove()\r\n      })\r\n    })\r\n  }\r\n\r\n  removePane() {\r\n    if (this.colorPicker !== null) {\r\n      this.colorPicker.hidePicker()\r\n    }\r\n  }\r\n\r\n  onInstall(figure) {\r\n    figure.setOutlineStroke(1)\r\n    figure.setOutlineColor(\"#ff0000\")\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n","import Filter from \"./Filter\"\r\n\r\nexport default shape_designer.filter.PortDirectionFilter = class PortDirectionFilter extends Filter {\r\n\r\n  constructor() {\r\n    super(\"shape_designer.filter.PortDirectionFilter\")\r\n  }\r\n\r\n  insertPane(figure, $parent) {\r\n    var _this = this\r\n    var dir = figure.getConnectionDirection()\r\n    $parent.append('<div id=\"' + this.containerId + '\" class=\"panel panel-default\">' +\r\n      ' <div class=\"panel-heading filter-heading\" data-toggle=\"collapse\" data-target=\"#' + this.cssScope + '_panel\">' +\r\n      '     Connection Direction' +\r\n      '</div>' +\r\n\r\n      ' <div class=\"panel-body collapse in\" id=\"' + this.cssScope + '_panel\">' +\r\n      '   <div class=\"form-group portDirectionOption\">' +\r\n      '      <div class=\"input-group\" ></div> ' + // required to ensure the correct width of the siblings\r\n\r\n      '<label>' +\r\n      '  <input ' + (dir === 0 ? ' checked=\"checked\"' : '') + ' type=\"radio\" value=\"\" name=\"' + this.cssScope + '_label\" name=\"' + this.cssScope + '_label\" data-dir=\"0\" />' +\r\n      '  <span  title=\"up\" class=\"glyphicon glyphicon-arrow-up\"></span>' +\r\n      '</label>' +\r\n\r\n      '<br>' +\r\n\r\n      '<label>' +\r\n      '  <input ' + (dir === 3 ? ' checked=\"checked\"' : '') + 'type=\"radio\" value=\"\" name=\"' + this.cssScope + '_label\" name=\"' + this.cssScope + '_label\" data-dir=\"3\" />' +\r\n      '  <span  title=\"left\" class=\"glyphicon glyphicon-arrow-left\"></span>' +\r\n      '</label>' +\r\n\r\n      '<label>' +\r\n      '  <input ' + (dir === null ? ' checked=\"checked\"' : '') + 'type=\"radio\" value=\"\" name=\"' + this.cssScope + '_label\" name=\"' + this.cssScope + '_label\" data-dir=\"null\" />' +\r\n      '  <span title=\"automatic\" class=\"glyphicon glyphicon-screenshot\"></span>' +\r\n      '</label>' +\r\n\r\n      '<label>' +\r\n      '  <input ' + (dir === 1 ? ' checked=\"checked\"' : '') + 'type=\"radio\" value=\"\" name=\"' + this.cssScope + '_label\" name=\"' + this.cssScope + '_label\" data-dir=\"1\" />' +\r\n      '  <span title=\"right\"  class=\"glyphicon glyphicon-arrow-right\"></span>' +\r\n      '</label>' +\r\n\r\n      '<br>' +\r\n\r\n      '<label>' +\r\n      '  <input ' + (dir === 2 ? ' checked=\"checked\"' : '') + 'type=\"radio\" value=\"\" name=\"' + this.cssScope + '_label\" name=\"' + this.cssScope + '_label\" data-dir=\"2\" />' +\r\n      '  <span  title=\"down\" class=\"glyphicon glyphicon-arrow-down\"></span>' +\r\n      '</label>' +\r\n\r\n\r\n      '       </div>' +\r\n      '   </div>' +\r\n      ' </div>' +\r\n      '</div>')\r\n    inlineSVG.init({svgSelector:\"#\"+this.containerId + \" img.svg\"})\r\n\r\n    $(\"#\" + _this.cssScope + \"_panel .portDirectionOption input\").on(\"change\", (event) => {\r\n      figure.setConnectionDirection($(event.currentTarget).data(\"dir\"))\r\n    })\r\n  }\r\n\r\n  removePane() {\r\n  }\r\n\r\n  onInstall(figure) {\r\n  }\r\n\r\n  getPersistentAttributes(relatedFigure) {\r\n    var memento = super.getPersistentAttributes(relatedFigure)\r\n\r\n    return memento\r\n  }\r\n\r\n  setPersistentAttributes(relatedFigure, memento) {\r\n    super.setPersistentAttributes(relatedFigure, memento)\r\n\r\n    return memento\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n","import Filter from \"./Filter\"\r\n\r\nexport default shape_designer.filter.PortTypeFilter = class PortTypeFilter extends Filter {\r\n\r\n  constructor() {\r\n    super(\"shape_designer.filter.PortTypeFilter\")\r\n  }\r\n\r\n  insertPane(figure, $parent) {\r\n    var _this = this\r\n    var type = figure.getInputType()\r\n    $parent.append('<div id=\"' + this.containerId + '\" class=\"panel panel-default\">' +\r\n      ' <div class=\"panel-heading filter-heading\" data-toggle=\"collapse\" data-target=\"#' + this.cssScope + '_panel\">' +\r\n      '     Port Type' +\r\n      '</div>' +\r\n\r\n      ' <div class=\"panel-body collapse in\" id=\"' + this.cssScope + '_panel\">' +\r\n      '   <div class=\"form-group portTypeOption\">' +\r\n\r\n      '<label>' +\r\n      '  <input ' + (type == 'Input' ? ' checked=\"checked\"' : '') + 'type=\"radio\" value=\"\" name=\"' + this.cssScope + '_label\" name=\"' + this.cssScope + '_label\" data-type=\"Input\" />' +\r\n      '  <span  title=\"down\" class=\"icon ion-log-in\">input</span>' +\r\n      '</label>' +\r\n      '<br>' +\r\n      '<label>' +\r\n      '  <input ' + (type == 'Output' ? ' checked=\"checked\"' : '') + 'type=\"radio\" value=\"\" name=\"' + this.cssScope + '_label\" name=\"' + this.cssScope + '_label\" data-type=\"Output\" />' +\r\n      '  <span  title=\"down\" class=\"icon ion-log-out\">output</span>' +\r\n      '</label>' +\r\n      '<br>' +\r\n      '<label>' +\r\n      '  <input ' + (type == 'Hybrid' ? ' checked=\"checked\"' : '') + 'type=\"radio\" value=\"\" name=\"' + this.cssScope + '_label\" name=\"' + this.cssScope + '_label\" data-type=\"Hybrid\" />' +\r\n      '  <span  title=\"down\" class=\"icon ion-ios-circle-outline\">unspecified</span>' +\r\n      '</label>' +\r\n\r\n      '       </div>' +\r\n      '   </div>' +\r\n      ' </div>' +\r\n      '</div>')\r\n    inlineSVG.init({svgSelector:\"#\"+this.containerId + \" img.svg\"})\r\n\r\n    $(\"#\" + _this.cssScope + \"_panel .portTypeOption input\").on(\"change\", (event) => {\r\n      figure.setInputType($(event.currentTarget).data(\"type\"))\r\n    })\r\n  }\r\n\r\n  removePane() {\r\n  }\r\n\r\n  onInstall(figure) {\r\n  }\r\n\r\n  getPersistentAttributes(relatedFigure) {\r\n    var memento = super.getPersistentAttributes(relatedFigure)\r\n\r\n    return memento\r\n  }\r\n\r\n  setPersistentAttributes(relatedFigure, memento) {\r\n    super.setPersistentAttributes(relatedFigure, memento)\r\n\r\n    return memento\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n","import Filter from \"./Filter\"\r\n\r\nexport default shape_designer.filter.PositionFilter = class PositionFilter extends Filter {\r\n\r\n  constructor() {\r\n    super(\"shape_designer.filter.PositionFilter\")\r\n  }\r\n\r\n  insertPane(figure, $parent) {\r\n\r\n    $parent.append('<div id=\"' + this.containerId + '\" class=\"panel panel-default\">' +\r\n      ' <div class=\"panel-heading filter-heading\" data-toggle=\"collapse\" data-target=\"#position_width_panel\">' +\r\n      '     Position' +\r\n      '</div>' +\r\n      ' <div class=\"panel-body  collapse in\" id=\"position_width_panel\">' +\r\n      '   <div class=\"form-group\">' +\r\n      '      <div class=\"input-group\" ></div> ' + // required to ensure the correct width of the siblings\r\n      '       <input id=\"filter_position_x\" type=\"text\" value=\"' + parseFloat(figure.getPosition().x) + '\" name=\"filter_position_x\" class=\"mousetrap-pause form-control\" />' +\r\n      '       <input id=\"filter_position_y\" type=\"text\" value=\"' + parseFloat(figure.getPosition().y) + '\" name=\"filter_position_y\" class=\"mousetrap-pause form-control\" />' +\r\n      '   </div>' +\r\n      ' </div>' +\r\n      '</div>')\r\n    inlineSVG.init({svgSelector:\"#\"+this.containerId + \" img.svg\"})\r\n\r\n    $(\"#filter_position_x\").TouchSpin({\r\n      min: 0,\r\n      max: 10000,\r\n      step: 1,\r\n      maxboostedstep: 10,\r\n      postfix: 'X'\r\n    })\r\n\r\n    $(\"#filter_position_y\").TouchSpin({\r\n      min: 0,\r\n      max: 10000,\r\n      step: 1,\r\n      maxboostedstep: 10,\r\n      postfix: 'Y'\r\n    })\r\n\r\n    $(\"input[name='filter_position_x']\").on(\"change\", () => {\r\n      try {\r\n        this.block = true\r\n        let pos = figure.getPosition()\r\n        figure.setPosition(parseFloat($(\"input[name='filter_position_x']\").val()), pos.y)\r\n      }\r\n      finally {\r\n        this.block = false\r\n      }\r\n    })\r\n\r\n    $(\"input[name='filter_position_y']\").on(\"change\", () => {\r\n      try {\r\n        this.block = true\r\n        let pos = figure.getPosition()\r\n        figure.setPosition(pos.x, parseFloat($(\"input[name='filter_position_y']\").val()))\r\n      }\r\n      finally {\r\n        this.block = false\r\n      }\r\n    })\r\n  }\r\n\r\n  apply(figure, attributes) {\r\n    if (this.block === true) {\r\n      return\r\n    }\r\n    let pos = figure.getPosition()\r\n    $(\"input[name='filter_position_y']\").val(pos.y)\r\n    $(\"input[name='filter_position_x']\").val(pos.x)\r\n  }\r\n\r\n  removePane() {\r\n  }\r\n\r\n  onInstall(figure) {\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n","import Filter from \"./Filter\"\r\n\r\nexport default shape_designer.filter.RadiusFilter = class RadiusFilter extends Filter {\r\n\r\n  constructor() {\r\n    super(\"shape_designer.filter.RadiusFilter\")\r\n  }\r\n\r\n  insertPane(figure, $parent) {\r\n\r\n    $parent.append('<div id=\"' + this.containerId + '\" class=\"panel panel-default\">' +\r\n      ' <div class=\"panel-heading filter-heading\" data-toggle=\"collapse\" data-target=\"#radius_panel\">' +\r\n      '    Corner Radius' +\r\n      '    <span id=\"button_remove_RadiusFilter\"><img class=\"svg icon pull-right\" src=\"./images/dialog_close.svg\"/></span>' +\r\n      '</div>' +\r\n      ' <div class=\"panel-body collapse in\" id=\"radius_panel\">' +\r\n      '   <div class=\"form-group\">' +\r\n      '      <div class=\"input-group\" ></div> ' + // required to ensure the correct width of the siblings\r\n      '      <div class=\"input-group\">' +\r\n      '         <input class=\"mousetrap-pause form-control\" id=\"filter_radius\" type=\"text\" value=\"' + figure.getRadius() + '\" />' +\r\n      '      </div>' +\r\n      '   </div>' +\r\n      ' </div>' +\r\n      '</div>')\r\n    inlineSVG.init({svgSelector:\"#\"+this.containerId + \" img.svg\"})\r\n\r\n    $(\"#filter_radius\").TouchSpin({\r\n      min: 0,\r\n      max: 200,\r\n      step: 1,\r\n      maxboostedstep: 10,\r\n      postfix: 'px'\r\n    })\r\n    $(\"#filter_radius\").on(\"change\", $.proxy(function () {\r\n      this.setRadius(parseInt($(\"#filter_radius\").val()))\r\n    }, figure))\r\n\r\n    $(\"#button_remove_RadiusFilter\").on(\"click\", () => {\r\n      figure.removeFilter(this)\r\n      figure.setRadius(0)\r\n      $(\"#\"+this.containerId).animate({\"height\": \"0\", \"opacity\": 0, \"margin-bottom\": 0}, 500, () => {\r\n        $('#'+this.containerId).remove()\r\n      })\r\n    })\r\n  }\r\n\r\n  removePane() {\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n","import Filter from \"./Filter\"\r\n\r\nexport default shape_designer.filter.SizeFilter = class SizeFilter extends Filter {\r\n\r\n  constructor() {\r\n    super(\"shape_designer.filter.SizeFilter\")\r\n  }\r\n\r\n  insertPane(figure, $parent) {\r\n\r\n    $parent.append('<div id=\"' + this.containerId + '\" class=\"panel panel-default\">' +\r\n      ' <div class=\"panel-heading filter-heading\" data-toggle=\"collapse\" data-target=\"#size_width_panel\">' +\r\n      '     Size' +\r\n      ' </div>' +\r\n      ' <div class=\"panel-body  collapse in\" id=\"size_width_panel\">' +\r\n      '   <div class=\"form-group\">' +\r\n      '       <div class=\"input-group\" ></div> ' + // required to ensure the correct width of the siblings\r\n      '       <input id=\"filter_width\"  type=\"text\" value=\"' + figure.getWidth() + '\"  name=\"filter_width\"  class=\"mousetrap-pause form-control\" />' +\r\n      '       <input id=\"filter_height\" type=\"text\" value=\"' + figure.getHeight() + '\" name=\"filter_height\" class=\"mousetrap-pause form-control\" />' +\r\n      '   </div>' +\r\n      ' </div>' +\r\n      '</div>')\r\n    inlineSVG.init({svgSelector:\"#\"+this.containerId + \" img.svg\"})\r\n\r\n    $(\"#filter_width\").TouchSpin({\r\n      min: 0,\r\n      max: 600,\r\n      step: 1,\r\n      maxboostedstep: 10,\r\n      postfix: 'width'\r\n    })\r\n\r\n    $(\"#filter_height\").TouchSpin({\r\n      min: 0,\r\n      max: 600,\r\n      step: 1,\r\n      maxboostedstep: 10,\r\n      postfix: 'height'\r\n    })\r\n\r\n    $(\"input[name='filter_width']\").on(\"change\", () => {\r\n      try {\r\n        this.block = true\r\n        figure.setWidth(parseInt($(\"input[name='filter_width']\").val()))\r\n      }\r\n      finally {\r\n        this.block = false\r\n      }\r\n    })\r\n\r\n    $(\"input[name='filter_height']\").on(\"change\", () => {\r\n      try {\r\n        this.block = true\r\n        figure.setHeight(parseInt($(\"input[name='filter_height']\").val()))\r\n      }\r\n      finally {\r\n        this.block = false\r\n      }\r\n    })\r\n  }\r\n\r\n  apply(figure, attributes) {\r\n    if (this.block === true) {\r\n      return\r\n    }\r\n\r\n    $(\"input[name='filter_width']\").val(figure.getWidth())\r\n    $(\"input[name='filter_height']\").val(figure.getHeight())\r\n  }\r\n\r\n  removePane() {\r\n  }\r\n\r\n  onInstall(figure) {\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n","import jscolor from \"../widget/jscolor/jscolor\"\r\n\r\nimport Filter from \"./Filter\"\r\n\r\nexport default shape_designer.filter.StrokeFilter = class StrokeFilter extends Filter {\r\n\r\n  constructor() {\r\n    super(\"shape_designer.filter.StrokeFilter\")\r\n  }\r\n\r\n  insertPane(figure, $parent) {\r\n    $parent.append('<div id=\"' + this.containerId + '\" class=\"panel panel-default\">' +\r\n      ' <div class=\"panel-heading filter-heading\" data-toggle=\"collapse\" data-target=\"#' + this.cssScope + '_width_panel\">' +\r\n      '     Stroke' +\r\n      '    <span id=\"button_remove_' + this.cssScope + '\"><img  class=\"svg icon pull-right\" src=\"./images/dialog_close.svg\"/></span>' +\r\n      '</div>' +\r\n\r\n      ' <div class=\"panel-body collapse in\" id=\"' + this.cssScope + '_width_panel\">' +\r\n      '   <div class=\"form-group\">' +\r\n      '      <div class=\"input-group\" ></div> ' + // required to ensure the correct width of the siblings\r\n      '       <input id=\"filter_' + this.cssScope + '_width\" type=\"text\" value=\"' + figure.getStroke() + '\" name=\"filter_' + this.cssScope + '_width\" class=\"mousetrap-pause form-control\" />' +\r\n      '       <div class=\"input-group\">' +\r\n      '          <span class=\"input-group-addon\">#</span>' +\r\n      '          <input id=\"filter_' + this.cssScope + '_color\" type=\"text\" value=\"\" name=\"stroke_' + this.cssScope + '_color\" class=\"mousetrap-pause form-control color\"/>' +\r\n      '       </div>' +\r\n      '   </div>' +\r\n      ' </div>' +\r\n      '</div>')\r\n    inlineSVG.init({svgSelector:\"#\"+this.containerId + \" img.svg\"})\r\n\r\n    $(\"input[name='filter_\" + this.cssScope + \"_width']\").TouchSpin({\r\n      min: 0,\r\n      max: 50,\r\n      step: 1,\r\n      maxboostedstep: 1,\r\n      postfix: 'px'\r\n    })\r\n    $(\"input[name='filter_\" + this.cssScope + \"_width']\").on(\"change\", $.proxy(function () {\r\n      this.setStroke(parseInt($(\"input[name='filter_\" + this.cssScope + \"_width']\").val()))\r\n    }, figure))\r\n\r\n    var picker = this.colorPicker = new jscolor.color(document.getElementById('filter_' + this.cssScope + '_color'), {})\r\n    this.colorPicker.fromString(figure.getColor().hash())\r\n    this.colorPicker.onImmediateChange = $.proxy(function () {\r\n      this.setColor(\"#\" + picker.toString())\r\n    }, figure)\r\n\r\n    $(\"#button_remove_\" + this.cssScope).on(\"click\", () => {\r\n      figure.removeFilter(this)\r\n      figure.setStroke(0)\r\n      $(\"#\" + this.containerId ).animate({\"height\": \"0\", \"opacity\": 0, \"margin-bottom\": 0}, 500, () => {\r\n        $('#' + this.containerId).remove()\r\n      })\r\n    })\r\n  }\r\n\r\n  removePane() {\r\n    if (this.colorPicker !== null) {\r\n      this.colorPicker.hidePicker()\r\n    }\r\n  }\r\n\r\n  onInstall(figure) {\r\n    figure.setStroke(1)\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n","import jscolor from \"../widget/jscolor/jscolor\"\r\n\r\nimport Filter from \"./Filter\"\r\nimport \"../widget/ui.anglepicker\"\r\n\r\nexport default shape_designer.filter.TextLinearGradientFilter = class TextLinearGradientFilter extends Filter {\r\n\r\n  constructor() {\r\n    super(\"shape_designer.filter.TextLinearGradientFilter\")\r\n    this.colorPicker1 = null\r\n    this.colorPicker2 = null\r\n    this.startColor = \"#f0f0f0\"\r\n    this.endColor = \"#3f3f3f\"\r\n    this.angle = 0\r\n  }\r\n\r\n  insertPane(figure, $parent) {\r\n\r\n    $parent.append('<div id=\"' + this.containerId + '\" class=\"panel panel-default\">' +\r\n      ' <div class=\"panel-heading filter-heading\" data-toggle=\"collapse\" data-target=\"#' + this.cssScope + '_panel\">' +\r\n      '     Linear Gradient' +\r\n      '    <span id=\"button_remove_' + this.cssScope + '\"><img  class=\"svg icon pull-right\" src=\"./images/dialog_close.svg\"/></span>' +\r\n      '</div>' +\r\n\r\n      ' <div class=\"panel-body collapse in\" id=\"' + this.cssScope + '_panel\">' +\r\n      '   <div class=\"form-group\">' +\r\n      '      <div class=\"input-group\" ></div> ' + // required to ensure the correct width of the siblings\r\n      '      <div class=\"input-group text-center\" style=\"width:100%\" >' +\r\n      '           <div id=\"' + this.cssScope + '_angle\" />' +\r\n      '      </div> ' +\r\n      '       <div class=\"input-group\">' +\r\n      '          <span class=\"input-group-addon\">#</span>' +\r\n      '          <input id=\"' + this.cssScope + '_color1\" type=\"text\" value=\"' + this.startColor + '\" class=\"mousetrap-pause form-control color\"/>' +\r\n      '       </div>' +\r\n      '       <div class=\"input-group\">' +\r\n      '          <span class=\"input-group-addon\">#</span>' +\r\n      '          <input id=\"' + this.cssScope + '_color2\" type=\"text\" value=\"' + this.endColor + '\" class=\"mousetrap-pause form-control color\"/>' +\r\n      '       </div>' +\r\n      '   </div>' +\r\n      ' </div>' +\r\n      '</div>')\r\n    inlineSVG.init({svgSelector:\"#\"+this.containerId + \" img.svg\"})\r\n\r\n    $('#' + this.cssScope + '_angle').anglepicker({\r\n      start: (e, ui) => {\r\n      },\r\n      change: (e, ui) => {\r\n        this.angle = ui.value\r\n        figure.repaint()\r\n      },\r\n      stop: (e, ui) => {\r\n      },\r\n      value: this.angle\r\n    })\r\n\r\n    var picker1 = this.colorPicker1 = new jscolor.color($(\"#\" + this.cssScope + '_color1')[0], {})\r\n    this.colorPicker1.fromString(this.startColor)\r\n    this.colorPicker1.onImmediateChange = () => {\r\n      this.startColor = \"#\" + picker1.toString()\r\n      figure.repaint()\r\n    }\r\n\r\n    var picker2 = this.colorPicker2 = new jscolor.color($(\"#\" + this.cssScope + '_color2')[0], {})\r\n    this.colorPicker2.fromString(this.endColor)\r\n    this.colorPicker2.onImmediateChange = () => {\r\n      this.endColor = \"#\" + picker2.toString()\r\n      figure.repaint()\r\n    }\r\n\r\n\r\n    $(\"#button_remove_\" + this.cssScope).on(\"click\", () => {\r\n      figure.removeFilter(this)\r\n      $('#' + this.containerId).animate({\r\n        \"height\": \"0\",\r\n        \"opacity\": 0,\r\n        \"margin-bottom\": 0\r\n      }, 500, () => {\r\n        $('#' + this.containerId ).remove()\r\n      })\r\n    })\r\n  }\r\n\r\n  apply(figure, attributes, lattr) {\r\n    lattr.fill = this.angle + \"-\" + this.endColor + \"-\" + this.startColor\r\n  }\r\n\r\n  removePane() {\r\n    if (this.colorPicker1 !== null) {\r\n      this.colorPicker1.hidePicker()\r\n    }\r\n    if (this.colorPicker2 !== null) {\r\n      this.colorPicker2.hidePicker()\r\n    }\r\n  }\r\n\r\n  onInstall(figure) {\r\n  }\r\n\r\n  getPersistentAttributes(relatedFigure) {\r\n    let memento = super.getPersistentAttributes(relatedFigure)\r\n\r\n    memento.startColor = this.startColor\r\n    memento.endColor = this.endColor\r\n    memento.angle = this.angle\r\n\r\n    return memento\r\n  }\r\n\r\n  setPersistentAttributes(relatedFigure, memento) {\r\n    super.setPersistentAttributes(relatedFigure, memento)\r\n\r\n    this.startColor = memento.startColor\r\n    this.endColor = memento.endColor\r\n    this.angle = memento.angle\r\n\r\n    return memento\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n","// required to register them for JSON serialize/deserialize\r\n//\r\nexport default [\r\n  require(\"./BlurFilter\"),\r\n  require(\"./FanoutFilter\"),\r\n  require(\"./FillColorFilter\"),\r\n  require(\"./Filter\"),\r\n  require(\"./FontColorFilter\"),\r\n  require(\"./FontSizeFilter\"),\r\n  require(\"./LinearGradientFilter\"),\r\n  require(\"./OpacityFilter\"),\r\n  require(\"./OutlineStrokeFilter\"),\r\n  require(\"./PortDirectionFilter\"),\r\n  require(\"./PortTypeFilter\"),\r\n  require(\"./PositionFilter\"),\r\n  require(\"./RadiusFilter\"),\r\n  require(\"./SizeFilter\"),\r\n  require(\"./StrokeFilter\"),\r\n  require(\"./TextLinearGradientFilter\")\r\n]\r\n","\r\nimport DecoratedInputPort from \"./figure/DecoratedInputPort\"\r\nimport CircuitFigure from \"./figure/CircuitFigure\"\r\nimport Mousetrap from \"mousetrap\"\r\nimport \"./util/mousetrap-global\"\r\nimport \"./util/mousetrap-pause\"\r\nimport hardware from \"./Hardware\"\r\nimport inlineSVG from \"../lib/inlineSVG\"\r\nimport LabelInplaceEditor from './LabelInplaceEditor'\r\nimport skillproxy from \"./io/BackendSkills\"\r\nimport ValueParserValidator from \"./util/ValueParserValidator\"\r\n\r\nexport default {\r\n  hardware,\r\n  DecoratedInputPort,\r\n  LabelInplaceEditor,\r\n  Mousetrap,\r\n  CircuitFigure,\r\n  inlineSVG,\r\n  skillproxy,\r\n  ValueParserValidator\r\n}\r\n","\r\nimport \"../less/index.less\"\r\nimport \"font-awesome/css/font-awesome.css\"\r\nimport global from \"./global\"\r\nimport conf from \"./Configuration\"\r\n\r\n//require('webpack-jquery-ui/css');  //ommit, if you don't want to load basic css theme\r\n\r\n// Resolve name collision between jQuery UI and Twitter Bootstrap\r\n/*** Handle jQuery plugin naming conflict between jQuery UI and Bootstrap ***/\r\n$.widget.bridge('uibutton', $.ui.button)\r\n$.widget.bridge('uitooltip', $.ui.tooltip)\r\n\r\n\r\n\r\n\r\nimport \"./figure/index\"\r\nimport \"./filter/index\"\r\n\r\n// required to be compatible with jquery.layout and jquery.handsontable\r\n//\r\njQuery.uaMatch = function (ua) {\r\n  ua = ua.toLowerCase()\r\n  var match = /(chrome)[ \\/]([\\w.]+)/.exec(ua) ||\r\n    /(webkit)[ \\/]([\\w.]+)/.exec(ua) ||\r\n    /(opera)(?:.*version|)[ \\/]([\\w.]+)/.exec(ua) ||\r\n    /(msie) ([\\w.]+)/.exec(ua) ||\r\n    ua.indexOf(\"compatible\") < 0 && /(mozilla)(?:.*? rv:([\\w.]+)|)/.exec(ua) ||\r\n    []\r\n  return {\r\n    browser: match[1] || \"\",\r\n    version: match[2] || \"0\"\r\n  }\r\n}\r\nif (!jQuery.browser) {\r\n  let matched = jQuery.uaMatch(navigator.userAgent)\r\n  let browser = {}\r\n  if (matched.browser) {\r\n    browser[matched.browser] = true\r\n    browser.version = matched.version\r\n  }\r\n// Chrome is Webkit, but Webkit is also Safari.\r\n  if (browser.chrome) {\r\n    browser.webkit = true\r\n  } else if (browser.webkit) {\r\n    browser.safari = true\r\n  }\r\n  jQuery.browser = browser\r\n}\r\n\r\n\r\nimport Application from \"./Application\"\r\n\r\n$(window).load(function () {\r\n\r\n  // export all required classes for deserialize JSON with \"eval\"\r\n  // \"eval\" code didn't sees imported class or code\r\n  //\r\n  for(var k in global) window[k]=global[k];\r\n\r\n  socket = io(\r\n    {\r\n      path: '/socket.io'\r\n    })\r\n\r\n  // Hack: add socket to the global context\r\n  window['socket']=socket;\r\n\r\n  // remove the fileOpen/Save stuff if we run in a \"serverless\" mode. e.g. on gh-pages\r\n  // (fake event from the socket.io mock )\r\n  //\r\n  socket.on(\"serverless\", () => {\r\n    conf.serverless =true\r\n    conf.backend.file.get = file => `./shapes/${file}`\r\n  });\r\n\r\n  socket.on(\"connect\", () => {\r\n    app = shape_designer.app = new Application();\r\n  });\r\n\r\n\r\n});\r\n","import conf from './../Configuration'\r\n\r\nlet sanitize = require(\"sanitize-filename\")\r\n\r\n\r\nclass BackendSkills {\r\n\r\n  /**\r\n   * @constructor\r\n   *\r\n   */\r\n  constructor() {\r\n    this.skillList = [];\r\n    Object.preventExtensions(this);\r\n  }\r\n\r\n  get allSkills() {\r\n    return this.skillList;\r\n  }\r\n\r\n  getSkillStateConfig() {\r\n    return {\r\n        \"nodeKeyProperty\": \"id\",\r\n        \"nodeDataArray\": [\r\n            { \"id\": \"running\", \"text\": \"Running\", \"isGroup\": true, \"group\": \"cleared\", \"isHighlighted\": true, \"nid\": 75 },\r\n            { \"id\": \"stopped\", \"text\": \"Stopped\", \"trans\": 0, \"group\": \"cleared\", \"isHighlighted\": true, \"loc\": \"150 650\", \"nid\": 53 },\r\n            { \"id\": \"cleared\", \"text\": \"cleared\", \"isGroup\": true, \"isHighlighted\": true, \"nid\": 71 },\r\n            { \"id\": \"aborted\", \"text\": \"aborted\", \"trans\": 0, \"loc\": \"600 850\", \"nid\": 62 },\r\n            { \"id\": \"aborting\", \"text\": \"aborting\", \"trans\": 1, \"loc\": \" 370 850\", \"nid\": 61 },\r\n            { \"id\": \"clearing\", \"text\": \"clearing\", \"trans\": 1, \"group\": \"cleared\", \"loc\": \"600 700\", \"nid\": 55 },\r\n            { \"id\": \"stopping\", \"text\": \"stopping\", \"trans\": 1, \"group\": \"cleared\", \"loc\": \"370 650\", \"nid\": 54 },\r\n    \r\n            { \"id\": \"resetting\", \"text\": \"resetting\", \"trans\": 1, \"group\": \"running\", \"isGroup\": true, \"loc\": \"150 500\", \"nid\": 27 },\r\n            { \"id\": \"check_resource\", \"text\": \"Check Res.\", \"trans\": 1, \"group\": \"resetting\", \"isHighlighted\": true, \"loc\": \"0 450\", \"nid\": 1026 },\r\n            { \"id\": \"initialize_resource\", \"text\": \"Init. Res.\", \"trans\": 1, \"group\": \"resetting\", \"loc\": \"300 450\", \"nid\": 1025 },\r\n            { \"id\": \"skill_initialized\", \"text\": \"Skill Res. Init.\", \"trans\": 1, \"group\": \"resetting\", \"loc\": \"150 400\", \"nid\": 1027 },\r\n    \r\n            { \"id\": \"idle\", \"text\": \"idle\", \"trans\": 0, \"group\": \"running\", \"isGroup\": true, \"loc\": \"150 250\", \"nid\": 28 },\r\n            { \"id\": \"init_skill\", \"text\": \"Init. Skill\", \"trans\": 0, \"group\": \"idle\", \"isHighlighted\": true, \"loc\": \"150 270\", \"nid\": 1018 },\r\n            { \"id\": \"skill_ready\", \"text\": \"Skill Ready\", \"trans\": 0, \"group\": \"idle\", \"loc\": \"150 200\", \"nid\": 1017 },\r\n    \r\n    \r\n            { \"id\": \"execute\", \"text\": \"execute\", \"trans\": 0, \"group\": \"running\", \"isGroup\": true, \"loc\": \"400 200\", \"nid\": 36 },\r\n            { \"id\": \"execute_skill\", \"text\": \"Execute Skill\", \"trans\": 0, \"group\": \"execute\", \"loc\": \"400 170\", \"nid\": 1013 },\r\n            { \"id\": \"wait_next_step\", \"text\": \"Wait next Step\", \"trans\": 0, \"group\": \"execute\", \"loc\": \"400 270\", \"nid\": 1014 },\r\n    \r\n    \r\n            { \"id\": \"completing\", \"text\": \"completing\", \"trans\": 1, \"group\": \"running\", \"loc\": \"600 200\", \"nid\": 37 },\r\n            { \"id\": \"completed\", \"text\": \"completed\", \"trans\": 0, \"group\": \"running\", \"loc\": \"800 200\", \"nid\": 38 },\r\n    \r\n            { \"id\": \"hold\", \"text\": \"hold\", \"trans\": 0, \"group\": \"running\", \"isGroup\": true, \"isHighlighted\": true, \"loc\": \"350 0\", \"nid\": 136 },\r\n            { \"id\": \"holding\", \"text\": \"holding\", \"trans\": 1, \"group\": \"hold\", \"loc\": \"200 0\", \"nid\": 1020 },\r\n            { \"id\": \"held\", \"text\": \"held\", \"trans\": 0, \"group\": \"hold\", \"loc\": \"400 0\", \"nid\": 1021 },\r\n            { \"id\": \"unholding\", \"text\": \"unholding\", \"trans\": 1, \"group\": \"hold\", \"loc\": \"600 0\", \"nid\": 1022 }\r\n        ],\r\n        \"linkDataArray\": [\r\n    \r\n            { \"from\": \"cleared\", \"to\": \"aborting\", \"curviness\": 0, \"text\": \"Abort\" },\r\n            { \"from\": \"aborting\", \"to\": \"aborted\", \"curviness\": 0, \"text\": \"SC\" },\r\n            { \"from\": \"aborted\", \"to\": \"clearing\", \"curviness\": 0, \"text\": \"Clear\" },\r\n            { \"from\": \"clearing\", \"to\": \"stopped\", \"curviness\": 50, \"text\": \"SC\" },\r\n            { \"from\": \"stopped\", \"to\": \"resetting\", \"curviness\": 0, \"text\": \"Reset\" },\r\n    \r\n            { \"from\": \"skill_initialized\", \"to\": \"idle\", \"curviness\": 0, \"text\": \"SC\" },\r\n            { \"from\": \"check_resource\", \"to\": \"skill_initialized\", \"curviness\": 20, \"text\": \"OK\" },\r\n            { \"from\": \"check_resource\", \"to\": \"initialize_resource\", \"curviness\": 0, \"text\": \"n.OK\" },\r\n            { \"from\": \"initialize_resource\", \"to\": \"check_resource\", \"curviness\": 50, \"text\": \"SC\" },\r\n    \r\n    \r\n            { \"from\": \"skill_ready\", \"to\": \"execute_skill\", \"curviness\": 0, \"text\": \"StartSkill\" },\r\n            { \"from\": \"init_skill\", \"to\": \"skill_ready\", \"curviness\": 0, \"text\": \"SC\" },\r\n    \r\n            { \"from\": \"execute_skill\", \"to\": \"completing\", \"curviness\": 0, \"text\": \"SC\" },\r\n            { \"from\": \"completing\", \"to\": \"completed\", \"curviness\": 0, \"text\": \"SC\" },\r\n            { \"from\": \"completed\", \"to\": \"init_skill\", \"curviness\": 180, \"text\": \"Reset\" },\r\n            { \"from\": \"execute\", \"to\": \"hold\", \"curviness\": 0, \"text\": \"hold\" },\r\n            { \"from\": \"holding\", \"to\": \"held\", \"curviness\": 0, \"text\": \"SC\" },\r\n            { \"from\": \"held\", \"to\": \"unholding\", \"curviness\": 0, \"text\": \"UnHold\" },\r\n            { \"from\": \"unholding\", \"to\": \"execute_skill\", \"curviness\": 0, \"text\": \"SC\" },\r\n            { \"from\": \"running\", \"to\": \"stopping\", \"curviness\": 0, \"text\": \"Stop\" },\r\n            { \"from\": \"stopping\", \"to\": \"stopped\", \"curviness\": 0, \"text\": \"SC\" },\r\n    \r\n            { \"from\": \"execute_skill\", \"to\": \"wait_next_step\", \"curviness\": 0, \"text\": \"SC\" },\r\n            { \"from\": \"wait_next_step\", \"to\": \"execute_skill\", \"curviness\": 50, \"text\": \"NEXT\" }\r\n        ]\r\n    }\r\n  }\r\n\r\n\r\n  connectSkill(ip, port) {\r\n    const self = this;\r\n    self.skillList = [];\r\n    return $.ajax({\r\n      url: conf.backend.skill.connect,\r\n      xhrFields: {\r\n        withCredentials: true\r\n      },\r\n      data: {\r\n        ip: ip,\r\n        port:port\r\n      }\r\n    }).then((resp) => {\r\n      if (resp.err){\r\n        return {err: resp.err};\r\n      }else{\r\n        self.skillList = resp.results;\r\n        return {err: resp.err, skills:self.skillList};\r\n      }        \r\n      return {err: \"Unknown response.\"};\r\n    });\r\n  }\r\n\r\n  browseSkills(ip, port) {\r\n    const self = this;\r\n    self.skillList = [];\r\n    return $.ajax({\r\n      url: conf.backend.skill.browse,\r\n      xhrFields: {\r\n        withCredentials: true\r\n      },\r\n      data: {\r\n        ip: ip,\r\n        port:port\r\n      }\r\n    }).then((resp) => {\r\n      if (resp.err){\r\n        return {err: resp.err};\r\n      }else{\r\n        self.skillList = resp.results;\r\n        return {err: resp.err, skills:self.skillList};\r\n      }        \r\n      return {err: \"Unknown response.\"};\r\n    });\r\n  }\r\n\r\n  saveSkill(skillObject, _machineName) {\r\n    return $.ajax({\r\n        url: conf.backend.skill.save,\r\n        method: \"POST\",\r\n        async: false,\r\n        xhrFields: {\r\n          withCredentials: true\r\n        },\r\n        data: {\r\n          filePath: \"\" + _machineName + \"_\" + skillObject.ip + \"_\" + skillObject.port + \"_\"+ skillObject.skill.name + \".shape\",\r\n          skill: skillObject\r\n        }\r\n      }\r\n    );\r\n  }\r\n\r\n  deleteSkill(skill) {\r\n    // TODO: Jupiter Delete Skill remotely\r\n    // return $.ajax({\r\n    //     url: conf.backend.skill.del,\r\n    //     method: \"POST\",\r\n    //     xhrFields: {\r\n    //       withCredentials: true\r\n    //     },\r\n    //     data: {\r\n    //       filePath: fileName\r\n    //     }\r\n    //   }\r\n    // );\r\n  }\r\n\r\n  getSkillDescription(skill_name) {\r\n    const self = this;\r\n    return $.ajax({\r\n      url: conf.backend.skill.getDescription,\r\n      xhrFields: {\r\n        withCredentials: true\r\n      },\r\n      data: {\r\n        skill_name: skill_name,\r\n      }\r\n    }).then((resp) => {\r\n      if (resp.err){\r\n        return {err: resp.err};\r\n      }else{\r\n        return {err: resp.err, skill_descp: JSON.parse(resp.skill_descp)};\r\n      }        \r\n      return {err: \"Unknown response.\"};\r\n    });\r\n  }\r\n\r\n  startSkill(_ip, _port, _skill_name, _parameters) {\r\n    const self = this;\r\n    self.skillList = [];\r\n    return $.ajax({\r\n      url: conf.backend.skill.call,\r\n      xhrFields: {\r\n        withCredentials: true\r\n      },\r\n      data: {\r\n        ip: _ip,\r\n        port: _port,\r\n        skillName: _skill_name,\r\n        method: 'Start',\r\n        parameters: _parameters\r\n      }\r\n    }).then((resp) => {\r\n      if (resp.err){\r\n        return {err: resp.err};\r\n      }else{\r\n        return {err: resp.err, results: resp.results};\r\n      }        \r\n      return {err: \"Unknown response.\"};\r\n    });\r\n  }\r\n\r\n  getResultsOfSkillCall(_ip, _port, _skill_name, _parameters) {\r\n    const self = this;\r\n    self.skillList = [];\r\n    return $.ajax({\r\n      url: conf.backend.skill.call,\r\n      xhrFields: {\r\n        withCredentials: true\r\n      },\r\n      data: {\r\n        ip: _ip,\r\n        port: _port,\r\n        skillName: _skill_name,\r\n        method: 'GetResults',\r\n        parameters: _parameters\r\n      }\r\n    }).then((resp) => {\r\n      if (resp.err){\r\n        return {err: resp.err};\r\n      }else{\r\n        return {err: resp.err, results: resp.results};\r\n      }        \r\n      return {err: \"Unknown response.\"};\r\n    });\r\n  }\r\n}\r\n\r\nlet skillproxy = new BackendSkills();\r\nexport default skillproxy","import conf from '../Configuration'\r\n\r\nexport default class BackendStorage{\r\n\r\n  /**\r\n   * @constructor\r\n   *\r\n   */\r\n  constructor() {\r\n    this.fileName = \"\"\r\n    Object.preventExtensions(this);\r\n  }\r\n\r\n  get currentDir(){\r\n    return this.dirname(this.dirname())\r\n  }\r\n\r\n  get currentFile(){\r\n    return this.basename(this.fileName)\r\n  }\r\n\r\n  set currentFile(name){\r\n    this.fileName=name;\r\n\r\n    let url = window.location.href.split('?')[0] + '?file=' + name\r\n    history.pushState(\r\n      { id: 'editor', file: name },\r\n      'Brainbox Designer ' + name,\r\n      url)\r\n  }\r\n\r\n  getFiles(path){\r\n      return $.ajax({\r\n        url: conf.backend.file.list,\r\n        xhrFields: {\r\n          withCredentials: true\r\n        },\r\n        data: {\r\n          path\r\n        }\r\n      }).then( (response)=>{\r\n        // happens in \"serverless\" mode on the gh-pages/docs installation\r\n        //\r\n        if (typeof response === \"string\")\r\n          response = JSON.parse(response)\r\n\r\n        let files = response.files\r\n        // sort the result\r\n        // Directories are always on top\r\n        //\r\n        files.sort(function (a, b) {\r\n          if (a.type === b.type) {\r\n            if (a.name.toLowerCase() < b.name.toLowerCase())\r\n              return -1\r\n            if (a.name.toLowerCase() > b.name.toLowerCase())\r\n              return 1\r\n            return 0\r\n          }\r\n          if (a.type === \"dir\") {\r\n            return -1\r\n          }\r\n          return 1\r\n        })\r\n        return files;\r\n      })\r\n  }\r\n\r\n  saveFile(json, imageDataUrl, fileName){\r\n    return $.ajax({\r\n        url: conf.backend.file.save,\r\n        method: \"POST\",\r\n        xhrFields: {\r\n          withCredentials: true\r\n        },\r\n        data: {\r\n          filePath: fileName,\r\n          content: JSON.stringify({draw2d: json, image: imageDataUrl}, undefined, 2)\r\n        }\r\n      }\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Load the file content of the given path\r\n   *\r\n   * @param fileName\r\n   * @returns {*}\r\n   */\r\n  loadFile(fileName){\r\n    return $.ajax({\r\n      url: conf.backend.file.get(fileName),\r\n      xhrFields: {\r\n        withCredentials: true\r\n      }\r\n    })\r\n      .fail(function(error) {\r\n        console.log(arguments)\r\n      })\r\n      .then((response)=>{\r\n        // happens in \"serverless\" mode on the gh-pages/docs installation\r\n        //\r\n        if (typeof response === \"string\")\r\n          response = JSON.parse(response)\r\n\r\n        if(response.draw2d)\r\n        return response.draw2d\r\n      return response\r\n    })\r\n  }\r\n\r\n  dirname(path) {\r\n    if (path===undefined || path===null || path.length === 0)\r\n      return null\r\n\r\n    var segments = path.split(\"/\")\r\n    if (segments.length <= 1)\r\n      return null\r\n\r\n    segments = segments.filter(n => n != \"\")\r\n    path = segments.slice(0, -1).join(\"/\")\r\n    return (path === \"\") ? null : path + \"/\"\r\n\r\n  }\r\n\r\n  basename(path) {\r\n    if(path === null || path===\"\" || path === undefined){\r\n      return null;\r\n    }\r\n    return path.split(/[\\\\/]/).pop()\r\n  }\r\n\r\n}\r\n","import Hogan from \"hogan.js\"\r\n\r\nexport default shape_designer.FigureWriter = draw2d.io.Writer.extend({\r\n\r\n  init: function () {\r\n    this._super()\r\n  },\r\n\r\n  /**\r\n   * @method\r\n   * Export the content to the implemented data format. Inherit class implements\r\n   * content specific writer.\r\n   * <br>\r\n   * <br>\r\n   *\r\n   * Method signature has been changed from version 2.10.1 to version 3.0.0.<br>\r\n   * The parameter <b>resultCallback</b> is required and new. The method calls\r\n   * the callback instead of return the result.\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @parma {String} className\r\n   * @param {Function} resultCallback the method to call on success. The first argument is the result object, the second the base64 representation of the file content\r\n   */\r\n  marshal: function (canvas, className, resultCallback) {\r\n    var baseClass = shape_designer.app.getConfiguration(\"baseClass\")\r\n    var customCode =  shape_designer.app.getConfiguration(\"code\")\r\n    customCode = customCode.replace(/testShape/g, className);\r\n\r\n    var figures = canvas.getExtFigures()\r\n    var b = canvas.getBoundingBox()\r\n\r\n    var x = b.x\r\n    var y = b.y\r\n\r\n    var ports = []\r\n    var shapes = []\r\n\r\n    shapes.push({\r\n      constructor: 'this.canvas.paper.path(\"M0,0 L' + (b.w) + ',0 L' + (b.w) + ',' + (b.h) + ' L0,' + (b.h) + '\")',\r\n      attr: '{\"stroke\":\"none\",\"stroke-width\":0,\"fill\":\"none\"}',\r\n      name: \"BoundingBox\"\r\n    })\r\n\r\n    figures.each(function (i, figure) {\r\n      figure.uninstallEditPolicy(\"draw2d.policy.figure.RegionEditPolicy\")\r\n      var attr = {}\r\n      figure.svgPathString = null\r\n      figure.translate(-x, -y)\r\n      // paint the element and fill the \"attr\" object with the current\r\n      // settings\r\n      figure.repaint(attr)\r\n      delete attr.path\r\n      delete attr.x\r\n      delete attr.y\r\n      if ((figure instanceof shape_designer.figure.ExtPolygon)) {\r\n        shapes.push({\r\n          constructor: \"this.canvas.paper.path('\" + figure.svgPathString + \"')\",\r\n          attr: JSON.stringify(attr),\r\n          extra: figure.getBlur() === 0 ? \"\" : \"shape.blur(\" + figure.getBlur() + \");\\n\",\r\n          name: figure.getUserData().name\r\n        })\r\n      } else if ((figure instanceof shape_designer.figure.PolyCircle)) {\r\n        shapes.push({\r\n          constructor: \"this.canvas.paper.ellipse()\",\r\n          attr: JSON.stringify(attr),\r\n          extra: figure.getBlur() === 0 ? \"\" : \"shape.blur(\" + figure.getBlur() + \");\\n\",\r\n          name: figure.getUserData().name\r\n        })\r\n      } else if ((figure instanceof shape_designer.figure.ExtLine)) {\r\n        // drop shadow\r\n        shapes.push({\r\n          constructor: \"this.canvas.paper.path('\" + figure.svgPathString + \"')\",\r\n          attr: JSON.stringify($.extend({}, attr, {\r\n            \"stroke-width\": attr[\"stroke-width\"] + figure.getOutlineStroke(),\r\n            \"stroke\": figure.getOutlineColor().hash()\r\n          })),\r\n          extra: figure.getBlur() === 0 ? \"\" : \"shape.blur(\" + figure.getBlur() + \");\\n\",\r\n          name: figure.getUserData().name + \"_shadow\"\r\n        })\r\n\r\n        // the line itself\r\n        shapes.push({\r\n          constructor: \"this.canvas.paper.path('\" + figure.svgPathString + \"')\",\r\n          attr: JSON.stringify(attr),\r\n          extra: figure.getBlur() === 0 ? \"\" : \"shape.blur(\" + figure.getBlur() + \");\\n\",\r\n          name: figure.getUserData().name\r\n        })\r\n      } else if (figure instanceof shape_designer.figure.ExtLabel) {\r\n        attr = figure.svgNodes[0].attr()\r\n        attr.x = attr.x + figure.getAbsoluteX()\r\n        attr.y = attr.y + figure.getAbsoluteY()\r\n        delete attr.transform\r\n        shapes.push({\r\n          constructor: \"this.canvas.paper.text(0,0,'\" + figure.getText() + \"')\",\r\n          attr: JSON.stringify(attr),\r\n          extra: \"\",\r\n          name: figure.getUserData().name\r\n        })\r\n      } else if (figure instanceof shape_designer.figure.ExtPort) {\r\n        ports.push({\r\n          type: figure.getInputType() === \"Input\" ? \"new DecoratedInputPort()\" : '\"' + figure.getInputType().toLowerCase() + '\"',\r\n          method: figure.getInputType() === \"Input\" ? \"addPort\" : 'createPort',\r\n          direction: figure.getConnectionDirection(),\r\n          x: 100 / b.w * figure.getCenter().x,\r\n          y: 100 / b.h * figure.getCenter().y,\r\n          color: figure.getBackgroundColor().hash(),\r\n          name: figure.getUserData().name,\r\n          fanout: figure.getMaxFanOut()\r\n        })\r\n      }\r\n      figure.translate(x, y)\r\n    })\r\n\r\n    var template = $(\"#shape-base-template\").text().trim()\r\n\r\n    var tags = className.split(\"_\")\r\n    var compiled = Hogan.compile(template)\r\n    var tooltip= tags.length>0?tags.slice(-1)[0]:name;\r\n    tooltip = tooltip.split(/\\s*(?=[A-Z][a-z])/).join(\" \")\r\n    var output = compiled.render({\r\n      tooltip: tooltip,\r\n      className: className,\r\n      baseClass: baseClass,\r\n      figures: shapes,\r\n      ports: ports,\r\n      width: b.w,\r\n      height: b.h\r\n    })\r\n\r\n    output = output + \"\\n\\n\" + customCode\r\n    resultCallback(output, draw2d.util.Base64.encode(output))\r\n  }\r\n})\r\n","import AbstractToolPolicy from \"./AbstractToolPolicy\"\r\n\r\nconst jsts = require(\"jsts/dist/jsts\")\r\n\r\n/* jshint evil: true */\r\nexport default AbstractToolPolicy.extend({\r\n\r\n  init: function () {\r\n    this._super()\r\n    this.firstFigure = null\r\n    this.operation = null\r\n  },\r\n\r\n\r\n  onInstall: function (canvas) {\r\n    this.setToolHeader(\"\")\r\n    this.setToolMessage(\"Select first figure..\")\r\n  },\r\n\r\n  select: function (canvas, figure) {\r\n\r\n    if (canvas.getSelection().getAll().contains(figure)) {\r\n      return // nothing to to\r\n    }\r\n\r\n    // check if the element an valid polygon. otherwise an boolean operation\r\n    // isn't possible\r\n    if (!(figure instanceof shape_designer.figure.ExtPolygon)) {\r\n      return\r\n    }\r\n\r\n    if (canvas.getSelection().getPrimary() !== null) {\r\n      this.unselect(canvas, canvas.getSelection().getPrimary())\r\n    }\r\n\r\n    if (figure !== null) {\r\n      figure.select(true) // primary selection\r\n    }\r\n\r\n    canvas.getSelection().setPrimary(figure)\r\n\r\n    // inform all selection listeners about the new selection.\r\n    //\r\n    canvas.fireEvent(\"select\", {figure: figure})\r\n  },\r\n\r\n\r\n  execute: function (canvas, firstFigure, figure) {\r\n    if (firstFigure instanceof draw2d.util.ArrayList) {\r\n      if (firstFigure.getSize() < 2) {\r\n        return // silently\r\n      }\r\n      figure = firstFigure.get(1)\r\n      firstFigure = firstFigure.get(0)\r\n    }\r\n    this.executeGeometryOperation(canvas, firstFigure, figure, this.operation)\r\n  },\r\n\r\n  executeGeometryOperation: function (canvas, figure1, figure2, operationFunc) {\r\n    var p1 = this.getGeometry(figure1)\r\n    var p2 = this.getGeometry(figure2)\r\n    var union = eval(\"p1.\" + operationFunc + \"(p2)\")\r\n    var geo = new jsts.io.GeoJSONWriter().write(union)\r\n    var memento = figure1.getPersistentAttributes()\r\n    var cmd = new draw2d.command.CommandCollection()\r\n    cmd.add(new draw2d.command.CommandDelete(figure1))\r\n    cmd.add(new draw2d.command.CommandDelete(figure2))\r\n    $.each(geo.coordinates, $.proxy(function (i, poly) {\r\n      var figure = new shape_designer.figure.ExtPolygon()\r\n      figure.setPersistentAttributes(memento)\r\n      figure.vertices = new draw2d.util.ArrayList()\r\n      $.each(poly, function (i, vertex) {\r\n        figure.addVertex(vertex[0], vertex[1])\r\n      })\r\n      var command = new draw2d.command.CommandAdd(canvas, figure, figure.getX(), figure.getY())\r\n      cmd.add(command)\r\n    }, this))\r\n    canvas.getCommandStack().execute(cmd)\r\n    this.executed()\r\n  },\r\n\r\n  getGeometry: function (figure) {\r\n    var reader = new jsts.io.WKTReader()\r\n    var v = figure.getVertices().clone().asArray()\r\n    v.push(v[0])\r\n    return reader.read(\"POLYGON((\" + $.map(v, function (e) {\r\n      return e.x + \" \" + e.y\r\n    }).join(\", \") + \"))\")\r\n  }\r\n\r\n})\r\n\r\n\r\n\r\n\r\n","export default draw2d.policy.canvas.SelectionPolicy.extend({\r\n\r\n  init: function () {\r\n    this._super()\r\n  },\r\n\r\n  setToolText: function (message) {\r\n    $('#currentTool_message').fadeOut(200, function () {\r\n      $(\"#currentTool_message\").html(message)\r\n      $('#currentTool_message').fadeIn(200)\r\n    })\r\n  },\r\n\r\n  executed: function(){\r\n  }\r\n})\r\n\r\n\r\n\r\n\r\n","import AbstractToolPolicy from \"./AbstractToolPolicy\"\r\n\r\nimport cursor from \"../../images/cursors/cursor_circle.png\"\r\n\r\nexport default AbstractToolPolicy.extend({\r\n\r\n  TITLE: \"Circle\",\r\n\r\n  init: function () {\r\n    this._super()\r\n\r\n    this.center = null\r\n    this.boundingBoxFigure1 = null\r\n    this.boundingBoxFigure2 = null\r\n  },\r\n\r\n\r\n  onInstall: function (canvas) {\r\n    canvas.setCursor(cursor)\r\n  },\r\n\r\n  onUninstall: function (canvas) {\r\n    if (this.boundingBoxFigure1 !== null) {\r\n      this.boundingBoxFigure1.setCanvas(null)\r\n      this.boundingBoxFigure1 = null\r\n      this.boundingBoxFigure2.setCanvas(null)\r\n      this.boundingBoxFigure2 = null\r\n    }\r\n    canvas.setCursor(null)\r\n  },\r\n\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @param {Number} x the x-coordinate of the mouse down event\r\n   * @param {Number} y the y-coordinate of the mouse down event\r\n   * @param {Boolean} shiftKey true if the shift key has been pressed during this event\r\n   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event\r\n   */\r\n  onMouseDown: function (canvas, x, y, shiftKey, ctrlKey) {\r\n    this.center = new draw2d.geo.Point(x, y)\r\n  },\r\n\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @param {Number} dx The x diff between start of dragging and this event\r\n   * @param {Number} dy The y diff between start of dragging and this event\r\n   * @param {Number} dx2 The x diff since the last call of this dragging operation\r\n   * @param {Number} dy2 The y diff since the last call of this dragging operation\r\n   * @template\r\n   */\r\n  onMouseDrag: function (canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey) {\r\n    let r = Math.sqrt(dx * dx + dy * dy)\r\n    if (this.boundingBoxFigure1 !== null) {\r\n      this.boundingBoxFigure1.setRadius(Math.abs(r))\r\n      this.boundingBoxFigure2.setRadius(Math.abs(r))\r\n    }\r\n    else {\r\n      this.boundingBoxFigure1 = new draw2d.shape.basic.Circle({radius: 1})\r\n      this.boundingBoxFigure1.setCenter(this.center)\r\n      this.boundingBoxFigure1.setCanvas(canvas)\r\n      this.boundingBoxFigure1.setBackgroundColor(\"#333333\")\r\n      this.boundingBoxFigure1.setAlpha(0.1)\r\n\r\n      this.boundingBoxFigure2 = new draw2d.shape.basic.Circle({radius: 1})\r\n      this.boundingBoxFigure2.setCenter(this.center)\r\n      this.boundingBoxFigure2.setCanvas(canvas)\r\n      this.boundingBoxFigure2.setStroke(1)\r\n      this.boundingBoxFigure2.setColor(new draw2d.util.Color(\"#333333\"))\r\n      this.boundingBoxFigure2.setBackgroundColor(null)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @param {Number} x the x-coordinate of the mouse down event\r\n   * @param {Number} y the y-coordinate of the mouse down event\r\n   * @template\r\n   */\r\n  onMouseUp: function (canvas, x, y) {\r\n    let dx = Math.abs(this.center.x - x)\r\n    let dy = Math.abs(this.center.y - y)\r\n    let r = Math.sqrt(dx * dx + dy * dy)\r\n    if (r > 3) {\r\n      let circle = new shape_designer.figure.PolyCircle(this.center, r)\r\n      let command = new draw2d.command.CommandAdd(canvas, circle, circle.getX(), circle.getY())\r\n      canvas.getCommandStack().execute(command)\r\n      canvas.setCurrentSelection(circle)\r\n    }\r\n\r\n    this.center = null\r\n    if (this.boundingBoxFigure1 !== null) {\r\n      this.boundingBoxFigure1.setCanvas(null)\r\n      this.boundingBoxFigure1 = null\r\n      this.boundingBoxFigure2.setCanvas(null)\r\n      this.boundingBoxFigure2 = null\r\n    }\r\n    this.executed()\r\n  }\r\n})\r\n\r\n\r\n\r\n\r\n","import AbstractGeoToolPolicy from \"./AbstractGeoToolPolicy\"\r\n\r\n\r\n\r\nexport default AbstractGeoToolPolicy.extend({\r\n\r\n  init: function () {\r\n    this._super()\r\n    this.operation = \"difference\"\r\n  },\r\n\r\n\r\n  onInstall: function (canvas) {\r\n    this.setToolText(\"Select polygon to subtract from\")\r\n  },\r\n\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @param {Number} x the x-coordinate of the mouse down event\r\n   * @param {Number} y the y-coordinate of the mouse down event\r\n   * @param {Boolean} shiftKey true if the shift key has been pressed during this event\r\n   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event\r\n   */\r\n  onMouseDown: function (canvas, x, y, shiftKey, ctrlKey) {\r\n    let figure = canvas.getBestFigure(x, y)\r\n\r\n    // check if the user click on a child shape. DragDrop and movement must redirect\r\n    // to the parent\r\n    // Exception: Port's\r\n    while ((figure !== null && figure.getParent() !== null) && !(figure instanceof draw2d.Port)) {\r\n      figure = figure.getParent()\r\n    }\r\n\r\n    if (figure !== canvas.getSelection().getPrimary() && figure !== null && figure.isSelectable() === true) {\r\n      if (this.firstFigure === null) {\r\n        this.firstFigure = figure\r\n        this.select(canvas, figure)\r\n        this.setToolText(\"Select polygon to subtract\")\r\n      }\r\n      else {\r\n        this.execute(canvas, this.firstFigure, figure)\r\n        this.firstFigure = null\r\n        this.setToolText(\"Select polygon to subtract from\")\r\n      }\r\n    }\r\n  }\r\n})\r\n\r\n\r\n\r\n\r\n","import AbstractGeoToolPolicy from \"./AbstractGeoToolPolicy\"\r\n\r\n\r\nexport default AbstractGeoToolPolicy.extend({\r\n\r\n  init: function () {\r\n    this._super()\r\n    this.operation = \"intersection\"\r\n  },\r\n\r\n\r\n  onInstall: function (canvas) {\r\n    this.setToolText(\"Select polygon to intersect with\")\r\n  },\r\n\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @param {Number} x the x-coordinate of the mouse down event\r\n   * @param {Number} y the y-coordinate of the mouse down event\r\n   * @param {Boolean} shiftKey true if the shift key has been pressed during this event\r\n   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event\r\n   */\r\n  onMouseDown: function (canvas, x, y, shiftKey, ctrlKey) {\r\n\r\n    var figure = canvas.getBestFigure(x, y)\r\n\r\n    // check if the user click on a child shape. DragDrop and movement must redirect\r\n    // to the parent\r\n    // Exception: Port's\r\n    while ((figure !== null && figure.getParent() !== null) && !(figure instanceof draw2d.Port)) {\r\n      figure = figure.getParent()\r\n    }\r\n\r\n    if (figure !== canvas.getSelection().getPrimary() && figure !== null && figure.isSelectable() === true) {\r\n      if (this.firstFigure === null) {\r\n        this.firstFigure = figure\r\n        this.select(canvas, figure)\r\n        this.setToolText(\"Select polygon to intersect\")\r\n      }\r\n      else {\r\n        this.execute(canvas, this.firstFigure, figure)\r\n        this.firstFigure = null\r\n        this.setToolText(\"Select polygon to intersect with\")\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n})\r\n\r\n\r\n\r\n\r\n","import AbstractGeoToolPolicy from \"./AbstractGeoToolPolicy\"\r\n\r\nexport default AbstractGeoToolPolicy.extend({\r\n\r\n  init: function () {\r\n    this._super()\r\n    this.operation = \"union\"\r\n  },\r\n\r\n\r\n  onInstall: function (canvas) {\r\n    this.setToolText(\"Select polygon to add to..\")\r\n  },\r\n\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @param {Number} x the x-coordinate of the mouse down event\r\n   * @param {Number} y the y-coordinate of the mouse down event\r\n   * @param {Boolean} shiftKey true if the shift key has been pressed during this event\r\n   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event\r\n   */\r\n  onMouseDown: function (canvas, x, y, shiftKey, ctrlKey) {\r\n\r\n    var figure = canvas.getBestFigure(x, y)\r\n\r\n    // check if the user click on a child shape. DragDrop and movement must redirect\r\n    // to the parent\r\n    // Exception: Port's\r\n    while ((figure !== null && figure.getParent() !== null) && !(figure instanceof draw2d.Port)) {\r\n      figure = figure.getParent()\r\n    }\r\n\r\n    if (figure !== canvas.getSelection().getPrimary() && figure !== null && figure.isSelectable() === true) {\r\n      if (this.firstFigure === null) {\r\n        this.firstFigure = figure\r\n        this.select(canvas, figure)\r\n        this.setToolText(\"Select polygon to merge\")\r\n      }\r\n      else {\r\n        this.execute(canvas, this.firstFigure, figure)\r\n        this.firstFigure = null\r\n        this.setToolText(\"Select polygon to add to\")\r\n      }\r\n    }\r\n  }\r\n})\r\n\r\n\r\n\r\n\r\n","import AbstractToolPolicy from \"./AbstractToolPolicy\"\r\n\r\nimport cursor from \"../../images/cursors/cursor_line.png\"\r\n\r\nexport default AbstractToolPolicy.extend({\r\n\r\n  MESSAGE_STEP1: \"Select start point of the line.\",\r\n  MESSAGE_STEP2: \"Click to add additional vertex.<br>Double click to finish line.\",\r\n\r\n  init: function () {\r\n    this._super()\r\n\r\n    this.lineFigure = null\r\n    this.canvas = null\r\n  },\r\n\r\n\r\n  onInstall: function (canvas) {\r\n    this.setToolText(this.MESSAGE_STEP1)\r\n    this.canvas = canvas\r\n    canvas.setCursor(cursor)\r\n  },\r\n\r\n  onUninstall: function (canvas) {\r\n    if (this.lineFigure !== null) {\r\n      if (this.lineFigure.getVertices().getSize() < 2) {\r\n        canvas.remove(this.lineFigure)\r\n        this.lineFigure = null\r\n      }\r\n      else {\r\n        // stay in the canvas and finalize the stroke if a doubleClick\r\n        let last = this.lineFigure.vertices.last()\r\n        this.onDoubleClick(this.lineFigure, last.x, last.y, false, false)\r\n      }\r\n    }\r\n    this.canvas = null\r\n    canvas.setCursor(null)\r\n  },\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @param {Number} x the x-coordinate of the mouse down event\r\n   * @param {Number} y the y-coordinate of the mouse down event\r\n   * @param {Boolean} shiftKey true if the shift key has been pressed during this event\r\n   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event\r\n   */\r\n  onMouseDown: function (canvas, x, y, shiftKey, ctrlKey) {\r\n\r\n  },\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @param {Number} x the x-coordinate of the mouse event\r\n   * @param {Number} y the y-coordinate of the mouse event\r\n   * @template\r\n   */\r\n  onMouseMove: function (canvas, x, y) {\r\n\r\n    if (this.lineFigure !== null) {\r\n      this.lineFigure.setEndPoint(x, y)\r\n    }\r\n  },\r\n\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @param {Number} dx The x diff between start of dragging and this event\r\n   * @param {Number} dy The y diff between start of dragging and this event\r\n   * @param {Number} dx2 The x diff since the last call of this dragging operation\r\n   * @param {Number} dy2 The y diff since the last call of this dragging operation\r\n   * @template\r\n   */\r\n  onMouseDrag: function (canvas, dx, dy, dx2, dy2) {\r\n  },\r\n\r\n\r\n  onDoubleClick: function (figure, x, y, shiftKey, ctrlKey) {\r\n    this.onClick(figure, x, y, shiftKey, ctrlKey)\r\n\r\n    // Remove duplicate points at the end of the polyLine. This happens during the DoubleClick.\r\n    // Reason: before the double click is fired the two \"single click\" comes before. In this case we\r\n    // added three vertex for a doubleClick event\r\n    //\r\n\r\n    // don't use the shortcut and assign the this.lineFigure.vertices to a local var.\r\n    // the vertices are recreated in the \"calculatePath\" mnethod of the polygon and\r\n    // the reference is in this case invalid...design flaw!\r\n    //\r\n    let last = this.lineFigure.vertices.last()\r\n    let beforeLast = this.lineFigure.vertices.get(this.lineFigure.vertices.getSize() - 2)\r\n    while (last.equals(beforeLast)) {\r\n      this.lineFigure.removeVertexAt(this.lineFigure.vertices.getSize() - 2)\r\n      beforeLast = this.lineFigure.vertices.get(this.lineFigure.vertices.getSize() - 2)\r\n    }\r\n\r\n    this.lineFigure = null\r\n    this.executed()\r\n  },\r\n\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @param {Number} x the x-coordinate of the mouse down event\r\n   * @param {Number} y the y-coordinate of the mouse down event\r\n   * @param {Boolean} shiftKey true if the shift key has been pressed during this event\r\n   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event\r\n   * @template\r\n   */\r\n  onClick: function (figure, x, y, shiftKey, ctrlKey) {\r\n    if (this.lineFigure === null) {\r\n      this.setToolText(this.MESSAGE_STEP2)\r\n\r\n      this.lineFigure = new shape_designer.figure.ExtLine()\r\n      this.lineFigure.setStartPoint(x, y)\r\n      this.lineFigure.setEndPoint(x, y)\r\n      let command = new draw2d.command.CommandAdd(this.canvas, this.lineFigure, x, y)\r\n      this.canvas.getCommandStack().execute(command)\r\n      this.canvas.setCurrentSelection(this.lineFigure)\r\n    }\r\n    else {\r\n      this.lineFigure.addVertex(x, y)\r\n    }\r\n  }\r\n})\r\n\r\n\r\n\r\n\r\n","import SelectionToolPolicy from \"./SelectionToolPolicy\"\r\n\r\nimport cursor from \"../../images/cursors/cursor_port.png\"\r\n\r\nexport default SelectionToolPolicy.extend({\r\n\r\n  TITLE: \"Port\",\r\n  MESSAGE_STEP1: \"Select location to add port.<br>Click on port to move.\",\r\n\r\n  init: function () {\r\n    this._super()\r\n  },\r\n\r\n\r\n  onInstall: function (canvas) {\r\n    this.setToolText(this.MESSAGE_STEP1)\r\n    canvas.setCursor(cursor)\r\n  },\r\n\r\n  onUninstall: function (canvas) {\r\n    canvas.setCursor(null)\r\n  },\r\n\r\n\r\n  select: function (canvas, figure) {\r\n    // check if the element an valid polygon. otherwise an boolean operation\r\n    // isn't possible\r\n    if (!(figure instanceof shape_designer.figure.ExtPort)) {\r\n      return\r\n    }\r\n\r\n    this._super(canvas, figure)\r\n  },\r\n\r\n  onMouseDown: function (canvas, x, y, shiftKey, ctrlKey) {\r\n    let figure = canvas.getBestFigure(x, y)\r\n\r\n    if (figure === null || figure instanceof shape_designer.figure.ExtPort) {\r\n      this._super(canvas, x, y, shiftKey, ctrlKey)\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @param {Number} x the x-coordinate of the mouse down event\r\n   * @param {Number} y the y-coordinate of the mouse down event\r\n   * @template\r\n   */\r\n  onMouseUp: function (canvas, x, y) {\r\n\r\n    if (this.mouseDownElement === null || !(this.mouseDownElement instanceof shape_designer.figure.ExtPort)) {\r\n      let command = new draw2d.command.CommandAdd(canvas, new shape_designer.figure.ExtPort(), x, y)\r\n      canvas.getCommandStack().execute(command)\r\n      canvas.setCurrentSelection(command.figure)\r\n      this.executed()\r\n    }\r\n    else {\r\n      this._super(canvas, x, y)\r\n    }\r\n  }\r\n})\r\n\r\n\r\n\r\n\r\n","import PolyRect from \"../figure/PolyRect\"\r\nimport AbstractToolPolicy from \"./AbstractToolPolicy\"\r\nimport cursor from \"../../images/cursors/cursor_rectangle.png\"\r\n\r\nexport default AbstractToolPolicy.extend({\r\n\r\n  init: function () {\r\n    this._super()\r\n\r\n    this.topLeftPoint = null\r\n    this.boundingBoxFigure1 = null\r\n    this.boundingBoxFigure2 = null\r\n  },\r\n\r\n\r\n  onInstall: function (canvas) {\r\n    this.setToolText(\"Select first corner of rectangle\")\r\n    canvas.setCursor(cursor)\r\n  },\r\n\r\n  onUninstall: function (canvas) {\r\n    if (this.boundingBoxFigure1 !== null) {\r\n      this.boundingBoxFigure1.setCanvas(null)\r\n      this.boundingBoxFigure1 = null\r\n      this.boundingBoxFigure2.setCanvas(null)\r\n      this.boundingBoxFigure2 = null\r\n    }\r\n    canvas.setCursor(null)\r\n  },\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @param {Number} x the x-coordinate of the mouse down event\r\n   * @param {Number} y the y-coordinate of the mouse down event\r\n   * @param {Boolean} shiftKey true if the shift key has been pressed during this event\r\n   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event\r\n   */\r\n  onMouseDown: function (canvas, x, y, shiftKey, ctrlKey) {\r\n    this.topLeftPoint = new draw2d.geo.Point(x, y)\r\n  },\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @param {Number} dx The x diff between start of dragging and this event\r\n   * @param {Number} dy The y diff between start of dragging and this event\r\n   * @param {Number} dx2 The x diff since the last call of this dragging operation\r\n   * @param {Number} dy2 The y diff since the last call of this dragging operation\r\n   * @template\r\n   */\r\n  onMouseDrag: function (canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey) {\r\n\r\n    if (this.boundingBoxFigure1 === null) {\r\n      this.boundingBoxFigure1 = new draw2d.shape.basic.Rectangle({\r\n        width: 1,\r\n        height: 1,\r\n        x: this.topLeftPoint.x,\r\n        y: this.topLeftPoint.y,\r\n        bgColor: \"#d4d1d4\",\r\n        alpha: 0.1\r\n      });\r\n      this.boundingBoxFigure1.setCanvas(canvas);\r\n\r\n      this.boundingBoxFigure2 = new draw2d.shape.basic.Rectangle({\r\n        width: 1,\r\n        height: 1,\r\n        x: this.topLeftPoint.x,\r\n        y: this.topLeftPoint.y,\r\n        dash: \"--..\",\r\n        stroke: 0.5,\r\n        color: \"#37a8ff\",\r\n        bgColor: null\r\n      });\r\n      this.boundingBoxFigure2.setCanvas(canvas);\r\n    }\r\n\r\n    if (this.boundingBoxFigure1 !== null) {\r\n      this.boundingBoxFigure1.setDimension(Math.abs(dx), Math.abs(dy));\r\n      this.boundingBoxFigure1.setPosition(this.topLeftPoint.x + Math.min(0, dx), this.topLeftPoint.y + Math.min(0, dy));\r\n      this.boundingBoxFigure2.setDimension(Math.abs(dx), Math.abs(dy));\r\n      this.boundingBoxFigure2.setPosition(this.topLeftPoint.x + Math.min(0, dx), this.topLeftPoint.y + Math.min(0, dy));\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @param {Number} x the x-coordinate of the mouse down event\r\n   * @param {Number} y the y-coordinate of the mouse down event\r\n   * @template\r\n   */\r\n  onMouseUp: function (canvas, x, y) {\r\n    if (this.boundingBoxFigure1 !== null) {\r\n      this.boundingBoxFigure1.setCanvas(null);\r\n      this.boundingBoxFigure1 = null;\r\n      this.boundingBoxFigure2.setCanvas(null);\r\n      this.boundingBoxFigure2 = null;\r\n    }\r\n\r\n    let bottomRight = new draw2d.geo.Point(x, y)\r\n    if (this.topLeftPoint.distance(bottomRight) > 3) {\r\n      let rect = new PolyRect(this.topLeftPoint, bottomRight)\r\n      let command = new draw2d.command.CommandAdd(canvas, rect, rect.getX(), rect.getY())\r\n      canvas.getCommandStack().execute(command)\r\n      canvas.setCurrentSelection(rect)\r\n    }\r\n    this.executed()\r\n    this.topLeftPoint = null\r\n  }\r\n})\r\n\r\n\r\n\r\n\r\n","\r\nexport default draw2d.policy.canvas.BoundingboxSelectionPolicy.extend({\r\n\r\n  init: function () {\r\n    this._super()\r\n  },\r\n\r\n  onInstall: function (canvas) {\r\n    this.setToolText(\"Click on shape to select<br>Double click to edit\")\r\n  },\r\n\r\n\r\n  setToolHeader: function (heading, icon) {\r\n    $(\"#currentTool_image\").attr({\"src\": icon})\r\n    $(\"#currentTool_heading\").text(heading)\r\n  },\r\n\r\n  setToolText: function (message) {\r\n    $(\"#currentTool_message\").html(message)\r\n  },\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @param {Number} x the x-coordinate of the mouse down event\r\n   * @param {Number} y the y-coordinate of the mouse down event\r\n   * @param {Boolean} shiftKey true if the shift key has been pressed during this event\r\n   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event\r\n   */\r\n  onMouseDown: function (canvas, x, y, shiftKey, ctrlKey) {\r\n    this.cloneOnDrag = shiftKey\r\n    this._super(canvas, x, y, shiftKey, ctrlKey)\r\n  },\r\n\r\n  /**\r\n   * Copy the selected figure if the user start dragging the selection.\r\n   *\r\n   */\r\n  onMouseDrag: function (canvas, dx, dy, dx2, dy2) {\r\n    if (!((this.mouseDraggingElement instanceof draw2d.ResizeHandle) || (this.mouseDraggingElement instanceof draw2d.Port))) {\r\n      if (this.cloneOnDrag === true && this.mouseDraggingElement !== null) {\r\n        // get the current position of the selected shape\r\n        var pos = this.mouseDraggingElement.getPosition()\r\n\r\n        // cancel the current drag&drop operation\r\n        this.mouseDraggingElement.onDragEnd(pos.x, pos.y, false, false)\r\n        this.mouseDraggingElement.unselect()\r\n\r\n        // clone the selection\r\n        this.mouseDraggingElement = this.mouseDraggingElement.clone()\r\n        // add the clone to the canvas and start dragging of the clone\r\n        canvas.add(this.mouseDraggingElement, pos)\r\n\r\n        // select the cloned shape\r\n        this.select(canvas, this.mouseDraggingElement)\r\n\r\n        // start dragging if the clone accept this operation\r\n        this.mouseDraggingElement.onDragStart(pos.x, pos.y, false, false)\r\n      }\r\n    }\r\n    this.cloneOnDrag = false\r\n    this._super(canvas, dx, dy, dx2, dy2)\r\n  }\r\n})\r\n","import AbstractToolPolicy from \"./AbstractToolPolicy\"\r\n\r\nimport cursor from \"../../images/cursors/cursor_text.png\"\r\n\r\nexport default AbstractToolPolicy.extend({\r\n\r\n  TITLE: \"Text\",\r\n  MESSAGE_STEP1: \"Select location for text\",\r\n  MESSAGE_STEP2: \"Enter Text\",\r\n\r\n  init: function () {\r\n    this._super()\r\n\r\n    this.topLeft = null\r\n    this.newFigure = null\r\n  },\r\n\r\n\r\n  onInstall: function (canvas) {\r\n    this.setToolText(this.MESSAGE_STEP1)\r\n    canvas.setCursor(cursor)\r\n  },\r\n\r\n  onUninstall: function (canvas) {\r\n    canvas.setCursor(null)\r\n  },\r\n\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @param {Number} x the x-coordinate of the mouse down event\r\n   * @param {Number} y the y-coordinate of the mouse down event\r\n   * @param {Boolean} shiftKey true if the shift key has been pressed during this event\r\n   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event\r\n   */\r\n  onMouseDown: function (canvas, x, y, shiftKey, ctrlKey) {\r\n\r\n  },\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @param {Number} x the x-coordinate of the mouse event\r\n   * @param {Number} y the y-coordinate of the mouse event\r\n   * @template\r\n   */\r\n  onMouseMove: function (canvas, x, y) {\r\n  },\r\n\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @param {Number} dx The x diff between start of dragging and this event\r\n   * @param {Number} dy The y diff between start of dragging and this event\r\n   * @param {Number} dx2 The x diff since the last call of this dragging operation\r\n   * @param {Number} dy2 The y diff since the last call of this dragging operation\r\n   * @template\r\n   */\r\n  onMouseDrag: function (canvas, dx, dy, dx2, dy2) {\r\n  },\r\n\r\n  /**\r\n   * @method\r\n   *\r\n   * @param {draw2d.Canvas} canvas\r\n   * @param {Number} x the x-coordinate of the mouse down event\r\n   * @param {Number} y the y-coordinate of the mouse down event\r\n   * @template\r\n   */\r\n  onMouseUp: function (canvas, x, y) {\r\n    if (this.topLeft === null) {\r\n      this.topLeft = new draw2d.geo.Point(x, y)\r\n      this.setToolText(this.MESSAGE_STEP2)\r\n\r\n      this.newFigure = new shape_designer.figure.ExtLabel()\r\n      this.newFigure.setText(\"Text\")\r\n      this.newFigure.setStroke(0)\r\n      this.newFigure.setPadding(5)\r\n      this.newFigure.setFontSize(16)\r\n\r\n      var command = new draw2d.command.CommandAdd(canvas, this.newFigure, parseInt(x), parseInt(y))\r\n      canvas.getCommandStack().execute(command)\r\n      canvas.setCurrentSelection(this.newFigure)\r\n\r\n      // start inplace editing\r\n      //\r\n      setTimeout($.proxy(function () {\r\n        this.newFigure.onDoubleClick()\r\n      }, this), 100)\r\n\r\n      this.executed()\r\n    }\r\n    else {\r\n      this.topLeft = null\r\n    }\r\n  }\r\n})\r\n\r\n\r\n\r\n\r\n","/**\r\n * Copyright 2020 Siemens AG.\r\n * \r\n * Project: SP 347\r\n * Author:\r\n *  - Jupiter Bakakeu\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * \r\n * --------------------------------------------------------------------\r\n * ###################### Changes #####################################\r\n * -- 22.09.2020\r\n *      Initial implementation\r\n * --------------------------------------------------------------------\r\n **/\r\n\r\n/*#####################################################################################*/\r\n/* ValueParserValidator\r\n /*#####################################################################################*/\r\n\r\nclass ValueParserValidator {\r\n    constructor() {\r\n        this.reg = /ns=([0-9]+);(.*)/;\r\n    }\r\n\r\n    stringToUInt32Array(_str) {\r\n        if(_str === null || _str === undefined || _str === \"\"){\r\n            throw \"Array is empty.\";\r\n        }\r\n        var str = (\"\" + _str).toLowerCase();\r\n        return JSON.parse( str).map(function (value) {\r\n            return parseInt(value);\r\n        }).map(function(_value) {\r\n            if(isNaN(_value)){\r\n                throw \"A value is not a number\";\r\n            }\r\n            return _value;\r\n        });\r\n    }\r\n\r\n    ListOf(isArray, parseFunc, _txt) {\r\n        if(_txt === null || _txt === undefined || _txt === \"\"){\r\n            throw \"Array is empty.\";\r\n        }\r\n        var txt = (\"\" + _txt).toLowerCase();\r\n        if( isArray){\r\n            var _tmp = JSON.parse(txt).map(function (value) {\r\n                return parseFunc(value);\r\n            });\r\n            if(! Array.isArray(_tmp)){\r\n                throw \"Value is not an Array.\";\r\n            }\r\n            _tmp.map(function (_iter, _index) {\r\n                if(_iter === undefined){\r\n                    throw \"The value \" + _index + \" of the array is undefined.\";\r\n                }\r\n                if(_iter === null){\r\n                    throw  \"The value \" + _index + \" of the array is null\";\r\n                }\r\n                if((\"\" +_iter) === \"\"){\r\n                    throw  \"The value \" + _index + \" of the array is empty.\";\r\n                }\r\n                return _iter;\r\n            });\r\n            return _tmp;            \r\n        }else{\r\n            var _rslt = parseFunc(txt);\r\n            if(_rslt === undefined){\r\n                throw \"The value is undefined.\";\r\n            }\r\n            if(_rslt === null){\r\n                throw \"The value is null.\";\r\n            }\r\n            if((\"\" +_rslt) === \"\"){\r\n                throw \"The value is empty.\";\r\n            }\r\n            return _rslt;\r\n        }\r\n    }\r\n\r\n    ListOfNumbers(isArray, parseFunc, _txt) {\r\n        if(_txt === null || _txt === undefined || _txt === \"\"){\r\n            throw \"Array is empty.\";\r\n        }\r\n        var txt = (\"\" + _txt).toLowerCase();\r\n        if( isArray){\r\n            var _tmp = JSON.parse(txt).map(function (value) {\r\n                return parseFunc(value);\r\n            });\r\n            if(! Array.isArray(_tmp)){\r\n                throw \"Value is not an Array.\";\r\n            }\r\n\r\n            _tmp.map(function (_iter, _index) {\r\n                if(_iter === undefined){\r\n                    throw \"The value \" + _index + \" of the array is undefined.\";\r\n                }\r\n                if(_iter === null){\r\n                    throw  \"The value \" + _index + \" of the array is null\";\r\n                }\r\n                if((\"\" +_iter) === \"\"){\r\n                    throw  \"The value \" + _index + \" of the array is empty.\";\r\n                }\r\n                if(isNaN(_iter)){\r\n                    throw  \"The value \" + _index + \" of the array is not a number.\";\r\n                }\r\n                return _iter;\r\n            });\r\n\r\n            return _tmp;            \r\n        }else{\r\n            var _rslt = parseFunc(txt);\r\n            if(_rslt === undefined){\r\n                throw \"The value is undefined.\";\r\n            }\r\n            if(_rslt === null){\r\n                throw \"The value is null.\";\r\n            }\r\n            if((\"\" +_rslt) === \"\"){\r\n                throw \"The value is empty.\";\r\n            }\r\n            if(isNaN(_rslt)){\r\n                throw \"The value is not a number.\";\r\n            }\r\n            return _rslt;\r\n        }\r\n    }\r\n\r\n    ListOfDates(isArray, _txt) {\r\n        if(_txt === null || _txt === undefined || _txt === \"\"){\r\n            throw \"Array is empty.\";\r\n        }\r\n        var txt = (\"\" + _txt).toLowerCase();\r\n        if( isArray){\r\n            var _tmp = JSON.parse(txt).map(function (value) {\r\n                return new Date(value);\r\n            });\r\n            if(! Array.isArray(_tmp)){\r\n                throw \"Value is not an Array.\";\r\n            }\r\n\r\n            _tmp.map(function (_iter, _index) {\r\n                if(_iter === undefined){\r\n                    throw \"The value \" + _index + \" of the array is undefined.\";\r\n                }\r\n                if(_iter === null){\r\n                    throw  \"The value \" + _index + \" of the array is null\";\r\n                }\r\n                if((\"\" +_iter) === \"\"){\r\n                    throw  \"The value \" + _index + \" of the array is empty.\";\r\n                }\r\n                if(isNaN(_iter.getTime())){\r\n                    throw  \"The value \" + _index + \" of the array is not a valid date.\";\r\n                }\r\n                return _iter.toDateString();\r\n            });\r\n\r\n            return _tmp;            \r\n        }else{\r\n            var _rslt = new Date(txt);\r\n            if(_rslt === undefined){\r\n                throw \"The value is undefined.\";\r\n            }\r\n            if(_rslt === null){\r\n                throw \"The value is null.\";\r\n            }\r\n            if((\"\" +_rslt) === \"\"){\r\n                throw \"The value is empty.\";\r\n            }\r\n            if(isNaN(_rslt.getTime())){\r\n                throw \"The value is not a valid date.\";\r\n            }\r\n            return _rslt.toDateString();\r\n        }\r\n    }\r\n\r\n    localizedText_parser(text){\r\n        var _localizedText = {};\r\n        _localizedText.locale= text.trim();\r\n        _localizedText.text =text.trim();\r\n        return _localizedText;\r\n    }\r\n\r\n    text_parser(text){\r\n        return text?\"\" + text:null;\r\n    }\r\n\r\n    parse(dataType, value_input, isArray){\r\n        var self = this;\r\n        var _dtype = dataType?dataType:'String';\r\n        var _isArray= isArray?isArray:false;\r\n        var value = (\"\" + value_input).toLowerCase();\r\n        var _value = null;\r\n\r\n        if (_dtype === 'Null' || _dtype === undefined) {\r\n            _value = self.ListOf(_isArray, function(text){return null;}, value);\r\n        }else if(_dtype === 'String') {\r\n            _value = self.ListOf(_isArray, function(text){return text?\"\" + text:null;}, value);\r\n        }else if(_dtype === 'Boolean') {\r\n            _value = self.ListOf(_isArray, function(text){return text?((\"\" + text).toLowerCase() === \"true\" ? true : false):false;}, value);\r\n        }else if(_dtype === 'ByteString') {\r\n            _value = self.ListOf(_isArray, function(text){return text?Buffer.from((\"\" + text), \"base64\"):null;}, value);\r\n        }else if(_dtype === 'localizedText') {\r\n            _value = self.ListOf(_isArray, self.localizedText_parser, value);\r\n        }else if(_dtype === 'Double') {\r\n            _value = self.ListOfNumbers(_isArray, parseFloat, value);\r\n        }else if(_dtype === 'Float') {\r\n            _value = self.ListOfNumbers(_isArray, parseFloat, value);\r\n        }else if(_dtype === 'SByte') {\r\n            _value = self.ListOfNumbers(_isArray, parseInt, value);\r\n        }else if(_dtype === 'Int16') {\r\n            _value = self.ListOfNumbers(_isArray, parseInt, value);\r\n        }else if(_dtype === 'Int32') {\r\n            _value = self.ListOfNumbers(_isArray, parseInt, value);\r\n        }else if(_dtype === 'Byte') {\r\n            _value = self.ListOfNumbers(_isArray, parseInt, value);\r\n        }else if(_dtype === 'UInt16') {\r\n            _value = self.ListOfNumbers(_isArray, parseInt, value);\r\n        }else if(_dtype === 'UInt32') {\r\n            _value = self.ListOfNumbers(_isArray, parseInt, value);\r\n        }else if(_dtype === 'Date') {\r\n            _value = self.ListOfDates(_isArray, value);\r\n        }else if(_dtype === 'Timestamp') {\r\n            _value = self.ListOfNumbers(_isArray, parseInt, value);\r\n        }else{\r\n            throw \"Datatype is not supported.\";\r\n        }\r\n\r\n        return {\r\n            dataType: _dtype, //el.dataType.value, // only basic datatypes are supported\r\n            isArray: _isArray,\r\n            value: _value\r\n        };\r\n    }\r\n}\r\n\r\nmodule.exports = ValueParserValidator;\r\n","/**\r\n * adds a bindGlobal method to Mousetrap that allows you to\r\n * bind specific keyboard shortcuts that will still work\r\n * inside a text input field\r\n *\r\n * usage:\r\n * Mousetrap.bindGlobal('ctrl+s', _saveChanges);\r\n */\r\n/* global Mousetrap:true */\r\n(function(Mousetrap) {\r\n  var _globalCallbacks = {};\r\n  var _originalStopCallback = Mousetrap.prototype.stopCallback;\r\n\r\n  Mousetrap.prototype.stopCallback = function(e, element, combo, sequence) {\r\n    var self = this;\r\n\r\n    if (self.paused) {\r\n      return true;\r\n    }\r\n\r\n    if (_globalCallbacks[combo] || _globalCallbacks[sequence]) {\r\n      return false;\r\n    }\r\n\r\n    return _originalStopCallback.call(self, e, element, combo);\r\n  };\r\n\r\n  Mousetrap.prototype.bindGlobal = function(keys, callback, action) {\r\n    var self = this;\r\n    self.bind(keys, callback, action);\r\n\r\n    if (keys instanceof Array) {\r\n      for (var i = 0; i < keys.length; i++) {\r\n        _globalCallbacks[keys[i]] = true;\r\n      }\r\n      return;\r\n    }\r\n\r\n    _globalCallbacks[keys] = true;\r\n  };\r\n\r\n  Mousetrap.init();\r\n}) (Mousetrap);\r\n","/**\r\n * adds a pause and unpause method to Mousetrap\r\n * this allows you to enable or disable keyboard shortcuts\r\n * without having to reset Mousetrap and rebind everything\r\n */\r\n/* global Mousetrap:true */\r\n(function(Mousetrap) {\r\n  let _originalStopCallback = Mousetrap.prototype.stopCallback;\r\n\r\n  Mousetrap.prototype.stopCallback = function(e, element, combo) {\r\n    let self = this;\r\n\r\n    if (self.paused) {\r\n      return true;\r\n    }\r\n\r\n    return _originalStopCallback.call(self, e, element, combo);\r\n  };\r\n\r\n  Mousetrap.prototype.pause = function() {\r\n    let self = this;\r\n    self.paused = true;\r\n  };\r\n\r\n  Mousetrap.prototype.unpause = function() {\r\n    let self = this;\r\n    self.paused = false;\r\n  };\r\n\r\n  Mousetrap.init();\r\n}) (Mousetrap);\r\n","/**\r\n * jscolor, JavaScript Color Picker\r\n *\r\n * @version 1.4.2\r\n * @license GNU Lesser General Public License, http://www.gnu.org/copyleft/lesser.html\r\n * @author  Jan Odvarko, http://odvarko.cz\r\n * @created 2008-06-15\r\n * @updated 2013-11-25\r\n * @link    http://jscolor.com\r\n */\r\nimport arrowImg from \"./arrow.gif\"\r\nimport crossImg from \"./cross.gif\"\r\nimport hsImg from \"./hs.png\"\r\nimport hvImg from \"./hv.png\"\r\n\r\nlet jscolor = null\r\nexport default jscolor = {\r\n\r\n  dir: '', // location of jscolor directory (leave empty to autodetect)\r\n  bindClass: 'color', // class name\r\n  binding: true, // automatic binding via <input class=\"...\">\r\n  preloading: true, // use image preloading?\r\n\r\n\r\n  install: function () {\r\n    jscolor.addEvent(window, 'load', jscolor.init)\r\n  },\r\n\r\n\r\n  init: function () {\r\n    if (jscolor.binding) {\r\n      jscolor.bind()\r\n    }\r\n    if (jscolor.preloading) {\r\n      jscolor.preload()\r\n    }\r\n  },\r\n\r\n  bind: function () {\r\n    var matchClass = new RegExp('(^|\\\\s)(' + jscolor.bindClass + ')\\\\s*(\\\\{[^}]*\\\\})?', 'i')\r\n    var e = document.getElementsByTagName('input')\r\n    for (var i = 0; i < e.length; i += 1) {\r\n      var m\r\n      if (!e[i].color && e[i].className && (m = e[i].className.match(matchClass))) {\r\n        var prop = {}\r\n        if (m[3]) {\r\n          try {\r\n            prop = (new Function('return (' + m[3] + ')'))()\r\n          } catch (eInvalidProp) {\r\n          }\r\n        }\r\n        e[i].color = new jscolor.color(e[i], prop)\r\n      }\r\n    }\r\n  },\r\n\r\n\r\n  preload: function () {\r\n    for (var fn in jscolor.imgRequire) {\r\n      if (jscolor.imgRequire.hasOwnProperty(fn)) {\r\n        jscolor.loadImage(fn)\r\n      }\r\n    }\r\n  },\r\n\r\n\r\n  images: {\r\n    pad: [181, 101],\r\n    sld: [16, 101],\r\n    cross: [15, 15],\r\n    arrow: [7, 11]\r\n  },\r\n\r\n\r\n  imgRequire: {},\r\n  imgLoaded: {},\r\n\r\n\r\n  requireImage: function (filename) {\r\n    jscolor.imgRequire[filename] = true\r\n  },\r\n\r\n\r\n  loadImage: function (filename) {\r\n    if (!jscolor.imgLoaded[filename]) {\r\n      jscolor.imgLoaded[filename] = new Image()\r\n      jscolor.imgLoaded[filename].src = filename\r\n    }\r\n  },\r\n\r\n\r\n  fetchElement: function (mixed) {\r\n    return typeof mixed === 'string' ? document.getElementById(mixed) : mixed\r\n  },\r\n\r\n\r\n  addEvent: function (el, evnt, func) {\r\n    if (el.addEventListener) {\r\n      el.addEventListener(evnt, func, false)\r\n    } else if (el.attachEvent) {\r\n      el.attachEvent('on' + evnt, func)\r\n    }\r\n  },\r\n\r\n\r\n  fireEvent: function (el, evnt) {\r\n    if (!el) {\r\n      return\r\n    }\r\n    if (document.createEvent) {\r\n      var ev = document.createEvent('HTMLEvents')\r\n      ev.initEvent(evnt, true, true)\r\n      el.dispatchEvent(ev)\r\n    } else if (document.createEventObject) {\r\n      var ev = document.createEventObject()\r\n      el.fireEvent('on' + evnt, ev)\r\n    } else if (el['on' + evnt]) { // alternatively use the traditional event model (IE5)\r\n      el['on' + evnt]()\r\n    }\r\n  },\r\n\r\n\r\n  getElementPos: function (e) {\r\n    var e1 = e, e2 = e\r\n    var x = 0, y = 0\r\n    if (e1.offsetParent) {\r\n      do {\r\n        x += e1.offsetLeft\r\n        y += e1.offsetTop\r\n      } while (e1 = e1.offsetParent)\r\n    }\r\n    while ((e2 = e2.parentNode) && e2.nodeName.toUpperCase() !== 'BODY') {\r\n      x -= e2.scrollLeft\r\n      y -= e2.scrollTop\r\n    }\r\n    return [x, y]\r\n  },\r\n\r\n\r\n  getElementSize: function (e) {\r\n    return [e.offsetWidth, e.offsetHeight]\r\n  },\r\n\r\n\r\n  getRelMousePos: function (e) {\r\n    var x = 0, y = 0\r\n    if (!e) {\r\n      e = window.event\r\n    }\r\n    if (typeof e.offsetX === 'number') {\r\n      x = e.offsetX\r\n      y = e.offsetY\r\n    } else if (typeof e.layerX === 'number') {\r\n      x = e.layerX\r\n      y = e.layerY\r\n    }\r\n    return {x: x, y: y}\r\n  },\r\n\r\n\r\n  getViewPos: function () {\r\n    if (typeof window.pageYOffset === 'number') {\r\n      return [window.pageXOffset, window.pageYOffset]\r\n    } else if (document.body && (document.body.scrollLeft || document.body.scrollTop)) {\r\n      return [document.body.scrollLeft, document.body.scrollTop]\r\n    } else if (document.documentElement && (document.documentElement.scrollLeft || document.documentElement.scrollTop)) {\r\n      return [document.documentElement.scrollLeft, document.documentElement.scrollTop]\r\n    } else {\r\n      return [0, 0]\r\n    }\r\n  },\r\n\r\n\r\n  getViewSize: function () {\r\n    if (typeof window.innerWidth === 'number') {\r\n      return [window.innerWidth, window.innerHeight]\r\n    } else if (document.body && (document.body.clientWidth || document.body.clientHeight)) {\r\n      return [document.body.clientWidth, document.body.clientHeight]\r\n    } else if (document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight)) {\r\n      return [document.documentElement.clientWidth, document.documentElement.clientHeight]\r\n    } else {\r\n      return [0, 0]\r\n    }\r\n  },\r\n\r\n\r\n  URI: function (uri) { // See RFC3986\r\n\r\n    this.scheme = null\r\n    this.authority = null\r\n    this.path = ''\r\n    this.query = null\r\n    this.fragment = null\r\n\r\n    this.parse = function (uri) {\r\n      var m = uri.match(/^(([A-Za-z][0-9A-Za-z+.-]*)(:))?((\\/\\/)([^\\/?#]*))?([^?#]*)((\\?)([^#]*))?((#)(.*))?/)\r\n      this.scheme = m[3] ? m[2] : null\r\n      this.authority = m[5] ? m[6] : null\r\n      this.path = m[7]\r\n      this.query = m[9] ? m[10] : null\r\n      this.fragment = m[12] ? m[13] : null\r\n      return this\r\n    }\r\n\r\n    this.toString = function () {\r\n      var result = ''\r\n      if (this.scheme !== null) {\r\n        result = result + this.scheme + ':'\r\n      }\r\n      if (this.authority !== null) {\r\n        result = result + '//' + this.authority\r\n      }\r\n      if (this.path !== null) {\r\n        result = result + this.path\r\n      }\r\n      if (this.query !== null) {\r\n        result = result + '?' + this.query\r\n      }\r\n      if (this.fragment !== null) {\r\n        result = result + '#' + this.fragment\r\n      }\r\n      return result\r\n    }\r\n\r\n    this.toAbsolute = function (base) {\r\n      var base = new jscolor.URI(base)\r\n      var r = this\r\n      var t = new jscolor.URI\r\n\r\n      if (base.scheme === null) {\r\n        return false\r\n      }\r\n\r\n      if (r.scheme !== null && r.scheme.toLowerCase() === base.scheme.toLowerCase()) {\r\n        r.scheme = null\r\n      }\r\n\r\n      if (r.scheme !== null) {\r\n        t.scheme = r.scheme\r\n        t.authority = r.authority\r\n        t.path = removeDotSegments(r.path)\r\n        t.query = r.query\r\n      } else {\r\n        if (r.authority !== null) {\r\n          t.authority = r.authority\r\n          t.path = removeDotSegments(r.path)\r\n          t.query = r.query\r\n        } else {\r\n          if (r.path === '') {\r\n            t.path = base.path\r\n            if (r.query !== null) {\r\n              t.query = r.query\r\n            } else {\r\n              t.query = base.query\r\n            }\r\n          } else {\r\n            if (r.path.substr(0, 1) === '/') {\r\n              t.path = removeDotSegments(r.path)\r\n            } else {\r\n              if (base.authority !== null && base.path === '') {\r\n                t.path = '/' + r.path\r\n              } else {\r\n                t.path = base.path.replace(/[^\\/]+$/, '') + r.path\r\n              }\r\n              t.path = removeDotSegments(t.path)\r\n            }\r\n            t.query = r.query\r\n          }\r\n          t.authority = base.authority\r\n        }\r\n        t.scheme = base.scheme\r\n      }\r\n      t.fragment = r.fragment\r\n\r\n      return t\r\n    }\r\n\r\n    function removeDotSegments(path) {\r\n      var out = ''\r\n      while (path) {\r\n        if (path.substr(0, 3) === '../' || path.substr(0, 2) === './') {\r\n          path = path.replace(/^\\.+/, '').substr(1)\r\n        } else if (path.substr(0, 3) === '/./' || path === '/.') {\r\n          path = '/' + path.substr(3)\r\n        } else if (path.substr(0, 4) === '/../' || path === '/..') {\r\n          path = '/' + path.substr(4)\r\n          out = out.replace(/\\/?[^\\/]*$/, '')\r\n        } else if (path === '.' || path === '..') {\r\n          path = ''\r\n        } else {\r\n          var rm = path.match(/^\\/?[^\\/]*/)[0]\r\n          path = path.substr(rm.length)\r\n          out = out + rm\r\n        }\r\n      }\r\n      return out\r\n    }\r\n\r\n    if (uri) {\r\n      this.parse(uri)\r\n    }\r\n\r\n  },\r\n\r\n\r\n  //\r\n  // Usage example:\r\n  // var myColor = new jscolor.color(myInputElement)\r\n  //\r\n\r\n  color: function (target, prop) {\r\n\r\n\r\n    this.required = true // refuse empty values?\r\n    this.adjust = true // adjust value to uniform notation?\r\n    this.hash = false // prefix color with # symbol?\r\n    this.caps = true // uppercase?\r\n    this.slider = true // show the value/saturation slider?\r\n    this.valueElement = target // value holder\r\n    this.styleElement = target // where to reflect current color\r\n    this.onImmediateChange = null // onchange callback (can be either string or function)\r\n    this.hsv = [0, 0, 1] // read-only  0-6, 0-1, 0-1\r\n    this.rgb = [1, 1, 1] // read-only  0-1, 0-1, 0-1\r\n    this.minH = 0 // read-only  0-6\r\n    this.maxH = 6 // read-only  0-6\r\n    this.minS = 0 // read-only  0-1\r\n    this.maxS = 1 // read-only  0-1\r\n    this.minV = 0 // read-only  0-1\r\n    this.maxV = 1 // read-only  0-1\r\n\r\n    this.pickerOnfocus = true // display picker on focus?\r\n    this.pickerMode = 'HSV' // HSV | HVS\r\n    this.pickerPosition = 'bottom' // left | right | top | bottom\r\n    this.pickerSmartPosition = true // automatically adjust picker position when necessary\r\n    this.pickerButtonHeight = 20 // px\r\n    this.pickerClosable = false\r\n    this.pickerCloseText = 'Close'\r\n    this.pickerButtonColor = 'ButtonText' // px\r\n    this.pickerFace = 10 // px\r\n    this.pickerFaceColor = 'ThreeDFace' // CSS color\r\n    this.pickerBorder = 1 // px\r\n    this.pickerBorderColor = 'ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight' // CSS color\r\n    this.pickerInset = 1 // px\r\n    this.pickerInsetColor = 'ThreeDShadow ThreeDHighlight ThreeDHighlight ThreeDShadow' // CSS color\r\n    this.pickerZIndex = 10000\r\n\r\n\r\n    for (var p in prop) {\r\n      if (prop.hasOwnProperty(p)) {\r\n        this[p] = prop[p]\r\n      }\r\n    }\r\n\r\n\r\n    this.hidePicker = function () {\r\n      if (isPickerOwner()) {\r\n        removePicker()\r\n      }\r\n    }\r\n\r\n\r\n    this.showPicker = function () {\r\n      if (!isPickerOwner()) {\r\n        var tp = jscolor.getElementPos(target) // target pos\r\n        var ts = jscolor.getElementSize(target) // target size\r\n        var vp = jscolor.getViewPos() // view pos\r\n        var vs = jscolor.getViewSize() // view size\r\n        var ps = getPickerDims(this) // picker size\r\n        var a, b, c\r\n        switch (this.pickerPosition.toLowerCase()) {\r\n          case 'left':\r\n            a = 1\r\n            b = 0\r\n            c = -1\r\n            break\r\n          case 'right':\r\n            a = 1\r\n            b = 0\r\n            c = 1\r\n            break\r\n          case 'top':\r\n            a = 0\r\n            b = 1\r\n            c = -1\r\n            break\r\n          default:\r\n            a = 0\r\n            b = 1\r\n            c = 1\r\n            break\r\n        }\r\n        var l = (ts[b] + ps[b]) / 2\r\n\r\n        // picker pos\r\n        if (!this.pickerSmartPosition) {\r\n          var pp = [\r\n            tp[a],\r\n            tp[b] + ts[b] - l + l * c\r\n          ]\r\n        } else {\r\n          var pp = [\r\n            -vp[a] + tp[a] + ps[a] > vs[a] ?\r\n              (-vp[a] + tp[a] + ts[a] / 2 > vs[a] / 2 && tp[a] + ts[a] - ps[a] >= 0 ? tp[a] + ts[a] - ps[a] : tp[a]) :\r\n              tp[a],\r\n            -vp[b] + tp[b] + ts[b] + ps[b] - l + l * c > vs[b] ?\r\n              (-vp[b] + tp[b] + ts[b] / 2 > vs[b] / 2 && tp[b] + ts[b] - l - l * c >= 0 ? tp[b] + ts[b] - l - l * c : tp[b] + ts[b] - l + l * c) :\r\n              (tp[b] + ts[b] - l + l * c >= 0 ? tp[b] + ts[b] - l + l * c : tp[b] + ts[b] - l - l * c)\r\n          ]\r\n        }\r\n        drawPicker(pp[a], pp[b])\r\n      }\r\n    }\r\n\r\n\r\n    this.importColor = function () {\r\n      if (!valueElement) {\r\n        this.exportColor()\r\n      } else {\r\n        if (!this.adjust) {\r\n          if (!this.fromString(valueElement.value, leaveValue)) {\r\n            styleElement.style.backgroundImage = styleElement.jscStyle.backgroundImage\r\n            styleElement.style.backgroundColor = styleElement.jscStyle.backgroundColor\r\n            styleElement.style.color = styleElement.jscStyle.color\r\n            this.exportColor(leaveValue | leaveStyle)\r\n          }\r\n        } else if (!this.required && /^\\s*$/.test(valueElement.value)) {\r\n          valueElement.value = ''\r\n          styleElement.style.backgroundImage = styleElement.jscStyle.backgroundImage\r\n          styleElement.style.backgroundColor = styleElement.jscStyle.backgroundColor\r\n          styleElement.style.color = styleElement.jscStyle.color\r\n          this.exportColor(leaveValue | leaveStyle)\r\n\r\n        } else if (this.fromString(valueElement.value)) {\r\n          // OK\r\n        } else {\r\n          this.exportColor()\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    this.exportColor = function (flags) {\r\n      if (!(flags & leaveValue) && valueElement) {\r\n        var value = this.toString()\r\n        if (this.caps) {\r\n          value = value.toUpperCase()\r\n        }\r\n        if (this.hash) {\r\n          value = '#' + value\r\n        }\r\n        valueElement.value = value\r\n      }\r\n      if (!(flags & leaveStyle) && styleElement) {\r\n        styleElement.style.backgroundImage = \"none\"\r\n        styleElement.style.backgroundColor =\r\n          '#' + this.toString()\r\n        styleElement.style.color =\r\n          0.213 * this.rgb[0] +\r\n          0.715 * this.rgb[1] +\r\n          0.072 * this.rgb[2]\r\n          < 0.5 ? '#FFF' : '#000'\r\n      }\r\n      if (!(flags & leavePad) && isPickerOwner()) {\r\n        redrawPad()\r\n      }\r\n      if (!(flags & leaveSld) && isPickerOwner()) {\r\n        redrawSld()\r\n      }\r\n    }\r\n\r\n\r\n    this.fromHSV = function (h, s, v, flags) { // null = don't change\r\n      if (h !== null) {\r\n        h = Math.max(0.0, this.minH, Math.min(6.0, this.maxH, h))\r\n      }\r\n      if (s !== null) {\r\n        s = Math.max(0.0, this.minS, Math.min(1.0, this.maxS, s))\r\n      }\r\n      if (v !== null) {\r\n        v = Math.max(0.0, this.minV, Math.min(1.0, this.maxV, v))\r\n      }\r\n\r\n      this.rgb = HSV_RGB(\r\n        h === null ? this.hsv[0] : (this.hsv[0] = h),\r\n        s === null ? this.hsv[1] : (this.hsv[1] = s),\r\n        v === null ? this.hsv[2] : (this.hsv[2] = v)\r\n      )\r\n\r\n      this.exportColor(flags)\r\n    }\r\n\r\n\r\n    this.fromRGB = function (r, g, b, flags) { // null = don't change\r\n      if (r !== null) {\r\n        r = Math.max(0.0, Math.min(1.0, r))\r\n      }\r\n      if (g !== null) {\r\n        g = Math.max(0.0, Math.min(1.0, g))\r\n      }\r\n      if (b !== null) {\r\n        b = Math.max(0.0, Math.min(1.0, b))\r\n      }\r\n\r\n      var hsv = RGB_HSV(\r\n        r === null ? this.rgb[0] : r,\r\n        g === null ? this.rgb[1] : g,\r\n        b === null ? this.rgb[2] : b\r\n      )\r\n      if (hsv[0] !== null) {\r\n        this.hsv[0] = Math.max(0.0, this.minH, Math.min(6.0, this.maxH, hsv[0]))\r\n      }\r\n      if (hsv[2] !== 0) {\r\n        this.hsv[1] = hsv[1] === null ? null : Math.max(0.0, this.minS, Math.min(1.0, this.maxS, hsv[1]))\r\n      }\r\n      this.hsv[2] = hsv[2] === null ? null : Math.max(0.0, this.minV, Math.min(1.0, this.maxV, hsv[2]))\r\n\r\n      // update RGB according to final HSV, as some values might be trimmed\r\n      var rgb = HSV_RGB(this.hsv[0], this.hsv[1], this.hsv[2])\r\n      this.rgb[0] = rgb[0]\r\n      this.rgb[1] = rgb[1]\r\n      this.rgb[2] = rgb[2]\r\n\r\n      this.exportColor(flags)\r\n    }\r\n\r\n\r\n    this.fromString = function (hex, flags) {\r\n      var m = hex.match(/^\\W*([0-9A-F]{3}([0-9A-F]{3})?)\\W*$/i)\r\n      if (!m) {\r\n        return false\r\n      } else {\r\n        if (m[1].length === 6) { // 6-char notation\r\n          this.fromRGB(\r\n            parseInt(m[1].substr(0, 2), 16) / 255,\r\n            parseInt(m[1].substr(2, 2), 16) / 255,\r\n            parseInt(m[1].substr(4, 2), 16) / 255,\r\n            flags\r\n          )\r\n        } else { // 3-char notation\r\n          this.fromRGB(\r\n            parseInt(m[1].charAt(0) + m[1].charAt(0), 16) / 255,\r\n            parseInt(m[1].charAt(1) + m[1].charAt(1), 16) / 255,\r\n            parseInt(m[1].charAt(2) + m[1].charAt(2), 16) / 255,\r\n            flags\r\n          )\r\n        }\r\n        return true\r\n      }\r\n    }\r\n\r\n\r\n    this.toString = function () {\r\n      return (\r\n        (0x100 | Math.round(255 * this.rgb[0])).toString(16).substr(1) +\r\n        (0x100 | Math.round(255 * this.rgb[1])).toString(16).substr(1) +\r\n        (0x100 | Math.round(255 * this.rgb[2])).toString(16).substr(1)\r\n      )\r\n    }\r\n\r\n\r\n    function RGB_HSV(r, g, b) {\r\n      var n = Math.min(Math.min(r, g), b)\r\n      var v = Math.max(Math.max(r, g), b)\r\n      var m = v - n\r\n      if (m === 0) {\r\n        return [null, 0, v]\r\n      }\r\n      var h = r === n ? 3 + (b - g) / m : (g === n ? 5 + (r - b) / m : 1 + (g - r) / m)\r\n      return [h === 6 ? 0 : h, m / v, v]\r\n    }\r\n\r\n\r\n    function HSV_RGB(h, s, v) {\r\n      if (h === null) {\r\n        return [v, v, v]\r\n      }\r\n      var i = Math.floor(h)\r\n      var f = i % 2 ? h - i : 1 - (h - i)\r\n      var m = v * (1 - s)\r\n      var n = v * (1 - s * f)\r\n      switch (i) {\r\n        case 6:\r\n        case 0:\r\n          return [v, n, m]\r\n        case 1:\r\n          return [n, v, m]\r\n        case 2:\r\n          return [m, v, n]\r\n        case 3:\r\n          return [m, n, v]\r\n        case 4:\r\n          return [n, m, v]\r\n        case 5:\r\n          return [v, m, n]\r\n      }\r\n    }\r\n\r\n\r\n    function removePicker() {\r\n      delete jscolor.picker.owner\r\n      document.getElementsByTagName('body')[0].removeChild(jscolor.picker.boxB)\r\n    }\r\n\r\n\r\n    function drawPicker(x, y) {\r\n      if (!jscolor.picker) {\r\n        jscolor.picker = {\r\n          box: document.createElement('div'),\r\n          boxB: document.createElement('div'),\r\n          pad: document.createElement('div'),\r\n          padB: document.createElement('div'),\r\n          padM: document.createElement('div'),\r\n          sld: document.createElement('div'),\r\n          sldB: document.createElement('div'),\r\n          sldM: document.createElement('div'),\r\n          btn: document.createElement('div'),\r\n          btnS: document.createElement('span'),\r\n          btnT: document.createTextNode(THIS.pickerCloseText)\r\n        }\r\n        for (var i = 0, segSize = 4; i < jscolor.images.sld[1]; i += segSize) {\r\n          var seg = document.createElement('div')\r\n          seg.style.height = segSize + 'px'\r\n          seg.style.fontSize = '1px'\r\n          seg.style.lineHeight = '0'\r\n          jscolor.picker.sld.appendChild(seg)\r\n        }\r\n        jscolor.picker.sldB.appendChild(jscolor.picker.sld)\r\n        jscolor.picker.box.appendChild(jscolor.picker.sldB)\r\n        jscolor.picker.box.appendChild(jscolor.picker.sldM)\r\n        jscolor.picker.padB.appendChild(jscolor.picker.pad)\r\n        jscolor.picker.box.appendChild(jscolor.picker.padB)\r\n        jscolor.picker.box.appendChild(jscolor.picker.padM)\r\n        jscolor.picker.btnS.appendChild(jscolor.picker.btnT)\r\n        jscolor.picker.btn.appendChild(jscolor.picker.btnS)\r\n        jscolor.picker.box.appendChild(jscolor.picker.btn)\r\n        jscolor.picker.boxB.appendChild(jscolor.picker.box)\r\n      }\r\n\r\n      var p = jscolor.picker\r\n\r\n      // controls interaction\r\n      p.box.onmouseup =\r\n        p.box.onmouseout = function () {\r\n          target.focus()\r\n        }\r\n      p.box.onmousedown = function () {\r\n        abortBlur = true\r\n      }\r\n      p.box.onmousemove = function (e) {\r\n        if (holdPad || holdSld) {\r\n          holdPad && setPad(e)\r\n          holdSld && setSld(e)\r\n          if (document.selection) {\r\n            document.selection.empty()\r\n          } else if (window.getSelection) {\r\n            window.getSelection().removeAllRanges()\r\n          }\r\n          dispatchImmediateChange()\r\n        }\r\n      }\r\n      if ('ontouchstart' in window) { // if touch device\r\n        var handle_touchmove = function (e) {\r\n          var event = {\r\n            'offsetX': e.touches[0].pageX - touchOffset.X,\r\n            'offsetY': e.touches[0].pageY - touchOffset.Y\r\n          }\r\n          if (holdPad || holdSld) {\r\n            holdPad && setPad(event)\r\n            holdSld && setSld(event)\r\n            dispatchImmediateChange()\r\n          }\r\n          e.stopPropagation() // prevent move \"view\" on broswer\r\n          e.preventDefault() // prevent Default - Android Fix (else android generated only 1-2 touchmove events)\r\n        }\r\n        p.box.removeEventListener('touchmove', handle_touchmove, false)\r\n        p.box.addEventListener('touchmove', handle_touchmove, false)\r\n      }\r\n      p.padM.onmouseup =\r\n        p.padM.onmouseout = function () {\r\n          if (holdPad) {\r\n            holdPad = false\r\n            jscolor.fireEvent(valueElement, 'change')\r\n          }\r\n        }\r\n      p.padM.onmousedown = function (e) {\r\n        // if the slider is at the bottom, move it up\r\n        switch (modeID) {\r\n          case 0:\r\n            if (THIS.hsv[2] === 0) {\r\n              THIS.fromHSV(null, null, 1.0)\r\n            }\r\n            \r\n            break\r\n          case 1:\r\n            if (THIS.hsv[1] === 0) {\r\n              THIS.fromHSV(null, 1.0, null)\r\n            }\r\n            \r\n            break\r\n        }\r\n        holdSld = false\r\n        holdPad = true\r\n        setPad(e)\r\n        dispatchImmediateChange()\r\n      }\r\n      if ('ontouchstart' in window) {\r\n        p.padM.addEventListener('touchstart', function (e) {\r\n          touchOffset = {\r\n            'X': e.target.offsetParent.offsetLeft,\r\n            'Y': e.target.offsetParent.offsetTop\r\n          }\r\n          this.onmousedown({\r\n            'offsetX': e.touches[0].pageX - touchOffset.X,\r\n            'offsetY': e.touches[0].pageY - touchOffset.Y\r\n          })\r\n        })\r\n      }\r\n      p.sldM.onmouseup =\r\n        p.sldM.onmouseout = function () {\r\n          if (holdSld) {\r\n            holdSld = false\r\n            jscolor.fireEvent(valueElement, 'change')\r\n          }\r\n        }\r\n      p.sldM.onmousedown = function (e) {\r\n        holdPad = false\r\n        holdSld = true\r\n        setSld(e)\r\n        dispatchImmediateChange()\r\n      }\r\n      if ('ontouchstart' in window) {\r\n        p.sldM.addEventListener('touchstart', function (e) {\r\n          touchOffset = {\r\n            'X': e.target.offsetParent.offsetLeft,\r\n            'Y': e.target.offsetParent.offsetTop\r\n          }\r\n          this.onmousedown({\r\n            'offsetX': e.touches[0].pageX - touchOffset.X,\r\n            'offsetY': e.touches[0].pageY - touchOffset.Y\r\n          })\r\n        })\r\n      }\r\n\r\n      // picker\r\n      var dims = getPickerDims(THIS)\r\n      p.box.style.width = dims[0] + 'px'\r\n      p.box.style.height = dims[1] + 'px'\r\n\r\n      // picker border\r\n      p.boxB.style.position = 'absolute'\r\n      p.boxB.style.clear = 'both'\r\n      p.boxB.style.left = x + 'px'\r\n      p.boxB.style.top = y + 'px'\r\n      p.boxB.style.zIndex = THIS.pickerZIndex\r\n      p.boxB.style.border = THIS.pickerBorder + 'px solid'\r\n      p.boxB.style.borderColor = THIS.pickerBorderColor\r\n      p.boxB.style.background = THIS.pickerFaceColor\r\n\r\n      // pad image\r\n      p.pad.style.width = jscolor.images.pad[0] + 'px'\r\n      p.pad.style.height = jscolor.images.pad[1] + 'px'\r\n\r\n      // pad border\r\n      p.padB.style.position = 'absolute'\r\n      p.padB.style.left = THIS.pickerFace + 'px'\r\n      p.padB.style.top = THIS.pickerFace + 'px'\r\n      p.padB.style.border = THIS.pickerInset + 'px solid'\r\n      p.padB.style.borderColor = THIS.pickerInsetColor\r\n\r\n      // pad mouse area\r\n      p.padM.style.position = 'absolute'\r\n      p.padM.style.left = '0'\r\n      p.padM.style.top = '0'\r\n      p.padM.style.width = THIS.pickerFace + 2 * THIS.pickerInset + jscolor.images.pad[0] + jscolor.images.arrow[0] + 'px'\r\n      p.padM.style.height = p.box.style.height\r\n      p.padM.style.cursor = 'crosshair'\r\n\r\n      // slider image\r\n      p.sld.style.overflow = 'hidden'\r\n      p.sld.style.width = jscolor.images.sld[0] + 'px'\r\n      p.sld.style.height = jscolor.images.sld[1] + 'px'\r\n\r\n      // slider border\r\n      p.sldB.style.display = THIS.slider ? 'block' : 'none'\r\n      p.sldB.style.position = 'absolute'\r\n      p.sldB.style.right = THIS.pickerFace + 'px'\r\n      p.sldB.style.top = THIS.pickerFace + 'px'\r\n      p.sldB.style.border = THIS.pickerInset + 'px solid'\r\n      p.sldB.style.borderColor = THIS.pickerInsetColor\r\n\r\n      // slider mouse area\r\n      p.sldM.style.display = THIS.slider ? 'block' : 'none'\r\n      p.sldM.style.position = 'absolute'\r\n      p.sldM.style.right = '0'\r\n      p.sldM.style.top = '0'\r\n      p.sldM.style.width = jscolor.images.sld[0] + jscolor.images.arrow[0] + THIS.pickerFace + 2 * THIS.pickerInset + 'px'\r\n      p.sldM.style.height = p.box.style.height\r\n      try {\r\n        p.sldM.style.cursor = 'pointer'\r\n      } catch (eOldIE) {\r\n        p.sldM.style.cursor = 'hand'\r\n      }\r\n\r\n      // \"close\" button\r\n      function setBtnBorder() {\r\n        var insetColors = THIS.pickerInsetColor.split(/\\s+/)\r\n        var pickerOutsetColor = insetColors.length < 2 ? insetColors[0] : insetColors[1] + ' ' + insetColors[0] + ' ' + insetColors[0] + ' ' + insetColors[1]\r\n        p.btn.style.borderColor = pickerOutsetColor\r\n      }\r\n\r\n      p.btn.style.display = THIS.pickerClosable ? 'block' : 'none'\r\n      p.btn.style.position = 'absolute'\r\n      p.btn.style.left = THIS.pickerFace + 'px'\r\n      p.btn.style.bottom = THIS.pickerFace + 'px'\r\n      p.btn.style.padding = '0 15px'\r\n      p.btn.style.height = '18px'\r\n      p.btn.style.border = THIS.pickerInset + 'px solid'\r\n      setBtnBorder()\r\n      p.btn.style.color = THIS.pickerButtonColor\r\n      p.btn.style.font = '12px sans-serif'\r\n      p.btn.style.textAlign = 'center'\r\n      try {\r\n        p.btn.style.cursor = 'pointer'\r\n      } catch (eOldIE) {\r\n        p.btn.style.cursor = 'hand'\r\n      }\r\n      p.btn.onmousedown = function () {\r\n        THIS.hidePicker()\r\n      }\r\n      p.btnS.style.lineHeight = p.btn.style.height\r\n\r\n      // load images in optimal order\r\n      switch (modeID) {\r\n        case 0:\r\n          var padImg = hsImg\r\n          break\r\n        case 1:\r\n          var padImg = hvImg\r\n          break\r\n      }\r\n\r\n      p.padM.style.backgroundImage = \"url('\" + crossImg + \"')\"\r\n      p.padM.style.backgroundRepeat = \"no-repeat\"\r\n      p.sldM.style.backgroundImage = \"url('./\" + arrowImg + \"')\"\r\n      p.sldM.style.backgroundRepeat = \"no-repeat\"\r\n      p.pad.style.backgroundImage = \"url('\" + padImg + \"')\"\r\n      p.pad.style.backgroundRepeat = \"no-repeat\"\r\n      p.pad.style.backgroundPosition = \"0 0\"\r\n\r\n      // place pointers\r\n      redrawPad()\r\n      redrawSld()\r\n\r\n      jscolor.picker.owner = THIS\r\n      document.getElementsByTagName('body')[0].appendChild(p.boxB)\r\n    }\r\n\r\n\r\n    function getPickerDims(o) {\r\n      var dims = [\r\n        2 * o.pickerInset + 2 * o.pickerFace + jscolor.images.pad[0] +\r\n        (o.slider ? 2 * o.pickerInset + 2 * jscolor.images.arrow[0] + jscolor.images.sld[0] : 0),\r\n        o.pickerClosable ?\r\n          4 * o.pickerInset + 3 * o.pickerFace + jscolor.images.pad[1] + o.pickerButtonHeight :\r\n          2 * o.pickerInset + 2 * o.pickerFace + jscolor.images.pad[1]\r\n      ]\r\n      return dims\r\n    }\r\n\r\n\r\n    function redrawPad() {\r\n      // redraw the pad pointer\r\n      switch (modeID) {\r\n        case 0:\r\n          var yComponent = 1\r\n          break\r\n        case 1:\r\n          var yComponent = 2\r\n          break\r\n      }\r\n      var x = Math.round((THIS.hsv[0] / 6) * (jscolor.images.pad[0] - 1))\r\n      var y = Math.round((1 - THIS.hsv[yComponent]) * (jscolor.images.pad[1] - 1))\r\n      jscolor.picker.padM.style.backgroundPosition =\r\n        (THIS.pickerFace + THIS.pickerInset + x - Math.floor(jscolor.images.cross[0] / 2)) + 'px ' +\r\n        (THIS.pickerFace + THIS.pickerInset + y - Math.floor(jscolor.images.cross[1] / 2)) + 'px'\r\n\r\n      // redraw the slider image\r\n      var seg = jscolor.picker.sld.childNodes\r\n\r\n      switch (modeID) {\r\n        case 0:\r\n          var rgb = HSV_RGB(THIS.hsv[0], THIS.hsv[1], 1)\r\n          for (var i = 0; i < seg.length; i += 1) {\r\n            seg[i].style.backgroundColor = 'rgb(' +\r\n              (rgb[0] * (1 - i / seg.length) * 100) + '%,' +\r\n              (rgb[1] * (1 - i / seg.length) * 100) + '%,' +\r\n              (rgb[2] * (1 - i / seg.length) * 100) + '%)'\r\n          }\r\n          break\r\n        case 1:\r\n          var rgb, s, c = [THIS.hsv[2], 0, 0]\r\n          var i = Math.floor(THIS.hsv[0])\r\n          var f = i % 2 ? THIS.hsv[0] - i : 1 - (THIS.hsv[0] - i)\r\n          switch (i) {\r\n            case 6:\r\n            case 0:\r\n              rgb = [0, 1, 2]\r\n              break\r\n            case 1:\r\n              rgb = [1, 0, 2]\r\n              break\r\n            case 2:\r\n              rgb = [2, 0, 1]\r\n              break\r\n            case 3:\r\n              rgb = [2, 1, 0]\r\n              break\r\n            case 4:\r\n              rgb = [1, 2, 0]\r\n              break\r\n            case 5:\r\n              rgb = [0, 2, 1]\r\n              break\r\n          }\r\n          for (var i = 0; i < seg.length; i += 1) {\r\n            s = 1 - 1 / (seg.length - 1) * i\r\n            c[1] = c[0] * (1 - s * f)\r\n            c[2] = c[0] * (1 - s)\r\n            seg[i].style.backgroundColor = 'rgb(' +\r\n              (c[rgb[0]] * 100) + '%,' +\r\n              (c[rgb[1]] * 100) + '%,' +\r\n              (c[rgb[2]] * 100) + '%)'\r\n          }\r\n          break\r\n      }\r\n    }\r\n\r\n\r\n    function redrawSld() {\r\n      // redraw the slider pointer\r\n      switch (modeID) {\r\n        case 0:\r\n          var yComponent = 2\r\n          break\r\n        case 1:\r\n          var yComponent = 1\r\n          break\r\n      }\r\n      var y = Math.round((1 - THIS.hsv[yComponent]) * (jscolor.images.sld[1] - 1))\r\n      jscolor.picker.sldM.style.backgroundPosition =\r\n        '0 ' + (THIS.pickerFace + THIS.pickerInset + y - Math.floor(jscolor.images.arrow[1] / 2)) + 'px'\r\n    }\r\n\r\n\r\n    function isPickerOwner() {\r\n      return jscolor.picker && jscolor.picker.owner === THIS\r\n    }\r\n\r\n\r\n    function blurTarget() {\r\n      if (valueElement === target) {\r\n        THIS.importColor()\r\n      }\r\n      if (THIS.pickerOnfocus) {\r\n        THIS.hidePicker()\r\n      }\r\n    }\r\n\r\n\r\n    function blurValue() {\r\n      if (valueElement !== target) {\r\n        THIS.importColor()\r\n      }\r\n    }\r\n\r\n\r\n    function setPad(e) {\r\n      var mpos = jscolor.getRelMousePos(e)\r\n      var x = mpos.x - THIS.pickerFace - THIS.pickerInset\r\n      var y = mpos.y - THIS.pickerFace - THIS.pickerInset\r\n      switch (modeID) {\r\n        case 0:\r\n          THIS.fromHSV(x * (6 / (jscolor.images.pad[0] - 1)), 1 - y / (jscolor.images.pad[1] - 1), null, leaveSld)\r\n          break\r\n        case 1:\r\n          THIS.fromHSV(x * (6 / (jscolor.images.pad[0] - 1)), null, 1 - y / (jscolor.images.pad[1] - 1), leaveSld)\r\n          break\r\n      }\r\n    }\r\n\r\n\r\n    function setSld(e) {\r\n      var mpos = jscolor.getRelMousePos(e)\r\n      var y = mpos.y - THIS.pickerFace - THIS.pickerInset\r\n      switch (modeID) {\r\n        case 0:\r\n          THIS.fromHSV(null, null, 1 - y / (jscolor.images.sld[1] - 1), leavePad)\r\n          break\r\n        case 1:\r\n          THIS.fromHSV(null, 1 - y / (jscolor.images.sld[1] - 1), null, leavePad)\r\n          break\r\n      }\r\n    }\r\n\r\n\r\n    function dispatchImmediateChange() {\r\n      if (THIS.onImmediateChange) {\r\n        var callback\r\n        if (typeof THIS.onImmediateChange === 'string') {\r\n          callback = new Function(THIS.onImmediateChange)\r\n        } else {\r\n          callback = THIS.onImmediateChange\r\n        }\r\n        callback.call(THIS)\r\n      }\r\n    }\r\n\r\n\r\n    var THIS = this\r\n    var modeID = this.pickerMode.toLowerCase() === 'hvs' ? 1 : 0\r\n    var abortBlur = false\r\n    var\r\n      valueElement = jscolor.fetchElement(this.valueElement),\r\n      styleElement = jscolor.fetchElement(this.styleElement)\r\n    var\r\n      holdPad = false,\r\n      holdSld = false,\r\n      touchOffset = {}\r\n    var\r\n      leaveValue = 1 << 0,\r\n      leaveStyle = 1 << 1,\r\n      leavePad = 1 << 2,\r\n      leaveSld = 1 << 3\r\n\r\n    // target\r\n    jscolor.addEvent(target, 'focus', function () {\r\n      if (THIS.pickerOnfocus) {\r\n        THIS.showPicker()\r\n      }\r\n    })\r\n    jscolor.addEvent(target, 'blur', function () {\r\n      if (!abortBlur) {\r\n        window.setTimeout(function () {\r\n          abortBlur || blurTarget()\r\n          abortBlur = false\r\n        }, 0)\r\n      } else {\r\n        abortBlur = false\r\n      }\r\n    })\r\n\r\n    // valueElement\r\n    if (valueElement) {\r\n      var updateField = function () {\r\n        THIS.fromString(valueElement.value, leaveValue)\r\n        dispatchImmediateChange()\r\n      }\r\n      jscolor.addEvent(valueElement, 'keyup', updateField)\r\n      jscolor.addEvent(valueElement, 'input', updateField)\r\n      jscolor.addEvent(valueElement, 'blur', blurValue)\r\n      valueElement.setAttribute('autocomplete', 'off')\r\n    }\r\n\r\n    // styleElement\r\n    if (styleElement) {\r\n      styleElement.jscStyle = {\r\n        backgroundImage: styleElement.style.backgroundImage,\r\n        backgroundColor: styleElement.style.backgroundColor,\r\n        color: styleElement.style.color\r\n      }\r\n    }\r\n\r\n    // require images\r\n    switch (modeID) {\r\n      case 0:\r\n        jscolor.requireImage(hsImg)\r\n        break\r\n      case 1:\r\n        jscolor.requireImage(hvImg)\r\n        break\r\n    }\r\n    jscolor.requireImage(crossImg)\r\n    jscolor.requireImage(arrowImg)\r\n\r\n    this.importColor()\r\n  }\r\n\r\n}\r\n","/*\r\n    ui.anglepicker\r\n*/\r\n\r\n$.widget(\"ui.anglepicker\", $.ui.mouse, {\r\n  widgetEventPrefix: \"angle\",\r\n  _init: function () {\r\n    this._mouseInit()\r\n    this.pointer = $('<div class=\"ui-anglepicker-pointer\"></div>')\r\n    this.pointer.append('<div class=\"ui-anglepicker-dot\"></div>')\r\n    this.pointer.append('<div class=\"ui-anglepicker-line\"></div>')\r\n\r\n    this.element.addClass(\"ui-anglepicker\")\r\n    this.element.append(this.pointer)\r\n\r\n    this.setDegrees(this.options.value)\r\n  },\r\n  _propagate: function (name, event) {\r\n    this._trigger(name, event, this.ui())\r\n  },\r\n  _create: function () {\r\n\r\n  },\r\n  destroy: function () {\r\n    this._mouseDestroy()\r\n\r\n    this.element.removeClass(\"ui-anglepicker\")\r\n    this.pointer.remove()\r\n  },\r\n  _mouseStart: function (event) {\r\n    var myOffset = this.element.offset()\r\n    this.width = this.element.width()\r\n    this.height = this.element.height()\r\n\r\n    this.startOffset = {\r\n      x: myOffset.left + (this.width / 2),\r\n      y: myOffset.top + (this.height / 2)\r\n    }\r\n\r\n    this.element.addClass(\"ui-anglepicker-dragging\")\r\n    this.setDegreesFromEvent(event)\r\n    this._propagate(\"start\", event)\r\n  },\r\n  _mouseStop: function (event) {\r\n    this.element.removeClass(\"ui-anglepicker-dragging\")\r\n    this._propagate(\"stop\", event)\r\n  },\r\n  _mouseDrag: function (event) {\r\n    this.setDegreesFromEvent(event)\r\n    this._propagate(\"change\", event)\r\n  },\r\n  _setOption: function (key, value) {\r\n\r\n    this._super(key, value)\r\n  },\r\n\r\n  ui: function () {\r\n    return {\r\n      element: this.element,\r\n      value: this.options.value\r\n    }\r\n  },\r\n  value: function (newValue) {\r\n\r\n    if (!arguments.length) {\r\n      return this.options.value\r\n    }\r\n\r\n    var oldValue = this.options.value\r\n    this.setDegrees(newValue)\r\n\r\n    if (oldValue !== this.options.value) {\r\n      this._propagate(\"change\")\r\n    }\r\n\r\n    return this\r\n  },\r\n  drawRotation: function () {\r\n    var value = this.options.clockwise ? this.options.value : -this.options.value\r\n    var rotation = 'rotate(' + -value + 'deg)'\r\n\r\n    this.pointer.css({\r\n      '-webkit-transform': rotation,\r\n      '-moz-transform': rotation,\r\n      '-ms-transform': rotation,\r\n      '-o-transform': rotation,\r\n      'transform': rotation\r\n    })\r\n  },\r\n  setDegrees: function (degrees) {\r\n    this.options.value = this.clamp(degrees)\r\n    this.drawRotation()\r\n  },\r\n  clamp: function (degrees) {\r\n    if (typeof degrees !== \"number\") {\r\n      degrees = 0\r\n    }\r\n\r\n    var min = this.options.min,\r\n      max = min + 360\r\n\r\n    while (degrees < min) {\r\n      degrees += 360\r\n    }\r\n    while (degrees > max) {\r\n      degrees -= 360\r\n    }\r\n\r\n    return degrees\r\n  },\r\n  setDegreesFromEvent: function (event) {\r\n    var opposite = this.startOffset.y - event.pageY\r\n    opposite = this.options.clockwise ? opposite : -opposite\r\n\r\n    var adjacent = event.pageX - this.startOffset.x,\r\n      radians = Math.atan(opposite / adjacent),\r\n      degrees = Math.round(radians * (180 / Math.PI), 10)\r\n\r\n    if (event.shiftKey) {\r\n      degrees = this.roundToMultiple(degrees, this.options.shiftSnap)\r\n    }\r\n    else {\r\n      degrees = this.roundToMultiple(degrees, this.options.snap)\r\n    }\r\n\r\n    if (adjacent < 0 && opposite >= 0) {\r\n      degrees += 180\r\n    }\r\n    else if (opposite < 0 && adjacent < 0) {\r\n      degrees -= 180\r\n    }\r\n\r\n    this.setDegrees(degrees)\r\n  },\r\n  roundToMultiple: function (number, multiple) {\r\n    var value = number / multiple,\r\n      integer = Math.floor(value),\r\n      rest = value - integer\r\n\r\n    return rest > 0.5 ? (integer + 1) * multiple : integer * multiple\r\n  },\r\n  options: {\r\n    distance: 1,\r\n    delay: 1,\r\n    snap: 1,\r\n    min: 0,\r\n    shiftSnap: 15,\r\n    value: 90,\r\n    clockwise: true // anti-clockwise if false\r\n  }\r\n})\r\n","(function (root, factory) {\r\n\r\n    if(typeof define === 'function' && define.amd) {\r\n        define([], factory(root));\r\n    } else if (typeof exports === 'object') {\r\n        module.exports = factory(root);\r\n    } else {\r\n        root.inlineSVG = factory(root);\r\n    }\r\n\r\n})(typeof global !== \"undefined\" ? global : this.window || this.global, function (root) {\r\n\r\n    // Variables\r\n    var inlineSVG = {},\r\n        supports = !!document.querySelector && !!root.addEventListener,\r\n        settings;\r\n\r\n    // Defaults\r\n    var defaults = {\r\n        initClass: 'js-inlinesvg',\r\n        svgSelector: 'img.svg'\r\n    };\r\n\r\n    /**\r\n     * Stolen from underscore.js\r\n     * @private\r\n     * @param {Int} times\r\n     * @param {Function} func\r\n     */\r\n\r\n    var after = function(times, func) {\r\n        return function() {\r\n            if (--times < 1) {\r\n                return func.apply(this, arguments);\r\n            }\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Merge two objects together\r\n     * @private\r\n     * @param {Function} fn\r\n     */\r\n    var extend = function () {\r\n\r\n        // Variables\r\n        var extended = {};\r\n        var deep = false;\r\n        var i = 0;\r\n        var length = arguments.length;\r\n\r\n        // Check if a deep merge\r\n        if ( Object.prototype.toString.call( arguments[0] ) === '[object Boolean]' ) {\r\n            deep = arguments[0];\r\n            i++;\r\n        }\r\n\r\n        // Merge the object into the extended object\r\n        var merge = function (obj) {\r\n            for ( var prop in obj ) {\r\n                if ( Object.prototype.hasOwnProperty.call( obj, prop ) ) {\r\n                    // If deep merge and property is an object, merge properties\r\n                    if ( deep && Object.prototype.toString.call(obj[prop]) === '[object Object]' ) {\r\n                        extended[prop] = extend( true, extended[prop], obj[prop] );\r\n                    } else {\r\n                        extended[prop] = obj[prop];\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        // Loop through each object and conduct a merge\r\n        for ( ; i < length; i++ ) {\r\n            var obj = arguments[i];\r\n            merge(obj);\r\n        }\r\n\r\n        return extended;\r\n\r\n    };\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Grab all the SVGs that match the selector\r\n     * @public\r\n     */\r\n    var getAll = function () {\r\n\r\n        var svgs = document.querySelectorAll(settings.svgSelector);\r\n        return svgs;\r\n\r\n    };\r\n\r\n    /**\r\n     * Inline all the SVGs in the array\r\n     * @public\r\n     */\r\n    var inliner = function (cb) {\r\n\r\n        var svgs = getAll();\r\n        var callback = after(svgs.length, cb);\r\n\r\n        Array.prototype.forEach.call(svgs, function (svg, i) {\r\n\r\n            // Store some attributes of the image\r\n            var src = svg.src || svg.getAttribute('data-src'),\r\n                attributes = svg.attributes;\r\n\r\n            // Get the contents of the SVG\r\n            var request = new XMLHttpRequest();\r\n            request.open('GET', src, true);\r\n\r\n            request.onload = function () {\r\n\r\n                if(request.status >= 200 && request.status < 400) {\r\n\r\n                    // Setup a parser to convert the response to text/xml in order for it\r\n                    // to be manipulated and changed\r\n                    var parser = new DOMParser(),\r\n                        result = parser.parseFromString(request.responseText, 'text/xml'),\r\n                        inlinedSVG = result.getElementsByTagName('svg')[0];\r\n\r\n                    let titles = inlinedSVG.getElementsByTagName('title')\r\n                    while (titles[0]) titles[0].parentNode.removeChild(titles[0])\r\n\r\n                    let descs = inlinedSVG.getElementsByTagName('desc')\r\n                    while (descs[0]) descs[0].parentNode.removeChild(descs[0])\r\n\r\n                    // Remove some of the attributes that aren't needed\r\n                    inlinedSVG.removeAttribute('xmlns:a');\r\n                    inlinedSVG.removeAttribute('width');\r\n                    inlinedSVG.removeAttribute('height');\r\n                    inlinedSVG.removeAttribute('x');\r\n                    inlinedSVG.removeAttribute('y');\r\n                    inlinedSVG.removeAttribute('enable-background');\r\n                    inlinedSVG.removeAttribute('xmlns:xlink');\r\n                    inlinedSVG.removeAttribute('xml:space');\r\n                    inlinedSVG.removeAttribute('version');\r\n\r\n                    // Add in the attributes from the original <img> except `src` or\r\n                    // `alt`, we don't need either\r\n                    Array.prototype.slice.call(attributes).forEach(function(attribute) {\r\n                        if(attribute.name !== 'src' && attribute.name !== 'alt') {\r\n                            inlinedSVG.setAttribute(attribute.name, attribute.value);\r\n                        }\r\n                    });\r\n\r\n                    // Add an additional class to the inlined SVG to imply it was\r\n                    // infact inlined, might be useful to know\r\n                    if (inlinedSVG.classList) {\r\n                        inlinedSVG.classList.add('inlined-svg');\r\n                    } else {\r\n                        inlinedSVG.className += ' ' + 'inlined-svg';\r\n                    }\r\n\r\n                    // Add in some accessibility quick wins\r\n                    inlinedSVG.setAttribute('role', 'img');\r\n\r\n                    // Use the `longdesc` attribute if one exists\r\n                    if(attributes.longdesc) {\r\n                        var description = document.createElementNS('http://www.w3.org/2000/svg', 'desc'),\r\n                            descriptionText = document.createTextNode(attributes.longdesc.value);\r\n\r\n                        description.appendChild(descriptionText);\r\n                        inlinedSVG.insertBefore(description, inlinedSVG.firstChild);\r\n                    }\r\n\r\n                    // Use the `alt` attribute if one exists\r\n                    if(attributes.alt) {\r\n                        inlinedSVG.setAttribute('aria-labelledby', 'title');\r\n\r\n                        var title = document.createElementNS('http://www.w3.org/2000/svg', 'title'),\r\n                            titleText = document.createTextNode(attributes.alt.value);\r\n\r\n                        title.appendChild(titleText);\r\n                        inlinedSVG.insertBefore(title, inlinedSVG.firstChild);\r\n                    }\r\n\r\n                    // Replace the image with the SVG\r\n                    svg.parentNode.replaceChild(inlinedSVG, svg);\r\n\r\n                    // Fire the callback\r\n                    callback(settings.svgSelector);\r\n\r\n                } else {\r\n\r\n                    console.error('There was an error retrieving the source of the SVG.');\r\n\r\n                }\r\n\r\n            };\r\n\r\n            request.onerror = function () {\r\n                console.error('There was an error connecting to the origin server.');\r\n            };\r\n\r\n            request.send();\r\n\r\n        });\r\n\r\n    };\r\n\r\n    /**\r\n     * Initialise the inliner\r\n     * @public\r\n     */\r\n    inlineSVG.init = function (options, callback) {\r\n\r\n        // Test for support\r\n        if (!supports) return;\r\n\r\n        // Merge users option with defaults\r\n        settings = extend(defaults, options || {});\r\n\r\n        // Kick-off the inliner\r\n        inliner(callback || function(){});\r\n    };\r\n\r\n    return inlineSVG;\r\n\r\n});\r\n","// Imports\nimport ___CSS_LOADER_API_IMPORT___ from \"../../css-loader/dist/runtime/api.js\";\nimport ___CSS_LOADER_GET_URL_IMPORT___ from \"../../css-loader/dist/runtime/getUrl.js\";\nimport ___CSS_LOADER_URL_IMPORT_0___ from \"../fonts/fontawesome-webfont.eot?v=4.7.0\";\nimport ___CSS_LOADER_URL_IMPORT_1___ from \"../fonts/fontawesome-webfont.eot\";\nimport ___CSS_LOADER_URL_IMPORT_2___ from \"../fonts/fontawesome-webfont.woff2?v=4.7.0\";\nimport ___CSS_LOADER_URL_IMPORT_3___ from \"../fonts/fontawesome-webfont.woff?v=4.7.0\";\nimport ___CSS_LOADER_URL_IMPORT_4___ from \"../fonts/fontawesome-webfont.ttf?v=4.7.0\";\nimport ___CSS_LOADER_URL_IMPORT_5___ from \"../fonts/fontawesome-webfont.svg?v=4.7.0\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___, { hash: \"?#iefix&v=4.7.0\" });\nvar ___CSS_LOADER_URL_REPLACEMENT_2___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_2___);\nvar ___CSS_LOADER_URL_REPLACEMENT_3___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_3___);\nvar ___CSS_LOADER_URL_REPLACEMENT_4___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_4___);\nvar ___CSS_LOADER_URL_REPLACEMENT_5___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_5___, { hash: \"#fontawesomeregular\" });\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/*!\\n *  Font Awesome 4.7.0 by @davegandy - http://fontawesome.io - @fontawesome\\n *  License - http://fontawesome.io/license (Font: SIL OFL 1.1, CSS: MIT License)\\n */\\n/* FONT PATH\\n * -------------------------- */\\n@font-face {\\n  font-family: 'FontAwesome';\\n  src: url(\" + ___CSS_LOADER_URL_REPLACEMENT_0___ + \");\\n  src: url(\" + ___CSS_LOADER_URL_REPLACEMENT_1___ + \") format('embedded-opentype'), url(\" + ___CSS_LOADER_URL_REPLACEMENT_2___ + \") format('woff2'), url(\" + ___CSS_LOADER_URL_REPLACEMENT_3___ + \") format('woff'), url(\" + ___CSS_LOADER_URL_REPLACEMENT_4___ + \") format('truetype'), url(\" + ___CSS_LOADER_URL_REPLACEMENT_5___ + \") format('svg');\\n  font-weight: normal;\\n  font-style: normal;\\n}\\n.fa {\\n  display: inline-block;\\n  font: normal normal normal 14px/1 FontAwesome;\\n  font-size: inherit;\\n  text-rendering: auto;\\n  -webkit-font-smoothing: antialiased;\\n  -moz-osx-font-smoothing: grayscale;\\n}\\n/* makes the font 33% larger relative to the icon container */\\n.fa-lg {\\n  font-size: 1.33333333em;\\n  line-height: 0.75em;\\n  vertical-align: -15%;\\n}\\n.fa-2x {\\n  font-size: 2em;\\n}\\n.fa-3x {\\n  font-size: 3em;\\n}\\n.fa-4x {\\n  font-size: 4em;\\n}\\n.fa-5x {\\n  font-size: 5em;\\n}\\n.fa-fw {\\n  width: 1.28571429em;\\n  text-align: center;\\n}\\n.fa-ul {\\n  padding-left: 0;\\n  margin-left: 2.14285714em;\\n  list-style-type: none;\\n}\\n.fa-ul > li {\\n  position: relative;\\n}\\n.fa-li {\\n  position: absolute;\\n  left: -2.14285714em;\\n  width: 2.14285714em;\\n  top: 0.14285714em;\\n  text-align: center;\\n}\\n.fa-li.fa-lg {\\n  left: -1.85714286em;\\n}\\n.fa-border {\\n  padding: .2em .25em .15em;\\n  border: solid 0.08em #eeeeee;\\n  border-radius: .1em;\\n}\\n.fa-pull-left {\\n  float: left;\\n}\\n.fa-pull-right {\\n  float: right;\\n}\\n.fa.fa-pull-left {\\n  margin-right: .3em;\\n}\\n.fa.fa-pull-right {\\n  margin-left: .3em;\\n}\\n/* Deprecated as of 4.4.0 */\\n.pull-right {\\n  float: right;\\n}\\n.pull-left {\\n  float: left;\\n}\\n.fa.pull-left {\\n  margin-right: .3em;\\n}\\n.fa.pull-right {\\n  margin-left: .3em;\\n}\\n.fa-spin {\\n  -webkit-animation: fa-spin 2s infinite linear;\\n  animation: fa-spin 2s infinite linear;\\n}\\n.fa-pulse {\\n  -webkit-animation: fa-spin 1s infinite steps(8);\\n  animation: fa-spin 1s infinite steps(8);\\n}\\n@-webkit-keyframes fa-spin {\\n  0% {\\n    -webkit-transform: rotate(0deg);\\n    transform: rotate(0deg);\\n  }\\n  100% {\\n    -webkit-transform: rotate(359deg);\\n    transform: rotate(359deg);\\n  }\\n}\\n@keyframes fa-spin {\\n  0% {\\n    -webkit-transform: rotate(0deg);\\n    transform: rotate(0deg);\\n  }\\n  100% {\\n    -webkit-transform: rotate(359deg);\\n    transform: rotate(359deg);\\n  }\\n}\\n.fa-rotate-90 {\\n  -ms-filter: \\\"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)\\\";\\n  -webkit-transform: rotate(90deg);\\n  -ms-transform: rotate(90deg);\\n  transform: rotate(90deg);\\n}\\n.fa-rotate-180 {\\n  -ms-filter: \\\"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)\\\";\\n  -webkit-transform: rotate(180deg);\\n  -ms-transform: rotate(180deg);\\n  transform: rotate(180deg);\\n}\\n.fa-rotate-270 {\\n  -ms-filter: \\\"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)\\\";\\n  -webkit-transform: rotate(270deg);\\n  -ms-transform: rotate(270deg);\\n  transform: rotate(270deg);\\n}\\n.fa-flip-horizontal {\\n  -ms-filter: \\\"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)\\\";\\n  -webkit-transform: scale(-1, 1);\\n  -ms-transform: scale(-1, 1);\\n  transform: scale(-1, 1);\\n}\\n.fa-flip-vertical {\\n  -ms-filter: \\\"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)\\\";\\n  -webkit-transform: scale(1, -1);\\n  -ms-transform: scale(1, -1);\\n  transform: scale(1, -1);\\n}\\n:root .fa-rotate-90,\\n:root .fa-rotate-180,\\n:root .fa-rotate-270,\\n:root .fa-flip-horizontal,\\n:root .fa-flip-vertical {\\n  filter: none;\\n}\\n.fa-stack {\\n  position: relative;\\n  display: inline-block;\\n  width: 2em;\\n  height: 2em;\\n  line-height: 2em;\\n  vertical-align: middle;\\n}\\n.fa-stack-1x,\\n.fa-stack-2x {\\n  position: absolute;\\n  left: 0;\\n  width: 100%;\\n  text-align: center;\\n}\\n.fa-stack-1x {\\n  line-height: inherit;\\n}\\n.fa-stack-2x {\\n  font-size: 2em;\\n}\\n.fa-inverse {\\n  color: #ffffff;\\n}\\n/* Font Awesome uses the Unicode Private Use Area (PUA) to ensure screen\\n   readers do not read off random characters that represent icons */\\n.fa-glass:before {\\n  content: \\\"\\\\f000\\\";\\n}\\n.fa-music:before {\\n  content: \\\"\\\\f001\\\";\\n}\\n.fa-search:before {\\n  content: \\\"\\\\f002\\\";\\n}\\n.fa-envelope-o:before {\\n  content: \\\"\\\\f003\\\";\\n}\\n.fa-heart:before {\\n  content: \\\"\\\\f004\\\";\\n}\\n.fa-star:before {\\n  content: \\\"\\\\f005\\\";\\n}\\n.fa-star-o:before {\\n  content: \\\"\\\\f006\\\";\\n}\\n.fa-user:before {\\n  content: \\\"\\\\f007\\\";\\n}\\n.fa-film:before {\\n  content: \\\"\\\\f008\\\";\\n}\\n.fa-th-large:before {\\n  content: \\\"\\\\f009\\\";\\n}\\n.fa-th:before {\\n  content: \\\"\\\\f00a\\\";\\n}\\n.fa-th-list:before {\\n  content: \\\"\\\\f00b\\\";\\n}\\n.fa-check:before {\\n  content: \\\"\\\\f00c\\\";\\n}\\n.fa-remove:before,\\n.fa-close:before,\\n.fa-times:before {\\n  content: \\\"\\\\f00d\\\";\\n}\\n.fa-search-plus:before {\\n  content: \\\"\\\\f00e\\\";\\n}\\n.fa-search-minus:before {\\n  content: \\\"\\\\f010\\\";\\n}\\n.fa-power-off:before {\\n  content: \\\"\\\\f011\\\";\\n}\\n.fa-signal:before {\\n  content: \\\"\\\\f012\\\";\\n}\\n.fa-gear:before,\\n.fa-cog:before {\\n  content: \\\"\\\\f013\\\";\\n}\\n.fa-trash-o:before {\\n  content: \\\"\\\\f014\\\";\\n}\\n.fa-home:before {\\n  content: \\\"\\\\f015\\\";\\n}\\n.fa-file-o:before {\\n  content: \\\"\\\\f016\\\";\\n}\\n.fa-clock-o:before {\\n  content: \\\"\\\\f017\\\";\\n}\\n.fa-road:before {\\n  content: \\\"\\\\f018\\\";\\n}\\n.fa-download:before {\\n  content: \\\"\\\\f019\\\";\\n}\\n.fa-arrow-circle-o-down:before {\\n  content: \\\"\\\\f01a\\\";\\n}\\n.fa-arrow-circle-o-up:before {\\n  content: \\\"\\\\f01b\\\";\\n}\\n.fa-inbox:before {\\n  content: \\\"\\\\f01c\\\";\\n}\\n.fa-play-circle-o:before {\\n  content: \\\"\\\\f01d\\\";\\n}\\n.fa-rotate-right:before,\\n.fa-repeat:before {\\n  content: \\\"\\\\f01e\\\";\\n}\\n.fa-refresh:before {\\n  content: \\\"\\\\f021\\\";\\n}\\n.fa-list-alt:before {\\n  content: \\\"\\\\f022\\\";\\n}\\n.fa-lock:before {\\n  content: \\\"\\\\f023\\\";\\n}\\n.fa-flag:before {\\n  content: \\\"\\\\f024\\\";\\n}\\n.fa-headphones:before {\\n  content: \\\"\\\\f025\\\";\\n}\\n.fa-volume-off:before {\\n  content: \\\"\\\\f026\\\";\\n}\\n.fa-volume-down:before {\\n  content: \\\"\\\\f027\\\";\\n}\\n.fa-volume-up:before {\\n  content: \\\"\\\\f028\\\";\\n}\\n.fa-qrcode:before {\\n  content: \\\"\\\\f029\\\";\\n}\\n.fa-barcode:before {\\n  content: \\\"\\\\f02a\\\";\\n}\\n.fa-tag:before {\\n  content: \\\"\\\\f02b\\\";\\n}\\n.fa-tags:before {\\n  content: \\\"\\\\f02c\\\";\\n}\\n.fa-book:before {\\n  content: \\\"\\\\f02d\\\";\\n}\\n.fa-bookmark:before {\\n  content: \\\"\\\\f02e\\\";\\n}\\n.fa-print:before {\\n  content: \\\"\\\\f02f\\\";\\n}\\n.fa-camera:before {\\n  content: \\\"\\\\f030\\\";\\n}\\n.fa-font:before {\\n  content: \\\"\\\\f031\\\";\\n}\\n.fa-bold:before {\\n  content: \\\"\\\\f032\\\";\\n}\\n.fa-italic:before {\\n  content: \\\"\\\\f033\\\";\\n}\\n.fa-text-height:before {\\n  content: \\\"\\\\f034\\\";\\n}\\n.fa-text-width:before {\\n  content: \\\"\\\\f035\\\";\\n}\\n.fa-align-left:before {\\n  content: \\\"\\\\f036\\\";\\n}\\n.fa-align-center:before {\\n  content: \\\"\\\\f037\\\";\\n}\\n.fa-align-right:before {\\n  content: \\\"\\\\f038\\\";\\n}\\n.fa-align-justify:before {\\n  content: \\\"\\\\f039\\\";\\n}\\n.fa-list:before {\\n  content: \\\"\\\\f03a\\\";\\n}\\n.fa-dedent:before,\\n.fa-outdent:before {\\n  content: \\\"\\\\f03b\\\";\\n}\\n.fa-indent:before {\\n  content: \\\"\\\\f03c\\\";\\n}\\n.fa-video-camera:before {\\n  content: \\\"\\\\f03d\\\";\\n}\\n.fa-photo:before,\\n.fa-image:before,\\n.fa-picture-o:before {\\n  content: \\\"\\\\f03e\\\";\\n}\\n.fa-pencil:before {\\n  content: \\\"\\\\f040\\\";\\n}\\n.fa-map-marker:before {\\n  content: \\\"\\\\f041\\\";\\n}\\n.fa-adjust:before {\\n  content: \\\"\\\\f042\\\";\\n}\\n.fa-tint:before {\\n  content: \\\"\\\\f043\\\";\\n}\\n.fa-edit:before,\\n.fa-pencil-square-o:before {\\n  content: \\\"\\\\f044\\\";\\n}\\n.fa-share-square-o:before {\\n  content: \\\"\\\\f045\\\";\\n}\\n.fa-check-square-o:before {\\n  content: \\\"\\\\f046\\\";\\n}\\n.fa-arrows:before {\\n  content: \\\"\\\\f047\\\";\\n}\\n.fa-step-backward:before {\\n  content: \\\"\\\\f048\\\";\\n}\\n.fa-fast-backward:before {\\n  content: \\\"\\\\f049\\\";\\n}\\n.fa-backward:before {\\n  content: \\\"\\\\f04a\\\";\\n}\\n.fa-play:before {\\n  content: \\\"\\\\f04b\\\";\\n}\\n.fa-pause:before {\\n  content: \\\"\\\\f04c\\\";\\n}\\n.fa-stop:before {\\n  content: \\\"\\\\f04d\\\";\\n}\\n.fa-forward:before {\\n  content: \\\"\\\\f04e\\\";\\n}\\n.fa-fast-forward:before {\\n  content: \\\"\\\\f050\\\";\\n}\\n.fa-step-forward:before {\\n  content: \\\"\\\\f051\\\";\\n}\\n.fa-eject:before {\\n  content: \\\"\\\\f052\\\";\\n}\\n.fa-chevron-left:before {\\n  content: \\\"\\\\f053\\\";\\n}\\n.fa-chevron-right:before {\\n  content: \\\"\\\\f054\\\";\\n}\\n.fa-plus-circle:before {\\n  content: \\\"\\\\f055\\\";\\n}\\n.fa-minus-circle:before {\\n  content: \\\"\\\\f056\\\";\\n}\\n.fa-times-circle:before {\\n  content: \\\"\\\\f057\\\";\\n}\\n.fa-check-circle:before {\\n  content: \\\"\\\\f058\\\";\\n}\\n.fa-question-circle:before {\\n  content: \\\"\\\\f059\\\";\\n}\\n.fa-info-circle:before {\\n  content: \\\"\\\\f05a\\\";\\n}\\n.fa-crosshairs:before {\\n  content: \\\"\\\\f05b\\\";\\n}\\n.fa-times-circle-o:before {\\n  content: \\\"\\\\f05c\\\";\\n}\\n.fa-check-circle-o:before {\\n  content: \\\"\\\\f05d\\\";\\n}\\n.fa-ban:before {\\n  content: \\\"\\\\f05e\\\";\\n}\\n.fa-arrow-left:before {\\n  content: \\\"\\\\f060\\\";\\n}\\n.fa-arrow-right:before {\\n  content: \\\"\\\\f061\\\";\\n}\\n.fa-arrow-up:before {\\n  content: \\\"\\\\f062\\\";\\n}\\n.fa-arrow-down:before {\\n  content: \\\"\\\\f063\\\";\\n}\\n.fa-mail-forward:before,\\n.fa-share:before {\\n  content: \\\"\\\\f064\\\";\\n}\\n.fa-expand:before {\\n  content: \\\"\\\\f065\\\";\\n}\\n.fa-compress:before {\\n  content: \\\"\\\\f066\\\";\\n}\\n.fa-plus:before {\\n  content: \\\"\\\\f067\\\";\\n}\\n.fa-minus:before {\\n  content: \\\"\\\\f068\\\";\\n}\\n.fa-asterisk:before {\\n  content: \\\"\\\\f069\\\";\\n}\\n.fa-exclamation-circle:before {\\n  content: \\\"\\\\f06a\\\";\\n}\\n.fa-gift:before {\\n  content: \\\"\\\\f06b\\\";\\n}\\n.fa-leaf:before {\\n  content: \\\"\\\\f06c\\\";\\n}\\n.fa-fire:before {\\n  content: \\\"\\\\f06d\\\";\\n}\\n.fa-eye:before {\\n  content: \\\"\\\\f06e\\\";\\n}\\n.fa-eye-slash:before {\\n  content: \\\"\\\\f070\\\";\\n}\\n.fa-warning:before,\\n.fa-exclamation-triangle:before {\\n  content: \\\"\\\\f071\\\";\\n}\\n.fa-plane:before {\\n  content: \\\"\\\\f072\\\";\\n}\\n.fa-calendar:before {\\n  content: \\\"\\\\f073\\\";\\n}\\n.fa-random:before {\\n  content: \\\"\\\\f074\\\";\\n}\\n.fa-comment:before {\\n  content: \\\"\\\\f075\\\";\\n}\\n.fa-magnet:before {\\n  content: \\\"\\\\f076\\\";\\n}\\n.fa-chevron-up:before {\\n  content: \\\"\\\\f077\\\";\\n}\\n.fa-chevron-down:before {\\n  content: \\\"\\\\f078\\\";\\n}\\n.fa-retweet:before {\\n  content: \\\"\\\\f079\\\";\\n}\\n.fa-shopping-cart:before {\\n  content: \\\"\\\\f07a\\\";\\n}\\n.fa-folder:before {\\n  content: \\\"\\\\f07b\\\";\\n}\\n.fa-folder-open:before {\\n  content: \\\"\\\\f07c\\\";\\n}\\n.fa-arrows-v:before {\\n  content: \\\"\\\\f07d\\\";\\n}\\n.fa-arrows-h:before {\\n  content: \\\"\\\\f07e\\\";\\n}\\n.fa-bar-chart-o:before,\\n.fa-bar-chart:before {\\n  content: \\\"\\\\f080\\\";\\n}\\n.fa-twitter-square:before {\\n  content: \\\"\\\\f081\\\";\\n}\\n.fa-facebook-square:before {\\n  content: \\\"\\\\f082\\\";\\n}\\n.fa-camera-retro:before {\\n  content: \\\"\\\\f083\\\";\\n}\\n.fa-key:before {\\n  content: \\\"\\\\f084\\\";\\n}\\n.fa-gears:before,\\n.fa-cogs:before {\\n  content: \\\"\\\\f085\\\";\\n}\\n.fa-comments:before {\\n  content: \\\"\\\\f086\\\";\\n}\\n.fa-thumbs-o-up:before {\\n  content: \\\"\\\\f087\\\";\\n}\\n.fa-thumbs-o-down:before {\\n  content: \\\"\\\\f088\\\";\\n}\\n.fa-star-half:before {\\n  content: \\\"\\\\f089\\\";\\n}\\n.fa-heart-o:before {\\n  content: \\\"\\\\f08a\\\";\\n}\\n.fa-sign-out:before {\\n  content: \\\"\\\\f08b\\\";\\n}\\n.fa-linkedin-square:before {\\n  content: \\\"\\\\f08c\\\";\\n}\\n.fa-thumb-tack:before {\\n  content: \\\"\\\\f08d\\\";\\n}\\n.fa-external-link:before {\\n  content: \\\"\\\\f08e\\\";\\n}\\n.fa-sign-in:before {\\n  content: \\\"\\\\f090\\\";\\n}\\n.fa-trophy:before {\\n  content: \\\"\\\\f091\\\";\\n}\\n.fa-github-square:before {\\n  content: \\\"\\\\f092\\\";\\n}\\n.fa-upload:before {\\n  content: \\\"\\\\f093\\\";\\n}\\n.fa-lemon-o:before {\\n  content: \\\"\\\\f094\\\";\\n}\\n.fa-phone:before {\\n  content: \\\"\\\\f095\\\";\\n}\\n.fa-square-o:before {\\n  content: \\\"\\\\f096\\\";\\n}\\n.fa-bookmark-o:before {\\n  content: \\\"\\\\f097\\\";\\n}\\n.fa-phone-square:before {\\n  content: \\\"\\\\f098\\\";\\n}\\n.fa-twitter:before {\\n  content: \\\"\\\\f099\\\";\\n}\\n.fa-facebook-f:before,\\n.fa-facebook:before {\\n  content: \\\"\\\\f09a\\\";\\n}\\n.fa-github:before {\\n  content: \\\"\\\\f09b\\\";\\n}\\n.fa-unlock:before {\\n  content: \\\"\\\\f09c\\\";\\n}\\n.fa-credit-card:before {\\n  content: \\\"\\\\f09d\\\";\\n}\\n.fa-feed:before,\\n.fa-rss:before {\\n  content: \\\"\\\\f09e\\\";\\n}\\n.fa-hdd-o:before {\\n  content: \\\"\\\\f0a0\\\";\\n}\\n.fa-bullhorn:before {\\n  content: \\\"\\\\f0a1\\\";\\n}\\n.fa-bell:before {\\n  content: \\\"\\\\f0f3\\\";\\n}\\n.fa-certificate:before {\\n  content: \\\"\\\\f0a3\\\";\\n}\\n.fa-hand-o-right:before {\\n  content: \\\"\\\\f0a4\\\";\\n}\\n.fa-hand-o-left:before {\\n  content: \\\"\\\\f0a5\\\";\\n}\\n.fa-hand-o-up:before {\\n  content: \\\"\\\\f0a6\\\";\\n}\\n.fa-hand-o-down:before {\\n  content: \\\"\\\\f0a7\\\";\\n}\\n.fa-arrow-circle-left:before {\\n  content: \\\"\\\\f0a8\\\";\\n}\\n.fa-arrow-circle-right:before {\\n  content: \\\"\\\\f0a9\\\";\\n}\\n.fa-arrow-circle-up:before {\\n  content: \\\"\\\\f0aa\\\";\\n}\\n.fa-arrow-circle-down:before {\\n  content: \\\"\\\\f0ab\\\";\\n}\\n.fa-globe:before {\\n  content: \\\"\\\\f0ac\\\";\\n}\\n.fa-wrench:before {\\n  content: \\\"\\\\f0ad\\\";\\n}\\n.fa-tasks:before {\\n  content: \\\"\\\\f0ae\\\";\\n}\\n.fa-filter:before {\\n  content: \\\"\\\\f0b0\\\";\\n}\\n.fa-briefcase:before {\\n  content: \\\"\\\\f0b1\\\";\\n}\\n.fa-arrows-alt:before {\\n  content: \\\"\\\\f0b2\\\";\\n}\\n.fa-group:before,\\n.fa-users:before {\\n  content: \\\"\\\\f0c0\\\";\\n}\\n.fa-chain:before,\\n.fa-link:before {\\n  content: \\\"\\\\f0c1\\\";\\n}\\n.fa-cloud:before {\\n  content: \\\"\\\\f0c2\\\";\\n}\\n.fa-flask:before {\\n  content: \\\"\\\\f0c3\\\";\\n}\\n.fa-cut:before,\\n.fa-scissors:before {\\n  content: \\\"\\\\f0c4\\\";\\n}\\n.fa-copy:before,\\n.fa-files-o:before {\\n  content: \\\"\\\\f0c5\\\";\\n}\\n.fa-paperclip:before {\\n  content: \\\"\\\\f0c6\\\";\\n}\\n.fa-save:before,\\n.fa-floppy-o:before {\\n  content: \\\"\\\\f0c7\\\";\\n}\\n.fa-square:before {\\n  content: \\\"\\\\f0c8\\\";\\n}\\n.fa-navicon:before,\\n.fa-reorder:before,\\n.fa-bars:before {\\n  content: \\\"\\\\f0c9\\\";\\n}\\n.fa-list-ul:before {\\n  content: \\\"\\\\f0ca\\\";\\n}\\n.fa-list-ol:before {\\n  content: \\\"\\\\f0cb\\\";\\n}\\n.fa-strikethrough:before {\\n  content: \\\"\\\\f0cc\\\";\\n}\\n.fa-underline:before {\\n  content: \\\"\\\\f0cd\\\";\\n}\\n.fa-table:before {\\n  content: \\\"\\\\f0ce\\\";\\n}\\n.fa-magic:before {\\n  content: \\\"\\\\f0d0\\\";\\n}\\n.fa-truck:before {\\n  content: \\\"\\\\f0d1\\\";\\n}\\n.fa-pinterest:before {\\n  content: \\\"\\\\f0d2\\\";\\n}\\n.fa-pinterest-square:before {\\n  content: \\\"\\\\f0d3\\\";\\n}\\n.fa-google-plus-square:before {\\n  content: \\\"\\\\f0d4\\\";\\n}\\n.fa-google-plus:before {\\n  content: \\\"\\\\f0d5\\\";\\n}\\n.fa-money:before {\\n  content: \\\"\\\\f0d6\\\";\\n}\\n.fa-caret-down:before {\\n  content: \\\"\\\\f0d7\\\";\\n}\\n.fa-caret-up:before {\\n  content: \\\"\\\\f0d8\\\";\\n}\\n.fa-caret-left:before {\\n  content: \\\"\\\\f0d9\\\";\\n}\\n.fa-caret-right:before {\\n  content: \\\"\\\\f0da\\\";\\n}\\n.fa-columns:before {\\n  content: \\\"\\\\f0db\\\";\\n}\\n.fa-unsorted:before,\\n.fa-sort:before {\\n  content: \\\"\\\\f0dc\\\";\\n}\\n.fa-sort-down:before,\\n.fa-sort-desc:before {\\n  content: \\\"\\\\f0dd\\\";\\n}\\n.fa-sort-up:before,\\n.fa-sort-asc:before {\\n  content: \\\"\\\\f0de\\\";\\n}\\n.fa-envelope:before {\\n  content: \\\"\\\\f0e0\\\";\\n}\\n.fa-linkedin:before {\\n  content: \\\"\\\\f0e1\\\";\\n}\\n.fa-rotate-left:before,\\n.fa-undo:before {\\n  content: \\\"\\\\f0e2\\\";\\n}\\n.fa-legal:before,\\n.fa-gavel:before {\\n  content: \\\"\\\\f0e3\\\";\\n}\\n.fa-dashboard:before,\\n.fa-tachometer:before {\\n  content: \\\"\\\\f0e4\\\";\\n}\\n.fa-comment-o:before {\\n  content: \\\"\\\\f0e5\\\";\\n}\\n.fa-comments-o:before {\\n  content: \\\"\\\\f0e6\\\";\\n}\\n.fa-flash:before,\\n.fa-bolt:before {\\n  content: \\\"\\\\f0e7\\\";\\n}\\n.fa-sitemap:before {\\n  content: \\\"\\\\f0e8\\\";\\n}\\n.fa-umbrella:before {\\n  content: \\\"\\\\f0e9\\\";\\n}\\n.fa-paste:before,\\n.fa-clipboard:before {\\n  content: \\\"\\\\f0ea\\\";\\n}\\n.fa-lightbulb-o:before {\\n  content: \\\"\\\\f0eb\\\";\\n}\\n.fa-exchange:before {\\n  content: \\\"\\\\f0ec\\\";\\n}\\n.fa-cloud-download:before {\\n  content: \\\"\\\\f0ed\\\";\\n}\\n.fa-cloud-upload:before {\\n  content: \\\"\\\\f0ee\\\";\\n}\\n.fa-user-md:before {\\n  content: \\\"\\\\f0f0\\\";\\n}\\n.fa-stethoscope:before {\\n  content: \\\"\\\\f0f1\\\";\\n}\\n.fa-suitcase:before {\\n  content: \\\"\\\\f0f2\\\";\\n}\\n.fa-bell-o:before {\\n  content: \\\"\\\\f0a2\\\";\\n}\\n.fa-coffee:before {\\n  content: \\\"\\\\f0f4\\\";\\n}\\n.fa-cutlery:before {\\n  content: \\\"\\\\f0f5\\\";\\n}\\n.fa-file-text-o:before {\\n  content: \\\"\\\\f0f6\\\";\\n}\\n.fa-building-o:before {\\n  content: \\\"\\\\f0f7\\\";\\n}\\n.fa-hospital-o:before {\\n  content: \\\"\\\\f0f8\\\";\\n}\\n.fa-ambulance:before {\\n  content: \\\"\\\\f0f9\\\";\\n}\\n.fa-medkit:before {\\n  content: \\\"\\\\f0fa\\\";\\n}\\n.fa-fighter-jet:before {\\n  content: \\\"\\\\f0fb\\\";\\n}\\n.fa-beer:before {\\n  content: \\\"\\\\f0fc\\\";\\n}\\n.fa-h-square:before {\\n  content: \\\"\\\\f0fd\\\";\\n}\\n.fa-plus-square:before {\\n  content: \\\"\\\\f0fe\\\";\\n}\\n.fa-angle-double-left:before {\\n  content: \\\"\\\\f100\\\";\\n}\\n.fa-angle-double-right:before {\\n  content: \\\"\\\\f101\\\";\\n}\\n.fa-angle-double-up:before {\\n  content: \\\"\\\\f102\\\";\\n}\\n.fa-angle-double-down:before {\\n  content: \\\"\\\\f103\\\";\\n}\\n.fa-angle-left:before {\\n  content: \\\"\\\\f104\\\";\\n}\\n.fa-angle-right:before {\\n  content: \\\"\\\\f105\\\";\\n}\\n.fa-angle-up:before {\\n  content: \\\"\\\\f106\\\";\\n}\\n.fa-angle-down:before {\\n  content: \\\"\\\\f107\\\";\\n}\\n.fa-desktop:before {\\n  content: \\\"\\\\f108\\\";\\n}\\n.fa-laptop:before {\\n  content: \\\"\\\\f109\\\";\\n}\\n.fa-tablet:before {\\n  content: \\\"\\\\f10a\\\";\\n}\\n.fa-mobile-phone:before,\\n.fa-mobile:before {\\n  content: \\\"\\\\f10b\\\";\\n}\\n.fa-circle-o:before {\\n  content: \\\"\\\\f10c\\\";\\n}\\n.fa-quote-left:before {\\n  content: \\\"\\\\f10d\\\";\\n}\\n.fa-quote-right:before {\\n  content: \\\"\\\\f10e\\\";\\n}\\n.fa-spinner:before {\\n  content: \\\"\\\\f110\\\";\\n}\\n.fa-circle:before {\\n  content: \\\"\\\\f111\\\";\\n}\\n.fa-mail-reply:before,\\n.fa-reply:before {\\n  content: \\\"\\\\f112\\\";\\n}\\n.fa-github-alt:before {\\n  content: \\\"\\\\f113\\\";\\n}\\n.fa-folder-o:before {\\n  content: \\\"\\\\f114\\\";\\n}\\n.fa-folder-open-o:before {\\n  content: \\\"\\\\f115\\\";\\n}\\n.fa-smile-o:before {\\n  content: \\\"\\\\f118\\\";\\n}\\n.fa-frown-o:before {\\n  content: \\\"\\\\f119\\\";\\n}\\n.fa-meh-o:before {\\n  content: \\\"\\\\f11a\\\";\\n}\\n.fa-gamepad:before {\\n  content: \\\"\\\\f11b\\\";\\n}\\n.fa-keyboard-o:before {\\n  content: \\\"\\\\f11c\\\";\\n}\\n.fa-flag-o:before {\\n  content: \\\"\\\\f11d\\\";\\n}\\n.fa-flag-checkered:before {\\n  content: \\\"\\\\f11e\\\";\\n}\\n.fa-terminal:before {\\n  content: \\\"\\\\f120\\\";\\n}\\n.fa-code:before {\\n  content: \\\"\\\\f121\\\";\\n}\\n.fa-mail-reply-all:before,\\n.fa-reply-all:before {\\n  content: \\\"\\\\f122\\\";\\n}\\n.fa-star-half-empty:before,\\n.fa-star-half-full:before,\\n.fa-star-half-o:before {\\n  content: \\\"\\\\f123\\\";\\n}\\n.fa-location-arrow:before {\\n  content: \\\"\\\\f124\\\";\\n}\\n.fa-crop:before {\\n  content: \\\"\\\\f125\\\";\\n}\\n.fa-code-fork:before {\\n  content: \\\"\\\\f126\\\";\\n}\\n.fa-unlink:before,\\n.fa-chain-broken:before {\\n  content: \\\"\\\\f127\\\";\\n}\\n.fa-question:before {\\n  content: \\\"\\\\f128\\\";\\n}\\n.fa-info:before {\\n  content: \\\"\\\\f129\\\";\\n}\\n.fa-exclamation:before {\\n  content: \\\"\\\\f12a\\\";\\n}\\n.fa-superscript:before {\\n  content: \\\"\\\\f12b\\\";\\n}\\n.fa-subscript:before {\\n  content: \\\"\\\\f12c\\\";\\n}\\n.fa-eraser:before {\\n  content: \\\"\\\\f12d\\\";\\n}\\n.fa-puzzle-piece:before {\\n  content: \\\"\\\\f12e\\\";\\n}\\n.fa-microphone:before {\\n  content: \\\"\\\\f130\\\";\\n}\\n.fa-microphone-slash:before {\\n  content: \\\"\\\\f131\\\";\\n}\\n.fa-shield:before {\\n  content: \\\"\\\\f132\\\";\\n}\\n.fa-calendar-o:before {\\n  content: \\\"\\\\f133\\\";\\n}\\n.fa-fire-extinguisher:before {\\n  content: \\\"\\\\f134\\\";\\n}\\n.fa-rocket:before {\\n  content: \\\"\\\\f135\\\";\\n}\\n.fa-maxcdn:before {\\n  content: \\\"\\\\f136\\\";\\n}\\n.fa-chevron-circle-left:before {\\n  content: \\\"\\\\f137\\\";\\n}\\n.fa-chevron-circle-right:before {\\n  content: \\\"\\\\f138\\\";\\n}\\n.fa-chevron-circle-up:before {\\n  content: \\\"\\\\f139\\\";\\n}\\n.fa-chevron-circle-down:before {\\n  content: \\\"\\\\f13a\\\";\\n}\\n.fa-html5:before {\\n  content: \\\"\\\\f13b\\\";\\n}\\n.fa-css3:before {\\n  content: \\\"\\\\f13c\\\";\\n}\\n.fa-anchor:before {\\n  content: \\\"\\\\f13d\\\";\\n}\\n.fa-unlock-alt:before {\\n  content: \\\"\\\\f13e\\\";\\n}\\n.fa-bullseye:before {\\n  content: \\\"\\\\f140\\\";\\n}\\n.fa-ellipsis-h:before {\\n  content: \\\"\\\\f141\\\";\\n}\\n.fa-ellipsis-v:before {\\n  content: \\\"\\\\f142\\\";\\n}\\n.fa-rss-square:before {\\n  content: \\\"\\\\f143\\\";\\n}\\n.fa-play-circle:before {\\n  content: \\\"\\\\f144\\\";\\n}\\n.fa-ticket:before {\\n  content: \\\"\\\\f145\\\";\\n}\\n.fa-minus-square:before {\\n  content: \\\"\\\\f146\\\";\\n}\\n.fa-minus-square-o:before {\\n  content: \\\"\\\\f147\\\";\\n}\\n.fa-level-up:before {\\n  content: \\\"\\\\f148\\\";\\n}\\n.fa-level-down:before {\\n  content: \\\"\\\\f149\\\";\\n}\\n.fa-check-square:before {\\n  content: \\\"\\\\f14a\\\";\\n}\\n.fa-pencil-square:before {\\n  content: \\\"\\\\f14b\\\";\\n}\\n.fa-external-link-square:before {\\n  content: \\\"\\\\f14c\\\";\\n}\\n.fa-share-square:before {\\n  content: \\\"\\\\f14d\\\";\\n}\\n.fa-compass:before {\\n  content: \\\"\\\\f14e\\\";\\n}\\n.fa-toggle-down:before,\\n.fa-caret-square-o-down:before {\\n  content: \\\"\\\\f150\\\";\\n}\\n.fa-toggle-up:before,\\n.fa-caret-square-o-up:before {\\n  content: \\\"\\\\f151\\\";\\n}\\n.fa-toggle-right:before,\\n.fa-caret-square-o-right:before {\\n  content: \\\"\\\\f152\\\";\\n}\\n.fa-euro:before,\\n.fa-eur:before {\\n  content: \\\"\\\\f153\\\";\\n}\\n.fa-gbp:before {\\n  content: \\\"\\\\f154\\\";\\n}\\n.fa-dollar:before,\\n.fa-usd:before {\\n  content: \\\"\\\\f155\\\";\\n}\\n.fa-rupee:before,\\n.fa-inr:before {\\n  content: \\\"\\\\f156\\\";\\n}\\n.fa-cny:before,\\n.fa-rmb:before,\\n.fa-yen:before,\\n.fa-jpy:before {\\n  content: \\\"\\\\f157\\\";\\n}\\n.fa-ruble:before,\\n.fa-rouble:before,\\n.fa-rub:before {\\n  content: \\\"\\\\f158\\\";\\n}\\n.fa-won:before,\\n.fa-krw:before {\\n  content: \\\"\\\\f159\\\";\\n}\\n.fa-bitcoin:before,\\n.fa-btc:before {\\n  content: \\\"\\\\f15a\\\";\\n}\\n.fa-file:before {\\n  content: \\\"\\\\f15b\\\";\\n}\\n.fa-file-text:before {\\n  content: \\\"\\\\f15c\\\";\\n}\\n.fa-sort-alpha-asc:before {\\n  content: \\\"\\\\f15d\\\";\\n}\\n.fa-sort-alpha-desc:before {\\n  content: \\\"\\\\f15e\\\";\\n}\\n.fa-sort-amount-asc:before {\\n  content: \\\"\\\\f160\\\";\\n}\\n.fa-sort-amount-desc:before {\\n  content: \\\"\\\\f161\\\";\\n}\\n.fa-sort-numeric-asc:before {\\n  content: \\\"\\\\f162\\\";\\n}\\n.fa-sort-numeric-desc:before {\\n  content: \\\"\\\\f163\\\";\\n}\\n.fa-thumbs-up:before {\\n  content: \\\"\\\\f164\\\";\\n}\\n.fa-thumbs-down:before {\\n  content: \\\"\\\\f165\\\";\\n}\\n.fa-youtube-square:before {\\n  content: \\\"\\\\f166\\\";\\n}\\n.fa-youtube:before {\\n  content: \\\"\\\\f167\\\";\\n}\\n.fa-xing:before {\\n  content: \\\"\\\\f168\\\";\\n}\\n.fa-xing-square:before {\\n  content: \\\"\\\\f169\\\";\\n}\\n.fa-youtube-play:before {\\n  content: \\\"\\\\f16a\\\";\\n}\\n.fa-dropbox:before {\\n  content: \\\"\\\\f16b\\\";\\n}\\n.fa-stack-overflow:before {\\n  content: \\\"\\\\f16c\\\";\\n}\\n.fa-instagram:before {\\n  content: \\\"\\\\f16d\\\";\\n}\\n.fa-flickr:before {\\n  content: \\\"\\\\f16e\\\";\\n}\\n.fa-adn:before {\\n  content: \\\"\\\\f170\\\";\\n}\\n.fa-bitbucket:before {\\n  content: \\\"\\\\f171\\\";\\n}\\n.fa-bitbucket-square:before {\\n  content: \\\"\\\\f172\\\";\\n}\\n.fa-tumblr:before {\\n  content: \\\"\\\\f173\\\";\\n}\\n.fa-tumblr-square:before {\\n  content: \\\"\\\\f174\\\";\\n}\\n.fa-long-arrow-down:before {\\n  content: \\\"\\\\f175\\\";\\n}\\n.fa-long-arrow-up:before {\\n  content: \\\"\\\\f176\\\";\\n}\\n.fa-long-arrow-left:before {\\n  content: \\\"\\\\f177\\\";\\n}\\n.fa-long-arrow-right:before {\\n  content: \\\"\\\\f178\\\";\\n}\\n.fa-apple:before {\\n  content: \\\"\\\\f179\\\";\\n}\\n.fa-windows:before {\\n  content: \\\"\\\\f17a\\\";\\n}\\n.fa-android:before {\\n  content: \\\"\\\\f17b\\\";\\n}\\n.fa-linux:before {\\n  content: \\\"\\\\f17c\\\";\\n}\\n.fa-dribbble:before {\\n  content: \\\"\\\\f17d\\\";\\n}\\n.fa-skype:before {\\n  content: \\\"\\\\f17e\\\";\\n}\\n.fa-foursquare:before {\\n  content: \\\"\\\\f180\\\";\\n}\\n.fa-trello:before {\\n  content: \\\"\\\\f181\\\";\\n}\\n.fa-female:before {\\n  content: \\\"\\\\f182\\\";\\n}\\n.fa-male:before {\\n  content: \\\"\\\\f183\\\";\\n}\\n.fa-gittip:before,\\n.fa-gratipay:before {\\n  content: \\\"\\\\f184\\\";\\n}\\n.fa-sun-o:before {\\n  content: \\\"\\\\f185\\\";\\n}\\n.fa-moon-o:before {\\n  content: \\\"\\\\f186\\\";\\n}\\n.fa-archive:before {\\n  content: \\\"\\\\f187\\\";\\n}\\n.fa-bug:before {\\n  content: \\\"\\\\f188\\\";\\n}\\n.fa-vk:before {\\n  content: \\\"\\\\f189\\\";\\n}\\n.fa-weibo:before {\\n  content: \\\"\\\\f18a\\\";\\n}\\n.fa-renren:before {\\n  content: \\\"\\\\f18b\\\";\\n}\\n.fa-pagelines:before {\\n  content: \\\"\\\\f18c\\\";\\n}\\n.fa-stack-exchange:before {\\n  content: \\\"\\\\f18d\\\";\\n}\\n.fa-arrow-circle-o-right:before {\\n  content: \\\"\\\\f18e\\\";\\n}\\n.fa-arrow-circle-o-left:before {\\n  content: \\\"\\\\f190\\\";\\n}\\n.fa-toggle-left:before,\\n.fa-caret-square-o-left:before {\\n  content: \\\"\\\\f191\\\";\\n}\\n.fa-dot-circle-o:before {\\n  content: \\\"\\\\f192\\\";\\n}\\n.fa-wheelchair:before {\\n  content: \\\"\\\\f193\\\";\\n}\\n.fa-vimeo-square:before {\\n  content: \\\"\\\\f194\\\";\\n}\\n.fa-turkish-lira:before,\\n.fa-try:before {\\n  content: \\\"\\\\f195\\\";\\n}\\n.fa-plus-square-o:before {\\n  content: \\\"\\\\f196\\\";\\n}\\n.fa-space-shuttle:before {\\n  content: \\\"\\\\f197\\\";\\n}\\n.fa-slack:before {\\n  content: \\\"\\\\f198\\\";\\n}\\n.fa-envelope-square:before {\\n  content: \\\"\\\\f199\\\";\\n}\\n.fa-wordpress:before {\\n  content: \\\"\\\\f19a\\\";\\n}\\n.fa-openid:before {\\n  content: \\\"\\\\f19b\\\";\\n}\\n.fa-institution:before,\\n.fa-bank:before,\\n.fa-university:before {\\n  content: \\\"\\\\f19c\\\";\\n}\\n.fa-mortar-board:before,\\n.fa-graduation-cap:before {\\n  content: \\\"\\\\f19d\\\";\\n}\\n.fa-yahoo:before {\\n  content: \\\"\\\\f19e\\\";\\n}\\n.fa-google:before {\\n  content: \\\"\\\\f1a0\\\";\\n}\\n.fa-reddit:before {\\n  content: \\\"\\\\f1a1\\\";\\n}\\n.fa-reddit-square:before {\\n  content: \\\"\\\\f1a2\\\";\\n}\\n.fa-stumbleupon-circle:before {\\n  content: \\\"\\\\f1a3\\\";\\n}\\n.fa-stumbleupon:before {\\n  content: \\\"\\\\f1a4\\\";\\n}\\n.fa-delicious:before {\\n  content: \\\"\\\\f1a5\\\";\\n}\\n.fa-digg:before {\\n  content: \\\"\\\\f1a6\\\";\\n}\\n.fa-pied-piper-pp:before {\\n  content: \\\"\\\\f1a7\\\";\\n}\\n.fa-pied-piper-alt:before {\\n  content: \\\"\\\\f1a8\\\";\\n}\\n.fa-drupal:before {\\n  content: \\\"\\\\f1a9\\\";\\n}\\n.fa-joomla:before {\\n  content: \\\"\\\\f1aa\\\";\\n}\\n.fa-language:before {\\n  content: \\\"\\\\f1ab\\\";\\n}\\n.fa-fax:before {\\n  content: \\\"\\\\f1ac\\\";\\n}\\n.fa-building:before {\\n  content: \\\"\\\\f1ad\\\";\\n}\\n.fa-child:before {\\n  content: \\\"\\\\f1ae\\\";\\n}\\n.fa-paw:before {\\n  content: \\\"\\\\f1b0\\\";\\n}\\n.fa-spoon:before {\\n  content: \\\"\\\\f1b1\\\";\\n}\\n.fa-cube:before {\\n  content: \\\"\\\\f1b2\\\";\\n}\\n.fa-cubes:before {\\n  content: \\\"\\\\f1b3\\\";\\n}\\n.fa-behance:before {\\n  content: \\\"\\\\f1b4\\\";\\n}\\n.fa-behance-square:before {\\n  content: \\\"\\\\f1b5\\\";\\n}\\n.fa-steam:before {\\n  content: \\\"\\\\f1b6\\\";\\n}\\n.fa-steam-square:before {\\n  content: \\\"\\\\f1b7\\\";\\n}\\n.fa-recycle:before {\\n  content: \\\"\\\\f1b8\\\";\\n}\\n.fa-automobile:before,\\n.fa-car:before {\\n  content: \\\"\\\\f1b9\\\";\\n}\\n.fa-cab:before,\\n.fa-taxi:before {\\n  content: \\\"\\\\f1ba\\\";\\n}\\n.fa-tree:before {\\n  content: \\\"\\\\f1bb\\\";\\n}\\n.fa-spotify:before {\\n  content: \\\"\\\\f1bc\\\";\\n}\\n.fa-deviantart:before {\\n  content: \\\"\\\\f1bd\\\";\\n}\\n.fa-soundcloud:before {\\n  content: \\\"\\\\f1be\\\";\\n}\\n.fa-database:before {\\n  content: \\\"\\\\f1c0\\\";\\n}\\n.fa-file-pdf-o:before {\\n  content: \\\"\\\\f1c1\\\";\\n}\\n.fa-file-word-o:before {\\n  content: \\\"\\\\f1c2\\\";\\n}\\n.fa-file-excel-o:before {\\n  content: \\\"\\\\f1c3\\\";\\n}\\n.fa-file-powerpoint-o:before {\\n  content: \\\"\\\\f1c4\\\";\\n}\\n.fa-file-photo-o:before,\\n.fa-file-picture-o:before,\\n.fa-file-image-o:before {\\n  content: \\\"\\\\f1c5\\\";\\n}\\n.fa-file-zip-o:before,\\n.fa-file-archive-o:before {\\n  content: \\\"\\\\f1c6\\\";\\n}\\n.fa-file-sound-o:before,\\n.fa-file-audio-o:before {\\n  content: \\\"\\\\f1c7\\\";\\n}\\n.fa-file-movie-o:before,\\n.fa-file-video-o:before {\\n  content: \\\"\\\\f1c8\\\";\\n}\\n.fa-file-code-o:before {\\n  content: \\\"\\\\f1c9\\\";\\n}\\n.fa-vine:before {\\n  content: \\\"\\\\f1ca\\\";\\n}\\n.fa-codepen:before {\\n  content: \\\"\\\\f1cb\\\";\\n}\\n.fa-jsfiddle:before {\\n  content: \\\"\\\\f1cc\\\";\\n}\\n.fa-life-bouy:before,\\n.fa-life-buoy:before,\\n.fa-life-saver:before,\\n.fa-support:before,\\n.fa-life-ring:before {\\n  content: \\\"\\\\f1cd\\\";\\n}\\n.fa-circle-o-notch:before {\\n  content: \\\"\\\\f1ce\\\";\\n}\\n.fa-ra:before,\\n.fa-resistance:before,\\n.fa-rebel:before {\\n  content: \\\"\\\\f1d0\\\";\\n}\\n.fa-ge:before,\\n.fa-empire:before {\\n  content: \\\"\\\\f1d1\\\";\\n}\\n.fa-git-square:before {\\n  content: \\\"\\\\f1d2\\\";\\n}\\n.fa-git:before {\\n  content: \\\"\\\\f1d3\\\";\\n}\\n.fa-y-combinator-square:before,\\n.fa-yc-square:before,\\n.fa-hacker-news:before {\\n  content: \\\"\\\\f1d4\\\";\\n}\\n.fa-tencent-weibo:before {\\n  content: \\\"\\\\f1d5\\\";\\n}\\n.fa-qq:before {\\n  content: \\\"\\\\f1d6\\\";\\n}\\n.fa-wechat:before,\\n.fa-weixin:before {\\n  content: \\\"\\\\f1d7\\\";\\n}\\n.fa-send:before,\\n.fa-paper-plane:before {\\n  content: \\\"\\\\f1d8\\\";\\n}\\n.fa-send-o:before,\\n.fa-paper-plane-o:before {\\n  content: \\\"\\\\f1d9\\\";\\n}\\n.fa-history:before {\\n  content: \\\"\\\\f1da\\\";\\n}\\n.fa-circle-thin:before {\\n  content: \\\"\\\\f1db\\\";\\n}\\n.fa-header:before {\\n  content: \\\"\\\\f1dc\\\";\\n}\\n.fa-paragraph:before {\\n  content: \\\"\\\\f1dd\\\";\\n}\\n.fa-sliders:before {\\n  content: \\\"\\\\f1de\\\";\\n}\\n.fa-share-alt:before {\\n  content: \\\"\\\\f1e0\\\";\\n}\\n.fa-share-alt-square:before {\\n  content: \\\"\\\\f1e1\\\";\\n}\\n.fa-bomb:before {\\n  content: \\\"\\\\f1e2\\\";\\n}\\n.fa-soccer-ball-o:before,\\n.fa-futbol-o:before {\\n  content: \\\"\\\\f1e3\\\";\\n}\\n.fa-tty:before {\\n  content: \\\"\\\\f1e4\\\";\\n}\\n.fa-binoculars:before {\\n  content: \\\"\\\\f1e5\\\";\\n}\\n.fa-plug:before {\\n  content: \\\"\\\\f1e6\\\";\\n}\\n.fa-slideshare:before {\\n  content: \\\"\\\\f1e7\\\";\\n}\\n.fa-twitch:before {\\n  content: \\\"\\\\f1e8\\\";\\n}\\n.fa-yelp:before {\\n  content: \\\"\\\\f1e9\\\";\\n}\\n.fa-newspaper-o:before {\\n  content: \\\"\\\\f1ea\\\";\\n}\\n.fa-wifi:before {\\n  content: \\\"\\\\f1eb\\\";\\n}\\n.fa-calculator:before {\\n  content: \\\"\\\\f1ec\\\";\\n}\\n.fa-paypal:before {\\n  content: \\\"\\\\f1ed\\\";\\n}\\n.fa-google-wallet:before {\\n  content: \\\"\\\\f1ee\\\";\\n}\\n.fa-cc-visa:before {\\n  content: \\\"\\\\f1f0\\\";\\n}\\n.fa-cc-mastercard:before {\\n  content: \\\"\\\\f1f1\\\";\\n}\\n.fa-cc-discover:before {\\n  content: \\\"\\\\f1f2\\\";\\n}\\n.fa-cc-amex:before {\\n  content: \\\"\\\\f1f3\\\";\\n}\\n.fa-cc-paypal:before {\\n  content: \\\"\\\\f1f4\\\";\\n}\\n.fa-cc-stripe:before {\\n  content: \\\"\\\\f1f5\\\";\\n}\\n.fa-bell-slash:before {\\n  content: \\\"\\\\f1f6\\\";\\n}\\n.fa-bell-slash-o:before {\\n  content: \\\"\\\\f1f7\\\";\\n}\\n.fa-trash:before {\\n  content: \\\"\\\\f1f8\\\";\\n}\\n.fa-copyright:before {\\n  content: \\\"\\\\f1f9\\\";\\n}\\n.fa-at:before {\\n  content: \\\"\\\\f1fa\\\";\\n}\\n.fa-eyedropper:before {\\n  content: \\\"\\\\f1fb\\\";\\n}\\n.fa-paint-brush:before {\\n  content: \\\"\\\\f1fc\\\";\\n}\\n.fa-birthday-cake:before {\\n  content: \\\"\\\\f1fd\\\";\\n}\\n.fa-area-chart:before {\\n  content: \\\"\\\\f1fe\\\";\\n}\\n.fa-pie-chart:before {\\n  content: \\\"\\\\f200\\\";\\n}\\n.fa-line-chart:before {\\n  content: \\\"\\\\f201\\\";\\n}\\n.fa-lastfm:before {\\n  content: \\\"\\\\f202\\\";\\n}\\n.fa-lastfm-square:before {\\n  content: \\\"\\\\f203\\\";\\n}\\n.fa-toggle-off:before {\\n  content: \\\"\\\\f204\\\";\\n}\\n.fa-toggle-on:before {\\n  content: \\\"\\\\f205\\\";\\n}\\n.fa-bicycle:before {\\n  content: \\\"\\\\f206\\\";\\n}\\n.fa-bus:before {\\n  content: \\\"\\\\f207\\\";\\n}\\n.fa-ioxhost:before {\\n  content: \\\"\\\\f208\\\";\\n}\\n.fa-angellist:before {\\n  content: \\\"\\\\f209\\\";\\n}\\n.fa-cc:before {\\n  content: \\\"\\\\f20a\\\";\\n}\\n.fa-shekel:before,\\n.fa-sheqel:before,\\n.fa-ils:before {\\n  content: \\\"\\\\f20b\\\";\\n}\\n.fa-meanpath:before {\\n  content: \\\"\\\\f20c\\\";\\n}\\n.fa-buysellads:before {\\n  content: \\\"\\\\f20d\\\";\\n}\\n.fa-connectdevelop:before {\\n  content: \\\"\\\\f20e\\\";\\n}\\n.fa-dashcube:before {\\n  content: \\\"\\\\f210\\\";\\n}\\n.fa-forumbee:before {\\n  content: \\\"\\\\f211\\\";\\n}\\n.fa-leanpub:before {\\n  content: \\\"\\\\f212\\\";\\n}\\n.fa-sellsy:before {\\n  content: \\\"\\\\f213\\\";\\n}\\n.fa-shirtsinbulk:before {\\n  content: \\\"\\\\f214\\\";\\n}\\n.fa-simplybuilt:before {\\n  content: \\\"\\\\f215\\\";\\n}\\n.fa-skyatlas:before {\\n  content: \\\"\\\\f216\\\";\\n}\\n.fa-cart-plus:before {\\n  content: \\\"\\\\f217\\\";\\n}\\n.fa-cart-arrow-down:before {\\n  content: \\\"\\\\f218\\\";\\n}\\n.fa-diamond:before {\\n  content: \\\"\\\\f219\\\";\\n}\\n.fa-ship:before {\\n  content: \\\"\\\\f21a\\\";\\n}\\n.fa-user-secret:before {\\n  content: \\\"\\\\f21b\\\";\\n}\\n.fa-motorcycle:before {\\n  content: \\\"\\\\f21c\\\";\\n}\\n.fa-street-view:before {\\n  content: \\\"\\\\f21d\\\";\\n}\\n.fa-heartbeat:before {\\n  content: \\\"\\\\f21e\\\";\\n}\\n.fa-venus:before {\\n  content: \\\"\\\\f221\\\";\\n}\\n.fa-mars:before {\\n  content: \\\"\\\\f222\\\";\\n}\\n.fa-mercury:before {\\n  content: \\\"\\\\f223\\\";\\n}\\n.fa-intersex:before,\\n.fa-transgender:before {\\n  content: \\\"\\\\f224\\\";\\n}\\n.fa-transgender-alt:before {\\n  content: \\\"\\\\f225\\\";\\n}\\n.fa-venus-double:before {\\n  content: \\\"\\\\f226\\\";\\n}\\n.fa-mars-double:before {\\n  content: \\\"\\\\f227\\\";\\n}\\n.fa-venus-mars:before {\\n  content: \\\"\\\\f228\\\";\\n}\\n.fa-mars-stroke:before {\\n  content: \\\"\\\\f229\\\";\\n}\\n.fa-mars-stroke-v:before {\\n  content: \\\"\\\\f22a\\\";\\n}\\n.fa-mars-stroke-h:before {\\n  content: \\\"\\\\f22b\\\";\\n}\\n.fa-neuter:before {\\n  content: \\\"\\\\f22c\\\";\\n}\\n.fa-genderless:before {\\n  content: \\\"\\\\f22d\\\";\\n}\\n.fa-facebook-official:before {\\n  content: \\\"\\\\f230\\\";\\n}\\n.fa-pinterest-p:before {\\n  content: \\\"\\\\f231\\\";\\n}\\n.fa-whatsapp:before {\\n  content: \\\"\\\\f232\\\";\\n}\\n.fa-server:before {\\n  content: \\\"\\\\f233\\\";\\n}\\n.fa-user-plus:before {\\n  content: \\\"\\\\f234\\\";\\n}\\n.fa-user-times:before {\\n  content: \\\"\\\\f235\\\";\\n}\\n.fa-hotel:before,\\n.fa-bed:before {\\n  content: \\\"\\\\f236\\\";\\n}\\n.fa-viacoin:before {\\n  content: \\\"\\\\f237\\\";\\n}\\n.fa-train:before {\\n  content: \\\"\\\\f238\\\";\\n}\\n.fa-subway:before {\\n  content: \\\"\\\\f239\\\";\\n}\\n.fa-medium:before {\\n  content: \\\"\\\\f23a\\\";\\n}\\n.fa-yc:before,\\n.fa-y-combinator:before {\\n  content: \\\"\\\\f23b\\\";\\n}\\n.fa-optin-monster:before {\\n  content: \\\"\\\\f23c\\\";\\n}\\n.fa-opencart:before {\\n  content: \\\"\\\\f23d\\\";\\n}\\n.fa-expeditedssl:before {\\n  content: \\\"\\\\f23e\\\";\\n}\\n.fa-battery-4:before,\\n.fa-battery:before,\\n.fa-battery-full:before {\\n  content: \\\"\\\\f240\\\";\\n}\\n.fa-battery-3:before,\\n.fa-battery-three-quarters:before {\\n  content: \\\"\\\\f241\\\";\\n}\\n.fa-battery-2:before,\\n.fa-battery-half:before {\\n  content: \\\"\\\\f242\\\";\\n}\\n.fa-battery-1:before,\\n.fa-battery-quarter:before {\\n  content: \\\"\\\\f243\\\";\\n}\\n.fa-battery-0:before,\\n.fa-battery-empty:before {\\n  content: \\\"\\\\f244\\\";\\n}\\n.fa-mouse-pointer:before {\\n  content: \\\"\\\\f245\\\";\\n}\\n.fa-i-cursor:before {\\n  content: \\\"\\\\f246\\\";\\n}\\n.fa-object-group:before {\\n  content: \\\"\\\\f247\\\";\\n}\\n.fa-object-ungroup:before {\\n  content: \\\"\\\\f248\\\";\\n}\\n.fa-sticky-note:before {\\n  content: \\\"\\\\f249\\\";\\n}\\n.fa-sticky-note-o:before {\\n  content: \\\"\\\\f24a\\\";\\n}\\n.fa-cc-jcb:before {\\n  content: \\\"\\\\f24b\\\";\\n}\\n.fa-cc-diners-club:before {\\n  content: \\\"\\\\f24c\\\";\\n}\\n.fa-clone:before {\\n  content: \\\"\\\\f24d\\\";\\n}\\n.fa-balance-scale:before {\\n  content: \\\"\\\\f24e\\\";\\n}\\n.fa-hourglass-o:before {\\n  content: \\\"\\\\f250\\\";\\n}\\n.fa-hourglass-1:before,\\n.fa-hourglass-start:before {\\n  content: \\\"\\\\f251\\\";\\n}\\n.fa-hourglass-2:before,\\n.fa-hourglass-half:before {\\n  content: \\\"\\\\f252\\\";\\n}\\n.fa-hourglass-3:before,\\n.fa-hourglass-end:before {\\n  content: \\\"\\\\f253\\\";\\n}\\n.fa-hourglass:before {\\n  content: \\\"\\\\f254\\\";\\n}\\n.fa-hand-grab-o:before,\\n.fa-hand-rock-o:before {\\n  content: \\\"\\\\f255\\\";\\n}\\n.fa-hand-stop-o:before,\\n.fa-hand-paper-o:before {\\n  content: \\\"\\\\f256\\\";\\n}\\n.fa-hand-scissors-o:before {\\n  content: \\\"\\\\f257\\\";\\n}\\n.fa-hand-lizard-o:before {\\n  content: \\\"\\\\f258\\\";\\n}\\n.fa-hand-spock-o:before {\\n  content: \\\"\\\\f259\\\";\\n}\\n.fa-hand-pointer-o:before {\\n  content: \\\"\\\\f25a\\\";\\n}\\n.fa-hand-peace-o:before {\\n  content: \\\"\\\\f25b\\\";\\n}\\n.fa-trademark:before {\\n  content: \\\"\\\\f25c\\\";\\n}\\n.fa-registered:before {\\n  content: \\\"\\\\f25d\\\";\\n}\\n.fa-creative-commons:before {\\n  content: \\\"\\\\f25e\\\";\\n}\\n.fa-gg:before {\\n  content: \\\"\\\\f260\\\";\\n}\\n.fa-gg-circle:before {\\n  content: \\\"\\\\f261\\\";\\n}\\n.fa-tripadvisor:before {\\n  content: \\\"\\\\f262\\\";\\n}\\n.fa-odnoklassniki:before {\\n  content: \\\"\\\\f263\\\";\\n}\\n.fa-odnoklassniki-square:before {\\n  content: \\\"\\\\f264\\\";\\n}\\n.fa-get-pocket:before {\\n  content: \\\"\\\\f265\\\";\\n}\\n.fa-wikipedia-w:before {\\n  content: \\\"\\\\f266\\\";\\n}\\n.fa-safari:before {\\n  content: \\\"\\\\f267\\\";\\n}\\n.fa-chrome:before {\\n  content: \\\"\\\\f268\\\";\\n}\\n.fa-firefox:before {\\n  content: \\\"\\\\f269\\\";\\n}\\n.fa-opera:before {\\n  content: \\\"\\\\f26a\\\";\\n}\\n.fa-internet-explorer:before {\\n  content: \\\"\\\\f26b\\\";\\n}\\n.fa-tv:before,\\n.fa-television:before {\\n  content: \\\"\\\\f26c\\\";\\n}\\n.fa-contao:before {\\n  content: \\\"\\\\f26d\\\";\\n}\\n.fa-500px:before {\\n  content: \\\"\\\\f26e\\\";\\n}\\n.fa-amazon:before {\\n  content: \\\"\\\\f270\\\";\\n}\\n.fa-calendar-plus-o:before {\\n  content: \\\"\\\\f271\\\";\\n}\\n.fa-calendar-minus-o:before {\\n  content: \\\"\\\\f272\\\";\\n}\\n.fa-calendar-times-o:before {\\n  content: \\\"\\\\f273\\\";\\n}\\n.fa-calendar-check-o:before {\\n  content: \\\"\\\\f274\\\";\\n}\\n.fa-industry:before {\\n  content: \\\"\\\\f275\\\";\\n}\\n.fa-map-pin:before {\\n  content: \\\"\\\\f276\\\";\\n}\\n.fa-map-signs:before {\\n  content: \\\"\\\\f277\\\";\\n}\\n.fa-map-o:before {\\n  content: \\\"\\\\f278\\\";\\n}\\n.fa-map:before {\\n  content: \\\"\\\\f279\\\";\\n}\\n.fa-commenting:before {\\n  content: \\\"\\\\f27a\\\";\\n}\\n.fa-commenting-o:before {\\n  content: \\\"\\\\f27b\\\";\\n}\\n.fa-houzz:before {\\n  content: \\\"\\\\f27c\\\";\\n}\\n.fa-vimeo:before {\\n  content: \\\"\\\\f27d\\\";\\n}\\n.fa-black-tie:before {\\n  content: \\\"\\\\f27e\\\";\\n}\\n.fa-fonticons:before {\\n  content: \\\"\\\\f280\\\";\\n}\\n.fa-reddit-alien:before {\\n  content: \\\"\\\\f281\\\";\\n}\\n.fa-edge:before {\\n  content: \\\"\\\\f282\\\";\\n}\\n.fa-credit-card-alt:before {\\n  content: \\\"\\\\f283\\\";\\n}\\n.fa-codiepie:before {\\n  content: \\\"\\\\f284\\\";\\n}\\n.fa-modx:before {\\n  content: \\\"\\\\f285\\\";\\n}\\n.fa-fort-awesome:before {\\n  content: \\\"\\\\f286\\\";\\n}\\n.fa-usb:before {\\n  content: \\\"\\\\f287\\\";\\n}\\n.fa-product-hunt:before {\\n  content: \\\"\\\\f288\\\";\\n}\\n.fa-mixcloud:before {\\n  content: \\\"\\\\f289\\\";\\n}\\n.fa-scribd:before {\\n  content: \\\"\\\\f28a\\\";\\n}\\n.fa-pause-circle:before {\\n  content: \\\"\\\\f28b\\\";\\n}\\n.fa-pause-circle-o:before {\\n  content: \\\"\\\\f28c\\\";\\n}\\n.fa-stop-circle:before {\\n  content: \\\"\\\\f28d\\\";\\n}\\n.fa-stop-circle-o:before {\\n  content: \\\"\\\\f28e\\\";\\n}\\n.fa-shopping-bag:before {\\n  content: \\\"\\\\f290\\\";\\n}\\n.fa-shopping-basket:before {\\n  content: \\\"\\\\f291\\\";\\n}\\n.fa-hashtag:before {\\n  content: \\\"\\\\f292\\\";\\n}\\n.fa-bluetooth:before {\\n  content: \\\"\\\\f293\\\";\\n}\\n.fa-bluetooth-b:before {\\n  content: \\\"\\\\f294\\\";\\n}\\n.fa-percent:before {\\n  content: \\\"\\\\f295\\\";\\n}\\n.fa-gitlab:before {\\n  content: \\\"\\\\f296\\\";\\n}\\n.fa-wpbeginner:before {\\n  content: \\\"\\\\f297\\\";\\n}\\n.fa-wpforms:before {\\n  content: \\\"\\\\f298\\\";\\n}\\n.fa-envira:before {\\n  content: \\\"\\\\f299\\\";\\n}\\n.fa-universal-access:before {\\n  content: \\\"\\\\f29a\\\";\\n}\\n.fa-wheelchair-alt:before {\\n  content: \\\"\\\\f29b\\\";\\n}\\n.fa-question-circle-o:before {\\n  content: \\\"\\\\f29c\\\";\\n}\\n.fa-blind:before {\\n  content: \\\"\\\\f29d\\\";\\n}\\n.fa-audio-description:before {\\n  content: \\\"\\\\f29e\\\";\\n}\\n.fa-volume-control-phone:before {\\n  content: \\\"\\\\f2a0\\\";\\n}\\n.fa-braille:before {\\n  content: \\\"\\\\f2a1\\\";\\n}\\n.fa-assistive-listening-systems:before {\\n  content: \\\"\\\\f2a2\\\";\\n}\\n.fa-asl-interpreting:before,\\n.fa-american-sign-language-interpreting:before {\\n  content: \\\"\\\\f2a3\\\";\\n}\\n.fa-deafness:before,\\n.fa-hard-of-hearing:before,\\n.fa-deaf:before {\\n  content: \\\"\\\\f2a4\\\";\\n}\\n.fa-glide:before {\\n  content: \\\"\\\\f2a5\\\";\\n}\\n.fa-glide-g:before {\\n  content: \\\"\\\\f2a6\\\";\\n}\\n.fa-signing:before,\\n.fa-sign-language:before {\\n  content: \\\"\\\\f2a7\\\";\\n}\\n.fa-low-vision:before {\\n  content: \\\"\\\\f2a8\\\";\\n}\\n.fa-viadeo:before {\\n  content: \\\"\\\\f2a9\\\";\\n}\\n.fa-viadeo-square:before {\\n  content: \\\"\\\\f2aa\\\";\\n}\\n.fa-snapchat:before {\\n  content: \\\"\\\\f2ab\\\";\\n}\\n.fa-snapchat-ghost:before {\\n  content: \\\"\\\\f2ac\\\";\\n}\\n.fa-snapchat-square:before {\\n  content: \\\"\\\\f2ad\\\";\\n}\\n.fa-pied-piper:before {\\n  content: \\\"\\\\f2ae\\\";\\n}\\n.fa-first-order:before {\\n  content: \\\"\\\\f2b0\\\";\\n}\\n.fa-yoast:before {\\n  content: \\\"\\\\f2b1\\\";\\n}\\n.fa-themeisle:before {\\n  content: \\\"\\\\f2b2\\\";\\n}\\n.fa-google-plus-circle:before,\\n.fa-google-plus-official:before {\\n  content: \\\"\\\\f2b3\\\";\\n}\\n.fa-fa:before,\\n.fa-font-awesome:before {\\n  content: \\\"\\\\f2b4\\\";\\n}\\n.fa-handshake-o:before {\\n  content: \\\"\\\\f2b5\\\";\\n}\\n.fa-envelope-open:before {\\n  content: \\\"\\\\f2b6\\\";\\n}\\n.fa-envelope-open-o:before {\\n  content: \\\"\\\\f2b7\\\";\\n}\\n.fa-linode:before {\\n  content: \\\"\\\\f2b8\\\";\\n}\\n.fa-address-book:before {\\n  content: \\\"\\\\f2b9\\\";\\n}\\n.fa-address-book-o:before {\\n  content: \\\"\\\\f2ba\\\";\\n}\\n.fa-vcard:before,\\n.fa-address-card:before {\\n  content: \\\"\\\\f2bb\\\";\\n}\\n.fa-vcard-o:before,\\n.fa-address-card-o:before {\\n  content: \\\"\\\\f2bc\\\";\\n}\\n.fa-user-circle:before {\\n  content: \\\"\\\\f2bd\\\";\\n}\\n.fa-user-circle-o:before {\\n  content: \\\"\\\\f2be\\\";\\n}\\n.fa-user-o:before {\\n  content: \\\"\\\\f2c0\\\";\\n}\\n.fa-id-badge:before {\\n  content: \\\"\\\\f2c1\\\";\\n}\\n.fa-drivers-license:before,\\n.fa-id-card:before {\\n  content: \\\"\\\\f2c2\\\";\\n}\\n.fa-drivers-license-o:before,\\n.fa-id-card-o:before {\\n  content: \\\"\\\\f2c3\\\";\\n}\\n.fa-quora:before {\\n  content: \\\"\\\\f2c4\\\";\\n}\\n.fa-free-code-camp:before {\\n  content: \\\"\\\\f2c5\\\";\\n}\\n.fa-telegram:before {\\n  content: \\\"\\\\f2c6\\\";\\n}\\n.fa-thermometer-4:before,\\n.fa-thermometer:before,\\n.fa-thermometer-full:before {\\n  content: \\\"\\\\f2c7\\\";\\n}\\n.fa-thermometer-3:before,\\n.fa-thermometer-three-quarters:before {\\n  content: \\\"\\\\f2c8\\\";\\n}\\n.fa-thermometer-2:before,\\n.fa-thermometer-half:before {\\n  content: \\\"\\\\f2c9\\\";\\n}\\n.fa-thermometer-1:before,\\n.fa-thermometer-quarter:before {\\n  content: \\\"\\\\f2ca\\\";\\n}\\n.fa-thermometer-0:before,\\n.fa-thermometer-empty:before {\\n  content: \\\"\\\\f2cb\\\";\\n}\\n.fa-shower:before {\\n  content: \\\"\\\\f2cc\\\";\\n}\\n.fa-bathtub:before,\\n.fa-s15:before,\\n.fa-bath:before {\\n  content: \\\"\\\\f2cd\\\";\\n}\\n.fa-podcast:before {\\n  content: \\\"\\\\f2ce\\\";\\n}\\n.fa-window-maximize:before {\\n  content: \\\"\\\\f2d0\\\";\\n}\\n.fa-window-minimize:before {\\n  content: \\\"\\\\f2d1\\\";\\n}\\n.fa-window-restore:before {\\n  content: \\\"\\\\f2d2\\\";\\n}\\n.fa-times-rectangle:before,\\n.fa-window-close:before {\\n  content: \\\"\\\\f2d3\\\";\\n}\\n.fa-times-rectangle-o:before,\\n.fa-window-close-o:before {\\n  content: \\\"\\\\f2d4\\\";\\n}\\n.fa-bandcamp:before {\\n  content: \\\"\\\\f2d5\\\";\\n}\\n.fa-grav:before {\\n  content: \\\"\\\\f2d6\\\";\\n}\\n.fa-etsy:before {\\n  content: \\\"\\\\f2d7\\\";\\n}\\n.fa-imdb:before {\\n  content: \\\"\\\\f2d8\\\";\\n}\\n.fa-ravelry:before {\\n  content: \\\"\\\\f2d9\\\";\\n}\\n.fa-eercast:before {\\n  content: \\\"\\\\f2da\\\";\\n}\\n.fa-microchip:before {\\n  content: \\\"\\\\f2db\\\";\\n}\\n.fa-snowflake-o:before {\\n  content: \\\"\\\\f2dc\\\";\\n}\\n.fa-superpowers:before {\\n  content: \\\"\\\\f2dd\\\";\\n}\\n.fa-wpexplorer:before {\\n  content: \\\"\\\\f2de\\\";\\n}\\n.fa-meetup:before {\\n  content: \\\"\\\\f2e0\\\";\\n}\\n.sr-only {\\n  position: absolute;\\n  width: 1px;\\n  height: 1px;\\n  padding: 0;\\n  margin: -1px;\\n  overflow: hidden;\\n  clip: rect(0, 0, 0, 0);\\n  border: 0;\\n}\\n.sr-only-focusable:active,\\n.sr-only-focusable:focus {\\n  position: static;\\n  width: auto;\\n  height: auto;\\n  margin: 0;\\n  overflow: visible;\\n  clip: auto;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"font-awesome.css\"],\"names\":[],\"mappings\":\"AAAA;;;EAGE;AACF;+BAC+B;AAC/B;EACE,0BAA0B;EAC1B,4CAAoD;EACpD,4SAAiX;EACjX,mBAAmB;EACnB,kBAAkB;AACpB;AACA;EACE,qBAAqB;EACrB,6CAA6C;EAC7C,kBAAkB;EAClB,oBAAoB;EACpB,mCAAmC;EACnC,kCAAkC;AACpC;AACA,6DAA6D;AAC7D;EACE,uBAAuB;EACvB,mBAAmB;EACnB,oBAAoB;AACtB;AACA;EACE,cAAc;AAChB;AACA;EACE,cAAc;AAChB;AACA;EACE,cAAc;AAChB;AACA;EACE,cAAc;AAChB;AACA;EACE,mBAAmB;EACnB,kBAAkB;AACpB;AACA;EACE,eAAe;EACf,yBAAyB;EACzB,qBAAqB;AACvB;AACA;EACE,kBAAkB;AACpB;AACA;EACE,kBAAkB;EAClB,mBAAmB;EACnB,mBAAmB;EACnB,iBAAiB;EACjB,kBAAkB;AACpB;AACA;EACE,mBAAmB;AACrB;AACA;EACE,yBAAyB;EACzB,4BAA4B;EAC5B,mBAAmB;AACrB;AACA;EACE,WAAW;AACb;AACA;EACE,YAAY;AACd;AACA;EACE,kBAAkB;AACpB;AACA;EACE,iBAAiB;AACnB;AACA,2BAA2B;AAC3B;EACE,YAAY;AACd;AACA;EACE,WAAW;AACb;AACA;EACE,kBAAkB;AACpB;AACA;EACE,iBAAiB;AACnB;AACA;EACE,6CAA6C;EAC7C,qCAAqC;AACvC;AACA;EACE,+CAA+C;EAC/C,uCAAuC;AACzC;AACA;EACE;IACE,+BAA+B;IAC/B,uBAAuB;EACzB;EACA;IACE,iCAAiC;IACjC,yBAAyB;EAC3B;AACF;AACA;EACE;IACE,+BAA+B;IAC/B,uBAAuB;EACzB;EACA;IACE,iCAAiC;IACjC,yBAAyB;EAC3B;AACF;AACA;EACE,sEAAsE;EACtE,gCAAgC;EAChC,4BAA4B;EAC5B,wBAAwB;AAC1B;AACA;EACE,sEAAsE;EACtE,iCAAiC;EACjC,6BAA6B;EAC7B,yBAAyB;AAC3B;AACA;EACE,sEAAsE;EACtE,iCAAiC;EACjC,6BAA6B;EAC7B,yBAAyB;AAC3B;AACA;EACE,gFAAgF;EAChF,+BAA+B;EAC/B,2BAA2B;EAC3B,uBAAuB;AACzB;AACA;EACE,gFAAgF;EAChF,+BAA+B;EAC/B,2BAA2B;EAC3B,uBAAuB;AACzB;AACA;;;;;EAKE,YAAY;AACd;AACA;EACE,kBAAkB;EAClB,qBAAqB;EACrB,UAAU;EACV,WAAW;EACX,gBAAgB;EAChB,sBAAsB;AACxB;AACA;;EAEE,kBAAkB;EAClB,OAAO;EACP,WAAW;EACX,kBAAkB;AACpB;AACA;EACE,oBAAoB;AACtB;AACA;EACE,cAAc;AAChB;AACA;EACE,cAAc;AAChB;AACA;mEACmE;AACnE;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;;EAGE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;;EAGE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;;EAGE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;;EAGE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;;;EAIE,gBAAgB;AAClB;AACA;;;EAGE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;;EAGE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;;EAGE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;;;;EAKE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;;EAGE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;;EAGE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;;EAGE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;;EAGE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;;EAGE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;;EAGE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;;EAGE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;;EAEE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,gBAAgB;AAClB;AACA;EACE,kBAAkB;EAClB,UAAU;EACV,WAAW;EACX,UAAU;EACV,YAAY;EACZ,gBAAgB;EAChB,sBAAsB;EACtB,SAAS;AACX;AACA;;EAEE,gBAAgB;EAChB,WAAW;EACX,YAAY;EACZ,SAAS;EACT,iBAAiB;EACjB,UAAU;AACZ\",\"file\":\"font-awesome.css\",\"sourcesContent\":[\"/*!\\n *  Font Awesome 4.7.0 by @davegandy - http://fontawesome.io - @fontawesome\\n *  License - http://fontawesome.io/license (Font: SIL OFL 1.1, CSS: MIT License)\\n */\\n/* FONT PATH\\n * -------------------------- */\\n@font-face {\\n  font-family: 'FontAwesome';\\n  src: url('../fonts/fontawesome-webfont.eot?v=4.7.0');\\n  src: url('../fonts/fontawesome-webfont.eot?#iefix&v=4.7.0') format('embedded-opentype'), url('../fonts/fontawesome-webfont.woff2?v=4.7.0') format('woff2'), url('../fonts/fontawesome-webfont.woff?v=4.7.0') format('woff'), url('../fonts/fontawesome-webfont.ttf?v=4.7.0') format('truetype'), url('../fonts/fontawesome-webfont.svg?v=4.7.0#fontawesomeregular') format('svg');\\n  font-weight: normal;\\n  font-style: normal;\\n}\\n.fa {\\n  display: inline-block;\\n  font: normal normal normal 14px/1 FontAwesome;\\n  font-size: inherit;\\n  text-rendering: auto;\\n  -webkit-font-smoothing: antialiased;\\n  -moz-osx-font-smoothing: grayscale;\\n}\\n/* makes the font 33% larger relative to the icon container */\\n.fa-lg {\\n  font-size: 1.33333333em;\\n  line-height: 0.75em;\\n  vertical-align: -15%;\\n}\\n.fa-2x {\\n  font-size: 2em;\\n}\\n.fa-3x {\\n  font-size: 3em;\\n}\\n.fa-4x {\\n  font-size: 4em;\\n}\\n.fa-5x {\\n  font-size: 5em;\\n}\\n.fa-fw {\\n  width: 1.28571429em;\\n  text-align: center;\\n}\\n.fa-ul {\\n  padding-left: 0;\\n  margin-left: 2.14285714em;\\n  list-style-type: none;\\n}\\n.fa-ul > li {\\n  position: relative;\\n}\\n.fa-li {\\n  position: absolute;\\n  left: -2.14285714em;\\n  width: 2.14285714em;\\n  top: 0.14285714em;\\n  text-align: center;\\n}\\n.fa-li.fa-lg {\\n  left: -1.85714286em;\\n}\\n.fa-border {\\n  padding: .2em .25em .15em;\\n  border: solid 0.08em #eeeeee;\\n  border-radius: .1em;\\n}\\n.fa-pull-left {\\n  float: left;\\n}\\n.fa-pull-right {\\n  float: right;\\n}\\n.fa.fa-pull-left {\\n  margin-right: .3em;\\n}\\n.fa.fa-pull-right {\\n  margin-left: .3em;\\n}\\n/* Deprecated as of 4.4.0 */\\n.pull-right {\\n  float: right;\\n}\\n.pull-left {\\n  float: left;\\n}\\n.fa.pull-left {\\n  margin-right: .3em;\\n}\\n.fa.pull-right {\\n  margin-left: .3em;\\n}\\n.fa-spin {\\n  -webkit-animation: fa-spin 2s infinite linear;\\n  animation: fa-spin 2s infinite linear;\\n}\\n.fa-pulse {\\n  -webkit-animation: fa-spin 1s infinite steps(8);\\n  animation: fa-spin 1s infinite steps(8);\\n}\\n@-webkit-keyframes fa-spin {\\n  0% {\\n    -webkit-transform: rotate(0deg);\\n    transform: rotate(0deg);\\n  }\\n  100% {\\n    -webkit-transform: rotate(359deg);\\n    transform: rotate(359deg);\\n  }\\n}\\n@keyframes fa-spin {\\n  0% {\\n    -webkit-transform: rotate(0deg);\\n    transform: rotate(0deg);\\n  }\\n  100% {\\n    -webkit-transform: rotate(359deg);\\n    transform: rotate(359deg);\\n  }\\n}\\n.fa-rotate-90 {\\n  -ms-filter: \\\"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)\\\";\\n  -webkit-transform: rotate(90deg);\\n  -ms-transform: rotate(90deg);\\n  transform: rotate(90deg);\\n}\\n.fa-rotate-180 {\\n  -ms-filter: \\\"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)\\\";\\n  -webkit-transform: rotate(180deg);\\n  -ms-transform: rotate(180deg);\\n  transform: rotate(180deg);\\n}\\n.fa-rotate-270 {\\n  -ms-filter: \\\"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)\\\";\\n  -webkit-transform: rotate(270deg);\\n  -ms-transform: rotate(270deg);\\n  transform: rotate(270deg);\\n}\\n.fa-flip-horizontal {\\n  -ms-filter: \\\"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)\\\";\\n  -webkit-transform: scale(-1, 1);\\n  -ms-transform: scale(-1, 1);\\n  transform: scale(-1, 1);\\n}\\n.fa-flip-vertical {\\n  -ms-filter: \\\"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)\\\";\\n  -webkit-transform: scale(1, -1);\\n  -ms-transform: scale(1, -1);\\n  transform: scale(1, -1);\\n}\\n:root .fa-rotate-90,\\n:root .fa-rotate-180,\\n:root .fa-rotate-270,\\n:root .fa-flip-horizontal,\\n:root .fa-flip-vertical {\\n  filter: none;\\n}\\n.fa-stack {\\n  position: relative;\\n  display: inline-block;\\n  width: 2em;\\n  height: 2em;\\n  line-height: 2em;\\n  vertical-align: middle;\\n}\\n.fa-stack-1x,\\n.fa-stack-2x {\\n  position: absolute;\\n  left: 0;\\n  width: 100%;\\n  text-align: center;\\n}\\n.fa-stack-1x {\\n  line-height: inherit;\\n}\\n.fa-stack-2x {\\n  font-size: 2em;\\n}\\n.fa-inverse {\\n  color: #ffffff;\\n}\\n/* Font Awesome uses the Unicode Private Use Area (PUA) to ensure screen\\n   readers do not read off random characters that represent icons */\\n.fa-glass:before {\\n  content: \\\"\\\\f000\\\";\\n}\\n.fa-music:before {\\n  content: \\\"\\\\f001\\\";\\n}\\n.fa-search:before {\\n  content: \\\"\\\\f002\\\";\\n}\\n.fa-envelope-o:before {\\n  content: \\\"\\\\f003\\\";\\n}\\n.fa-heart:before {\\n  content: \\\"\\\\f004\\\";\\n}\\n.fa-star:before {\\n  content: \\\"\\\\f005\\\";\\n}\\n.fa-star-o:before {\\n  content: \\\"\\\\f006\\\";\\n}\\n.fa-user:before {\\n  content: \\\"\\\\f007\\\";\\n}\\n.fa-film:before {\\n  content: \\\"\\\\f008\\\";\\n}\\n.fa-th-large:before {\\n  content: \\\"\\\\f009\\\";\\n}\\n.fa-th:before {\\n  content: \\\"\\\\f00a\\\";\\n}\\n.fa-th-list:before {\\n  content: \\\"\\\\f00b\\\";\\n}\\n.fa-check:before {\\n  content: \\\"\\\\f00c\\\";\\n}\\n.fa-remove:before,\\n.fa-close:before,\\n.fa-times:before {\\n  content: \\\"\\\\f00d\\\";\\n}\\n.fa-search-plus:before {\\n  content: \\\"\\\\f00e\\\";\\n}\\n.fa-search-minus:before {\\n  content: \\\"\\\\f010\\\";\\n}\\n.fa-power-off:before {\\n  content: \\\"\\\\f011\\\";\\n}\\n.fa-signal:before {\\n  content: \\\"\\\\f012\\\";\\n}\\n.fa-gear:before,\\n.fa-cog:before {\\n  content: \\\"\\\\f013\\\";\\n}\\n.fa-trash-o:before {\\n  content: \\\"\\\\f014\\\";\\n}\\n.fa-home:before {\\n  content: \\\"\\\\f015\\\";\\n}\\n.fa-file-o:before {\\n  content: \\\"\\\\f016\\\";\\n}\\n.fa-clock-o:before {\\n  content: \\\"\\\\f017\\\";\\n}\\n.fa-road:before {\\n  content: \\\"\\\\f018\\\";\\n}\\n.fa-download:before {\\n  content: \\\"\\\\f019\\\";\\n}\\n.fa-arrow-circle-o-down:before {\\n  content: \\\"\\\\f01a\\\";\\n}\\n.fa-arrow-circle-o-up:before {\\n  content: \\\"\\\\f01b\\\";\\n}\\n.fa-inbox:before {\\n  content: \\\"\\\\f01c\\\";\\n}\\n.fa-play-circle-o:before {\\n  content: \\\"\\\\f01d\\\";\\n}\\n.fa-rotate-right:before,\\n.fa-repeat:before {\\n  content: \\\"\\\\f01e\\\";\\n}\\n.fa-refresh:before {\\n  content: \\\"\\\\f021\\\";\\n}\\n.fa-list-alt:before {\\n  content: \\\"\\\\f022\\\";\\n}\\n.fa-lock:before {\\n  content: \\\"\\\\f023\\\";\\n}\\n.fa-flag:before {\\n  content: \\\"\\\\f024\\\";\\n}\\n.fa-headphones:before {\\n  content: \\\"\\\\f025\\\";\\n}\\n.fa-volume-off:before {\\n  content: \\\"\\\\f026\\\";\\n}\\n.fa-volume-down:before {\\n  content: \\\"\\\\f027\\\";\\n}\\n.fa-volume-up:before {\\n  content: \\\"\\\\f028\\\";\\n}\\n.fa-qrcode:before {\\n  content: \\\"\\\\f029\\\";\\n}\\n.fa-barcode:before {\\n  content: \\\"\\\\f02a\\\";\\n}\\n.fa-tag:before {\\n  content: \\\"\\\\f02b\\\";\\n}\\n.fa-tags:before {\\n  content: \\\"\\\\f02c\\\";\\n}\\n.fa-book:before {\\n  content: \\\"\\\\f02d\\\";\\n}\\n.fa-bookmark:before {\\n  content: \\\"\\\\f02e\\\";\\n}\\n.fa-print:before {\\n  content: \\\"\\\\f02f\\\";\\n}\\n.fa-camera:before {\\n  content: \\\"\\\\f030\\\";\\n}\\n.fa-font:before {\\n  content: \\\"\\\\f031\\\";\\n}\\n.fa-bold:before {\\n  content: \\\"\\\\f032\\\";\\n}\\n.fa-italic:before {\\n  content: \\\"\\\\f033\\\";\\n}\\n.fa-text-height:before {\\n  content: \\\"\\\\f034\\\";\\n}\\n.fa-text-width:before {\\n  content: \\\"\\\\f035\\\";\\n}\\n.fa-align-left:before {\\n  content: \\\"\\\\f036\\\";\\n}\\n.fa-align-center:before {\\n  content: \\\"\\\\f037\\\";\\n}\\n.fa-align-right:before {\\n  content: \\\"\\\\f038\\\";\\n}\\n.fa-align-justify:before {\\n  content: \\\"\\\\f039\\\";\\n}\\n.fa-list:before {\\n  content: \\\"\\\\f03a\\\";\\n}\\n.fa-dedent:before,\\n.fa-outdent:before {\\n  content: \\\"\\\\f03b\\\";\\n}\\n.fa-indent:before {\\n  content: \\\"\\\\f03c\\\";\\n}\\n.fa-video-camera:before {\\n  content: \\\"\\\\f03d\\\";\\n}\\n.fa-photo:before,\\n.fa-image:before,\\n.fa-picture-o:before {\\n  content: \\\"\\\\f03e\\\";\\n}\\n.fa-pencil:before {\\n  content: \\\"\\\\f040\\\";\\n}\\n.fa-map-marker:before {\\n  content: \\\"\\\\f041\\\";\\n}\\n.fa-adjust:before {\\n  content: \\\"\\\\f042\\\";\\n}\\n.fa-tint:before {\\n  content: \\\"\\\\f043\\\";\\n}\\n.fa-edit:before,\\n.fa-pencil-square-o:before {\\n  content: \\\"\\\\f044\\\";\\n}\\n.fa-share-square-o:before {\\n  content: \\\"\\\\f045\\\";\\n}\\n.fa-check-square-o:before {\\n  content: \\\"\\\\f046\\\";\\n}\\n.fa-arrows:before {\\n  content: \\\"\\\\f047\\\";\\n}\\n.fa-step-backward:before {\\n  content: \\\"\\\\f048\\\";\\n}\\n.fa-fast-backward:before {\\n  content: \\\"\\\\f049\\\";\\n}\\n.fa-backward:before {\\n  content: \\\"\\\\f04a\\\";\\n}\\n.fa-play:before {\\n  content: \\\"\\\\f04b\\\";\\n}\\n.fa-pause:before {\\n  content: \\\"\\\\f04c\\\";\\n}\\n.fa-stop:before {\\n  content: \\\"\\\\f04d\\\";\\n}\\n.fa-forward:before {\\n  content: \\\"\\\\f04e\\\";\\n}\\n.fa-fast-forward:before {\\n  content: \\\"\\\\f050\\\";\\n}\\n.fa-step-forward:before {\\n  content: \\\"\\\\f051\\\";\\n}\\n.fa-eject:before {\\n  content: \\\"\\\\f052\\\";\\n}\\n.fa-chevron-left:before {\\n  content: \\\"\\\\f053\\\";\\n}\\n.fa-chevron-right:before {\\n  content: \\\"\\\\f054\\\";\\n}\\n.fa-plus-circle:before {\\n  content: \\\"\\\\f055\\\";\\n}\\n.fa-minus-circle:before {\\n  content: \\\"\\\\f056\\\";\\n}\\n.fa-times-circle:before {\\n  content: \\\"\\\\f057\\\";\\n}\\n.fa-check-circle:before {\\n  content: \\\"\\\\f058\\\";\\n}\\n.fa-question-circle:before {\\n  content: \\\"\\\\f059\\\";\\n}\\n.fa-info-circle:before {\\n  content: \\\"\\\\f05a\\\";\\n}\\n.fa-crosshairs:before {\\n  content: \\\"\\\\f05b\\\";\\n}\\n.fa-times-circle-o:before {\\n  content: \\\"\\\\f05c\\\";\\n}\\n.fa-check-circle-o:before {\\n  content: \\\"\\\\f05d\\\";\\n}\\n.fa-ban:before {\\n  content: \\\"\\\\f05e\\\";\\n}\\n.fa-arrow-left:before {\\n  content: \\\"\\\\f060\\\";\\n}\\n.fa-arrow-right:before {\\n  content: \\\"\\\\f061\\\";\\n}\\n.fa-arrow-up:before {\\n  content: \\\"\\\\f062\\\";\\n}\\n.fa-arrow-down:before {\\n  content: \\\"\\\\f063\\\";\\n}\\n.fa-mail-forward:before,\\n.fa-share:before {\\n  content: \\\"\\\\f064\\\";\\n}\\n.fa-expand:before {\\n  content: \\\"\\\\f065\\\";\\n}\\n.fa-compress:before {\\n  content: \\\"\\\\f066\\\";\\n}\\n.fa-plus:before {\\n  content: \\\"\\\\f067\\\";\\n}\\n.fa-minus:before {\\n  content: \\\"\\\\f068\\\";\\n}\\n.fa-asterisk:before {\\n  content: \\\"\\\\f069\\\";\\n}\\n.fa-exclamation-circle:before {\\n  content: \\\"\\\\f06a\\\";\\n}\\n.fa-gift:before {\\n  content: \\\"\\\\f06b\\\";\\n}\\n.fa-leaf:before {\\n  content: \\\"\\\\f06c\\\";\\n}\\n.fa-fire:before {\\n  content: \\\"\\\\f06d\\\";\\n}\\n.fa-eye:before {\\n  content: \\\"\\\\f06e\\\";\\n}\\n.fa-eye-slash:before {\\n  content: \\\"\\\\f070\\\";\\n}\\n.fa-warning:before,\\n.fa-exclamation-triangle:before {\\n  content: \\\"\\\\f071\\\";\\n}\\n.fa-plane:before {\\n  content: \\\"\\\\f072\\\";\\n}\\n.fa-calendar:before {\\n  content: \\\"\\\\f073\\\";\\n}\\n.fa-random:before {\\n  content: \\\"\\\\f074\\\";\\n}\\n.fa-comment:before {\\n  content: \\\"\\\\f075\\\";\\n}\\n.fa-magnet:before {\\n  content: \\\"\\\\f076\\\";\\n}\\n.fa-chevron-up:before {\\n  content: \\\"\\\\f077\\\";\\n}\\n.fa-chevron-down:before {\\n  content: \\\"\\\\f078\\\";\\n}\\n.fa-retweet:before {\\n  content: \\\"\\\\f079\\\";\\n}\\n.fa-shopping-cart:before {\\n  content: \\\"\\\\f07a\\\";\\n}\\n.fa-folder:before {\\n  content: \\\"\\\\f07b\\\";\\n}\\n.fa-folder-open:before {\\n  content: \\\"\\\\f07c\\\";\\n}\\n.fa-arrows-v:before {\\n  content: \\\"\\\\f07d\\\";\\n}\\n.fa-arrows-h:before {\\n  content: \\\"\\\\f07e\\\";\\n}\\n.fa-bar-chart-o:before,\\n.fa-bar-chart:before {\\n  content: \\\"\\\\f080\\\";\\n}\\n.fa-twitter-square:before {\\n  content: \\\"\\\\f081\\\";\\n}\\n.fa-facebook-square:before {\\n  content: \\\"\\\\f082\\\";\\n}\\n.fa-camera-retro:before {\\n  content: \\\"\\\\f083\\\";\\n}\\n.fa-key:before {\\n  content: \\\"\\\\f084\\\";\\n}\\n.fa-gears:before,\\n.fa-cogs:before {\\n  content: \\\"\\\\f085\\\";\\n}\\n.fa-comments:before {\\n  content: \\\"\\\\f086\\\";\\n}\\n.fa-thumbs-o-up:before {\\n  content: \\\"\\\\f087\\\";\\n}\\n.fa-thumbs-o-down:before {\\n  content: \\\"\\\\f088\\\";\\n}\\n.fa-star-half:before {\\n  content: \\\"\\\\f089\\\";\\n}\\n.fa-heart-o:before {\\n  content: \\\"\\\\f08a\\\";\\n}\\n.fa-sign-out:before {\\n  content: \\\"\\\\f08b\\\";\\n}\\n.fa-linkedin-square:before {\\n  content: \\\"\\\\f08c\\\";\\n}\\n.fa-thumb-tack:before {\\n  content: \\\"\\\\f08d\\\";\\n}\\n.fa-external-link:before {\\n  content: \\\"\\\\f08e\\\";\\n}\\n.fa-sign-in:before {\\n  content: \\\"\\\\f090\\\";\\n}\\n.fa-trophy:before {\\n  content: \\\"\\\\f091\\\";\\n}\\n.fa-github-square:before {\\n  content: \\\"\\\\f092\\\";\\n}\\n.fa-upload:before {\\n  content: \\\"\\\\f093\\\";\\n}\\n.fa-lemon-o:before {\\n  content: \\\"\\\\f094\\\";\\n}\\n.fa-phone:before {\\n  content: \\\"\\\\f095\\\";\\n}\\n.fa-square-o:before {\\n  content: \\\"\\\\f096\\\";\\n}\\n.fa-bookmark-o:before {\\n  content: \\\"\\\\f097\\\";\\n}\\n.fa-phone-square:before {\\n  content: \\\"\\\\f098\\\";\\n}\\n.fa-twitter:before {\\n  content: \\\"\\\\f099\\\";\\n}\\n.fa-facebook-f:before,\\n.fa-facebook:before {\\n  content: \\\"\\\\f09a\\\";\\n}\\n.fa-github:before {\\n  content: \\\"\\\\f09b\\\";\\n}\\n.fa-unlock:before {\\n  content: \\\"\\\\f09c\\\";\\n}\\n.fa-credit-card:before {\\n  content: \\\"\\\\f09d\\\";\\n}\\n.fa-feed:before,\\n.fa-rss:before {\\n  content: \\\"\\\\f09e\\\";\\n}\\n.fa-hdd-o:before {\\n  content: \\\"\\\\f0a0\\\";\\n}\\n.fa-bullhorn:before {\\n  content: \\\"\\\\f0a1\\\";\\n}\\n.fa-bell:before {\\n  content: \\\"\\\\f0f3\\\";\\n}\\n.fa-certificate:before {\\n  content: \\\"\\\\f0a3\\\";\\n}\\n.fa-hand-o-right:before {\\n  content: \\\"\\\\f0a4\\\";\\n}\\n.fa-hand-o-left:before {\\n  content: \\\"\\\\f0a5\\\";\\n}\\n.fa-hand-o-up:before {\\n  content: \\\"\\\\f0a6\\\";\\n}\\n.fa-hand-o-down:before {\\n  content: \\\"\\\\f0a7\\\";\\n}\\n.fa-arrow-circle-left:before {\\n  content: \\\"\\\\f0a8\\\";\\n}\\n.fa-arrow-circle-right:before {\\n  content: \\\"\\\\f0a9\\\";\\n}\\n.fa-arrow-circle-up:before {\\n  content: \\\"\\\\f0aa\\\";\\n}\\n.fa-arrow-circle-down:before {\\n  content: \\\"\\\\f0ab\\\";\\n}\\n.fa-globe:before {\\n  content: \\\"\\\\f0ac\\\";\\n}\\n.fa-wrench:before {\\n  content: \\\"\\\\f0ad\\\";\\n}\\n.fa-tasks:before {\\n  content: \\\"\\\\f0ae\\\";\\n}\\n.fa-filter:before {\\n  content: \\\"\\\\f0b0\\\";\\n}\\n.fa-briefcase:before {\\n  content: \\\"\\\\f0b1\\\";\\n}\\n.fa-arrows-alt:before {\\n  content: \\\"\\\\f0b2\\\";\\n}\\n.fa-group:before,\\n.fa-users:before {\\n  content: \\\"\\\\f0c0\\\";\\n}\\n.fa-chain:before,\\n.fa-link:before {\\n  content: \\\"\\\\f0c1\\\";\\n}\\n.fa-cloud:before {\\n  content: \\\"\\\\f0c2\\\";\\n}\\n.fa-flask:before {\\n  content: \\\"\\\\f0c3\\\";\\n}\\n.fa-cut:before,\\n.fa-scissors:before {\\n  content: \\\"\\\\f0c4\\\";\\n}\\n.fa-copy:before,\\n.fa-files-o:before {\\n  content: \\\"\\\\f0c5\\\";\\n}\\n.fa-paperclip:before {\\n  content: \\\"\\\\f0c6\\\";\\n}\\n.fa-save:before,\\n.fa-floppy-o:before {\\n  content: \\\"\\\\f0c7\\\";\\n}\\n.fa-square:before {\\n  content: \\\"\\\\f0c8\\\";\\n}\\n.fa-navicon:before,\\n.fa-reorder:before,\\n.fa-bars:before {\\n  content: \\\"\\\\f0c9\\\";\\n}\\n.fa-list-ul:before {\\n  content: \\\"\\\\f0ca\\\";\\n}\\n.fa-list-ol:before {\\n  content: \\\"\\\\f0cb\\\";\\n}\\n.fa-strikethrough:before {\\n  content: \\\"\\\\f0cc\\\";\\n}\\n.fa-underline:before {\\n  content: \\\"\\\\f0cd\\\";\\n}\\n.fa-table:before {\\n  content: \\\"\\\\f0ce\\\";\\n}\\n.fa-magic:before {\\n  content: \\\"\\\\f0d0\\\";\\n}\\n.fa-truck:before {\\n  content: \\\"\\\\f0d1\\\";\\n}\\n.fa-pinterest:before {\\n  content: \\\"\\\\f0d2\\\";\\n}\\n.fa-pinterest-square:before {\\n  content: \\\"\\\\f0d3\\\";\\n}\\n.fa-google-plus-square:before {\\n  content: \\\"\\\\f0d4\\\";\\n}\\n.fa-google-plus:before {\\n  content: \\\"\\\\f0d5\\\";\\n}\\n.fa-money:before {\\n  content: \\\"\\\\f0d6\\\";\\n}\\n.fa-caret-down:before {\\n  content: \\\"\\\\f0d7\\\";\\n}\\n.fa-caret-up:before {\\n  content: \\\"\\\\f0d8\\\";\\n}\\n.fa-caret-left:before {\\n  content: \\\"\\\\f0d9\\\";\\n}\\n.fa-caret-right:before {\\n  content: \\\"\\\\f0da\\\";\\n}\\n.fa-columns:before {\\n  content: \\\"\\\\f0db\\\";\\n}\\n.fa-unsorted:before,\\n.fa-sort:before {\\n  content: \\\"\\\\f0dc\\\";\\n}\\n.fa-sort-down:before,\\n.fa-sort-desc:before {\\n  content: \\\"\\\\f0dd\\\";\\n}\\n.fa-sort-up:before,\\n.fa-sort-asc:before {\\n  content: \\\"\\\\f0de\\\";\\n}\\n.fa-envelope:before {\\n  content: \\\"\\\\f0e0\\\";\\n}\\n.fa-linkedin:before {\\n  content: \\\"\\\\f0e1\\\";\\n}\\n.fa-rotate-left:before,\\n.fa-undo:before {\\n  content: \\\"\\\\f0e2\\\";\\n}\\n.fa-legal:before,\\n.fa-gavel:before {\\n  content: \\\"\\\\f0e3\\\";\\n}\\n.fa-dashboard:before,\\n.fa-tachometer:before {\\n  content: \\\"\\\\f0e4\\\";\\n}\\n.fa-comment-o:before {\\n  content: \\\"\\\\f0e5\\\";\\n}\\n.fa-comments-o:before {\\n  content: \\\"\\\\f0e6\\\";\\n}\\n.fa-flash:before,\\n.fa-bolt:before {\\n  content: \\\"\\\\f0e7\\\";\\n}\\n.fa-sitemap:before {\\n  content: \\\"\\\\f0e8\\\";\\n}\\n.fa-umbrella:before {\\n  content: \\\"\\\\f0e9\\\";\\n}\\n.fa-paste:before,\\n.fa-clipboard:before {\\n  content: \\\"\\\\f0ea\\\";\\n}\\n.fa-lightbulb-o:before {\\n  content: \\\"\\\\f0eb\\\";\\n}\\n.fa-exchange:before {\\n  content: \\\"\\\\f0ec\\\";\\n}\\n.fa-cloud-download:before {\\n  content: \\\"\\\\f0ed\\\";\\n}\\n.fa-cloud-upload:before {\\n  content: \\\"\\\\f0ee\\\";\\n}\\n.fa-user-md:before {\\n  content: \\\"\\\\f0f0\\\";\\n}\\n.fa-stethoscope:before {\\n  content: \\\"\\\\f0f1\\\";\\n}\\n.fa-suitcase:before {\\n  content: \\\"\\\\f0f2\\\";\\n}\\n.fa-bell-o:before {\\n  content: \\\"\\\\f0a2\\\";\\n}\\n.fa-coffee:before {\\n  content: \\\"\\\\f0f4\\\";\\n}\\n.fa-cutlery:before {\\n  content: \\\"\\\\f0f5\\\";\\n}\\n.fa-file-text-o:before {\\n  content: \\\"\\\\f0f6\\\";\\n}\\n.fa-building-o:before {\\n  content: \\\"\\\\f0f7\\\";\\n}\\n.fa-hospital-o:before {\\n  content: \\\"\\\\f0f8\\\";\\n}\\n.fa-ambulance:before {\\n  content: \\\"\\\\f0f9\\\";\\n}\\n.fa-medkit:before {\\n  content: \\\"\\\\f0fa\\\";\\n}\\n.fa-fighter-jet:before {\\n  content: \\\"\\\\f0fb\\\";\\n}\\n.fa-beer:before {\\n  content: \\\"\\\\f0fc\\\";\\n}\\n.fa-h-square:before {\\n  content: \\\"\\\\f0fd\\\";\\n}\\n.fa-plus-square:before {\\n  content: \\\"\\\\f0fe\\\";\\n}\\n.fa-angle-double-left:before {\\n  content: \\\"\\\\f100\\\";\\n}\\n.fa-angle-double-right:before {\\n  content: \\\"\\\\f101\\\";\\n}\\n.fa-angle-double-up:before {\\n  content: \\\"\\\\f102\\\";\\n}\\n.fa-angle-double-down:before {\\n  content: \\\"\\\\f103\\\";\\n}\\n.fa-angle-left:before {\\n  content: \\\"\\\\f104\\\";\\n}\\n.fa-angle-right:before {\\n  content: \\\"\\\\f105\\\";\\n}\\n.fa-angle-up:before {\\n  content: \\\"\\\\f106\\\";\\n}\\n.fa-angle-down:before {\\n  content: \\\"\\\\f107\\\";\\n}\\n.fa-desktop:before {\\n  content: \\\"\\\\f108\\\";\\n}\\n.fa-laptop:before {\\n  content: \\\"\\\\f109\\\";\\n}\\n.fa-tablet:before {\\n  content: \\\"\\\\f10a\\\";\\n}\\n.fa-mobile-phone:before,\\n.fa-mobile:before {\\n  content: \\\"\\\\f10b\\\";\\n}\\n.fa-circle-o:before {\\n  content: \\\"\\\\f10c\\\";\\n}\\n.fa-quote-left:before {\\n  content: \\\"\\\\f10d\\\";\\n}\\n.fa-quote-right:before {\\n  content: \\\"\\\\f10e\\\";\\n}\\n.fa-spinner:before {\\n  content: \\\"\\\\f110\\\";\\n}\\n.fa-circle:before {\\n  content: \\\"\\\\f111\\\";\\n}\\n.fa-mail-reply:before,\\n.fa-reply:before {\\n  content: \\\"\\\\f112\\\";\\n}\\n.fa-github-alt:before {\\n  content: \\\"\\\\f113\\\";\\n}\\n.fa-folder-o:before {\\n  content: \\\"\\\\f114\\\";\\n}\\n.fa-folder-open-o:before {\\n  content: \\\"\\\\f115\\\";\\n}\\n.fa-smile-o:before {\\n  content: \\\"\\\\f118\\\";\\n}\\n.fa-frown-o:before {\\n  content: \\\"\\\\f119\\\";\\n}\\n.fa-meh-o:before {\\n  content: \\\"\\\\f11a\\\";\\n}\\n.fa-gamepad:before {\\n  content: \\\"\\\\f11b\\\";\\n}\\n.fa-keyboard-o:before {\\n  content: \\\"\\\\f11c\\\";\\n}\\n.fa-flag-o:before {\\n  content: \\\"\\\\f11d\\\";\\n}\\n.fa-flag-checkered:before {\\n  content: \\\"\\\\f11e\\\";\\n}\\n.fa-terminal:before {\\n  content: \\\"\\\\f120\\\";\\n}\\n.fa-code:before {\\n  content: \\\"\\\\f121\\\";\\n}\\n.fa-mail-reply-all:before,\\n.fa-reply-all:before {\\n  content: \\\"\\\\f122\\\";\\n}\\n.fa-star-half-empty:before,\\n.fa-star-half-full:before,\\n.fa-star-half-o:before {\\n  content: \\\"\\\\f123\\\";\\n}\\n.fa-location-arrow:before {\\n  content: \\\"\\\\f124\\\";\\n}\\n.fa-crop:before {\\n  content: \\\"\\\\f125\\\";\\n}\\n.fa-code-fork:before {\\n  content: \\\"\\\\f126\\\";\\n}\\n.fa-unlink:before,\\n.fa-chain-broken:before {\\n  content: \\\"\\\\f127\\\";\\n}\\n.fa-question:before {\\n  content: \\\"\\\\f128\\\";\\n}\\n.fa-info:before {\\n  content: \\\"\\\\f129\\\";\\n}\\n.fa-exclamation:before {\\n  content: \\\"\\\\f12a\\\";\\n}\\n.fa-superscript:before {\\n  content: \\\"\\\\f12b\\\";\\n}\\n.fa-subscript:before {\\n  content: \\\"\\\\f12c\\\";\\n}\\n.fa-eraser:before {\\n  content: \\\"\\\\f12d\\\";\\n}\\n.fa-puzzle-piece:before {\\n  content: \\\"\\\\f12e\\\";\\n}\\n.fa-microphone:before {\\n  content: \\\"\\\\f130\\\";\\n}\\n.fa-microphone-slash:before {\\n  content: \\\"\\\\f131\\\";\\n}\\n.fa-shield:before {\\n  content: \\\"\\\\f132\\\";\\n}\\n.fa-calendar-o:before {\\n  content: \\\"\\\\f133\\\";\\n}\\n.fa-fire-extinguisher:before {\\n  content: \\\"\\\\f134\\\";\\n}\\n.fa-rocket:before {\\n  content: \\\"\\\\f135\\\";\\n}\\n.fa-maxcdn:before {\\n  content: \\\"\\\\f136\\\";\\n}\\n.fa-chevron-circle-left:before {\\n  content: \\\"\\\\f137\\\";\\n}\\n.fa-chevron-circle-right:before {\\n  content: \\\"\\\\f138\\\";\\n}\\n.fa-chevron-circle-up:before {\\n  content: \\\"\\\\f139\\\";\\n}\\n.fa-chevron-circle-down:before {\\n  content: \\\"\\\\f13a\\\";\\n}\\n.fa-html5:before {\\n  content: \\\"\\\\f13b\\\";\\n}\\n.fa-css3:before {\\n  content: \\\"\\\\f13c\\\";\\n}\\n.fa-anchor:before {\\n  content: \\\"\\\\f13d\\\";\\n}\\n.fa-unlock-alt:before {\\n  content: \\\"\\\\f13e\\\";\\n}\\n.fa-bullseye:before {\\n  content: \\\"\\\\f140\\\";\\n}\\n.fa-ellipsis-h:before {\\n  content: \\\"\\\\f141\\\";\\n}\\n.fa-ellipsis-v:before {\\n  content: \\\"\\\\f142\\\";\\n}\\n.fa-rss-square:before {\\n  content: \\\"\\\\f143\\\";\\n}\\n.fa-play-circle:before {\\n  content: \\\"\\\\f144\\\";\\n}\\n.fa-ticket:before {\\n  content: \\\"\\\\f145\\\";\\n}\\n.fa-minus-square:before {\\n  content: \\\"\\\\f146\\\";\\n}\\n.fa-minus-square-o:before {\\n  content: \\\"\\\\f147\\\";\\n}\\n.fa-level-up:before {\\n  content: \\\"\\\\f148\\\";\\n}\\n.fa-level-down:before {\\n  content: \\\"\\\\f149\\\";\\n}\\n.fa-check-square:before {\\n  content: \\\"\\\\f14a\\\";\\n}\\n.fa-pencil-square:before {\\n  content: \\\"\\\\f14b\\\";\\n}\\n.fa-external-link-square:before {\\n  content: \\\"\\\\f14c\\\";\\n}\\n.fa-share-square:before {\\n  content: \\\"\\\\f14d\\\";\\n}\\n.fa-compass:before {\\n  content: \\\"\\\\f14e\\\";\\n}\\n.fa-toggle-down:before,\\n.fa-caret-square-o-down:before {\\n  content: \\\"\\\\f150\\\";\\n}\\n.fa-toggle-up:before,\\n.fa-caret-square-o-up:before {\\n  content: \\\"\\\\f151\\\";\\n}\\n.fa-toggle-right:before,\\n.fa-caret-square-o-right:before {\\n  content: \\\"\\\\f152\\\";\\n}\\n.fa-euro:before,\\n.fa-eur:before {\\n  content: \\\"\\\\f153\\\";\\n}\\n.fa-gbp:before {\\n  content: \\\"\\\\f154\\\";\\n}\\n.fa-dollar:before,\\n.fa-usd:before {\\n  content: \\\"\\\\f155\\\";\\n}\\n.fa-rupee:before,\\n.fa-inr:before {\\n  content: \\\"\\\\f156\\\";\\n}\\n.fa-cny:before,\\n.fa-rmb:before,\\n.fa-yen:before,\\n.fa-jpy:before {\\n  content: \\\"\\\\f157\\\";\\n}\\n.fa-ruble:before,\\n.fa-rouble:before,\\n.fa-rub:before {\\n  content: \\\"\\\\f158\\\";\\n}\\n.fa-won:before,\\n.fa-krw:before {\\n  content: \\\"\\\\f159\\\";\\n}\\n.fa-bitcoin:before,\\n.fa-btc:before {\\n  content: \\\"\\\\f15a\\\";\\n}\\n.fa-file:before {\\n  content: \\\"\\\\f15b\\\";\\n}\\n.fa-file-text:before {\\n  content: \\\"\\\\f15c\\\";\\n}\\n.fa-sort-alpha-asc:before {\\n  content: \\\"\\\\f15d\\\";\\n}\\n.fa-sort-alpha-desc:before {\\n  content: \\\"\\\\f15e\\\";\\n}\\n.fa-sort-amount-asc:before {\\n  content: \\\"\\\\f160\\\";\\n}\\n.fa-sort-amount-desc:before {\\n  content: \\\"\\\\f161\\\";\\n}\\n.fa-sort-numeric-asc:before {\\n  content: \\\"\\\\f162\\\";\\n}\\n.fa-sort-numeric-desc:before {\\n  content: \\\"\\\\f163\\\";\\n}\\n.fa-thumbs-up:before {\\n  content: \\\"\\\\f164\\\";\\n}\\n.fa-thumbs-down:before {\\n  content: \\\"\\\\f165\\\";\\n}\\n.fa-youtube-square:before {\\n  content: \\\"\\\\f166\\\";\\n}\\n.fa-youtube:before {\\n  content: \\\"\\\\f167\\\";\\n}\\n.fa-xing:before {\\n  content: \\\"\\\\f168\\\";\\n}\\n.fa-xing-square:before {\\n  content: \\\"\\\\f169\\\";\\n}\\n.fa-youtube-play:before {\\n  content: \\\"\\\\f16a\\\";\\n}\\n.fa-dropbox:before {\\n  content: \\\"\\\\f16b\\\";\\n}\\n.fa-stack-overflow:before {\\n  content: \\\"\\\\f16c\\\";\\n}\\n.fa-instagram:before {\\n  content: \\\"\\\\f16d\\\";\\n}\\n.fa-flickr:before {\\n  content: \\\"\\\\f16e\\\";\\n}\\n.fa-adn:before {\\n  content: \\\"\\\\f170\\\";\\n}\\n.fa-bitbucket:before {\\n  content: \\\"\\\\f171\\\";\\n}\\n.fa-bitbucket-square:before {\\n  content: \\\"\\\\f172\\\";\\n}\\n.fa-tumblr:before {\\n  content: \\\"\\\\f173\\\";\\n}\\n.fa-tumblr-square:before {\\n  content: \\\"\\\\f174\\\";\\n}\\n.fa-long-arrow-down:before {\\n  content: \\\"\\\\f175\\\";\\n}\\n.fa-long-arrow-up:before {\\n  content: \\\"\\\\f176\\\";\\n}\\n.fa-long-arrow-left:before {\\n  content: \\\"\\\\f177\\\";\\n}\\n.fa-long-arrow-right:before {\\n  content: \\\"\\\\f178\\\";\\n}\\n.fa-apple:before {\\n  content: \\\"\\\\f179\\\";\\n}\\n.fa-windows:before {\\n  content: \\\"\\\\f17a\\\";\\n}\\n.fa-android:before {\\n  content: \\\"\\\\f17b\\\";\\n}\\n.fa-linux:before {\\n  content: \\\"\\\\f17c\\\";\\n}\\n.fa-dribbble:before {\\n  content: \\\"\\\\f17d\\\";\\n}\\n.fa-skype:before {\\n  content: \\\"\\\\f17e\\\";\\n}\\n.fa-foursquare:before {\\n  content: \\\"\\\\f180\\\";\\n}\\n.fa-trello:before {\\n  content: \\\"\\\\f181\\\";\\n}\\n.fa-female:before {\\n  content: \\\"\\\\f182\\\";\\n}\\n.fa-male:before {\\n  content: \\\"\\\\f183\\\";\\n}\\n.fa-gittip:before,\\n.fa-gratipay:before {\\n  content: \\\"\\\\f184\\\";\\n}\\n.fa-sun-o:before {\\n  content: \\\"\\\\f185\\\";\\n}\\n.fa-moon-o:before {\\n  content: \\\"\\\\f186\\\";\\n}\\n.fa-archive:before {\\n  content: \\\"\\\\f187\\\";\\n}\\n.fa-bug:before {\\n  content: \\\"\\\\f188\\\";\\n}\\n.fa-vk:before {\\n  content: \\\"\\\\f189\\\";\\n}\\n.fa-weibo:before {\\n  content: \\\"\\\\f18a\\\";\\n}\\n.fa-renren:before {\\n  content: \\\"\\\\f18b\\\";\\n}\\n.fa-pagelines:before {\\n  content: \\\"\\\\f18c\\\";\\n}\\n.fa-stack-exchange:before {\\n  content: \\\"\\\\f18d\\\";\\n}\\n.fa-arrow-circle-o-right:before {\\n  content: \\\"\\\\f18e\\\";\\n}\\n.fa-arrow-circle-o-left:before {\\n  content: \\\"\\\\f190\\\";\\n}\\n.fa-toggle-left:before,\\n.fa-caret-square-o-left:before {\\n  content: \\\"\\\\f191\\\";\\n}\\n.fa-dot-circle-o:before {\\n  content: \\\"\\\\f192\\\";\\n}\\n.fa-wheelchair:before {\\n  content: \\\"\\\\f193\\\";\\n}\\n.fa-vimeo-square:before {\\n  content: \\\"\\\\f194\\\";\\n}\\n.fa-turkish-lira:before,\\n.fa-try:before {\\n  content: \\\"\\\\f195\\\";\\n}\\n.fa-plus-square-o:before {\\n  content: \\\"\\\\f196\\\";\\n}\\n.fa-space-shuttle:before {\\n  content: \\\"\\\\f197\\\";\\n}\\n.fa-slack:before {\\n  content: \\\"\\\\f198\\\";\\n}\\n.fa-envelope-square:before {\\n  content: \\\"\\\\f199\\\";\\n}\\n.fa-wordpress:before {\\n  content: \\\"\\\\f19a\\\";\\n}\\n.fa-openid:before {\\n  content: \\\"\\\\f19b\\\";\\n}\\n.fa-institution:before,\\n.fa-bank:before,\\n.fa-university:before {\\n  content: \\\"\\\\f19c\\\";\\n}\\n.fa-mortar-board:before,\\n.fa-graduation-cap:before {\\n  content: \\\"\\\\f19d\\\";\\n}\\n.fa-yahoo:before {\\n  content: \\\"\\\\f19e\\\";\\n}\\n.fa-google:before {\\n  content: \\\"\\\\f1a0\\\";\\n}\\n.fa-reddit:before {\\n  content: \\\"\\\\f1a1\\\";\\n}\\n.fa-reddit-square:before {\\n  content: \\\"\\\\f1a2\\\";\\n}\\n.fa-stumbleupon-circle:before {\\n  content: \\\"\\\\f1a3\\\";\\n}\\n.fa-stumbleupon:before {\\n  content: \\\"\\\\f1a4\\\";\\n}\\n.fa-delicious:before {\\n  content: \\\"\\\\f1a5\\\";\\n}\\n.fa-digg:before {\\n  content: \\\"\\\\f1a6\\\";\\n}\\n.fa-pied-piper-pp:before {\\n  content: \\\"\\\\f1a7\\\";\\n}\\n.fa-pied-piper-alt:before {\\n  content: \\\"\\\\f1a8\\\";\\n}\\n.fa-drupal:before {\\n  content: \\\"\\\\f1a9\\\";\\n}\\n.fa-joomla:before {\\n  content: \\\"\\\\f1aa\\\";\\n}\\n.fa-language:before {\\n  content: \\\"\\\\f1ab\\\";\\n}\\n.fa-fax:before {\\n  content: \\\"\\\\f1ac\\\";\\n}\\n.fa-building:before {\\n  content: \\\"\\\\f1ad\\\";\\n}\\n.fa-child:before {\\n  content: \\\"\\\\f1ae\\\";\\n}\\n.fa-paw:before {\\n  content: \\\"\\\\f1b0\\\";\\n}\\n.fa-spoon:before {\\n  content: \\\"\\\\f1b1\\\";\\n}\\n.fa-cube:before {\\n  content: \\\"\\\\f1b2\\\";\\n}\\n.fa-cubes:before {\\n  content: \\\"\\\\f1b3\\\";\\n}\\n.fa-behance:before {\\n  content: \\\"\\\\f1b4\\\";\\n}\\n.fa-behance-square:before {\\n  content: \\\"\\\\f1b5\\\";\\n}\\n.fa-steam:before {\\n  content: \\\"\\\\f1b6\\\";\\n}\\n.fa-steam-square:before {\\n  content: \\\"\\\\f1b7\\\";\\n}\\n.fa-recycle:before {\\n  content: \\\"\\\\f1b8\\\";\\n}\\n.fa-automobile:before,\\n.fa-car:before {\\n  content: \\\"\\\\f1b9\\\";\\n}\\n.fa-cab:before,\\n.fa-taxi:before {\\n  content: \\\"\\\\f1ba\\\";\\n}\\n.fa-tree:before {\\n  content: \\\"\\\\f1bb\\\";\\n}\\n.fa-spotify:before {\\n  content: \\\"\\\\f1bc\\\";\\n}\\n.fa-deviantart:before {\\n  content: \\\"\\\\f1bd\\\";\\n}\\n.fa-soundcloud:before {\\n  content: \\\"\\\\f1be\\\";\\n}\\n.fa-database:before {\\n  content: \\\"\\\\f1c0\\\";\\n}\\n.fa-file-pdf-o:before {\\n  content: \\\"\\\\f1c1\\\";\\n}\\n.fa-file-word-o:before {\\n  content: \\\"\\\\f1c2\\\";\\n}\\n.fa-file-excel-o:before {\\n  content: \\\"\\\\f1c3\\\";\\n}\\n.fa-file-powerpoint-o:before {\\n  content: \\\"\\\\f1c4\\\";\\n}\\n.fa-file-photo-o:before,\\n.fa-file-picture-o:before,\\n.fa-file-image-o:before {\\n  content: \\\"\\\\f1c5\\\";\\n}\\n.fa-file-zip-o:before,\\n.fa-file-archive-o:before {\\n  content: \\\"\\\\f1c6\\\";\\n}\\n.fa-file-sound-o:before,\\n.fa-file-audio-o:before {\\n  content: \\\"\\\\f1c7\\\";\\n}\\n.fa-file-movie-o:before,\\n.fa-file-video-o:before {\\n  content: \\\"\\\\f1c8\\\";\\n}\\n.fa-file-code-o:before {\\n  content: \\\"\\\\f1c9\\\";\\n}\\n.fa-vine:before {\\n  content: \\\"\\\\f1ca\\\";\\n}\\n.fa-codepen:before {\\n  content: \\\"\\\\f1cb\\\";\\n}\\n.fa-jsfiddle:before {\\n  content: \\\"\\\\f1cc\\\";\\n}\\n.fa-life-bouy:before,\\n.fa-life-buoy:before,\\n.fa-life-saver:before,\\n.fa-support:before,\\n.fa-life-ring:before {\\n  content: \\\"\\\\f1cd\\\";\\n}\\n.fa-circle-o-notch:before {\\n  content: \\\"\\\\f1ce\\\";\\n}\\n.fa-ra:before,\\n.fa-resistance:before,\\n.fa-rebel:before {\\n  content: \\\"\\\\f1d0\\\";\\n}\\n.fa-ge:before,\\n.fa-empire:before {\\n  content: \\\"\\\\f1d1\\\";\\n}\\n.fa-git-square:before {\\n  content: \\\"\\\\f1d2\\\";\\n}\\n.fa-git:before {\\n  content: \\\"\\\\f1d3\\\";\\n}\\n.fa-y-combinator-square:before,\\n.fa-yc-square:before,\\n.fa-hacker-news:before {\\n  content: \\\"\\\\f1d4\\\";\\n}\\n.fa-tencent-weibo:before {\\n  content: \\\"\\\\f1d5\\\";\\n}\\n.fa-qq:before {\\n  content: \\\"\\\\f1d6\\\";\\n}\\n.fa-wechat:before,\\n.fa-weixin:before {\\n  content: \\\"\\\\f1d7\\\";\\n}\\n.fa-send:before,\\n.fa-paper-plane:before {\\n  content: \\\"\\\\f1d8\\\";\\n}\\n.fa-send-o:before,\\n.fa-paper-plane-o:before {\\n  content: \\\"\\\\f1d9\\\";\\n}\\n.fa-history:before {\\n  content: \\\"\\\\f1da\\\";\\n}\\n.fa-circle-thin:before {\\n  content: \\\"\\\\f1db\\\";\\n}\\n.fa-header:before {\\n  content: \\\"\\\\f1dc\\\";\\n}\\n.fa-paragraph:before {\\n  content: \\\"\\\\f1dd\\\";\\n}\\n.fa-sliders:before {\\n  content: \\\"\\\\f1de\\\";\\n}\\n.fa-share-alt:before {\\n  content: \\\"\\\\f1e0\\\";\\n}\\n.fa-share-alt-square:before {\\n  content: \\\"\\\\f1e1\\\";\\n}\\n.fa-bomb:before {\\n  content: \\\"\\\\f1e2\\\";\\n}\\n.fa-soccer-ball-o:before,\\n.fa-futbol-o:before {\\n  content: \\\"\\\\f1e3\\\";\\n}\\n.fa-tty:before {\\n  content: \\\"\\\\f1e4\\\";\\n}\\n.fa-binoculars:before {\\n  content: \\\"\\\\f1e5\\\";\\n}\\n.fa-plug:before {\\n  content: \\\"\\\\f1e6\\\";\\n}\\n.fa-slideshare:before {\\n  content: \\\"\\\\f1e7\\\";\\n}\\n.fa-twitch:before {\\n  content: \\\"\\\\f1e8\\\";\\n}\\n.fa-yelp:before {\\n  content: \\\"\\\\f1e9\\\";\\n}\\n.fa-newspaper-o:before {\\n  content: \\\"\\\\f1ea\\\";\\n}\\n.fa-wifi:before {\\n  content: \\\"\\\\f1eb\\\";\\n}\\n.fa-calculator:before {\\n  content: \\\"\\\\f1ec\\\";\\n}\\n.fa-paypal:before {\\n  content: \\\"\\\\f1ed\\\";\\n}\\n.fa-google-wallet:before {\\n  content: \\\"\\\\f1ee\\\";\\n}\\n.fa-cc-visa:before {\\n  content: \\\"\\\\f1f0\\\";\\n}\\n.fa-cc-mastercard:before {\\n  content: \\\"\\\\f1f1\\\";\\n}\\n.fa-cc-discover:before {\\n  content: \\\"\\\\f1f2\\\";\\n}\\n.fa-cc-amex:before {\\n  content: \\\"\\\\f1f3\\\";\\n}\\n.fa-cc-paypal:before {\\n  content: \\\"\\\\f1f4\\\";\\n}\\n.fa-cc-stripe:before {\\n  content: \\\"\\\\f1f5\\\";\\n}\\n.fa-bell-slash:before {\\n  content: \\\"\\\\f1f6\\\";\\n}\\n.fa-bell-slash-o:before {\\n  content: \\\"\\\\f1f7\\\";\\n}\\n.fa-trash:before {\\n  content: \\\"\\\\f1f8\\\";\\n}\\n.fa-copyright:before {\\n  content: \\\"\\\\f1f9\\\";\\n}\\n.fa-at:before {\\n  content: \\\"\\\\f1fa\\\";\\n}\\n.fa-eyedropper:before {\\n  content: \\\"\\\\f1fb\\\";\\n}\\n.fa-paint-brush:before {\\n  content: \\\"\\\\f1fc\\\";\\n}\\n.fa-birthday-cake:before {\\n  content: \\\"\\\\f1fd\\\";\\n}\\n.fa-area-chart:before {\\n  content: \\\"\\\\f1fe\\\";\\n}\\n.fa-pie-chart:before {\\n  content: \\\"\\\\f200\\\";\\n}\\n.fa-line-chart:before {\\n  content: \\\"\\\\f201\\\";\\n}\\n.fa-lastfm:before {\\n  content: \\\"\\\\f202\\\";\\n}\\n.fa-lastfm-square:before {\\n  content: \\\"\\\\f203\\\";\\n}\\n.fa-toggle-off:before {\\n  content: \\\"\\\\f204\\\";\\n}\\n.fa-toggle-on:before {\\n  content: \\\"\\\\f205\\\";\\n}\\n.fa-bicycle:before {\\n  content: \\\"\\\\f206\\\";\\n}\\n.fa-bus:before {\\n  content: \\\"\\\\f207\\\";\\n}\\n.fa-ioxhost:before {\\n  content: \\\"\\\\f208\\\";\\n}\\n.fa-angellist:before {\\n  content: \\\"\\\\f209\\\";\\n}\\n.fa-cc:before {\\n  content: \\\"\\\\f20a\\\";\\n}\\n.fa-shekel:before,\\n.fa-sheqel:before,\\n.fa-ils:before {\\n  content: \\\"\\\\f20b\\\";\\n}\\n.fa-meanpath:before {\\n  content: \\\"\\\\f20c\\\";\\n}\\n.fa-buysellads:before {\\n  content: \\\"\\\\f20d\\\";\\n}\\n.fa-connectdevelop:before {\\n  content: \\\"\\\\f20e\\\";\\n}\\n.fa-dashcube:before {\\n  content: \\\"\\\\f210\\\";\\n}\\n.fa-forumbee:before {\\n  content: \\\"\\\\f211\\\";\\n}\\n.fa-leanpub:before {\\n  content: \\\"\\\\f212\\\";\\n}\\n.fa-sellsy:before {\\n  content: \\\"\\\\f213\\\";\\n}\\n.fa-shirtsinbulk:before {\\n  content: \\\"\\\\f214\\\";\\n}\\n.fa-simplybuilt:before {\\n  content: \\\"\\\\f215\\\";\\n}\\n.fa-skyatlas:before {\\n  content: \\\"\\\\f216\\\";\\n}\\n.fa-cart-plus:before {\\n  content: \\\"\\\\f217\\\";\\n}\\n.fa-cart-arrow-down:before {\\n  content: \\\"\\\\f218\\\";\\n}\\n.fa-diamond:before {\\n  content: \\\"\\\\f219\\\";\\n}\\n.fa-ship:before {\\n  content: \\\"\\\\f21a\\\";\\n}\\n.fa-user-secret:before {\\n  content: \\\"\\\\f21b\\\";\\n}\\n.fa-motorcycle:before {\\n  content: \\\"\\\\f21c\\\";\\n}\\n.fa-street-view:before {\\n  content: \\\"\\\\f21d\\\";\\n}\\n.fa-heartbeat:before {\\n  content: \\\"\\\\f21e\\\";\\n}\\n.fa-venus:before {\\n  content: \\\"\\\\f221\\\";\\n}\\n.fa-mars:before {\\n  content: \\\"\\\\f222\\\";\\n}\\n.fa-mercury:before {\\n  content: \\\"\\\\f223\\\";\\n}\\n.fa-intersex:before,\\n.fa-transgender:before {\\n  content: \\\"\\\\f224\\\";\\n}\\n.fa-transgender-alt:before {\\n  content: \\\"\\\\f225\\\";\\n}\\n.fa-venus-double:before {\\n  content: \\\"\\\\f226\\\";\\n}\\n.fa-mars-double:before {\\n  content: \\\"\\\\f227\\\";\\n}\\n.fa-venus-mars:before {\\n  content: \\\"\\\\f228\\\";\\n}\\n.fa-mars-stroke:before {\\n  content: \\\"\\\\f229\\\";\\n}\\n.fa-mars-stroke-v:before {\\n  content: \\\"\\\\f22a\\\";\\n}\\n.fa-mars-stroke-h:before {\\n  content: \\\"\\\\f22b\\\";\\n}\\n.fa-neuter:before {\\n  content: \\\"\\\\f22c\\\";\\n}\\n.fa-genderless:before {\\n  content: \\\"\\\\f22d\\\";\\n}\\n.fa-facebook-official:before {\\n  content: \\\"\\\\f230\\\";\\n}\\n.fa-pinterest-p:before {\\n  content: \\\"\\\\f231\\\";\\n}\\n.fa-whatsapp:before {\\n  content: \\\"\\\\f232\\\";\\n}\\n.fa-server:before {\\n  content: \\\"\\\\f233\\\";\\n}\\n.fa-user-plus:before {\\n  content: \\\"\\\\f234\\\";\\n}\\n.fa-user-times:before {\\n  content: \\\"\\\\f235\\\";\\n}\\n.fa-hotel:before,\\n.fa-bed:before {\\n  content: \\\"\\\\f236\\\";\\n}\\n.fa-viacoin:before {\\n  content: \\\"\\\\f237\\\";\\n}\\n.fa-train:before {\\n  content: \\\"\\\\f238\\\";\\n}\\n.fa-subway:before {\\n  content: \\\"\\\\f239\\\";\\n}\\n.fa-medium:before {\\n  content: \\\"\\\\f23a\\\";\\n}\\n.fa-yc:before,\\n.fa-y-combinator:before {\\n  content: \\\"\\\\f23b\\\";\\n}\\n.fa-optin-monster:before {\\n  content: \\\"\\\\f23c\\\";\\n}\\n.fa-opencart:before {\\n  content: \\\"\\\\f23d\\\";\\n}\\n.fa-expeditedssl:before {\\n  content: \\\"\\\\f23e\\\";\\n}\\n.fa-battery-4:before,\\n.fa-battery:before,\\n.fa-battery-full:before {\\n  content: \\\"\\\\f240\\\";\\n}\\n.fa-battery-3:before,\\n.fa-battery-three-quarters:before {\\n  content: \\\"\\\\f241\\\";\\n}\\n.fa-battery-2:before,\\n.fa-battery-half:before {\\n  content: \\\"\\\\f242\\\";\\n}\\n.fa-battery-1:before,\\n.fa-battery-quarter:before {\\n  content: \\\"\\\\f243\\\";\\n}\\n.fa-battery-0:before,\\n.fa-battery-empty:before {\\n  content: \\\"\\\\f244\\\";\\n}\\n.fa-mouse-pointer:before {\\n  content: \\\"\\\\f245\\\";\\n}\\n.fa-i-cursor:before {\\n  content: \\\"\\\\f246\\\";\\n}\\n.fa-object-group:before {\\n  content: \\\"\\\\f247\\\";\\n}\\n.fa-object-ungroup:before {\\n  content: \\\"\\\\f248\\\";\\n}\\n.fa-sticky-note:before {\\n  content: \\\"\\\\f249\\\";\\n}\\n.fa-sticky-note-o:before {\\n  content: \\\"\\\\f24a\\\";\\n}\\n.fa-cc-jcb:before {\\n  content: \\\"\\\\f24b\\\";\\n}\\n.fa-cc-diners-club:before {\\n  content: \\\"\\\\f24c\\\";\\n}\\n.fa-clone:before {\\n  content: \\\"\\\\f24d\\\";\\n}\\n.fa-balance-scale:before {\\n  content: \\\"\\\\f24e\\\";\\n}\\n.fa-hourglass-o:before {\\n  content: \\\"\\\\f250\\\";\\n}\\n.fa-hourglass-1:before,\\n.fa-hourglass-start:before {\\n  content: \\\"\\\\f251\\\";\\n}\\n.fa-hourglass-2:before,\\n.fa-hourglass-half:before {\\n  content: \\\"\\\\f252\\\";\\n}\\n.fa-hourglass-3:before,\\n.fa-hourglass-end:before {\\n  content: \\\"\\\\f253\\\";\\n}\\n.fa-hourglass:before {\\n  content: \\\"\\\\f254\\\";\\n}\\n.fa-hand-grab-o:before,\\n.fa-hand-rock-o:before {\\n  content: \\\"\\\\f255\\\";\\n}\\n.fa-hand-stop-o:before,\\n.fa-hand-paper-o:before {\\n  content: \\\"\\\\f256\\\";\\n}\\n.fa-hand-scissors-o:before {\\n  content: \\\"\\\\f257\\\";\\n}\\n.fa-hand-lizard-o:before {\\n  content: \\\"\\\\f258\\\";\\n}\\n.fa-hand-spock-o:before {\\n  content: \\\"\\\\f259\\\";\\n}\\n.fa-hand-pointer-o:before {\\n  content: \\\"\\\\f25a\\\";\\n}\\n.fa-hand-peace-o:before {\\n  content: \\\"\\\\f25b\\\";\\n}\\n.fa-trademark:before {\\n  content: \\\"\\\\f25c\\\";\\n}\\n.fa-registered:before {\\n  content: \\\"\\\\f25d\\\";\\n}\\n.fa-creative-commons:before {\\n  content: \\\"\\\\f25e\\\";\\n}\\n.fa-gg:before {\\n  content: \\\"\\\\f260\\\";\\n}\\n.fa-gg-circle:before {\\n  content: \\\"\\\\f261\\\";\\n}\\n.fa-tripadvisor:before {\\n  content: \\\"\\\\f262\\\";\\n}\\n.fa-odnoklassniki:before {\\n  content: \\\"\\\\f263\\\";\\n}\\n.fa-odnoklassniki-square:before {\\n  content: \\\"\\\\f264\\\";\\n}\\n.fa-get-pocket:before {\\n  content: \\\"\\\\f265\\\";\\n}\\n.fa-wikipedia-w:before {\\n  content: \\\"\\\\f266\\\";\\n}\\n.fa-safari:before {\\n  content: \\\"\\\\f267\\\";\\n}\\n.fa-chrome:before {\\n  content: \\\"\\\\f268\\\";\\n}\\n.fa-firefox:before {\\n  content: \\\"\\\\f269\\\";\\n}\\n.fa-opera:before {\\n  content: \\\"\\\\f26a\\\";\\n}\\n.fa-internet-explorer:before {\\n  content: \\\"\\\\f26b\\\";\\n}\\n.fa-tv:before,\\n.fa-television:before {\\n  content: \\\"\\\\f26c\\\";\\n}\\n.fa-contao:before {\\n  content: \\\"\\\\f26d\\\";\\n}\\n.fa-500px:before {\\n  content: \\\"\\\\f26e\\\";\\n}\\n.fa-amazon:before {\\n  content: \\\"\\\\f270\\\";\\n}\\n.fa-calendar-plus-o:before {\\n  content: \\\"\\\\f271\\\";\\n}\\n.fa-calendar-minus-o:before {\\n  content: \\\"\\\\f272\\\";\\n}\\n.fa-calendar-times-o:before {\\n  content: \\\"\\\\f273\\\";\\n}\\n.fa-calendar-check-o:before {\\n  content: \\\"\\\\f274\\\";\\n}\\n.fa-industry:before {\\n  content: \\\"\\\\f275\\\";\\n}\\n.fa-map-pin:before {\\n  content: \\\"\\\\f276\\\";\\n}\\n.fa-map-signs:before {\\n  content: \\\"\\\\f277\\\";\\n}\\n.fa-map-o:before {\\n  content: \\\"\\\\f278\\\";\\n}\\n.fa-map:before {\\n  content: \\\"\\\\f279\\\";\\n}\\n.fa-commenting:before {\\n  content: \\\"\\\\f27a\\\";\\n}\\n.fa-commenting-o:before {\\n  content: \\\"\\\\f27b\\\";\\n}\\n.fa-houzz:before {\\n  content: \\\"\\\\f27c\\\";\\n}\\n.fa-vimeo:before {\\n  content: \\\"\\\\f27d\\\";\\n}\\n.fa-black-tie:before {\\n  content: \\\"\\\\f27e\\\";\\n}\\n.fa-fonticons:before {\\n  content: \\\"\\\\f280\\\";\\n}\\n.fa-reddit-alien:before {\\n  content: \\\"\\\\f281\\\";\\n}\\n.fa-edge:before {\\n  content: \\\"\\\\f282\\\";\\n}\\n.fa-credit-card-alt:before {\\n  content: \\\"\\\\f283\\\";\\n}\\n.fa-codiepie:before {\\n  content: \\\"\\\\f284\\\";\\n}\\n.fa-modx:before {\\n  content: \\\"\\\\f285\\\";\\n}\\n.fa-fort-awesome:before {\\n  content: \\\"\\\\f286\\\";\\n}\\n.fa-usb:before {\\n  content: \\\"\\\\f287\\\";\\n}\\n.fa-product-hunt:before {\\n  content: \\\"\\\\f288\\\";\\n}\\n.fa-mixcloud:before {\\n  content: \\\"\\\\f289\\\";\\n}\\n.fa-scribd:before {\\n  content: \\\"\\\\f28a\\\";\\n}\\n.fa-pause-circle:before {\\n  content: \\\"\\\\f28b\\\";\\n}\\n.fa-pause-circle-o:before {\\n  content: \\\"\\\\f28c\\\";\\n}\\n.fa-stop-circle:before {\\n  content: \\\"\\\\f28d\\\";\\n}\\n.fa-stop-circle-o:before {\\n  content: \\\"\\\\f28e\\\";\\n}\\n.fa-shopping-bag:before {\\n  content: \\\"\\\\f290\\\";\\n}\\n.fa-shopping-basket:before {\\n  content: \\\"\\\\f291\\\";\\n}\\n.fa-hashtag:before {\\n  content: \\\"\\\\f292\\\";\\n}\\n.fa-bluetooth:before {\\n  content: \\\"\\\\f293\\\";\\n}\\n.fa-bluetooth-b:before {\\n  content: \\\"\\\\f294\\\";\\n}\\n.fa-percent:before {\\n  content: \\\"\\\\f295\\\";\\n}\\n.fa-gitlab:before {\\n  content: \\\"\\\\f296\\\";\\n}\\n.fa-wpbeginner:before {\\n  content: \\\"\\\\f297\\\";\\n}\\n.fa-wpforms:before {\\n  content: \\\"\\\\f298\\\";\\n}\\n.fa-envira:before {\\n  content: \\\"\\\\f299\\\";\\n}\\n.fa-universal-access:before {\\n  content: \\\"\\\\f29a\\\";\\n}\\n.fa-wheelchair-alt:before {\\n  content: \\\"\\\\f29b\\\";\\n}\\n.fa-question-circle-o:before {\\n  content: \\\"\\\\f29c\\\";\\n}\\n.fa-blind:before {\\n  content: \\\"\\\\f29d\\\";\\n}\\n.fa-audio-description:before {\\n  content: \\\"\\\\f29e\\\";\\n}\\n.fa-volume-control-phone:before {\\n  content: \\\"\\\\f2a0\\\";\\n}\\n.fa-braille:before {\\n  content: \\\"\\\\f2a1\\\";\\n}\\n.fa-assistive-listening-systems:before {\\n  content: \\\"\\\\f2a2\\\";\\n}\\n.fa-asl-interpreting:before,\\n.fa-american-sign-language-interpreting:before {\\n  content: \\\"\\\\f2a3\\\";\\n}\\n.fa-deafness:before,\\n.fa-hard-of-hearing:before,\\n.fa-deaf:before {\\n  content: \\\"\\\\f2a4\\\";\\n}\\n.fa-glide:before {\\n  content: \\\"\\\\f2a5\\\";\\n}\\n.fa-glide-g:before {\\n  content: \\\"\\\\f2a6\\\";\\n}\\n.fa-signing:before,\\n.fa-sign-language:before {\\n  content: \\\"\\\\f2a7\\\";\\n}\\n.fa-low-vision:before {\\n  content: \\\"\\\\f2a8\\\";\\n}\\n.fa-viadeo:before {\\n  content: \\\"\\\\f2a9\\\";\\n}\\n.fa-viadeo-square:before {\\n  content: \\\"\\\\f2aa\\\";\\n}\\n.fa-snapchat:before {\\n  content: \\\"\\\\f2ab\\\";\\n}\\n.fa-snapchat-ghost:before {\\n  content: \\\"\\\\f2ac\\\";\\n}\\n.fa-snapchat-square:before {\\n  content: \\\"\\\\f2ad\\\";\\n}\\n.fa-pied-piper:before {\\n  content: \\\"\\\\f2ae\\\";\\n}\\n.fa-first-order:before {\\n  content: \\\"\\\\f2b0\\\";\\n}\\n.fa-yoast:before {\\n  content: \\\"\\\\f2b1\\\";\\n}\\n.fa-themeisle:before {\\n  content: \\\"\\\\f2b2\\\";\\n}\\n.fa-google-plus-circle:before,\\n.fa-google-plus-official:before {\\n  content: \\\"\\\\f2b3\\\";\\n}\\n.fa-fa:before,\\n.fa-font-awesome:before {\\n  content: \\\"\\\\f2b4\\\";\\n}\\n.fa-handshake-o:before {\\n  content: \\\"\\\\f2b5\\\";\\n}\\n.fa-envelope-open:before {\\n  content: \\\"\\\\f2b6\\\";\\n}\\n.fa-envelope-open-o:before {\\n  content: \\\"\\\\f2b7\\\";\\n}\\n.fa-linode:before {\\n  content: \\\"\\\\f2b8\\\";\\n}\\n.fa-address-book:before {\\n  content: \\\"\\\\f2b9\\\";\\n}\\n.fa-address-book-o:before {\\n  content: \\\"\\\\f2ba\\\";\\n}\\n.fa-vcard:before,\\n.fa-address-card:before {\\n  content: \\\"\\\\f2bb\\\";\\n}\\n.fa-vcard-o:before,\\n.fa-address-card-o:before {\\n  content: \\\"\\\\f2bc\\\";\\n}\\n.fa-user-circle:before {\\n  content: \\\"\\\\f2bd\\\";\\n}\\n.fa-user-circle-o:before {\\n  content: \\\"\\\\f2be\\\";\\n}\\n.fa-user-o:before {\\n  content: \\\"\\\\f2c0\\\";\\n}\\n.fa-id-badge:before {\\n  content: \\\"\\\\f2c1\\\";\\n}\\n.fa-drivers-license:before,\\n.fa-id-card:before {\\n  content: \\\"\\\\f2c2\\\";\\n}\\n.fa-drivers-license-o:before,\\n.fa-id-card-o:before {\\n  content: \\\"\\\\f2c3\\\";\\n}\\n.fa-quora:before {\\n  content: \\\"\\\\f2c4\\\";\\n}\\n.fa-free-code-camp:before {\\n  content: \\\"\\\\f2c5\\\";\\n}\\n.fa-telegram:before {\\n  content: \\\"\\\\f2c6\\\";\\n}\\n.fa-thermometer-4:before,\\n.fa-thermometer:before,\\n.fa-thermometer-full:before {\\n  content: \\\"\\\\f2c7\\\";\\n}\\n.fa-thermometer-3:before,\\n.fa-thermometer-three-quarters:before {\\n  content: \\\"\\\\f2c8\\\";\\n}\\n.fa-thermometer-2:before,\\n.fa-thermometer-half:before {\\n  content: \\\"\\\\f2c9\\\";\\n}\\n.fa-thermometer-1:before,\\n.fa-thermometer-quarter:before {\\n  content: \\\"\\\\f2ca\\\";\\n}\\n.fa-thermometer-0:before,\\n.fa-thermometer-empty:before {\\n  content: \\\"\\\\f2cb\\\";\\n}\\n.fa-shower:before {\\n  content: \\\"\\\\f2cc\\\";\\n}\\n.fa-bathtub:before,\\n.fa-s15:before,\\n.fa-bath:before {\\n  content: \\\"\\\\f2cd\\\";\\n}\\n.fa-podcast:before {\\n  content: \\\"\\\\f2ce\\\";\\n}\\n.fa-window-maximize:before {\\n  content: \\\"\\\\f2d0\\\";\\n}\\n.fa-window-minimize:before {\\n  content: \\\"\\\\f2d1\\\";\\n}\\n.fa-window-restore:before {\\n  content: \\\"\\\\f2d2\\\";\\n}\\n.fa-times-rectangle:before,\\n.fa-window-close:before {\\n  content: \\\"\\\\f2d3\\\";\\n}\\n.fa-times-rectangle-o:before,\\n.fa-window-close-o:before {\\n  content: \\\"\\\\f2d4\\\";\\n}\\n.fa-bandcamp:before {\\n  content: \\\"\\\\f2d5\\\";\\n}\\n.fa-grav:before {\\n  content: \\\"\\\\f2d6\\\";\\n}\\n.fa-etsy:before {\\n  content: \\\"\\\\f2d7\\\";\\n}\\n.fa-imdb:before {\\n  content: \\\"\\\\f2d8\\\";\\n}\\n.fa-ravelry:before {\\n  content: \\\"\\\\f2d9\\\";\\n}\\n.fa-eercast:before {\\n  content: \\\"\\\\f2da\\\";\\n}\\n.fa-microchip:before {\\n  content: \\\"\\\\f2db\\\";\\n}\\n.fa-snowflake-o:before {\\n  content: \\\"\\\\f2dc\\\";\\n}\\n.fa-superpowers:before {\\n  content: \\\"\\\\f2dd\\\";\\n}\\n.fa-wpexplorer:before {\\n  content: \\\"\\\\f2de\\\";\\n}\\n.fa-meetup:before {\\n  content: \\\"\\\\f2e0\\\";\\n}\\n.sr-only {\\n  position: absolute;\\n  width: 1px;\\n  height: 1px;\\n  padding: 0;\\n  margin: -1px;\\n  overflow: hidden;\\n  clip: rect(0, 0, 0, 0);\\n  border: 0;\\n}\\n.sr-only-focusable:active,\\n.sr-only-focusable:focus {\\n  position: static;\\n  width: auto;\\n  height: auto;\\n  margin: 0;\\n  overflow: visible;\\n  clip: auto;\\n}\\n\"]}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// Imports\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../node_modules/css-loader/dist/runtime/api.js\";\nimport ___CSS_LOADER_GET_URL_IMPORT___ from \"../../../../node_modules/css-loader/dist/runtime/getUrl.js\";\nimport ___CSS_LOADER_URL_IMPORT_0___ from \"../images/layer_line.svg\";\nimport ___CSS_LOADER_URL_IMPORT_1___ from \"../images/layer_rect.svg\";\nimport ___CSS_LOADER_URL_IMPORT_2___ from \"../images/layer_circle.svg\";\nimport ___CSS_LOADER_URL_IMPORT_3___ from \"../images/layer_text.svg\";\nimport ___CSS_LOADER_URL_IMPORT_4___ from \"../images/layer_port.svg\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);\nvar ___CSS_LOADER_URL_REPLACEMENT_2___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_2___);\nvar ___CSS_LOADER_URL_REPLACEMENT_3___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_3___);\nvar ___CSS_LOADER_URL_REPLACEMENT_4___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_4___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".toolbar {\\n  margin: 0;\\n  padding-top: 0;\\n  padding-right: 10px;\\n  top: 0;\\n  right: 0;\\n  left: 220px;\\n  height: 60px;\\n  overflow: visible;\\n  z-index: 500 !important;\\n  position: absolute;\\n  background-color: #ebf0f5;\\n  border: none !important;\\n}\\n.toolbar * {\\n  outline: none;\\n}\\n.toolbar .group {\\n  padding-right: 20px;\\n  display: inline-block;\\n  vertical-align: top;\\n}\\n.toolbar .group .image-button {\\n  display: inline-block;\\n}\\n.toolbar .group .image-button img {\\n  margin: 5px;\\n  margin-bottom: 0;\\n  padding: 0;\\n  width: 40px;\\n  height: 40px;\\n  position: relative;\\n  display: inline-block;\\n  text-align: center;\\n  color: #777;\\n  font-size: 45px;\\n  transition: all 0.5s;\\n}\\n.toolbar .group .image-button .img_span {\\n  margin: 5px;\\n  margin-bottom: 0;\\n  padding: 0;\\n  width: 40px;\\n  height: 40px;\\n  position: relative;\\n  display: inline-block;\\n  text-align: center;\\n  color: #777;\\n  font-size: 45px;\\n  transition: all 0.5s;\\n}\\n.toolbar .group .image-button div {\\n  color: rgba(0, 0, 0, 0.5);\\n  text-align: center;\\n  font-size: 10px;\\n}\\n.toolbar .group .image-button.disabled {\\n  opacity: 0.2;\\n}\\n.toolbar .group .image-button:not(.disabled) img {\\n  cursor: pointer;\\n}\\n.toolbar .group .image-button:not(.disabled) img:hover {\\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);\\n}\\n.modal-backdrop.in {\\n  opacity: 0.7;\\n  background-color: black;\\n  transition: opacity 0.4s linear;\\n}\\n.genericDialog .modal-content {\\n  border-radius: 4px;\\n  box-shadow: 0 19px 38px rgba(0, 0, 0, 0.3), 0 15px 12px rgba(0, 0, 0, 0.22);\\n  background-color: #ffffff;\\n}\\n.genericDialog .modal-content .modal-header {\\n  border-bottom: 0;\\n  font-weight: 400;\\n  box-shadow: 0 3px 5px rgba(57, 63, 72, 0.3);\\n}\\n.genericDialog .modal-content .modal-body {\\n  padding: 1px;\\n  min-height: 120px;\\n}\\n.genericDialog .modal-content .modal-body .form-control {\\n  -webkit-appearance: none;\\n  -moz-appearance: none;\\n  appearance: none;\\n  box-sizing: border-box;\\n  border-radius: 4px;\\n  margin: 0;\\n  padding: 0;\\n  color: #4D4D4D;\\n  display: inline-block;\\n  font: inherit;\\n  border: 1px solid #DFDFDF;\\n  box-shadow: none;\\n  height: 24px;\\n  padding: 0 3px;\\n}\\n.genericDialog .modal-content .modal-body .form-control:focus {\\n  background-color: #f5f5f5;\\n}\\n.genericDialog .modal-content .modal-body .list-group {\\n  overflow-y: auto;\\n  overflow-x: auto;\\n}\\n.genericDialog .modal-content .modal-body .list-group *[data-draw2d=\\\"true\\\"] {\\n  font-weight: bold;\\n  color: #41aaaa;\\n}\\n.genericDialog .modal-content .modal-body .list-group .glyphicon,\\n.genericDialog .modal-content .modal-body .list-group .fa {\\n  font-size: 20px;\\n  padding-right: 10px;\\n  color: #41aaaa;\\n}\\n.genericDialog .modal-content .modal-body .list-group .list-group-item {\\n  background-color: transparent;\\n  font-weight: 300;\\n}\\n.genericDialog .modal-content .modal-body .list-group .list-group-item:hover {\\n  text-decoration: underline;\\n}\\n.genericDialog .modal-content .modal-body .list-group *[data-draw2d=\\\"false\\\"][data-type=\\\"file\\\"] {\\n  color: gray;\\n  cursor: default;\\n  text-decoration: none !important;\\n}\\n.genericDialog .modal-content .modal-body .list-group *[data-draw2d=\\\"false\\\"][data-type=\\\"file\\\"] .fa {\\n  color: gray;\\n}\\n.genericDialog .modal-content .modal-footer {\\n  background-color: transparent;\\n  border-top: 0;\\n}\\n.genericDialog .modal-content .modal-footer .btn {\\n  border: 0;\\n  text-transform: uppercase;\\n  background-color: transparent;\\n  color: #41aaaa;\\n  transition: all 0.5s;\\n}\\n.genericDialog .modal-content .modal-footer .btn:hover {\\n  background-color: rgba(65, 170, 170, 0.04);\\n  transition: all 0.5s;\\n}\\n.genericDialog .modal-content .modal-footer .btn-primary {\\n  font-weight: bold;\\n}\\n#fileOpenDialog .list-group {\\n  height: 60%;\\n}\\n#fileSaveDialog .filePreview {\\n  max-width: 200px;\\n  max-height: 200px;\\n}\\n#fileSaveDialog .modal-body .media {\\n  padding: 20px;\\n}\\n#githubFileSaveAsDialog .filePreview {\\n  max-width: 200px;\\n  max-height: 200px;\\n}\\n#githubFileSaveAsDialog .list-group {\\n  height: 250px;\\n}\\n#canvas_zoom {\\n  position: fixed;\\n  bottom: 20px;\\n  right: 270px;\\n  background-color: rgba(235, 240, 245, 0.3);\\n  border-radius: 5px;\\n}\\n#canvas_zoom button {\\n  background-color: transparent;\\n  font-weight: 300;\\n  padding: 5px;\\n  padding-left: 10px;\\n  padding-right: 10px;\\n  border: 1px solid transparent;\\n  outline: none;\\n  transition: all 0.5s;\\n}\\n#canvas_zoom button:hover {\\n  border: 1px solid #41aaaa;\\n}\\n/***BOOTSTRAP****/\\n.btn {\\n  border-radius: 0 !important;\\n}\\n.tooltip-inner {\\n  border-radius: 0 !important;\\n  padding: 10px !important;\\n  padding-top: 5px !important;\\n  padding-bottom: 5px !important;\\n  font-family: 'Roboto', sans-serif !important;\\n  font-weight: 300 !important;\\n  font-size: 14px !important;\\n  color: #b0b0b0 !important;\\n}\\n/********/\\nbody {\\n  overflow: hidden;\\n  font-family: 'Roboto', sans-serif !important;\\n  font-weight: 300;\\n}\\ninput {\\n  background: none repeat scroll 0 0 #f8f8f8;\\n  border-color: #C6C6C6 #DADADA #EAEAEA;\\n  border-radius: 4px 4px 4px 4px;\\n  -moz-box-sizing: border-box;\\n  padding-left: 7px;\\n  border-style: solid ;\\n  border-width: 1px;\\n  vertical-align: middle;\\n  height: 25px;\\n  font-size: 14px;\\n  line-height: 25px;\\n}\\n.input-block-level {\\n  display: block;\\n  width: 100%;\\n  min-height: 28px;\\n}\\n.control-label {\\n  font-family: 'Roboto', sans-serif;\\n  font-weight: 300;\\n}\\n/******************************************************************\\n * Einstellungen der PropertyViews im Editmodus der \\\"Form\\\".\\n ******************************************************************/\\n.palette_node_element {\\n  width: 48px;\\n  height: 48px;\\n  cursor: move;\\n  margin: 10px auto 10px auto;\\n}\\n.tooltip {\\n  z-index: 1000000;\\n}\\n/* Effects */\\n.overlay-scale {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 100%;\\n  z-index: 10000;\\n  visibility: hidden;\\n  opacity: 0;\\n  -webkit-transform: scale(0.9);\\n  transform: scale(0.9);\\n  -webkit-transition: all 0.4s;\\n  transition: all 0.4s;\\n}\\n.overlay-scale.open {\\n  visibility: visible;\\n  opacity: 1;\\n  -webkit-transform: scale(1);\\n  transform: scale(1);\\n  -webkit-transition: all 0.4s;\\n  transition: all 0.4s;\\n}\\n.readonly-highlight {\\n  background-color: rgba(50, 43, 168, 0.5);\\n  opacity: 0.2;\\n  color: darkblue;\\n  position: absolute;\\n}\\n#canvas {\\n  padding: 0;\\n  margin: 0;\\n  border: 0;\\n  position: absolute;\\n  top: 60px;\\n  right: 250px;\\n  left: 220px;\\n  bottom: 0;\\n  overflow: scroll;\\n  background-color: #FFFFFF;\\n}\\n#canvas_config {\\n  position: fixed;\\n  width: 40px;\\n  top: 65px;\\n  left: 225px;\\n  cursor: pointer;\\n  border: 1px solid transparent;\\n  background-color: rgba(235, 240, 245, 0.3);\\n}\\n#canvas_config:hover {\\n  border: 1px solid #41aaaa !important;\\n}\\n#canvas_config:hover {\\n  color: #41aaaa;\\n}\\n#canvas_config_items {\\n  position: fixed;\\n  top: 90px;\\n  left: 225px;\\n  cursor: pointer;\\n  padding: 10px;\\n  white-space: nowrap;\\n  min-width: 250px;\\n}\\n.layer-name-prompt .modal-title {\\n  font-weight: 100;\\n}\\n.layer-name-prompt .modal-footer {\\n  border: 0;\\n}\\n.layer-name-prompt .modal-header {\\n  border-bottom: 3px solid #41aaaa;\\n}\\n.layer-name-prompt input {\\n  outline: none !important;\\n  -webkit-box-shadow: inset !important;\\n  box-shadow: inset !important;\\n  background-color: rgba(0, 0, 0, 0.02) !important;\\n  border-radius: 1px !important;\\n}\\n.layer-name-prompt input:focus {\\n  border: 1px solid #41aaaa;\\n}\\n.layer-name-prompt .btn-primary {\\n  background-color: #41aaaa;\\n  border: 0;\\n}\\n.layer-name-prompt .btn-primary:hover {\\n  background-color: #338585;\\n}\\n#layer {\\n  padding: 0;\\n  margin: 0;\\n  border: 0;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  bottom: 0;\\n  width: 220px;\\n  background-color: #ffffff;\\n  text-align: center;\\n  box-shadow: 5px 0 20px -3px rgba(31, 73, 125, 0.3);\\n  z-index: 1;\\n}\\n#layer .title {\\n  left: 10px;\\n  right: 0px;\\n  top: 10px;\\n  position: absolute;\\n}\\n#layer .title img {\\n  padding-right: 20px;\\n  position: absolute;\\n  left: 10px;\\n  max-height: 28px;\\n}\\n#layer .title div {\\n  position: absolute;\\n  left: 90px;\\n}\\n#layer .title div h1 {\\n  font-size: 25px;\\n  font-weight: 200;\\n  line-height: 45px;\\n  margin: 0;\\n  padding: 0;\\n  text-align: left;\\n}\\n#layer .title div h2 {\\n  font-size: 15px;\\n  font-weight: 200;\\n  margin: 0;\\n  padding: 0;\\n  text-align: left;\\n}\\n#layer .panetitle {\\n  position: fixed;\\n  height: 30px;\\n  width: 220px;\\n  top: 60px;\\n  border-bottom: 1px solid #222222;\\n  font-weight: 500;\\n  font-size: 12px;\\n  padding: 4px 4px 4px 20px;\\n  letter-spacing: 5px;\\n  text-align: left;\\n  color: #41aaaa;\\n  box-shadow: 0 4px 2px -2px rgba(31, 73, 125, 0.3);\\n}\\n#layer #layer_elements {\\n  padding: 0;\\n  margin: 0;\\n  border: 0;\\n  position: fixed;\\n  top: 90px;\\n  left: 0;\\n  bottom: 0;\\n  width: 220px;\\n  overflow: auto;\\n}\\n#layer #layer_elements .layerElement {\\n  background-color: #fafafa;\\n  color: black;\\n  cursor: move;\\n  font-weight: 400;\\n  font-size: 12px;\\n  letter-spacing: 1px;\\n  padding: 4px 4px 4px 5px;\\n  text-align: left;\\n  border: 1px solid transparent;\\n  border-bottom: 1px solid #222222;\\n}\\n#layer #layer_elements .layerElement::before {\\n  content: \\\"\\\";\\n  display: block;\\n  width: 20px;\\n  height: 20px;\\n  float: left;\\n  margin-right: 5px;\\n}\\n#layer #layer_elements .layerElement.ExtLine::before {\\n  background: url(\" + ___CSS_LOADER_URL_REPLACEMENT_0___ + \") no-repeat;\\n  background-size: cover;\\n}\\n#layer #layer_elements .layerElement.PolyRect::before {\\n  background: url(\" + ___CSS_LOADER_URL_REPLACEMENT_1___ + \") no-repeat;\\n  background-size: cover;\\n}\\n#layer #layer_elements .layerElement.PolyCircle::before {\\n  background: url(\" + ___CSS_LOADER_URL_REPLACEMENT_2___ + \") no-repeat;\\n  background-size: cover;\\n}\\n#layer #layer_elements .layerElement.ExtLabel::before {\\n  background: url(\" + ___CSS_LOADER_URL_REPLACEMENT_3___ + \") no-repeat;\\n  background-size: cover;\\n}\\n#layer #layer_elements .layerElement.ExtPort::before {\\n  background: url(\" + ___CSS_LOADER_URL_REPLACEMENT_4___ + \") no-repeat;\\n  background-size: cover;\\n}\\n#layer #layer_elements .layerElement[data-visibility=\\\"false\\\"] {\\n  opacity: 0.5;\\n  font-style: italic;\\n}\\n#layer #layer_elements .layerElement .icon {\\n  cursor: pointer;\\n  padding-right: 4px;\\n  width: 20px;\\n  height: 20px;\\n}\\n#layer #layer_elements .layerElement .icon * {\\n  stroke: black !important;\\n}\\n#layer #layer_elements .layerElement .icon:hover * {\\n  stroke: #41aaaa !important;\\n}\\n#layer #layer_elements .layerSelectedElement {\\n  background-color: #f5f5f5;\\n  color: black;\\n  border-style: dotted;\\n  border-width: 1px;\\n  border-color: #41aaaa;\\n  font-weight: 600;\\n}\\n#code_overlay {\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  width: 100%;\\n  height: 100%;\\n  background-color: white;\\n  z-index: 10000;\\n}\\n#code_close {\\n  position: fixed;\\n  right: 40px;\\n  top: 10px;\\n  width: 32px;\\n  height: 32px;\\n  z-index: 10000;\\n  cursor: pointer;\\n  font-size: 50px;\\n}\\n#code_close:hover {\\n  color: #41aaaa;\\n}\\n#test_run {\\n  position: fixed;\\n  right: 90px;\\n  top: 10px;\\n  width: 32px;\\n  height: 32px;\\n  z-index: 10000;\\n  cursor: pointer;\\n  font-size: 50px;\\n}\\n#test_run:hover {\\n  color: #41aaaa;\\n}\\n#test_info {\\n  position: absolute;\\n  color: black;\\n  z-index: 20000;\\n  top: 20px;\\n  left: 20px;\\n  border: 1px solid lightgray;\\n  padding: 7px;\\n  background-color: white;\\n  border-radius: 2px;\\n}\\n#test_canvas {\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  width: 100%;\\n  height: 100%;\\n  background-color: white;\\n  z-index: 10000;\\n}\\n#test_close {\\n  position: fixed;\\n  right: 40px;\\n  top: 10px;\\n  width: 32px;\\n  height: 32px;\\n  z-index: 10000;\\n  cursor: pointer;\\n  font-size: 50px;\\n}\\n#test_close:hover {\\n  color: #41aaaa;\\n}\\n#test_clipboard {\\n  position: fixed;\\n  right: 100px;\\n  top: 10px;\\n  width: 32px;\\n  height: 32px;\\n  z-index: 10000;\\n  cursor: pointer;\\n  font-size: 50px;\\n}\\n#test_clipboard:hover {\\n  color: #41aaaa;\\n}\\n.portDirectionOption {\\n  height: 60px;\\n  text-align: center;\\n}\\n.portDirectionOption label > input {\\n  /* HIDE RADIO */\\n  display: none;\\n}\\n.portDirectionOption label > input + span {\\n  /* IMAGE STYLES */\\n  cursor: pointer;\\n  color: gray !important;\\n  padding-right: 5px;\\n}\\n.portDirectionOption label > input:checked + span {\\n  /* (CHECKED) IMAGE STYLES */\\n  color: #41aaaa !important;\\n}\\n.portTypeOption {\\n  height: 65px;\\n  padding-left: 60px;\\n}\\n.portTypeOption label > input {\\n  /* HIDE RADIO */\\n  display: none;\\n}\\n.portTypeOption label > input + span {\\n  /* IMAGE STYLES */\\n  cursor: pointer;\\n  color: gray !important;\\n  padding-right: 5px;\\n  font-weight: 100;\\n  font-size: 14px;\\n}\\n.portTypeOption label > input + span:before {\\n  padding-right: 10px;\\n}\\n.portTypeOption label > input:checked + span {\\n  /* (CHECKED) IMAGE STYLES */\\n  color: #41aaaa !important;\\n}\\n#filter {\\n  position: absolute;\\n  top: 60px;\\n  right: 0;\\n  bottom: 0;\\n  width: 250px;\\n  padding: 0;\\n  margin: 0;\\n  border-radius: 0;\\n  border: 0;\\n  background-color: #282a30;\\n}\\n#filter .filter_header {\\n  background: none repeat scroll 0 0 #303030;\\n  position: fixed;\\n  height: 30px;\\n  width: 250px;\\n  top: 60px;\\n  border-bottom: 1px solid #222222;\\n  border-top: 1px solid #111111;\\n  font-weight: 500;\\n  font-size: 12px;\\n  padding-top: 5px;\\n  letter-spacing: 5px;\\n  text-align: center;\\n  color: #41aaaa;\\n}\\n#filter .filter_toolbar {\\n  overflow: visible;\\n  border: 0;\\n  padding: 3px;\\n  padding-left: 10px;\\n  position: absolute;\\n  bottom: 0;\\n  right: 0;\\n  width: 250px;\\n  height: 30px;\\n  background: none repeat scroll 0 0 #303030;\\n}\\n#filter .filter_actions {\\n  position: fixed;\\n  top: 90px;\\n  bottom: 30px;\\n  width: 250px;\\n  border: 0;\\n  padding: 0;\\n  overflow-y: auto;\\n}\\n#filter .filter_actions .panel-body {\\n  padding: 7px;\\n  padding-top: 0;\\n}\\n#filter .filter_actions .form-group {\\n  margin-bottom: 2px !important;\\n}\\n#filter .filter_actions .form-group > .input-group {\\n  margin-bottom: 10px;\\n}\\n#filter .filter_actions .form-group > .input-group:last-child {\\n  margin-bottom: 0px;\\n}\\n#filter .filter_actions .icon {\\n  color: #26B4A8;\\n  padding: 0;\\n  top: -4px;\\n  color: rgba(255, 255, 255, 0.25);\\n}\\n#filter .filter_actions .icon:hover {\\n  color: #41aaaa;\\n}\\n#filter .filter_actions .filter-heading {\\n  color: #DDDDDD !important;\\n  font-size: 12px;\\n  padding-right: 10px !important;\\n  padding-top: 1px !important;\\n  padding-bottom: 0 !important;\\n  background-color: transparent !important;\\n  background-image: none !important;\\n  border: 0 !important;\\n  margin-top: 4px;\\n  cursor: pointer;\\n  font-weight: 300;\\n}\\n#filter .filter_actions .filter-heading .icon {\\n  width: 15px;\\n}\\n#filter .filter_actions .filter-heading .icon * {\\n  stroke: white !important;\\n}\\n#filter .form-control {\\n  height: 25px;\\n}\\n#filter .btn {\\n  padding-left: 5px;\\n  padding-right: 5px;\\n  padding-top: 1px;\\n  padding-bottom: 2px;\\n}\\n#filter .input-group-addon {\\n  padding: 0;\\n  padding-left: 5px;\\n  padding-right: 5px;\\n  color: rgba(0, 0, 0, 0.3);\\n  background-color: white;\\n  border-left: 0;\\n  border-radius: 0;\\n  font-weight: 100;\\n  text-transform: lowercase;\\n  font-size: 12px;\\n}\\n#filter .panel-default {\\n  margin: 0;\\n  border-radius: 0;\\n  background-color: rgba(65, 170, 170, 0.02);\\n  border: 0;\\n  border-top: 1px solid #303030;\\n  border-bottom: 1px solid #202525;\\n  margin-top: 3px;\\n}\\n#FigureMarkdownEdit .header {\\n  width: 100%;\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  display: inline-block;\\n  height: 60px;\\n  background-color: white;\\n  overflow: hidden;\\n}\\n#FigureMarkdownEdit .header .left {\\n  width: 50%;\\n  display: inline-block;\\n  height: 60px;\\n  font-size: 20px;\\n  padding: 6px;\\n  color: #CC4F5A;\\n  background-color: rgba(0, 0, 0, 0.1);\\n  vertical-align: top;\\n}\\n#FigureMarkdownEdit .header .left small {\\n  font-size: 16px;\\n}\\n#FigureMarkdownEdit .header .right {\\n  width: 50%;\\n  display: inline-block;\\n  height: 60px;\\n  font-size: 20px;\\n  padding: 6px;\\n  color: #CC4F5A;\\n  background-color: rgba(0, 0, 0, 0.05);\\n  vertical-align: top;\\n}\\n#FigureMarkdownEdit .source {\\n  width: 50%;\\n  display: inline-block;\\n  font-family: Menlo, Monaco, Consolas, \\\"Courier New\\\", monospace;\\n  font-size: 13px;\\n  padding: 2px;\\n  top: 60px;\\n  bottom: 0px;\\n  position: absolute;\\n}\\n#FigureMarkdownEdit .preview {\\n  width: 50%;\\n  display: inline-block;\\n  top: 0px;\\n  left: 50%;\\n  position: absolute;\\n  background-color: white;\\n  padding: 30px;\\n  overflow: auto;\\n  top: 60px;\\n  bottom: 0px;\\n}\\n#FigureMarkdownEdit .preview img {\\n  max-width: 35%;\\n}\\n#FigureMarkdownEdit .preview table {\\n  font-family: Arial, Helvetica, sans-serif;\\n  color: #666;\\n  font-size: 12px;\\n  text-shadow: 1px 1px 0px #fff;\\n  background: #eaebec;\\n  margin: 20px;\\n  margin-left: 0;\\n  border: #ccc 1px solid;\\n  -moz-border-radius: 3px;\\n  -webkit-border-radius: 3px;\\n  border-radius: 3px;\\n  -moz-box-shadow: 0 1px 2px #d1d1d1;\\n  -webkit-box-shadow: 0 1px 2px #d1d1d1;\\n  box-shadow: 0 1px 2px #d1d1d1;\\n}\\n#FigureMarkdownEdit .preview table th {\\n  padding: 21px 25px 22px 25px;\\n  border-top: 1px solid #fafafa;\\n  border-bottom: 1px solid #e0e0e0;\\n}\\n#FigureMarkdownEdit .preview table th:first-child {\\n  text-align: left;\\n  padding-left: 20px;\\n}\\n#FigureMarkdownEdit .preview table tr:first-child th:first-child {\\n  -moz-border-radius-topleft: 3px;\\n  -webkit-border-top-left-radius: 3px;\\n  border-top-left-radius: 3px;\\n}\\n#FigureMarkdownEdit .preview table tr:first-child th:last-child {\\n  -moz-border-radius-topright: 3px;\\n  -webkit-border-top-right-radius: 3px;\\n  border-top-right-radius: 3px;\\n}\\n#FigureMarkdownEdit .preview table tr {\\n  text-align: center;\\n  padding-left: 20px;\\n}\\n#FigureMarkdownEdit .preview table tr td:first-child {\\n  text-align: left;\\n  padding-left: 20px;\\n  border-left: 0;\\n}\\n#FigureMarkdownEdit .preview table tr td {\\n  padding: 18px;\\n  border-top: 1px solid #ffffff;\\n  border-bottom: 1px solid #e0e0e0;\\n  border-left: 1px solid #e0e0e0;\\n}\\n#FigureMarkdownEdit .preview tbody tr:nth-child(odd) {\\n  background: #fafafa;\\n}\\n#FigureMarkdownEdit .preview tbody tr:nth-child(even) {\\n  background: #f3f3f3;\\n}\\n#FigureMarkdownEdit .preview table tr:last-child td {\\n  border-bottom: 0;\\n}\\n#FigureMarkdownEdit .preview table tr:last-child td:first-child {\\n  -moz-border-radius-bottomleft: 3px;\\n  -webkit-border-bottom-left-radius: 3px;\\n  border-bottom-left-radius: 3px;\\n}\\n#FigureMarkdownEdit .preview table tr:last-child td:last-child {\\n  -moz-border-radius-bottomright: 3px;\\n  -webkit-border-bottom-right-radius: 3px;\\n  border-bottom-right-radius: 3px;\\n}\\n.ui-anglepicker {\\n  width: 52px;\\n  height: 52px;\\n  background: #dbdbdb;\\n  background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEgMSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkLXVjZ2ctZ2VuZXJhdGVkIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iI2RiZGJkYiIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjIwJSIgc3RvcC1jb2xvcj0iI2UxZTFkZSIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiNmOGY4ZjMiIHN0b3Atb3BhY2l0eT0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0idXJsKCNncmFkLXVjZ2ctZ2VuZXJhdGVkKSIgLz4KPC9zdmc+);\\n  background: -moz-linear-gradient(top, #dbdbdb 0%, #e1e1de 20%, #f8f8f3 100%);\\n  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #dbdbdb), color-stop(20%, #e1e1de), color-stop(100%, #f8f8f3));\\n  background: -webkit-linear-gradient(top, #dbdbdb 0%, #e1e1de 20%, #f8f8f3 100%);\\n  background: -o-linear-gradient(top, #dbdbdb 0%, #e1e1de 20%, #f8f8f3 100%);\\n  background: -ms-linear-gradient(top, #dbdbdb 0%, #e1e1de 20%, #f8f8f3 100%);\\n  background: linear-gradient(to bottom, #dbdbdb 0%, #e1e1de 20%, #f8f8f3 100%);\\n  border: 2px solid #666;\\n  -moz-box-shadow: inset 0 2px 3px white, inset 0 -1px 2px #fffef8;\\n  -webkit-box-shadow: inset 0 2px 3px white, inset 0 -1px 2px #fffef8;\\n  box-shadow: inset 0 2px 3px white, inset 0 -1px 2px #fffef8;\\n  -moz-border-radius: 50%;\\n  -webkit-border-radius: 50%;\\n  border-radius: 50%;\\n  position: relative;\\n  display: inline-block;\\n}\\n.ui-anglepicker-pointer {\\n  position: absolute;\\n  top: 50%;\\n  left: 50%;\\n  width: 50%;\\n  margin: -2px 0 0 -2px;\\n  -moz-transform-origin: 2px 2px;\\n  -webkit-transform-origin: 2px 2px;\\n  -ms-transform-origin: 2px 2px;\\n  -o-transform-origin: 2px 2px;\\n  transform-origin: 2px 2px;\\n}\\n.ui-anglepicker:hover,\\n.ui-anglepicker.ui-anglepicker-dragging {\\n  border-color: #494949;\\n}\\n.ui-anglepicker-dragging .ui-anglepicker-dot,\\n.ui-anglepicker-dragging .ui-anglepicker-line,\\n.ui-anglepicker:hover .ui-anglepicker-dot,\\n.ui-anglepicker:hover .ui-anglepicker-line {\\n  background: #494949;\\n}\\n.ui-anglepicker-dot {\\n  height: 4px;\\n  width: 4px;\\n  position: absolute;\\n  background: #838383;\\n  -moz-border-radius: 50%;\\n  -webkit-border-radius: 50%;\\n  border-radius: 50%;\\n}\\n.ui-anglepicker-line {\\n  margin-top: 1.5px;\\n  margin-right: -2px;\\n  height: 1px;\\n  background: #838383;\\n}\\n#tool_shape.open .dropdown-menu {\\n  -webkit-transform: scale(1, 1);\\n  opacity: 1;\\n  transform: scale(1, 1);\\n}\\n#tool_shape .dropdown-menu {\\n  opacity: 0.1;\\n  animation-fill-mode: forwards;\\n  transform: scale(1, 0);\\n  transform-origin: 0 0 ;\\n  display: block;\\n  transition: all 0.2s ease;\\n}\\n#tool_shape .tool_shape_entry {\\n  text-align: left;\\n}\\n#tool_shape .tool_shape_entry img {\\n  height: 30px;\\n  padding-right: 20px;\\n}\\n#tool_shape .tool_shape_entry .tool_label {\\n  min-width: 95px;\\n  display: inline-block;\\n}\\n#tool_shape .tool_shape_entry .tool_shortcut {\\n  color: rgba(0, 0, 0, 0.5);\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"C:/GitHub/Siemens_Skill_Invokation_Client_Restrukturierung/app/frontend/_common/less/toolbar.less\",\"index.less\",\"C:/GitHub/Siemens_Skill_Invokation_Client_Restrukturierung/app/frontend/_common/less/dialog.less\",\"C:/GitHub/Siemens_Skill_Invokation_Client_Restrukturierung/app/frontend/_common/less/file_open_dialog.less\",\"C:/GitHub/Siemens_Skill_Invokation_Client_Restrukturierung/app/frontend/_common/less/file_save_dialog.less\",\"C:/GitHub/Siemens_Skill_Invokation_Client_Restrukturierung/app/frontend/_common/less/file_saveas_dialog.less\",\"C:/GitHub/Siemens_Skill_Invokation_Client_Restrukturierung/app/frontend/_common/less/canvas_zoom.less\",\"C:/GitHub/Siemens_Skill_Invokation_Client_Restrukturierung/app/frontend/designer/less/application.less\",\"C:/GitHub/Siemens_Skill_Invokation_Client_Restrukturierung/app/frontend/designer/less/main.less\",\"C:/GitHub/Siemens_Skill_Invokation_Client_Restrukturierung/app/frontend/designer/less/canvas.less\",\"C:/GitHub/Siemens_Skill_Invokation_Client_Restrukturierung/app/frontend/designer/less/layer.less\",\"C:/GitHub/Siemens_Skill_Invokation_Client_Restrukturierung/app/frontend/designer/less/dialog_code.less\",\"C:/GitHub/Siemens_Skill_Invokation_Client_Restrukturierung/app/frontend/designer/less/dialog_test.less\",\"C:/GitHub/Siemens_Skill_Invokation_Client_Restrukturierung/app/frontend/designer/less/filter.less\",\"C:/GitHub/Siemens_Skill_Invokation_Client_Restrukturierung/app/frontend/designer/less/markdown_dialog.less\",\"C:/GitHub/Siemens_Skill_Invokation_Client_Restrukturierung/app/frontend/designer/less/anglepicker.less\",\"C:/GitHub/Siemens_Skill_Invokation_Client_Restrukturierung/app/frontend/designer/less/tool_dropdown.less\"],\"names\":[],\"mappings\":\"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\",\"file\":\"index.less\",\"sourcesContent\":[\".toolbar {\\n  margin:0;\\n  padding-top:0;\\n  padding-right:10px;\\n  top:0;\\n  right:0;\\n  left:@leftPaneWidth;\\n  height:@toolbarHeight;\\n  overflow: visible;\\n  z-index:500 !important;\\n  position:absolute;\\n  background-color:@toolbarBackground;\\n  border: none !important;\\n\\n  * {\\n    outline:none;\\n  }\\n\\n  .group{\\n    padding-right:20px;\\n    display: inline-block;\\n    vertical-align: top;\\n\\n    .image-button{\\n      display: inline-block;\\n      img{\\n        margin: 5px;\\n        margin-bottom:0;\\n        padding: 0;\\n        width: @toolbarHeight - 20;\\n        height: @toolbarHeight - 20;\\n        position: relative;\\n        display: inline-block;\\n        text-align: center;\\n        color:#777;\\n        font-size:45px;\\n        transition: all 0.5s;\\n      }\\n      .img_span{\\n        margin: 5px;\\n        margin-bottom:0;\\n        padding: 0;\\n        width: @toolbarHeight - 20;\\n        height: @toolbarHeight - 20;\\n        position: relative;\\n        display: inline-block;\\n        text-align: center;\\n        color:#777;\\n        font-size:45px;\\n        transition: all 0.5s;\\n      }\\n\\n      div{\\n        color:@toolbarButtonFontColor;\\n        text-align: center;\\n        font-size: 10px;\\n      }\\n      &.disabled{\\n        opacity:0.2;\\n      }\\n      &:not(.disabled){\\n        img {\\n          cursor:pointer;\\n          &:hover{\\n            box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n\",\".toolbar {\\n  margin: 0;\\n  padding-top: 0;\\n  padding-right: 10px;\\n  top: 0;\\n  right: 0;\\n  left: 220px;\\n  height: 60px;\\n  overflow: visible;\\n  z-index: 500 !important;\\n  position: absolute;\\n  background-color: #ebf0f5;\\n  border: none !important;\\n}\\n.toolbar * {\\n  outline: none;\\n}\\n.toolbar .group {\\n  padding-right: 20px;\\n  display: inline-block;\\n  vertical-align: top;\\n}\\n.toolbar .group .image-button {\\n  display: inline-block;\\n}\\n.toolbar .group .image-button img {\\n  margin: 5px;\\n  margin-bottom: 0;\\n  padding: 0;\\n  width: 40px;\\n  height: 40px;\\n  position: relative;\\n  display: inline-block;\\n  text-align: center;\\n  color: #777;\\n  font-size: 45px;\\n  transition: all 0.5s;\\n}\\n.toolbar .group .image-button .img_span {\\n  margin: 5px;\\n  margin-bottom: 0;\\n  padding: 0;\\n  width: 40px;\\n  height: 40px;\\n  position: relative;\\n  display: inline-block;\\n  text-align: center;\\n  color: #777;\\n  font-size: 45px;\\n  transition: all 0.5s;\\n}\\n.toolbar .group .image-button div {\\n  color: rgba(0, 0, 0, 0.5);\\n  text-align: center;\\n  font-size: 10px;\\n}\\n.toolbar .group .image-button.disabled {\\n  opacity: 0.2;\\n}\\n.toolbar .group .image-button:not(.disabled) img {\\n  cursor: pointer;\\n}\\n.toolbar .group .image-button:not(.disabled) img:hover {\\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);\\n}\\n.modal-backdrop.in {\\n  opacity: 0.7;\\n  background-color: black;\\n  transition: opacity 0.4s linear;\\n}\\n.genericDialog .modal-content {\\n  border-radius: 4px;\\n  box-shadow: 0 19px 38px rgba(0, 0, 0, 0.3), 0 15px 12px rgba(0, 0, 0, 0.22);\\n  background-color: #ffffff;\\n}\\n.genericDialog .modal-content .modal-header {\\n  border-bottom: 0;\\n  font-weight: 400;\\n  box-shadow: 0 3px 5px rgba(57, 63, 72, 0.3);\\n}\\n.genericDialog .modal-content .modal-body {\\n  padding: 1px;\\n  min-height: 120px;\\n}\\n.genericDialog .modal-content .modal-body .form-control {\\n  -webkit-appearance: none;\\n  -moz-appearance: none;\\n  appearance: none;\\n  box-sizing: border-box;\\n  border-radius: 4px;\\n  margin: 0;\\n  padding: 0;\\n  color: #4D4D4D;\\n  display: inline-block;\\n  font: inherit;\\n  border: 1px solid #DFDFDF;\\n  box-shadow: none;\\n  height: 24px;\\n  padding: 0 3px;\\n}\\n.genericDialog .modal-content .modal-body .form-control:focus {\\n  background-color: #f5f5f5;\\n}\\n.genericDialog .modal-content .modal-body .list-group {\\n  overflow-y: auto;\\n  overflow-x: auto;\\n}\\n.genericDialog .modal-content .modal-body .list-group *[data-draw2d=\\\"true\\\"] {\\n  font-weight: bold;\\n  color: #41aaaa;\\n}\\n.genericDialog .modal-content .modal-body .list-group .glyphicon,\\n.genericDialog .modal-content .modal-body .list-group .fa {\\n  font-size: 20px;\\n  padding-right: 10px;\\n  color: #41aaaa;\\n}\\n.genericDialog .modal-content .modal-body .list-group .list-group-item {\\n  background-color: transparent;\\n  font-weight: 300;\\n}\\n.genericDialog .modal-content .modal-body .list-group .list-group-item:hover {\\n  text-decoration: underline;\\n}\\n.genericDialog .modal-content .modal-body .list-group *[data-draw2d=\\\"false\\\"][data-type=\\\"file\\\"] {\\n  color: gray;\\n  cursor: default;\\n  text-decoration: none !important;\\n}\\n.genericDialog .modal-content .modal-body .list-group *[data-draw2d=\\\"false\\\"][data-type=\\\"file\\\"] .fa {\\n  color: gray;\\n}\\n.genericDialog .modal-content .modal-footer {\\n  background-color: transparent;\\n  border-top: 0;\\n}\\n.genericDialog .modal-content .modal-footer .btn {\\n  border: 0;\\n  text-transform: uppercase;\\n  background-color: transparent;\\n  color: #41aaaa;\\n  transition: all 0.5s;\\n}\\n.genericDialog .modal-content .modal-footer .btn:hover {\\n  background-color: rgba(65, 170, 170, 0.04);\\n  transition: all 0.5s;\\n}\\n.genericDialog .modal-content .modal-footer .btn-primary {\\n  font-weight: bold;\\n}\\n#fileOpenDialog .list-group {\\n  height: 60%;\\n}\\n#fileSaveDialog .filePreview {\\n  max-width: 200px;\\n  max-height: 200px;\\n}\\n#fileSaveDialog .modal-body .media {\\n  padding: 20px;\\n}\\n#githubFileSaveAsDialog .filePreview {\\n  max-width: 200px;\\n  max-height: 200px;\\n}\\n#githubFileSaveAsDialog .list-group {\\n  height: 250px;\\n}\\n#canvas_zoom {\\n  position: fixed;\\n  bottom: 20px;\\n  right: 270px;\\n  background-color: rgba(235, 240, 245, 0.3);\\n  border-radius: 5px;\\n}\\n#canvas_zoom button {\\n  background-color: transparent;\\n  font-weight: 300;\\n  padding: 5px;\\n  padding-left: 10px;\\n  padding-right: 10px;\\n  border: 1px solid transparent;\\n  outline: none;\\n  transition: all 0.5s;\\n}\\n#canvas_zoom button:hover {\\n  border: 1px solid #41aaaa;\\n}\\n/***BOOTSTRAP****/\\n.btn {\\n  border-radius: 0 !important;\\n}\\n.tooltip-inner {\\n  border-radius: 0 !important;\\n  padding: 10px !important;\\n  padding-top: 5px !important;\\n  padding-bottom: 5px !important;\\n  font-family: 'Roboto', sans-serif !important;\\n  font-weight: 300 !important;\\n  font-size: 14px !important;\\n  color: #b0b0b0 !important;\\n}\\n/********/\\nbody {\\n  overflow: hidden;\\n  font-family: 'Roboto', sans-serif !important;\\n  font-weight: 300;\\n}\\ninput {\\n  background: none repeat scroll 0 0 #f8f8f8;\\n  border-color: #C6C6C6 #DADADA #EAEAEA;\\n  border-radius: 4px 4px 4px 4px;\\n  -moz-box-sizing: border-box;\\n  padding-left: 7px;\\n  border-style: solid ;\\n  border-width: 1px;\\n  vertical-align: middle;\\n  height: 25px;\\n  font-size: 14px;\\n  line-height: 25px;\\n}\\n.input-block-level {\\n  display: block;\\n  width: 100%;\\n  min-height: 28px;\\n}\\n.control-label {\\n  font-family: 'Roboto', sans-serif;\\n  font-weight: 300;\\n}\\n/******************************************************************\\n * Einstellungen der PropertyViews im Editmodus der \\\"Form\\\".\\n ******************************************************************/\\n.palette_node_element {\\n  width: 48px;\\n  height: 48px;\\n  cursor: move;\\n  margin: 10px auto 10px auto;\\n}\\n.tooltip {\\n  z-index: 1000000;\\n}\\n/* Effects */\\n.overlay-scale {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 100%;\\n  z-index: 10000;\\n  visibility: hidden;\\n  opacity: 0;\\n  -webkit-transform: scale(0.9);\\n  transform: scale(0.9);\\n  -webkit-transition: all 0.4s;\\n  transition: all 0.4s;\\n}\\n.overlay-scale.open {\\n  visibility: visible;\\n  opacity: 1;\\n  -webkit-transform: scale(1);\\n  transform: scale(1);\\n  -webkit-transition: all 0.4s;\\n  transition: all 0.4s;\\n}\\n.readonly-highlight {\\n  background-color: rgba(50, 43, 168, 0.5);\\n  opacity: 0.2;\\n  color: darkblue;\\n  position: absolute;\\n}\\n#canvas {\\n  padding: 0;\\n  margin: 0;\\n  border: 0;\\n  position: absolute;\\n  top: 60px;\\n  right: 250px;\\n  left: 220px;\\n  bottom: 0;\\n  overflow: scroll;\\n  background-color: #FFFFFF;\\n}\\n#canvas_config {\\n  position: fixed;\\n  width: 40px;\\n  top: 65px;\\n  left: 225px;\\n  cursor: pointer;\\n  border: 1px solid transparent;\\n  background-color: rgba(235, 240, 245, 0.3);\\n}\\n#canvas_config:hover {\\n  border: 1px solid #41aaaa !important;\\n}\\n#canvas_config:hover {\\n  color: #41aaaa;\\n}\\n#canvas_config_items {\\n  position: fixed;\\n  top: 90px;\\n  left: 225px;\\n  cursor: pointer;\\n  padding: 10px;\\n  white-space: nowrap;\\n  min-width: 250px;\\n}\\n.layer-name-prompt .modal-title {\\n  font-weight: 100;\\n}\\n.layer-name-prompt .modal-footer {\\n  border: 0;\\n}\\n.layer-name-prompt .modal-header {\\n  border-bottom: 3px solid #41aaaa;\\n}\\n.layer-name-prompt input {\\n  outline: none !important;\\n  -webkit-box-shadow: inset !important;\\n  box-shadow: inset !important;\\n  background-color: rgba(0, 0, 0, 0.02) !important;\\n  border-radius: 1px !important;\\n}\\n.layer-name-prompt input:focus {\\n  border: 1px solid #41aaaa;\\n}\\n.layer-name-prompt .btn-primary {\\n  background-color: #41aaaa;\\n  border: 0;\\n}\\n.layer-name-prompt .btn-primary:hover {\\n  background-color: #338585;\\n}\\n#layer {\\n  padding: 0;\\n  margin: 0;\\n  border: 0;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  bottom: 0;\\n  width: 220px;\\n  background-color: #ffffff;\\n  text-align: center;\\n  box-shadow: 5px 0 20px -3px rgba(31, 73, 125, 0.3);\\n  z-index: 1;\\n}\\n#layer .title {\\n  left: 10px;\\n  right: 0px;\\n  top: 10px;\\n  position: absolute;\\n}\\n#layer .title img {\\n  padding-right: 20px;\\n  position: absolute;\\n  left: 10px;\\n  max-height: 28px;\\n}\\n#layer .title div {\\n  position: absolute;\\n  left: 90px;\\n}\\n#layer .title div h1 {\\n  font-size: 25px;\\n  font-weight: 200;\\n  line-height: 45px;\\n  margin: 0;\\n  padding: 0;\\n  text-align: left;\\n}\\n#layer .title div h2 {\\n  font-size: 15px;\\n  font-weight: 200;\\n  margin: 0;\\n  padding: 0;\\n  text-align: left;\\n}\\n#layer .panetitle {\\n  position: fixed;\\n  height: 30px;\\n  width: 220px;\\n  top: 60px;\\n  border-bottom: 1px solid #222222;\\n  font-weight: 500;\\n  font-size: 12px;\\n  padding: 4px 4px 4px 20px;\\n  letter-spacing: 5px;\\n  text-align: left;\\n  color: #41aaaa;\\n  box-shadow: 0 4px 2px -2px rgba(31, 73, 125, 0.3);\\n}\\n#layer #layer_elements {\\n  padding: 0;\\n  margin: 0;\\n  border: 0;\\n  position: fixed;\\n  top: 90px;\\n  left: 0;\\n  bottom: 0;\\n  width: 220px;\\n  overflow: auto;\\n}\\n#layer #layer_elements .layerElement {\\n  background-color: #fafafa;\\n  color: black;\\n  cursor: move;\\n  font-weight: 400;\\n  font-size: 12px;\\n  letter-spacing: 1px;\\n  padding: 4px 4px 4px 5px;\\n  text-align: left;\\n  border: 1px solid transparent;\\n  border-bottom: 1px solid #222222;\\n}\\n#layer #layer_elements .layerElement::before {\\n  content: \\\"\\\";\\n  display: block;\\n  width: 20px;\\n  height: 20px;\\n  float: left;\\n  margin-right: 5px;\\n}\\n#layer #layer_elements .layerElement.ExtLine::before {\\n  background: url(\\\"../images/layer_line.svg\\\") no-repeat;\\n  background-size: cover;\\n}\\n#layer #layer_elements .layerElement.PolyRect::before {\\n  background: url(\\\"../images/layer_rect.svg\\\") no-repeat;\\n  background-size: cover;\\n}\\n#layer #layer_elements .layerElement.PolyCircle::before {\\n  background: url(\\\"../images/layer_circle.svg\\\") no-repeat;\\n  background-size: cover;\\n}\\n#layer #layer_elements .layerElement.ExtLabel::before {\\n  background: url(\\\"../images/layer_text.svg\\\") no-repeat;\\n  background-size: cover;\\n}\\n#layer #layer_elements .layerElement.ExtPort::before {\\n  background: url(\\\"../images/layer_port.svg\\\") no-repeat;\\n  background-size: cover;\\n}\\n#layer #layer_elements .layerElement[data-visibility=\\\"false\\\"] {\\n  opacity: 0.5;\\n  font-style: italic;\\n}\\n#layer #layer_elements .layerElement .icon {\\n  cursor: pointer;\\n  padding-right: 4px;\\n  width: 20px;\\n  height: 20px;\\n}\\n#layer #layer_elements .layerElement .icon * {\\n  stroke: black !important;\\n}\\n#layer #layer_elements .layerElement .icon:hover * {\\n  stroke: #41aaaa !important;\\n}\\n#layer #layer_elements .layerSelectedElement {\\n  background-color: #f5f5f5;\\n  color: black;\\n  border-style: dotted;\\n  border-width: 1px;\\n  border-color: #41aaaa;\\n  font-weight: 600;\\n}\\n#code_overlay {\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  width: 100%;\\n  height: 100%;\\n  background-color: white;\\n  z-index: 10000;\\n}\\n#code_close {\\n  position: fixed;\\n  right: 40px;\\n  top: 10px;\\n  width: 32px;\\n  height: 32px;\\n  z-index: 10000;\\n  cursor: pointer;\\n  font-size: 50px;\\n}\\n#code_close:hover {\\n  color: #41aaaa;\\n}\\n#test_run {\\n  position: fixed;\\n  right: 90px;\\n  top: 10px;\\n  width: 32px;\\n  height: 32px;\\n  z-index: 10000;\\n  cursor: pointer;\\n  font-size: 50px;\\n}\\n#test_run:hover {\\n  color: #41aaaa;\\n}\\n#test_info {\\n  position: absolute;\\n  color: black;\\n  z-index: 20000;\\n  top: 20px;\\n  left: 20px;\\n  border: 1px solid lightgray;\\n  padding: 7px;\\n  background-color: white;\\n  border-radius: 2px;\\n}\\n#test_canvas {\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  width: 100%;\\n  height: 100%;\\n  background-color: white;\\n  z-index: 10000;\\n}\\n#test_close {\\n  position: fixed;\\n  right: 40px;\\n  top: 10px;\\n  width: 32px;\\n  height: 32px;\\n  z-index: 10000;\\n  cursor: pointer;\\n  font-size: 50px;\\n}\\n#test_close:hover {\\n  color: #41aaaa;\\n}\\n#test_clipboard {\\n  position: fixed;\\n  right: 100px;\\n  top: 10px;\\n  width: 32px;\\n  height: 32px;\\n  z-index: 10000;\\n  cursor: pointer;\\n  font-size: 50px;\\n}\\n#test_clipboard:hover {\\n  color: #41aaaa;\\n}\\n.portDirectionOption {\\n  height: 60px;\\n  text-align: center;\\n}\\n.portDirectionOption label > input {\\n  /* HIDE RADIO */\\n  display: none;\\n}\\n.portDirectionOption label > input + span {\\n  /* IMAGE STYLES */\\n  cursor: pointer;\\n  color: gray !important;\\n  padding-right: 5px;\\n}\\n.portDirectionOption label > input:checked + span {\\n  /* (CHECKED) IMAGE STYLES */\\n  color: #41aaaa !important;\\n}\\n.portTypeOption {\\n  height: 65px;\\n  padding-left: 60px;\\n}\\n.portTypeOption label > input {\\n  /* HIDE RADIO */\\n  display: none;\\n}\\n.portTypeOption label > input + span {\\n  /* IMAGE STYLES */\\n  cursor: pointer;\\n  color: gray !important;\\n  padding-right: 5px;\\n  font-weight: 100;\\n  font-size: 14px;\\n}\\n.portTypeOption label > input + span:before {\\n  padding-right: 10px;\\n}\\n.portTypeOption label > input:checked + span {\\n  /* (CHECKED) IMAGE STYLES */\\n  color: #41aaaa !important;\\n}\\n#filter {\\n  position: absolute;\\n  top: 60px;\\n  right: 0;\\n  bottom: 0;\\n  width: 250px;\\n  padding: 0;\\n  margin: 0;\\n  border-radius: 0;\\n  border: 0;\\n  background-color: #282a30;\\n}\\n#filter .filter_header {\\n  background: none repeat scroll 0 0 #303030;\\n  position: fixed;\\n  height: 30px;\\n  width: 250px;\\n  top: 60px;\\n  border-bottom: 1px solid #222222;\\n  border-top: 1px solid #111111;\\n  font-weight: 500;\\n  font-size: 12px;\\n  padding-top: 5px;\\n  letter-spacing: 5px;\\n  text-align: center;\\n  color: #41aaaa;\\n}\\n#filter .filter_toolbar {\\n  overflow: visible;\\n  border: 0;\\n  padding: 3px;\\n  padding-left: 10px;\\n  position: absolute;\\n  bottom: 0;\\n  right: 0;\\n  width: 250px;\\n  height: 30px;\\n  background: none repeat scroll 0 0 #303030;\\n}\\n#filter .filter_actions {\\n  position: fixed;\\n  top: 90px;\\n  bottom: 30px;\\n  width: 250px;\\n  border: 0;\\n  padding: 0;\\n  overflow-y: auto;\\n}\\n#filter .filter_actions .panel-body {\\n  padding: 7px;\\n  padding-top: 0;\\n}\\n#filter .filter_actions .form-group {\\n  margin-bottom: 2px !important;\\n}\\n#filter .filter_actions .form-group > .input-group {\\n  margin-bottom: 10px;\\n}\\n#filter .filter_actions .form-group > .input-group:last-child {\\n  margin-bottom: 0px;\\n}\\n#filter .filter_actions .icon {\\n  color: #26B4A8;\\n  padding: 0;\\n  top: -4px;\\n  color: rgba(255, 255, 255, 0.25);\\n}\\n#filter .filter_actions .icon:hover {\\n  color: #41aaaa;\\n}\\n#filter .filter_actions .filter-heading {\\n  color: #DDDDDD !important;\\n  font-size: 12px;\\n  padding-right: 10px !important;\\n  padding-top: 1px !important;\\n  padding-bottom: 0 !important;\\n  background-color: transparent !important;\\n  background-image: none !important;\\n  border: 0 !important;\\n  margin-top: 4px;\\n  cursor: pointer;\\n  font-weight: 300;\\n}\\n#filter .filter_actions .filter-heading .icon {\\n  width: 15px;\\n}\\n#filter .filter_actions .filter-heading .icon * {\\n  stroke: white !important;\\n}\\n#filter .form-control {\\n  height: 25px;\\n}\\n#filter .btn {\\n  padding-left: 5px;\\n  padding-right: 5px;\\n  padding-top: 1px;\\n  padding-bottom: 2px;\\n}\\n#filter .input-group-addon {\\n  padding: 0;\\n  padding-left: 5px;\\n  padding-right: 5px;\\n  color: rgba(0, 0, 0, 0.3);\\n  background-color: white;\\n  border-left: 0;\\n  border-radius: 0;\\n  font-weight: 100;\\n  text-transform: lowercase;\\n  font-size: 12px;\\n}\\n#filter .panel-default {\\n  margin: 0;\\n  border-radius: 0;\\n  background-color: rgba(65, 170, 170, 0.02);\\n  border: 0;\\n  border-top: 1px solid #303030;\\n  border-bottom: 1px solid #202525;\\n  margin-top: 3px;\\n}\\n#FigureMarkdownEdit .header {\\n  width: 100%;\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  display: inline-block;\\n  height: 60px;\\n  background-color: white;\\n  overflow: hidden;\\n}\\n#FigureMarkdownEdit .header .left {\\n  width: 50%;\\n  display: inline-block;\\n  height: 60px;\\n  font-size: 20px;\\n  padding: 6px;\\n  color: #CC4F5A;\\n  background-color: rgba(0, 0, 0, 0.1);\\n  vertical-align: top;\\n}\\n#FigureMarkdownEdit .header .left small {\\n  font-size: 16px;\\n}\\n#FigureMarkdownEdit .header .right {\\n  width: 50%;\\n  display: inline-block;\\n  height: 60px;\\n  font-size: 20px;\\n  padding: 6px;\\n  color: #CC4F5A;\\n  background-color: rgba(0, 0, 0, 0.05);\\n  vertical-align: top;\\n}\\n#FigureMarkdownEdit .source {\\n  width: 50%;\\n  display: inline-block;\\n  font-family: Menlo, Monaco, Consolas, \\\"Courier New\\\", monospace;\\n  font-size: 13px;\\n  padding: 2px;\\n  top: 60px;\\n  bottom: 0px;\\n  position: absolute;\\n}\\n#FigureMarkdownEdit .preview {\\n  width: 50%;\\n  display: inline-block;\\n  top: 0px;\\n  left: 50%;\\n  position: absolute;\\n  background-color: white;\\n  padding: 30px;\\n  overflow: auto;\\n  top: 60px;\\n  bottom: 0px;\\n}\\n#FigureMarkdownEdit .preview img {\\n  max-width: 35%;\\n}\\n#FigureMarkdownEdit .preview table {\\n  font-family: Arial, Helvetica, sans-serif;\\n  color: #666;\\n  font-size: 12px;\\n  text-shadow: 1px 1px 0px #fff;\\n  background: #eaebec;\\n  margin: 20px;\\n  margin-left: 0;\\n  border: #ccc 1px solid;\\n  -moz-border-radius: 3px;\\n  -webkit-border-radius: 3px;\\n  border-radius: 3px;\\n  -moz-box-shadow: 0 1px 2px #d1d1d1;\\n  -webkit-box-shadow: 0 1px 2px #d1d1d1;\\n  box-shadow: 0 1px 2px #d1d1d1;\\n}\\n#FigureMarkdownEdit .preview table th {\\n  padding: 21px 25px 22px 25px;\\n  border-top: 1px solid #fafafa;\\n  border-bottom: 1px solid #e0e0e0;\\n}\\n#FigureMarkdownEdit .preview table th:first-child {\\n  text-align: left;\\n  padding-left: 20px;\\n}\\n#FigureMarkdownEdit .preview table tr:first-child th:first-child {\\n  -moz-border-radius-topleft: 3px;\\n  -webkit-border-top-left-radius: 3px;\\n  border-top-left-radius: 3px;\\n}\\n#FigureMarkdownEdit .preview table tr:first-child th:last-child {\\n  -moz-border-radius-topright: 3px;\\n  -webkit-border-top-right-radius: 3px;\\n  border-top-right-radius: 3px;\\n}\\n#FigureMarkdownEdit .preview table tr {\\n  text-align: center;\\n  padding-left: 20px;\\n}\\n#FigureMarkdownEdit .preview table tr td:first-child {\\n  text-align: left;\\n  padding-left: 20px;\\n  border-left: 0;\\n}\\n#FigureMarkdownEdit .preview table tr td {\\n  padding: 18px;\\n  border-top: 1px solid #ffffff;\\n  border-bottom: 1px solid #e0e0e0;\\n  border-left: 1px solid #e0e0e0;\\n}\\n#FigureMarkdownEdit .preview tbody tr:nth-child(odd) {\\n  background: #fafafa;\\n}\\n#FigureMarkdownEdit .preview tbody tr:nth-child(even) {\\n  background: #f3f3f3;\\n}\\n#FigureMarkdownEdit .preview table tr:last-child td {\\n  border-bottom: 0;\\n}\\n#FigureMarkdownEdit .preview table tr:last-child td:first-child {\\n  -moz-border-radius-bottomleft: 3px;\\n  -webkit-border-bottom-left-radius: 3px;\\n  border-bottom-left-radius: 3px;\\n}\\n#FigureMarkdownEdit .preview table tr:last-child td:last-child {\\n  -moz-border-radius-bottomright: 3px;\\n  -webkit-border-bottom-right-radius: 3px;\\n  border-bottom-right-radius: 3px;\\n}\\n.ui-anglepicker {\\n  width: 52px;\\n  height: 52px;\\n  background: #dbdbdb;\\n  background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEgMSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkLXVjZ2ctZ2VuZXJhdGVkIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iI2RiZGJkYiIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjIwJSIgc3RvcC1jb2xvcj0iI2UxZTFkZSIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiNmOGY4ZjMiIHN0b3Atb3BhY2l0eT0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0idXJsKCNncmFkLXVjZ2ctZ2VuZXJhdGVkKSIgLz4KPC9zdmc+);\\n  background: -moz-linear-gradient(top, #dbdbdb 0%, #e1e1de 20%, #f8f8f3 100%);\\n  background: -webkit-gradient(linear, left top, left bottom, color-stop(0%, #dbdbdb), color-stop(20%, #e1e1de), color-stop(100%, #f8f8f3));\\n  background: -webkit-linear-gradient(top, #dbdbdb 0%, #e1e1de 20%, #f8f8f3 100%);\\n  background: -o-linear-gradient(top, #dbdbdb 0%, #e1e1de 20%, #f8f8f3 100%);\\n  background: -ms-linear-gradient(top, #dbdbdb 0%, #e1e1de 20%, #f8f8f3 100%);\\n  background: linear-gradient(to bottom, #dbdbdb 0%, #e1e1de 20%, #f8f8f3 100%);\\n  border: 2px solid #666;\\n  -moz-box-shadow: inset 0 2px 3px white, inset 0 -1px 2px #fffef8;\\n  -webkit-box-shadow: inset 0 2px 3px white, inset 0 -1px 2px #fffef8;\\n  box-shadow: inset 0 2px 3px white, inset 0 -1px 2px #fffef8;\\n  -moz-border-radius: 50%;\\n  -webkit-border-radius: 50%;\\n  border-radius: 50%;\\n  position: relative;\\n  display: inline-block;\\n}\\n.ui-anglepicker-pointer {\\n  position: absolute;\\n  top: 50%;\\n  left: 50%;\\n  width: 50%;\\n  margin: -2px 0 0 -2px;\\n  -moz-transform-origin: 2px 2px;\\n  -webkit-transform-origin: 2px 2px;\\n  -ms-transform-origin: 2px 2px;\\n  -o-transform-origin: 2px 2px;\\n  transform-origin: 2px 2px;\\n}\\n.ui-anglepicker:hover,\\n.ui-anglepicker.ui-anglepicker-dragging {\\n  border-color: #494949;\\n}\\n.ui-anglepicker-dragging .ui-anglepicker-dot,\\n.ui-anglepicker-dragging .ui-anglepicker-line,\\n.ui-anglepicker:hover .ui-anglepicker-dot,\\n.ui-anglepicker:hover .ui-anglepicker-line {\\n  background: #494949;\\n}\\n.ui-anglepicker-dot {\\n  height: 4px;\\n  width: 4px;\\n  position: absolute;\\n  background: #838383;\\n  -moz-border-radius: 50%;\\n  -webkit-border-radius: 50%;\\n  border-radius: 50%;\\n}\\n.ui-anglepicker-line {\\n  margin-top: 1.5px;\\n  margin-right: -2px;\\n  height: 1px;\\n  background: #838383;\\n}\\n#tool_shape.open .dropdown-menu {\\n  -webkit-transform: scale(1, 1);\\n  opacity: 1;\\n  transform: scale(1, 1);\\n}\\n#tool_shape .dropdown-menu {\\n  opacity: 0.1;\\n  animation-fill-mode: forwards;\\n  transform: scale(1, 0);\\n  transform-origin: 0 0 ;\\n  display: block;\\n  transition: all 0.2s ease;\\n}\\n#tool_shape .tool_shape_entry {\\n  text-align: left;\\n}\\n#tool_shape .tool_shape_entry img {\\n  height: 30px;\\n  padding-right: 20px;\\n}\\n#tool_shape .tool_shape_entry .tool_label {\\n  min-width: 95px;\\n  display: inline-block;\\n}\\n#tool_shape .tool_shape_entry .tool_shortcut {\\n  color: rgba(0, 0, 0, 0.5);\\n}\\n\",\".modal-backdrop.in{\\n  opacity: 0.7;\\n  background-color: black;\\n  transition: opacity .4s linear;\\n}\\n\\n.genericDialog {\\n  .modal-content{\\n    border-radius:4px;\\n    box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\\n    background-color: rgb(255,255,255);\\n\\n    .modal-header{\\n      border-bottom:0;\\n      font-weight:400;\\n      box-shadow: 0 3px 5px rgba(57, 63, 72, 0.3);\\n    }\\n\\n    .modal-body {\\n      padding: 1px;\\n      min-height:120px;\\n\\n      .form-control{\\n         -webkit-appearance: none;\\n        -moz-appearance: none;\\n        appearance: none;\\n        box-sizing: border-box;\\n        border-radius: 4px;\\n        margin: 0;\\n        padding: 0;\\n        color: #4D4D4D;\\n        display: inline-block;\\n        font: inherit;\\n        border: 1px solid #DFDFDF;\\n        box-shadow: none;\\n        height: 24px;\\n        padding: 0 3px;\\n        &:focus{\\n          background-color: rgb(245,245,245);\\n        }\\n      }\\n\\n      .list-group {\\n        overflow-y: auto;\\n        overflow-x: auto;\\n\\n        *[data-draw2d=\\\"true\\\"] {\\n          font-weight: bold;\\n          color: @tintColor;\\n        }\\n\\n        .glyphicon, .fa {\\n          font-size: 20px;\\n          padding-right: 10px;\\n          color: @tintColor;\\n        }\\n\\n        .list-group-item {\\n          background-color: transparent;\\n          font-weight: 300;\\n\\n          &:hover {\\n            text-decoration: underline;\\n          }\\n        }\\n\\n        *[data-draw2d=\\\"false\\\"][data-type=\\\"file\\\"] {\\n          color: gray;\\n          cursor: default;\\n          text-decoration: none !important;\\n          .fa {\\n            color: gray;\\n          }\\n        }\\n      }\\n    }\\n\\n    .modal-footer {\\n      background-color: transparent;\\n      border-top:0;\\n\\n      .btn{\\n        border:0;\\n        text-transform: uppercase;\\n        background-color:transparent;\\n        color:@tintColor;\\n        transition: all 0.5s;\\n\\n        &:hover{\\n          background-color: fadeout(@tintColor,96);\\n          transition: all 0.5s;\\n        }\\n      }\\n\\n      .btn-primary{\\n        font-weight: bold;\\n      }\\n    }\\n  }\\n}\\n\\n\",\"\\n#fileOpenDialog {\\n\\n  .list-group{\\n    height:60%;\\n  }\\n}\\n\",\"\\n#fileSaveDialog {\\n\\n  .filePreview{\\n    max-width: 200px;\\n    max-height: 200px;\\n  }\\n\\n  .modal-body {\\n    .media {\\n      padding: 20px;\\n    }\\n  }\\n}\\n\",\"\\n#githubFileSaveAsDialog {\\n\\n  .filePreview{\\n    max-width: 200px;\\n    max-height: 200px;\\n  }\\n\\n\\n  .list-group{\\n    height:250px;\\n  }\\n}\\n\",\"#canvas_zoom{\\n  position: fixed;\\n  bottom: 20px;\\n  right: @rightMenuWidth + 20px;\\n  background-color:fadeout(@toolbarBackground,70%);\\n  border-radius:5px;\\n\\n  button {\\n    background-color:transparent;\\n    font-weight:300;\\n    padding:5px;\\n    padding-left:10px;\\n    padding-right:10px;\\n    border:1px solid transparent;\\n    outline:none;\\n    transition: all 0.5s;\\n    &:hover {\\n      border:1px solid @tintColor;\\n    }\\n  }\\n}\\n\",\"/***BOOTSTRAP****/\\n.btn{\\n    border-radius:0 !important;\\n}\\n\\n.tooltip-inner{\\n border-radius:0 !important;\\n padding:10px !important;\\n padding-top:5px !important;\\n padding-bottom:5px !important;\\n font-family: 'Roboto', sans-serif !important;\\n font-weight: 300 !important;\\n font-size:14px !important;\\n color:#b0b0b0 !important;\\n}\\n/********/\\n\\n\\n\\nbody{\\n overflow:hidden;\\n font-family:  'Roboto', sans-serif !important;\\n font-weight: 300;\\n}\\n\\ninput{\\n background: none repeat scroll 0 0 #f8f8f8;\\n border-color: #C6C6C6 #DADADA #EAEAEA;\\n border-radius: 4px 4px 4px 4px;\\n -moz-box-sizing: border-box;\\n padding-left:7px;\\n border-style: solid ;\\n border-width: 1px;\\n vertical-align: middle;\\n height:25px;\\n font-size:14px;\\n line-height:25px;\\n}\\n\\n\\n.input-block-level {\\n  display: block;\\n  width: 100%;\\n  min-height: 28px;        // Make inputs at least the height of their button counterpart\\n}\\n\\n\\n.control-label{\\n font-family: 'Roboto', sans-serif;\\n font-weight: 300;\\n}\\n\\n/******************************************************************\\n * Einstellungen der PropertyViews im Editmodus der \\\"Form\\\".\\n ******************************************************************/\\n\\n\\n.palette_node_element{\\n width:48px;\\n height:48px;\\n cursor:move;\\n margin: 10px auto 10px auto;\\n}\\n\\n\\n\",\"\\n\\n.tooltip{\\n  z-index: 1000000;\\n}\\n\\n\\n/* Effects */\\n.overlay-scale {\\n  position:absolute;\\n  top:0;\\n  left:0;\\n  width:100%;\\n  height:100%;\\n  z-index:10000;\\n\\n  visibility: hidden;\\n  opacity: 0;\\n  -webkit-transform: scale(0.9);\\n  transform: scale(0.9);\\n  -webkit-transition: all 0.4s;\\n  transition: all 0.4s;\\n}\\n\\n.overlay-scale.open {\\n  visibility: visible;\\n  opacity: 1;\\n  -webkit-transform: scale(1);\\n  transform: scale(1);\\n  -webkit-transition: all 0.4s;\\n  transition: all 0.4s;\\n}\\n\",\"\\n\\n.readonly-highlight{\\n  background-color: rgba(50,43,168,0.5);\\n  opacity: 0.2;\\n  color:darkblue;\\n  position: absolute;\\n}\\n\\n\\n#canvas {\\n  padding:0;\\n  margin:0;\\n  border:0;\\n  position: absolute;\\n  top: @toolbarHeight;\\n  right: @filterPaneWidth;\\n  left: @leftPaneWidth;\\n  bottom: 0;\\n  overflow: scroll;\\n  background-color:#FFFFFF;\\n}\\n\\n\\n#canvas_config{\\n  position: fixed;\\n  width:40px;\\n  top:@toolbarHeight+5;\\n  left:@leftPaneWidth+5px;\\n  cursor:pointer;\\n  border:1px solid transparent;\\n  background-color:fadeout(@toolbarBackground,70%);\\n  &:hover {\\n    border:1px solid @tintColor  !important;\\n  }\\n}\\n\\n#canvas_config:hover{\\n  color:@tintColor;\\n}\\n\\n\\n#canvas_config_items{\\n  position: fixed;\\n  top:@toolbarHeight+30;\\n  left:@leftPaneWidth+5px;\\n  cursor:pointer;\\n  padding:10px;\\n  white-space:nowrap;\\n  min-width:250px;\\n}\\n\",\".layer-name-prompt {\\n  .modal-title{\\n    font-weight:100;\\n  }\\n  .modal-footer{\\n    border:0;\\n  }\\n  .modal-header{\\n    border-bottom:3px solid @tintColor;\\n  }\\n\\n  input{\\n    outline:none !important;\\n    -webkit-box-shadow: inset !important;\\n    box-shadow: inset !important;\\n    background-color: rgba(0,0,0,0.02) !important;\\n    border-radius: 1px !important;\\n    &:focus{\\n      border:1px solid @tintColor;\\n    }\\n  }\\n  .btn-primary{\\n    background-color:@tintColor;\\n    border:0;\\n\\n    &:hover{\\n      background-color:darken(@tintColor,10%);\\n    }\\n  }\\n}\\n\\n#layer {\\n  padding: 0;\\n  margin: 0;\\n  border: 0;\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  bottom: 0;\\n  width: @leftPaneWidth;\\n  background-color: @layerPaneBgColor;\\n  text-align: center;\\n  box-shadow: 5px 0 20px -3px rgba(31, 73, 125, 0.3);\\n  z-index: 1;\\n\\n  .title {\\n    left: 10px;\\n    right:0px;\\n    top: 10px;\\n    position: absolute;\\n    img {\\n      padding-right:20px;\\n      position: absolute;\\n      left:10px;\\n      max-height: 28px;\\n    }\\n    div{\\n      position: absolute;\\n      left:90px;\\n      h1{\\n        font-size: 25px;\\n        font-weight:200;\\n        line-height: 45px;\\n        margin:0;\\n        padding:0;\\n        text-align: left;\\n      }\\n      h2{\\n        font-size: 15px;\\n        font-weight:200;\\n        margin:0;\\n        padding:0;\\n        text-align: left;\\n      }\\n    }\\n  }\\n\\n  .panetitle {\\n    position: fixed;\\n    height: @layerPaneTitleHeight;\\n    width: @leftPaneWidth;\\n    top: @layerTitleHeight;\\n    border-bottom: 1px solid #222222;\\n    font-weight: 500;\\n    font-size: 12px;\\n    padding: 4px 4px 4px 20px;\\n    letter-spacing: 5px;\\n    text-align: left;\\n    color: @tintColor;\\n    box-shadow: 0 4px 2px -2px rgba(31, 73, 125, 0.3);\\n  }\\n\\n  #layer_elements {\\n    padding: 0;\\n    margin: 0;\\n    border: 0;\\n    position: fixed;\\n    top: @layerPaneTitleHeight + @layerTitleHeight;\\n    left: 0;\\n    bottom: 0;\\n    width: @leftPaneWidth;\\n    overflow: auto;\\n\\n    .layerElement {\\n      background-color:darken(@layerPaneBgColor, 2%);\\n      color: @layerPaneColor;\\n      cursor: move;\\n      font-weight: 400;\\n      font-size: 12px;\\n      letter-spacing: 1px;\\n      padding: 4px 4px 4px 5px;\\n      text-align: left;\\n      border: 1px solid transparent;\\n      border-bottom: 1px solid #222222;\\n\\n      &::before {\\n        content: \\\"\\\";\\n        display: block;\\n        width: 20px;\\n        height: 20px;\\n        float: left;\\n        margin-right: 5px;\\n      }\\n\\n      &.ExtLine::before {\\n        background: url(\\\"../images/layer_line.svg\\\") no-repeat;\\n        background-size: cover;\\n      }\\n      &.PolyRect::before {\\n        background: url(\\\"../images/layer_rect.svg\\\") no-repeat;\\n        background-size: cover;\\n      }\\n\\n      &.PolyCircle::before {\\n        background: url(\\\"../images/layer_circle.svg\\\") no-repeat;\\n        background-size: cover;\\n      }\\n\\n      &.ExtLabel::before {\\n        background: url(\\\"../images/layer_text.svg\\\") no-repeat;\\n        background-size: cover;\\n      }\\n\\n      &.ExtPort::before {\\n        background: url(\\\"../images/layer_port.svg\\\") no-repeat;\\n        background-size: cover;\\n      }\\n\\n      &[data-visibility=\\\"false\\\"]{\\n        opacity: 0.5;\\n        font-style: italic;\\n      }\\n      .icon {\\n        cursor: pointer;\\n        padding-right: 4px;\\n        width: 20px;\\n        height: 20px;\\n        * {\\n          stroke: @layerPaneColor !important;\\n        }\\n        &:hover {\\n          * {\\n            stroke: @tintColor !important;\\n          }\\n        }\\n      }\\n    }\\n\\n    .layerSelectedElement {\\n      background-color: darken(@layerPaneBgColor, 4%);\\n      color: @layerPaneColor;\\n      border-style: dotted;\\n      border-width: 1px;\\n      border-color: @tintColor;\\n      font-weight: 600;\\n    }\\n  }\\n}\\n\",\"\\n#code_overlay{\\n  position:absolute;\\n  top:0px;\\n  left:0px;\\n  width:100%;\\n  height:100%;\\n  background-color:white;\\n  z-index:10000;\\n}\\n\\n#code_close{\\n  position: fixed;\\n  right: 40px;\\n  top: 10px;\\n  width: 32px;\\n  height: 32px;\\n  z-index: 10000;\\n  cursor: pointer;\\n  font-size: 50px;\\n}\\n\\n#code_close:hover{\\n  color:@tintColor;\\n}\\n\\n#test_run{\\n  position: fixed;\\n  right: 90px;\\n  top: 10px;\\n  width: 32px;\\n  height: 32px;\\n  z-index: 10000;\\n  cursor: pointer;\\n  font-size: 50px;\\n}\\n\\n#test_run:hover{\\n  color:@tintColor;\\n}\\n\\n\",\"\\n#test_info{\\n  position: absolute;\\n  color: black;\\n  z-index: 20000;\\n  top: 20px;\\n  left: 20px;\\n  border: 1px solid lightgray;\\n  padding: 7px;\\n  background-color: white;\\n  border-radius: 2px;\\n}\\n\\n#test_canvas{\\n  position:absolute;\\n  top:0px;\\n  left:0px;\\n  width:100%;\\n  height:100%;\\n  background-color:white;\\n  z-index:10000;\\n}\\n\\n#test_close{\\n  position: fixed;\\n  right: 40px;\\n  top: 10px;\\n  width: 32px;\\n  height: 32px;\\n  z-index: 10000;\\n  cursor: pointer;\\n  font-size: 50px;\\n}\\n\\n#test_close:hover{\\n  color:@tintColor;\\n}\\n\\n\\n#test_clipboard{\\n  position: fixed;\\n  right: 100px;\\n  top: 10px;\\n  width: 32px;\\n  height: 32px;\\n  z-index: 10000;\\n  cursor: pointer;\\n  font-size: 50px;\\n}\\n\\n#test_clipboard:hover{\\n  color:@tintColor;\\n}\\n\",\"\\n\\n.portDirectionOption{\\n  height: 60px;\\n  text-align: center;\\n\\n  & label > input{ /* HIDE RADIO */\\n    display:none;\\n  }\\n\\n  & label > input + span{ /* IMAGE STYLES */\\n    cursor:pointer;\\n    color:gray !important;\\n    padding-right: 5px;\\n  }\\n\\n  & label > input:checked + span{ /* (CHECKED) IMAGE STYLES */\\n    color:@tintColor !important;\\n  }\\n}\\n\\n\\n\\n\\n.portTypeOption{\\n  height: 65px;\\n  padding-left:60px;\\n\\n  & label > input{ /* HIDE RADIO */\\n    display:none;\\n\\n    + span{ /* IMAGE STYLES */\\n      cursor:pointer;\\n      color:gray !important;\\n      padding-right: 5px;\\n      font-weight:100;\\n      font-size:14px;\\n      &:before{\\n        padding-right:10px;\\n      }\\n    }\\n  }\\n\\n  & label > input:checked + span{ /* (CHECKED) IMAGE STYLES */\\n    color:@tintColor !important;\\n  }\\n}\\n\\n#filter {\\n  .filter_header{\\n    background:none repeat scroll 0 0 #303030;\\n    position: fixed;\\n    height: @filterPaneTitleHeight;\\n    width: @filterPaneWidth;\\n    top:@toolbarHeight;\\n    border-bottom: 1px solid #222222;\\n    border-top: 1px solid #111111;\\n    font-weight: 500;\\n    font-size: 12px;\\n    padding-top: 5px;\\n    letter-spacing: 5px;\\n    text-align: center;\\n    color:@tintColor;\\n  }\\n\\n  .filter_toolbar{\\n    overflow:visible;\\n    border:0;\\n    padding:3px;\\n    padding-left:10px;\\n    position:absolute;\\n    bottom:0;\\n    right:0;\\n    width:@filterPaneWidth;\\n    height:30px;\\n    background:none repeat scroll 0 0 #303030;\\n  }\\n\\n\\n  .filter_actions{\\n    position:fixed;\\n    top:@toolbarHeight+30;\\n    bottom:30px;\\n    width:@filterPaneWidth;\\n    border:0;\\n    padding:0;\\n    overflow-y: auto;\\n\\n    .panel-body{\\n      padding:7px;\\n      padding-top:0;\\n    }\\n\\n\\n    .form-group{\\n      margin-bottom: 2px !important;\\n\\n      > .input-group{\\n        margin-bottom: 10px;\\n      }\\n\\n      > .input-group:last-child{\\n        margin-bottom: 0px;\\n      }\\n    }\\n\\n    .icon {\\n      color: #26B4A8;\\n      padding:0;\\n      top: -4px;\\n      color:rgba(255,255,255,0.25);\\n      &:hover{\\n        color:@tintColor;\\n      }\\n    }\\n\\n    .filter-heading{\\n      color: #DDDDDD !important;\\n      font-size: 12px;\\n      padding-right:10px !important;\\n      padding-top:1px !important;\\n      padding-bottom:0 !important;\\n      background-color: transparent !important;\\n      background-image: none !important;\\n      border: 0 !important;\\n      margin-top:4px;\\n      cursor:pointer;\\n      font-weight:300;\\n      .icon {\\n        width: 15px;\\n        * {\\n          stroke : white !important;\\n        }\\n      }\\n    }\\n\\n  }\\n\\n\\n  position:absolute;\\n  top:@toolbarHeight;\\n  right:0;\\n  bottom:0;\\n  width:@filterPaneWidth;\\n\\n  padding:0;\\n  margin:0;\\n  border-radius:0;\\n  border:0;\\n  background-color: @filterPaneBackground;\\n\\n  .form-control{\\n    height:25px;\\n  }\\n  .btn{\\n    padding-left:5px;\\n    padding-right:5px;\\n    padding-top: 1px;\\n    padding-bottom: 2px;\\n  }\\n  .input-group-addon{\\n    padding:0;\\n    padding-left:5px;\\n    padding-right:5px;\\n    color:rgba(0,0,0,0.3);\\n    background-color: white;\\n    border-left: 0;\\n    border-radius:0;\\n    font-weight: 100;\\n    text-transform: lowercase;\\n    font-size: 12px;\\n  }\\n  .panel-default {\\n    margin: 0;\\n    border-radius: 0;\\n    background-color: fade(@tintColor, 2%);\\n    border: 0;\\n    border-top: 1px solid #303030;\\n    border-bottom: 1px solid #202525;\\n    margin-top: 3px;\\n  }\\n}\\n\",\"\\n@headerHeight:60px;\\n\\n#FigureMarkdownEdit\\n{\\n\\n  .header{\\n    width: 100%;\\n    position: absolute;\\n    top: 0px;\\n    left: 0px;\\n    display: inline-block;\\n    height: @headerHeight;\\n    background-color:white;\\n    overflow:hidden;\\n    .left{\\n      width: 50%;\\n      display: inline-block;\\n      height: @headerHeight;\\n      font-size: 20px;\\n      padding: 6px;\\n      color: #CC4F5A;\\n      background-color: rgba(0,0,0,0.1);\\n      vertical-align: top;\\n      small{\\n        font-size:16px;\\n      }\\n    }\\n    .right{\\n      width: 50%;\\n      display: inline-block;\\n      height: @headerHeight;\\n      font-size: 20px;\\n      padding: 6px;\\n      color: #CC4F5A;\\n      background-color: rgba(0,0,0,0.05);\\n      vertical-align: top;\\n    }\\n  }\\n\\n  .source{\\n    width:50%;\\n    display:inline-block;\\n    font-family: Menlo, Monaco, Consolas, \\\"Courier New\\\", monospace;\\n    font-size: 13px;\\n    padding: 2px;\\n    top:@headerHeight;\\n    bottom:0px;\\n    position:absolute;\\n  }\\n\\n  .preview{\\n    width: 50%;\\n    display: inline-block;\\n    top: 0px;\\n    left:50%;\\n    position: absolute;\\n    background-color: white;\\n    padding: 30px;\\n    overflow: auto;\\n    top:@headerHeight;\\n    bottom:0px;\\n    img {\\n      max-width: 35%;\\n    }\\n\\n    table {\\n      font-family:Arial, Helvetica, sans-serif;\\n      color:#666;\\n      font-size:12px;\\n      text-shadow: 1px 1px 0px #fff;\\n      background:#eaebec;\\n      margin:20px;\\n      margin-left:0;\\n      border:#ccc 1px solid;\\n      -moz-border-radius:3px;\\n      -webkit-border-radius:3px;\\n      border-radius:3px;\\n\\n      -moz-box-shadow: 0 1px 2px #d1d1d1;\\n      -webkit-box-shadow: 0 1px 2px #d1d1d1;\\n      box-shadow: 0 1px 2px #d1d1d1;\\n    }\\n    table th {\\n      padding:21px 25px 22px 25px;\\n      border-top:1px solid #fafafa;\\n      border-bottom:1px solid #e0e0e0;\\n    }\\n\\n    table th:first-child{\\n      text-align: left;\\n      padding-left:20px;\\n    }\\n    table tr:first-child th:first-child{\\n      -moz-border-radius-topleft:3px;\\n      -webkit-border-top-left-radius:3px;\\n      border-top-left-radius:3px;\\n    }\\n    table tr:first-child th:last-child{\\n      -moz-border-radius-topright:3px;\\n      -webkit-border-top-right-radius:3px;\\n      border-top-right-radius:3px;\\n    }\\n    table tr{\\n      text-align: center;\\n      padding-left:20px;\\n    }\\n    table tr td:first-child{\\n      text-align: left;\\n      padding-left:20px;\\n      border-left: 0;\\n    }\\n    table tr td {\\n      padding:18px;\\n      border-top: 1px solid #ffffff;\\n      border-bottom:1px solid #e0e0e0;\\n      border-left: 1px solid #e0e0e0;\\n    }\\n\\n    tbody tr:nth-child(odd) {\\n      background: #fafafa;\\n    }\\n\\n    tbody tr:nth-child(even) {\\n      background: #f3f3f3;\\n    }\\n\\n    table tr:last-child td{\\n      border-bottom:0;\\n    }\\n\\n    table tr:last-child td:first-child{\\n      -moz-border-radius-bottomleft:3px;\\n      -webkit-border-bottom-left-radius:3px;\\n      border-bottom-left-radius:3px;\\n    }\\n\\n    table tr:last-child td:last-child{\\n      -moz-border-radius-bottomright:3px;\\n      -webkit-border-bottom-right-radius:3px;\\n      border-bottom-right-radius:3px;\\n    }\\n  }\\n}\\n\",\".ui-anglepicker {\\n    width: 52px;\\n    height: 52px;\\n\\n    background: #dbdbdb;\\n    background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiA/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDEgMSIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSI+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkLXVjZ2ctZ2VuZXJhdGVkIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iI2RiZGJkYiIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjIwJSIgc3RvcC1jb2xvcj0iI2UxZTFkZSIgc3RvcC1vcGFjaXR5PSIxIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiNmOGY4ZjMiIHN0b3Atb3BhY2l0eT0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0idXJsKCNncmFkLXVjZ2ctZ2VuZXJhdGVkKSIgLz4KPC9zdmc+);\\n    background: -moz-linear-gradient(top, #dbdbdb 0%, #e1e1de 20%, #f8f8f3 100%);\\n    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#dbdbdb), color-stop(20%,#e1e1de), color-stop(100%,#f8f8f3));\\n    background: -webkit-linear-gradient(top, #dbdbdb 0%,#e1e1de 20%,#f8f8f3 100%);\\n    background: -o-linear-gradient(top, #dbdbdb 0%,#e1e1de 20%,#f8f8f3 100%);\\n    background: -ms-linear-gradient(top, #dbdbdb 0%,#e1e1de 20%,#f8f8f3 100%);\\n    background: linear-gradient(to bottom, #dbdbdb 0%,#e1e1de 20%,#f8f8f3 100%);\\n\\n    border: 2px solid #666;\\n\\n    -moz-box-shadow: inset 0 2px 3px white, inset 0 -1px 2px #fffef8;\\n    -webkit-box-shadow: inset 0 2px 3px white, inset 0 -1px 2px #fffef8;\\n    box-shadow: inset 0 2px 3px white, inset 0 -1px 2px #fffef8;\\n\\n    -moz-border-radius: 50%;\\n    -webkit-border-radius: 50%;\\n    border-radius: 50%;\\n    position: relative;\\n    display: inline-block;\\n}\\n\\n.ui-anglepicker-pointer {\\n    position: absolute;\\n    top: 50%;\\n    left: 50%;\\n    width: 50%;\\n\\n    margin: -2px 0 0 -2px;\\n    -moz-transform-origin: 2px 2px;\\n    -webkit-transform-origin: 2px 2px;\\n    -ms-transform-origin: 2px 2px;\\n    -o-transform-origin: 2px 2px;\\n    transform-origin: 2px 2px;\\n}\\n\\n.ui-anglepicker:hover, .ui-anglepicker.ui-anglepicker-dragging {\\n    border-color: #494949;\\n}\\n\\n.ui-anglepicker-dragging .ui-anglepicker-dot, .ui-anglepicker-dragging .ui-anglepicker-line,\\n.ui-anglepicker:hover .ui-anglepicker-dot, .ui-anglepicker:hover .ui-anglepicker-line {\\n    background: #494949;\\n}\\n\\n.ui-anglepicker-dot {\\n    height: 4px;\\n    width: 4px;\\n    position: absolute;\\n    background: #838383;\\n    -moz-border-radius: 50%;\\n    -webkit-border-radius: 50%;\\n    border-radius: 50%;\\n}\\n\\n.ui-anglepicker-line {\\n  margin-top: 1.5px;\\n  margin-right: -2px;\\n  height: 1px;\\n  background: #838383;\\n}\\n\\n\",\"\\n#tool_shape {\\n  &:hover {\\n\\n  }\\n\\n  &.open{\\n    .dropdown-menu {\\n      -webkit-transform: scale(1, 1);\\n      opacity:1;\\n      transform: scale(1, 1);\\n    }\\n  }\\n\\n  .dropdown-menu {\\n    opacity:0.1;\\n    animation-fill-mode: forwards;\\n    transform: scale(1, 0);\\n    transform-origin: 0 0 ;\\n    display: block;\\n    transition: all 0.2s ease;\\n  }\\n\\n  .tool_shape_entry {\\n    text-align: left;\\n\\n    img{\\n      height:30px;\\n      padding-right:20px;\\n    }\\n\\n    .tool_label{\\n      min-width:95px;\\n      display:inline-block;\\n    }\\n\\n    .tool_shortcut{\\n      color:rgba(0, 0, 0, 0.5);\\n    }\\n  }\\n}\\n\\n\"]}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join('');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === 'string') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || '').concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n  return \"/*# \".concat(data, \" */\");\n}","\"use strict\";\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign\n\n\n  url = url && url.__esModule ? url.default : url;\n\n  if (typeof url !== 'string') {\n    return url;\n  } // If url is already wrapped in quotes, remove them\n\n\n  if (/^['\"].*['\"]$/.test(url)) {\n    // eslint-disable-next-line no-param-reassign\n    url = url.slice(1, -1);\n  }\n\n  if (options.hash) {\n    // eslint-disable-next-line no-param-reassign\n    url += options.hash;\n  } // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n\n\n  if (/[\"'() \\t\\n]/.test(url) || options.needQuotes) {\n    return \"\\\"\".concat(url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n'), \"\\\"\");\n  }\n\n  return url;\n};","export default \"js/webpack/c6e3a236d6d6abcc441bcae6555c2b1b.png\";","export default \"js/webpack/e7c03e12553d61a339c856697dfd9662.png\";","export default \"js/webpack/6f29c1da2cf793e3670975d7699915d2.png\";","export default \"js/webpack/1b00168b538c511778323eb122e251eb.png\";","export default \"js/webpack/d4f4c1861dab6b1e42e43d169adaee20.png\";","export default \"js/webpack/30682bbaeeeb171dcb500d21c05017b0.svg\";","export default \"js/webpack/cab94b7b1c3706082ef46e4725087781.svg\";","export default \"js/webpack/e5804fbc8280337fd4c666d48d872919.svg\";","export default \"js/webpack/b398cd1681c50f688fb37702f713cac7.svg\";","export default \"js/webpack/5baaaf8676f740a32868fa4d816f59e9.svg\";","export default \"js/webpack/1fcdadcfd7310cacaa45fb622622d9e0.gif\";","export default \"js/webpack/2b2a1e2e30b1e6c6b9aa407295ff2b01.gif\";","export default \"js/webpack/e84163ec7f2f96c7f9b6288932caa26a.png\";","export default \"js/webpack/944b0ef3d12dfde1e18d95dc42c80eb5.png\";","export default \"js/webpack/8b43027f47b20503057dfbbaa9401fef.eot\";","export default \"js/webpack/8b43027f47b20503057dfbbaa9401fef.eot\";","export default \"js/webpack/c1e38fd9e0e74ba58f7a2b77ef29fdd3.svg\";","export default \"js/webpack/1e59d2330b4c6deb84b340635ed36249.ttf\";","export default \"js/webpack/20fd1704ea223900efa9fd4e869efb08.woff2\";","export default \"js/webpack/f691f37e57f04c152e2315ab7dbad881.woff\";","/*\n *  Copyright 2011 Twitter, Inc.\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n(function (Hogan) {\n  // Setup regex  assignments\n  // remove whitespace according to Mustache spec\n  var rIsWhitespace = /\\S/,\n      rQuot = /\\\"/g,\n      rNewline =  /\\n/g,\n      rCr = /\\r/g,\n      rSlash = /\\\\/g,\n      rLineSep = /\\u2028/,\n      rParagraphSep = /\\u2029/;\n\n  Hogan.tags = {\n    '#': 1, '^': 2, '<': 3, '$': 4,\n    '/': 5, '!': 6, '>': 7, '=': 8, '_v': 9,\n    '{': 10, '&': 11, '_t': 12\n  };\n\n  Hogan.scan = function scan(text, delimiters) {\n    var len = text.length,\n        IN_TEXT = 0,\n        IN_TAG_TYPE = 1,\n        IN_TAG = 2,\n        state = IN_TEXT,\n        tagType = null,\n        tag = null,\n        buf = '',\n        tokens = [],\n        seenTag = false,\n        i = 0,\n        lineStart = 0,\n        otag = '{{',\n        ctag = '}}';\n\n    function addBuf() {\n      if (buf.length > 0) {\n        tokens.push({tag: '_t', text: new String(buf)});\n        buf = '';\n      }\n    }\n\n    function lineIsWhitespace() {\n      var isAllWhitespace = true;\n      for (var j = lineStart; j < tokens.length; j++) {\n        isAllWhitespace =\n          (Hogan.tags[tokens[j].tag] < Hogan.tags['_v']) ||\n          (tokens[j].tag == '_t' && tokens[j].text.match(rIsWhitespace) === null);\n        if (!isAllWhitespace) {\n          return false;\n        }\n      }\n\n      return isAllWhitespace;\n    }\n\n    function filterLine(haveSeenTag, noNewLine) {\n      addBuf();\n\n      if (haveSeenTag && lineIsWhitespace()) {\n        for (var j = lineStart, next; j < tokens.length; j++) {\n          if (tokens[j].text) {\n            if ((next = tokens[j+1]) && next.tag == '>') {\n              // set indent to token value\n              next.indent = tokens[j].text.toString()\n            }\n            tokens.splice(j, 1);\n          }\n        }\n      } else if (!noNewLine) {\n        tokens.push({tag:'\\n'});\n      }\n\n      seenTag = false;\n      lineStart = tokens.length;\n    }\n\n    function changeDelimiters(text, index) {\n      var close = '=' + ctag,\n          closeIndex = text.indexOf(close, index),\n          delimiters = trim(\n            text.substring(text.indexOf('=', index) + 1, closeIndex)\n          ).split(' ');\n\n      otag = delimiters[0];\n      ctag = delimiters[delimiters.length - 1];\n\n      return closeIndex + close.length - 1;\n    }\n\n    if (delimiters) {\n      delimiters = delimiters.split(' ');\n      otag = delimiters[0];\n      ctag = delimiters[1];\n    }\n\n    for (i = 0; i < len; i++) {\n      if (state == IN_TEXT) {\n        if (tagChange(otag, text, i)) {\n          --i;\n          addBuf();\n          state = IN_TAG_TYPE;\n        } else {\n          if (text.charAt(i) == '\\n') {\n            filterLine(seenTag);\n          } else {\n            buf += text.charAt(i);\n          }\n        }\n      } else if (state == IN_TAG_TYPE) {\n        i += otag.length - 1;\n        tag = Hogan.tags[text.charAt(i + 1)];\n        tagType = tag ? text.charAt(i + 1) : '_v';\n        if (tagType == '=') {\n          i = changeDelimiters(text, i);\n          state = IN_TEXT;\n        } else {\n          if (tag) {\n            i++;\n          }\n          state = IN_TAG;\n        }\n        seenTag = i;\n      } else {\n        if (tagChange(ctag, text, i)) {\n          tokens.push({tag: tagType, n: trim(buf), otag: otag, ctag: ctag,\n                       i: (tagType == '/') ? seenTag - otag.length : i + ctag.length});\n          buf = '';\n          i += ctag.length - 1;\n          state = IN_TEXT;\n          if (tagType == '{') {\n            if (ctag == '}}') {\n              i++;\n            } else {\n              cleanTripleStache(tokens[tokens.length - 1]);\n            }\n          }\n        } else {\n          buf += text.charAt(i);\n        }\n      }\n    }\n\n    filterLine(seenTag, true);\n\n    return tokens;\n  }\n\n  function cleanTripleStache(token) {\n    if (token.n.substr(token.n.length - 1) === '}') {\n      token.n = token.n.substring(0, token.n.length - 1);\n    }\n  }\n\n  function trim(s) {\n    if (s.trim) {\n      return s.trim();\n    }\n\n    return s.replace(/^\\s*|\\s*$/g, '');\n  }\n\n  function tagChange(tag, text, index) {\n    if (text.charAt(index) != tag.charAt(0)) {\n      return false;\n    }\n\n    for (var i = 1, l = tag.length; i < l; i++) {\n      if (text.charAt(index + i) != tag.charAt(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // the tags allowed inside super templates\n  var allowedInSuper = {'_t': true, '\\n': true, '$': true, '/': true};\n\n  function buildTree(tokens, kind, stack, customTags) {\n    var instructions = [],\n        opener = null,\n        tail = null,\n        token = null;\n\n    tail = stack[stack.length - 1];\n\n    while (tokens.length > 0) {\n      token = tokens.shift();\n\n      if (tail && tail.tag == '<' && !(token.tag in allowedInSuper)) {\n        throw new Error('Illegal content in < super tag.');\n      }\n\n      if (Hogan.tags[token.tag] <= Hogan.tags['$'] || isOpener(token, customTags)) {\n        stack.push(token);\n        token.nodes = buildTree(tokens, token.tag, stack, customTags);\n      } else if (token.tag == '/') {\n        if (stack.length === 0) {\n          throw new Error('Closing tag without opener: /' + token.n);\n        }\n        opener = stack.pop();\n        if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {\n          throw new Error('Nesting error: ' + opener.n + ' vs. ' + token.n);\n        }\n        opener.end = token.i;\n        return instructions;\n      } else if (token.tag == '\\n') {\n        token.last = (tokens.length == 0) || (tokens[0].tag == '\\n');\n      }\n\n      instructions.push(token);\n    }\n\n    if (stack.length > 0) {\n      throw new Error('missing closing tag: ' + stack.pop().n);\n    }\n\n    return instructions;\n  }\n\n  function isOpener(token, tags) {\n    for (var i = 0, l = tags.length; i < l; i++) {\n      if (tags[i].o == token.n) {\n        token.tag = '#';\n        return true;\n      }\n    }\n  }\n\n  function isCloser(close, open, tags) {\n    for (var i = 0, l = tags.length; i < l; i++) {\n      if (tags[i].c == close && tags[i].o == open) {\n        return true;\n      }\n    }\n  }\n\n  function stringifySubstitutions(obj) {\n    var items = [];\n    for (var key in obj) {\n      items.push('\"' + esc(key) + '\": function(c,p,t,i) {' + obj[key] + '}');\n    }\n    return \"{ \" + items.join(\",\") + \" }\";\n  }\n\n  function stringifyPartials(codeObj) {\n    var partials = [];\n    for (var key in codeObj.partials) {\n      partials.push('\"' + esc(key) + '\":{name:\"' + esc(codeObj.partials[key].name) + '\", ' + stringifyPartials(codeObj.partials[key]) + \"}\");\n    }\n    return \"partials: {\" + partials.join(\",\") + \"}, subs: \" + stringifySubstitutions(codeObj.subs);\n  }\n\n  Hogan.stringify = function(codeObj, text, options) {\n    return \"{code: function (c,p,i) { \" + Hogan.wrapMain(codeObj.code) + \" },\" + stringifyPartials(codeObj) +  \"}\";\n  }\n\n  var serialNo = 0;\n  Hogan.generate = function(tree, text, options) {\n    serialNo = 0;\n    var context = { code: '', subs: {}, partials: {} };\n    Hogan.walk(tree, context);\n\n    if (options.asString) {\n      return this.stringify(context, text, options);\n    }\n\n    return this.makeTemplate(context, text, options);\n  }\n\n  Hogan.wrapMain = function(code) {\n    return 'var t=this;t.b(i=i||\"\");' + code + 'return t.fl();';\n  }\n\n  Hogan.template = Hogan.Template;\n\n  Hogan.makeTemplate = function(codeObj, text, options) {\n    var template = this.makePartials(codeObj);\n    template.code = new Function('c', 'p', 'i', this.wrapMain(codeObj.code));\n    return new this.template(template, text, this, options);\n  }\n\n  Hogan.makePartials = function(codeObj) {\n    var key, template = {subs: {}, partials: codeObj.partials, name: codeObj.name};\n    for (key in template.partials) {\n      template.partials[key] = this.makePartials(template.partials[key]);\n    }\n    for (key in codeObj.subs) {\n      template.subs[key] = new Function('c', 'p', 't', 'i', codeObj.subs[key]);\n    }\n    return template;\n  }\n\n  function esc(s) {\n    return s.replace(rSlash, '\\\\\\\\')\n            .replace(rQuot, '\\\\\\\"')\n            .replace(rNewline, '\\\\n')\n            .replace(rCr, '\\\\r')\n            .replace(rLineSep, '\\\\u2028')\n            .replace(rParagraphSep, '\\\\u2029');\n  }\n\n  function chooseMethod(s) {\n    return (~s.indexOf('.')) ? 'd' : 'f';\n  }\n\n  function createPartial(node, context) {\n    var prefix = \"<\" + (context.prefix || \"\");\n    var sym = prefix + node.n + serialNo++;\n    context.partials[sym] = {name: node.n, partials: {}};\n    context.code += 't.b(t.rp(\"' +  esc(sym) + '\",c,p,\"' + (node.indent || '') + '\"));';\n    return sym;\n  }\n\n  Hogan.codegen = {\n    '#': function(node, context) {\n      context.code += 'if(t.s(t.' + chooseMethod(node.n) + '(\"' + esc(node.n) + '\",c,p,1),' +\n                      'c,p,0,' + node.i + ',' + node.end + ',\"' + node.otag + \" \" + node.ctag + '\")){' +\n                      't.rs(c,p,' + 'function(c,p,t){';\n      Hogan.walk(node.nodes, context);\n      context.code += '});c.pop();}';\n    },\n\n    '^': function(node, context) {\n      context.code += 'if(!t.s(t.' + chooseMethod(node.n) + '(\"' + esc(node.n) + '\",c,p,1),c,p,1,0,0,\"\")){';\n      Hogan.walk(node.nodes, context);\n      context.code += '};';\n    },\n\n    '>': createPartial,\n    '<': function(node, context) {\n      var ctx = {partials: {}, code: '', subs: {}, inPartial: true};\n      Hogan.walk(node.nodes, ctx);\n      var template = context.partials[createPartial(node, context)];\n      template.subs = ctx.subs;\n      template.partials = ctx.partials;\n    },\n\n    '$': function(node, context) {\n      var ctx = {subs: {}, code: '', partials: context.partials, prefix: node.n};\n      Hogan.walk(node.nodes, ctx);\n      context.subs[node.n] = ctx.code;\n      if (!context.inPartial) {\n        context.code += 't.sub(\"' + esc(node.n) + '\",c,p,i);';\n      }\n    },\n\n    '\\n': function(node, context) {\n      context.code += write('\"\\\\n\"' + (node.last ? '' : ' + i'));\n    },\n\n    '_v': function(node, context) {\n      context.code += 't.b(t.v(t.' + chooseMethod(node.n) + '(\"' + esc(node.n) + '\",c,p,0)));';\n    },\n\n    '_t': function(node, context) {\n      context.code += write('\"' + esc(node.text) + '\"');\n    },\n\n    '{': tripleStache,\n\n    '&': tripleStache\n  }\n\n  function tripleStache(node, context) {\n    context.code += 't.b(t.t(t.' + chooseMethod(node.n) + '(\"' + esc(node.n) + '\",c,p,0)));';\n  }\n\n  function write(s) {\n    return 't.b(' + s + ');';\n  }\n\n  Hogan.walk = function(nodelist, context) {\n    var func;\n    for (var i = 0, l = nodelist.length; i < l; i++) {\n      func = Hogan.codegen[nodelist[i].tag];\n      func && func(nodelist[i], context);\n    }\n    return context;\n  }\n\n  Hogan.parse = function(tokens, text, options) {\n    options = options || {};\n    return buildTree(tokens, '', [], options.sectionTags || []);\n  }\n\n  Hogan.cache = {};\n\n  Hogan.cacheKey = function(text, options) {\n    return [text, !!options.asString, !!options.disableLambda, options.delimiters, !!options.modelGet].join('||');\n  }\n\n  Hogan.compile = function(text, options) {\n    options = options || {};\n    var key = Hogan.cacheKey(text, options);\n    var template = this.cache[key];\n\n    if (template) {\n      var partials = template.partials;\n      for (var name in partials) {\n        delete partials[name].instance;\n      }\n      return template;\n    }\n\n    template = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);\n    return this.cache[key] = template;\n  }\n})(typeof exports !== 'undefined' ? exports : Hogan);\n","/*\n *  Copyright 2011 Twitter, Inc.\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n// This file is for use with Node.js. See dist/ for browser files.\n\nvar Hogan = require('./compiler');\nHogan.Template = require('./template').Template;\nHogan.template = Hogan.Template;\nmodule.exports = Hogan;\n","/*\n *  Copyright 2011 Twitter, Inc.\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\nvar Hogan = {};\n\n(function (Hogan) {\n  Hogan.Template = function (codeObj, text, compiler, options) {\n    codeObj = codeObj || {};\n    this.r = codeObj.code || this.r;\n    this.c = compiler;\n    this.options = options || {};\n    this.text = text || '';\n    this.partials = codeObj.partials || {};\n    this.subs = codeObj.subs || {};\n    this.buf = '';\n  }\n\n  Hogan.Template.prototype = {\n    // render: replaced by generated code.\n    r: function (context, partials, indent) { return ''; },\n\n    // variable escaping\n    v: hoganEscape,\n\n    // triple stache\n    t: coerceToString,\n\n    render: function render(context, partials, indent) {\n      return this.ri([context], partials || {}, indent);\n    },\n\n    // render internal -- a hook for overrides that catches partials too\n    ri: function (context, partials, indent) {\n      return this.r(context, partials, indent);\n    },\n\n    // ensurePartial\n    ep: function(symbol, partials) {\n      var partial = this.partials[symbol];\n\n      // check to see that if we've instantiated this partial before\n      var template = partials[partial.name];\n      if (partial.instance && partial.base == template) {\n        return partial.instance;\n      }\n\n      if (typeof template == 'string') {\n        if (!this.c) {\n          throw new Error(\"No compiler available.\");\n        }\n        template = this.c.compile(template, this.options);\n      }\n\n      if (!template) {\n        return null;\n      }\n\n      // We use this to check whether the partials dictionary has changed\n      this.partials[symbol].base = template;\n\n      if (partial.subs) {\n        // Make sure we consider parent template now\n        if (!partials.stackText) partials.stackText = {};\n        for (key in partial.subs) {\n          if (!partials.stackText[key]) {\n            partials.stackText[key] = (this.activeSub !== undefined && partials.stackText[this.activeSub]) ? partials.stackText[this.activeSub] : this.text;\n          }\n        }\n        template = createSpecializedPartial(template, partial.subs, partial.partials,\n          this.stackSubs, this.stackPartials, partials.stackText);\n      }\n      this.partials[symbol].instance = template;\n\n      return template;\n    },\n\n    // tries to find a partial in the current scope and render it\n    rp: function(symbol, context, partials, indent) {\n      var partial = this.ep(symbol, partials);\n      if (!partial) {\n        return '';\n      }\n\n      return partial.ri(context, partials, indent);\n    },\n\n    // render a section\n    rs: function(context, partials, section) {\n      var tail = context[context.length - 1];\n\n      if (!isArray(tail)) {\n        section(context, partials, this);\n        return;\n      }\n\n      for (var i = 0; i < tail.length; i++) {\n        context.push(tail[i]);\n        section(context, partials, this);\n        context.pop();\n      }\n    },\n\n    // maybe start a section\n    s: function(val, ctx, partials, inverted, start, end, tags) {\n      var pass;\n\n      if (isArray(val) && val.length === 0) {\n        return false;\n      }\n\n      if (typeof val == 'function') {\n        val = this.ms(val, ctx, partials, inverted, start, end, tags);\n      }\n\n      pass = !!val;\n\n      if (!inverted && pass && ctx) {\n        ctx.push((typeof val == 'object') ? val : ctx[ctx.length - 1]);\n      }\n\n      return pass;\n    },\n\n    // find values with dotted names\n    d: function(key, ctx, partials, returnFound) {\n      var found,\n          names = key.split('.'),\n          val = this.f(names[0], ctx, partials, returnFound),\n          doModelGet = this.options.modelGet,\n          cx = null;\n\n      if (key === '.' && isArray(ctx[ctx.length - 2])) {\n        val = ctx[ctx.length - 1];\n      } else {\n        for (var i = 1; i < names.length; i++) {\n          found = findInScope(names[i], val, doModelGet);\n          if (found !== undefined) {\n            cx = val;\n            val = found;\n          } else {\n            val = '';\n          }\n        }\n      }\n\n      if (returnFound && !val) {\n        return false;\n      }\n\n      if (!returnFound && typeof val == 'function') {\n        ctx.push(cx);\n        val = this.mv(val, ctx, partials);\n        ctx.pop();\n      }\n\n      return val;\n    },\n\n    // find values with normal names\n    f: function(key, ctx, partials, returnFound) {\n      var val = false,\n          v = null,\n          found = false,\n          doModelGet = this.options.modelGet;\n\n      for (var i = ctx.length - 1; i >= 0; i--) {\n        v = ctx[i];\n        val = findInScope(key, v, doModelGet);\n        if (val !== undefined) {\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        return (returnFound) ? false : \"\";\n      }\n\n      if (!returnFound && typeof val == 'function') {\n        val = this.mv(val, ctx, partials);\n      }\n\n      return val;\n    },\n\n    // higher order templates\n    ls: function(func, cx, partials, text, tags) {\n      var oldTags = this.options.delimiters;\n\n      this.options.delimiters = tags;\n      this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));\n      this.options.delimiters = oldTags;\n\n      return false;\n    },\n\n    // compile text\n    ct: function(text, cx, partials) {\n      if (this.options.disableLambda) {\n        throw new Error('Lambda features disabled.');\n      }\n      return this.c.compile(text, this.options).render(cx, partials);\n    },\n\n    // template result buffering\n    b: function(s) { this.buf += s; },\n\n    fl: function() { var r = this.buf; this.buf = ''; return r; },\n\n    // method replace section\n    ms: function(func, ctx, partials, inverted, start, end, tags) {\n      var textSource,\n          cx = ctx[ctx.length - 1],\n          result = func.call(cx);\n\n      if (typeof result == 'function') {\n        if (inverted) {\n          return true;\n        } else {\n          textSource = (this.activeSub && this.subsText && this.subsText[this.activeSub]) ? this.subsText[this.activeSub] : this.text;\n          return this.ls(result, cx, partials, textSource.substring(start, end), tags);\n        }\n      }\n\n      return result;\n    },\n\n    // method replace variable\n    mv: function(func, ctx, partials) {\n      var cx = ctx[ctx.length - 1];\n      var result = func.call(cx);\n\n      if (typeof result == 'function') {\n        return this.ct(coerceToString(result.call(cx)), cx, partials);\n      }\n\n      return result;\n    },\n\n    sub: function(name, context, partials, indent) {\n      var f = this.subs[name];\n      if (f) {\n        this.activeSub = name;\n        f(context, partials, this, indent);\n        this.activeSub = false;\n      }\n    }\n\n  };\n\n  //Find a key in an object\n  function findInScope(key, scope, doModelGet) {\n    var val;\n\n    if (scope && typeof scope == 'object') {\n\n      if (scope[key] !== undefined) {\n        val = scope[key];\n\n      // try lookup with get for backbone or similar model data\n      } else if (doModelGet && scope.get && typeof scope.get == 'function') {\n        val = scope.get(key);\n      }\n    }\n\n    return val;\n  }\n\n  function createSpecializedPartial(instance, subs, partials, stackSubs, stackPartials, stackText) {\n    function PartialTemplate() {};\n    PartialTemplate.prototype = instance;\n    function Substitutions() {};\n    Substitutions.prototype = instance.subs;\n    var key;\n    var partial = new PartialTemplate();\n    partial.subs = new Substitutions();\n    partial.subsText = {};  //hehe. substext.\n    partial.buf = '';\n\n    stackSubs = stackSubs || {};\n    partial.stackSubs = stackSubs;\n    partial.subsText = stackText;\n    for (key in subs) {\n      if (!stackSubs[key]) stackSubs[key] = subs[key];\n    }\n    for (key in stackSubs) {\n      partial.subs[key] = stackSubs[key];\n    }\n\n    stackPartials = stackPartials || {};\n    partial.stackPartials = stackPartials;\n    for (key in partials) {\n      if (!stackPartials[key]) stackPartials[key] = partials[key];\n    }\n    for (key in stackPartials) {\n      partial.partials[key] = stackPartials[key];\n    }\n\n    return partial;\n  }\n\n  var rAmp = /&/g,\n      rLt = /</g,\n      rGt = />/g,\n      rApos = /\\'/g,\n      rQuot = /\\\"/g,\n      hChars = /[&<>\\\"\\']/;\n\n  function coerceToString(val) {\n    return String((val === null || val === undefined) ? '' : val);\n  }\n\n  function hoganEscape(str) {\n    str = coerceToString(str);\n    return hChars.test(str) ?\n      str\n        .replace(rAmp, '&amp;')\n        .replace(rLt, '&lt;')\n        .replace(rGt, '&gt;')\n        .replace(rApos, '&#39;')\n        .replace(rQuot, '&quot;') :\n      str;\n  }\n\n  var isArray = Array.isArray || function(a) {\n    return Object.prototype.toString.call(a) === '[object Array]';\n  };\n\n})(typeof exports !== 'undefined' ? exports : Hogan);\n","/**\n * JSTS. See https://github.com/bjornharrtell/jsts\n * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt\n * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt\n * @license\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.jsts = {}));\n}(this, (function (exports) { 'use strict';\n\n  class NumberUtil {\n    static equalsWithTolerance(x1, x2, tolerance) {\n      return Math.abs(x1 - x2) <= tolerance;\n    }\n\n  }\n\n  class Exception {\n    constructor(message) {\n      this.message = message;\n    }\n\n    toString() {\n      return this.message;\n    }\n\n  }\n\n  class IllegalArgumentException extends Exception {}\n\n  class Long {\n    constructor(high, low) {\n      this.low = low || 0;\n      this.high = high || 0;\n    }\n\n    static toBinaryString(i) {\n      let mask;\n      let result = '';\n\n      for (mask = 0x80000000; mask > 0; mask >>>= 1) result += (i.high & mask) === mask ? '1' : '0';\n\n      for (mask = 0x80000000; mask > 0; mask >>>= 1) result += (i.low & mask) === mask ? '1' : '0';\n\n      return result;\n    }\n\n  }\n\n  function Double() {}\n  Double.NaN = NaN;\n\n  Double.isNaN = n => Number.isNaN(n);\n\n  Double.isInfinite = n => !Number.isFinite(n);\n\n  Double.MAX_VALUE = Number.MAX_VALUE;\n  if (typeof Float64Array === 'function' && typeof Int32Array === 'function') // Simple and fast conversion between double and long bits\n    // using TypedArrays and ArrayViewBuffers.\n    (function () {\n      const EXP_BIT_MASK = 0x7ff00000;\n      const SIGNIF_BIT_MASK = 0xFFFFF;\n      const f64buf = new Float64Array(1);\n      const i32buf = new Int32Array(f64buf.buffer);\n\n      Double.doubleToLongBits = function (value) {\n        f64buf[0] = value;\n        let low = i32buf[0] | 0;\n        let high = i32buf[1] | 0; // Check for NaN based on values of bit fields, maximum\n        // exponent and nonzero significand.\n\n        if ((high & EXP_BIT_MASK) === EXP_BIT_MASK && (high & SIGNIF_BIT_MASK) !== 0 && low !== 0) {\n          low = 0 | 0;\n          high = 0x7ff80000 | 0;\n        }\n\n        return new Long(high, low);\n      };\n\n      Double.longBitsToDouble = function (bits) {\n        i32buf[0] = bits.low;\n        i32buf[1] = bits.high;\n        return f64buf[0];\n      };\n    })();else // More complex and slower fallback implementation using\n    // math and the divide-by-two and multiply-by-two algorithms.\n    (function () {\n      const BIAS = 1023;\n      const log2 = Math.log2;\n      const floor = Math.floor;\n      const pow = Math.pow;\n\n      const MAX_REL_BITS_INTEGER = function () {\n        for (let i = 53; i > 0; i--) {\n          const bits = pow(2, i) - 1;\n          if (floor(log2(bits)) + 1 === i) return bits;\n        }\n\n        return 0;\n      }();\n\n      Double.doubleToLongBits = function (value) {\n        let x, y, f, bits, skip;\n        let sign, exp, high, low; // Get the sign bit and absolute value.\n\n        if (value < 0 || 1 / value === Number.NEGATIVE_INFINITY) {\n          sign = 1 << 31;\n          value = -value;\n        } else {\n          sign = 0;\n        } // Handle some special values.\n\n\n        if (value === 0) {\n          // Handle zeros (+/-0).\n          low = 0 | 0;\n          high = sign; // exponent: 00..00, significand: 00..00\n\n          return new Long(high, low);\n        }\n\n        if (value === Infinity) {\n          // Handle infinity (only positive values for value possible).\n          low = 0 | 0;\n          high = sign | 0x7ff00000; // exponent: 11..11, significand: 00..00\n\n          return new Long(high, low);\n        }\n\n        if (value !== value) {\n          // eslint-disable-line\n          // Handle NaNs (boiled down to only one distinct NaN).\n          low = 0 | 0;\n          high = 0x7ff80000; // exponent: 11..11, significand: 10..00\n\n          return new Long(high, low);\n        } // Preinitialize variables, that are not neccessarily set by\n        // the algorithm.\n\n\n        bits = 0;\n        low = 0 | 0; // Get the (always positive) integer part of value.\n\n        x = floor(value); // Process the integer part if it's greater than 1. Zero requires\n        // no bits at all, 1 represents the implicit (hidden) leading bit,\n        // which must not be written as well.\n\n        if (x > 1) // If we can reliably determine the number of bits required for\n          // the integer part,\n          if (x <= MAX_REL_BITS_INTEGER) {\n            // get the number of bits required to represent it minus 1\n            bits = floor(log2(x));\n            /* + 1 - 1 */\n            // and simply copy/shift the integer bits into low and high.\n            // That's much faster than the divide-by-two algorithm (saves\n            // up to ~60%).\n            // We always need to mask out the most significant bit, which\n            // is the implicit (aka hidden) bit.\n\n            if (bits <= 20) {\n              // The simple case in which the integer fits into the\n              // lower 20 bits of the high word is worth to be handled\n              // separately (saves ~25%).\n              low = 0 | 0;\n              high = x << 20 - bits & 0xfffff;\n            } else {\n              // Here, the integer part is split into low and high.\n              // Since its value may require more than 32 bits, we\n              // cannot use bitwise operators (which implicitly cast\n              // to Int32), but use arithmetic operators % and / to\n              // get low and high parts. The uppper 20 bits go to high,\n              // the remaining bits (in f) to low.\n              f = bits - 20; // Like (1 << f) but safe with even more than 32 bits.\n\n              y = pow(2, f);\n              low = x % y << 32 - f;\n              high = x / y & 0xfffff;\n            }\n          } else {\n            // For greater values, we must use the much slower divide-by-two\n            // algorithm. Bits are generated from right to left, that is from\n            // least to most significant bit. For each bit, we left-shift both\n            // low and high by one and carry bit #0 from high to #31 in low.\n            // The next bit is then copied into bit #19 in high, the leftmost\n            // bit of the double's significand.\n            // Preserve x for later user, so work with f.\n            f = x;\n            low = 0 | 0;\n\n            for (;;) {\n              y = f / 2;\n              f = floor(y);\n              if (f === 0) // We just found the most signigicant (1-)bit, which\n                // is the implicit bit and so, not stored in the double\n                // value. So, it's time to leave the loop.\n                break; // Count this bit, shift low and carry bit #0 from high.\n\n              bits++;\n              low >>>= 1;\n              low |= (high & 0x1) << 31; // Shift high.\n\n              high >>>= 1;\n              if (y !== f) // Copy the new bit into bit #19 in high (only required if 1).\n                high |= 0x80000;\n            }\n          } // Bias the exponent.\n\n        exp = bits + BIAS; // If the integer part is zero, we've not yet seen the implicit\n        // leading bit. Variable skip is later used while processing the\n        // fractional part (if any).\n\n        skip = x === 0; // Get fraction only into x.\n\n        x = value - x; // If some significand bits are still left to be filled and\n        // the fractional part is not zero, convert the fraction using\n        // the multiply-by-2 algorithm.\n\n        if (bits < 52 && x !== 0) {\n          // Initialize 'buffer' f, into which newly created bits get\n          // shifted from right to left.\n          f = 0;\n\n          for (;;) {\n            y = x * 2;\n\n            if (y >= 1) {\n              // This is a new 1-bit. Add and count this bit, if not\n              // prohibited by skip.\n              x = y - 1;\n\n              if (!skip) {\n                f <<= 1;\n                f |= 1;\n                bits++;\n              } else {\n                // Otherwise, decrement the exponent and unset\n                // skip, so that all following bits get written.\n                exp--;\n                skip = false;\n              }\n            } else {\n              // This is a new 0-bit. Add and count this bit, if not\n              // prohibited by skip.\n              x = y;\n\n              if (!skip) {\n                f <<= 1;\n                bits++;\n              } else if (--exp === 0) {\n                // Otherwise we've just decremented the exponent. If the\n                // biased exponent is zero now (-1023), we process a\n                // subnormal number, which has no impled leading 1-bit.\n                // So, count this 0-bit and unset skip to write out\n                // all the following bits.\n                bits++;\n                skip = false;\n              }\n            }\n\n            if (bits === 20) {\n              // When 20 bits have been created in total, we're done with\n              // the high word. Copy the bits from 'buffer' f into high\n              // and reset 'buffer' f. Following bits will end up in the\n              // low word.\n              high |= f;\n              f = 0;\n            } else if (bits === 52) {\n              // When 52 bits have been created in total, we're done with\n              // low word as well. Copy the bits from 'buffer' f into low\n              // and exit the loop.\n              low |= f;\n              break;\n            }\n\n            if (y === 1) {\n              // When y is exactly 1, there is no remainder and the process\n              // is complete (the number is finite). Copy the bits from\n              // 'buffer' f into either low or high and exit the loop.\n              if (bits < 20) high |= f << 20 - bits;else if (bits < 52) low |= f << 52 - bits;\n              break;\n            }\n          }\n        } // Copy/shift the exponent and sign bits into the high word.\n\n\n        high |= exp << 20;\n        high |= sign;\n        return new Long(high, low);\n      };\n\n      Double.longBitsToDouble = function (bits) {\n        let i;\n        let x, exp, fract;\n        const high = bits.high;\n        const low = bits.low; // Extract the sign.\n\n        const sign = high & 1 << 31 ? -1 : 1; // Extract the unbiased exponent.\n\n        exp = ((high & 0x7ff00000) >> 20) - BIAS; // Calculate the fraction from left to right. Start\n        // off with the 20 lower bits from the high word.\n\n        fract = 0;\n        x = 1 << 19;\n\n        for (i = 1; i <= 20; i++) {\n          if (high & x) fract += pow(2, -i);\n          x >>>= 1;\n        } // Continue with all 32 bits from the low word.\n\n\n        x = 1 << 31;\n\n        for (i = 21; i <= 52; i++) {\n          if (low & x) fract += pow(2, -i);\n          x >>>= 1;\n        } // Handle special values.\n        // Check for zero and subnormal values.\n\n\n        if (exp === -BIAS) {\n          if (fract === 0) // +/-1.0 * 0.0 => +/-0.0\n            return sign * 0;\n          exp = -1022;\n        } else if (exp === BIAS + 1) {\n          // Check for +/-Infinity or NaN.\n          if (fract === 0) // +/-1.0 / 0.0 => +/-Infinity\n            return sign / 0;\n          return NaN;\n        } else {\n          // Nothing special? Seems to be a normal number.\n          // Add the implicit leading bit (1*2^0).\n          fract += 1;\n        }\n\n        return sign * fract * pow(2, exp);\n      };\n    })();\n\n  function Comparable() {}\n\n  function Clonable() {}\n\n  function Comparator() {}\n\n  function Serializable() {}\n\n  class RuntimeException extends Exception {}\n\n  class AssertionFailedException extends RuntimeException {\n    constructor() {\n      super();\n      AssertionFailedException.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      if (arguments.length === 0) {\n        RuntimeException.constructor_.call(this);\n      } else if (arguments.length === 1) {\n        const message = arguments[0];\n        RuntimeException.constructor_.call(this, message);\n      }\n    }\n\n  }\n\n  class Assert {\n    static shouldNeverReachHere() {\n      if (arguments.length === 0) {\n        Assert.shouldNeverReachHere(null);\n      } else if (arguments.length === 1) {\n        const message = arguments[0];\n        throw new AssertionFailedException('Should never reach here' + (message !== null ? ': ' + message : ''));\n      }\n    }\n\n    static isTrue() {\n      if (arguments.length === 1) {\n        const assertion = arguments[0];\n        Assert.isTrue(assertion, null);\n      } else if (arguments.length === 2) {\n        const assertion = arguments[0],\n              message = arguments[1];\n        if (!assertion) if (message === null) throw new AssertionFailedException();else throw new AssertionFailedException(message);\n      }\n    }\n\n    static equals() {\n      if (arguments.length === 2) {\n        const expectedValue = arguments[0],\n              actualValue = arguments[1];\n        Assert.equals(expectedValue, actualValue, null);\n      } else if (arguments.length === 3) {\n        const expectedValue = arguments[0],\n              actualValue = arguments[1],\n              message = arguments[2];\n        if (!actualValue.equals(expectedValue)) throw new AssertionFailedException('Expected ' + expectedValue + ' but encountered ' + actualValue + (message !== null ? ': ' + message : ''));\n      }\n    }\n\n  }\n\n  const kBuf = new ArrayBuffer(8);\n  const kBufAsF64 = new Float64Array(kBuf);\n  const kBufAsI32 = new Int32Array(kBuf);\n  class Coordinate {\n    constructor() {\n      Coordinate.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.x = null;\n      this.y = null;\n      this.z = null;\n\n      if (arguments.length === 0) {\n        Coordinate.constructor_.call(this, 0.0, 0.0);\n      } else if (arguments.length === 1) {\n        const c = arguments[0];\n        Coordinate.constructor_.call(this, c.x, c.y, c.getZ());\n      } else if (arguments.length === 2) {\n        const x = arguments[0],\n              y = arguments[1];\n        Coordinate.constructor_.call(this, x, y, Coordinate.NULL_ORDINATE);\n      } else if (arguments.length === 3) {\n        const x = arguments[0],\n              y = arguments[1],\n              z = arguments[2];\n        this.x = x;\n        this.y = y;\n        this.z = z;\n      }\n    }\n\n    static hashCode(n) {\n      kBufAsF64[0] = n;\n      return kBufAsI32[0] ^ kBufAsI32[1];\n    }\n\n    getM() {\n      return Double.NaN;\n    }\n\n    setOrdinate(ordinateIndex, value) {\n      switch (ordinateIndex) {\n        case Coordinate.X:\n          this.x = value;\n          break;\n\n        case Coordinate.Y:\n          this.y = value;\n          break;\n\n        case Coordinate.Z:\n          this.setZ(value);\n          break;\n\n        default:\n          throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex);\n      }\n    }\n\n    equals2D() {\n      if (arguments.length === 1) {\n        const other = arguments[0];\n        if (this.x !== other.x) return false;\n        if (this.y !== other.y) return false;\n        return true;\n      } else if (arguments.length === 2) {\n        const c = arguments[0],\n              tolerance = arguments[1];\n        if (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) return false;\n        if (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) return false;\n        return true;\n      }\n    }\n\n    setM(m) {\n      throw new IllegalArgumentException('Invalid ordinate index: ' + Coordinate.M);\n    }\n\n    getZ() {\n      return this.z;\n    }\n\n    getOrdinate(ordinateIndex) {\n      switch (ordinateIndex) {\n        case Coordinate.X:\n          return this.x;\n\n        case Coordinate.Y:\n          return this.y;\n\n        case Coordinate.Z:\n          return this.getZ();\n      }\n\n      throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex);\n    }\n\n    equals3D(other) {\n      return this.x === other.x && this.y === other.y && (this.getZ() === other.getZ() || Double.isNaN(this.getZ()) && Double.isNaN(other.getZ()));\n    }\n\n    equals(other) {\n      if (!(other instanceof Coordinate)) return false;\n      return this.equals2D(other);\n    }\n\n    equalInZ(c, tolerance) {\n      return NumberUtil.equalsWithTolerance(this.getZ(), c.getZ(), tolerance);\n    }\n\n    setX(x) {\n      this.x = x;\n    }\n\n    compareTo(o) {\n      const other = o;\n      if (this.x < other.x) return -1;\n      if (this.x > other.x) return 1;\n      if (this.y < other.y) return -1;\n      if (this.y > other.y) return 1;\n      return 0;\n    }\n\n    getX() {\n      return this.x;\n    }\n\n    setZ(z) {\n      this.z = z;\n    }\n\n    clone() {\n      try {\n        const coord = null;\n        return coord;\n      } catch (e) {\n        if (e instanceof CloneNotSupportedException) {\n          Assert.shouldNeverReachHere('this shouldn\\'t happen because this class is Cloneable');\n          return null;\n        } else {\n          throw e;\n        }\n      } finally {}\n    }\n\n    copy() {\n      return new Coordinate(this);\n    }\n\n    toString() {\n      return '(' + this.x + ', ' + this.y + ', ' + this.getZ() + ')';\n    }\n\n    distance3D(c) {\n      const dx = this.x - c.x;\n      const dy = this.y - c.y;\n      const dz = this.getZ() - c.getZ();\n      return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n\n    getY() {\n      return this.y;\n    }\n\n    setY(y) {\n      this.y = y;\n    }\n\n    distance(c) {\n      const dx = this.x - c.x;\n      const dy = this.y - c.y;\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    hashCode() {\n      let result = 17;\n      result = 37 * result + Coordinate.hashCode(this.x);\n      result = 37 * result + Coordinate.hashCode(this.y);\n      return result;\n    }\n\n    setCoordinate(other) {\n      this.x = other.x;\n      this.y = other.y;\n      this.z = other.getZ();\n    }\n\n    get interfaces_() {\n      return [Comparable, Clonable, Serializable];\n    }\n\n  }\n\n  class DimensionalComparator {\n    constructor() {\n      DimensionalComparator.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._dimensionsToTest = 2;\n\n      if (arguments.length === 0) {\n        DimensionalComparator.constructor_.call(this, 2);\n      } else if (arguments.length === 1) {\n        const dimensionsToTest = arguments[0];\n        if (dimensionsToTest !== 2 && dimensionsToTest !== 3) throw new IllegalArgumentException('only 2 or 3 dimensions may be specified');\n        this._dimensionsToTest = dimensionsToTest;\n      }\n    }\n\n    static compare(a, b) {\n      if (a < b) return -1;\n      if (a > b) return 1;\n\n      if (Double.isNaN(a)) {\n        if (Double.isNaN(b)) return 0;\n        return -1;\n      }\n\n      if (Double.isNaN(b)) return 1;\n      return 0;\n    }\n\n    compare(c1, c2) {\n      const compX = DimensionalComparator.compare(c1.x, c2.x);\n      if (compX !== 0) return compX;\n      const compY = DimensionalComparator.compare(c1.y, c2.y);\n      if (compY !== 0) return compY;\n      if (this._dimensionsToTest <= 2) return 0;\n      const compZ = DimensionalComparator.compare(c1.getZ(), c2.getZ());\n      return compZ;\n    }\n\n    get interfaces_() {\n      return [Comparator];\n    }\n\n  }\n\n  Coordinate.DimensionalComparator = DimensionalComparator;\n  Coordinate.NULL_ORDINATE = Double.NaN;\n  Coordinate.X = 0;\n  Coordinate.Y = 1;\n  Coordinate.Z = 2;\n  Coordinate.M = 3;\n\n  function hasInterface (o, i) {\n    return o.interfaces_ && o.interfaces_.indexOf(i) > -1;\n  }\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html\n   */\n  class Collection {\n    /**\n       * Ensures that this collection contains the specified element (optional\n       * operation).\n       * @param {Object} e\n       * @return {boolean}\n       */\n    add() {}\n    /**\n       * Appends all of the elements in the specified collection to the end of this\n       * list, in the order that they are returned by the specified collection's\n       * iterator (optional operation).\n       * @param {javascript.util.Collection} c\n       * @return {boolean}\n       */\n\n\n    addAll() {}\n    /**\n       * Returns true if this collection contains no elements.\n       * @return {boolean}\n       */\n\n\n    isEmpty() {}\n    /**\n       * Returns an iterator over the elements in this collection.\n       * @return {javascript.util.Iterator}\n       */\n\n\n    iterator() {}\n    /**\n       * Returns an iterator over the elements in this collection.\n       * @return {number}\n       */\n\n\n    size() {}\n    /**\n       * Returns an array containing all of the elements in this collection.\n       * @return {Array}\n       */\n\n\n    toArray() {}\n    /**\n       * Removes a single instance of the specified element from this collection if it\n       * is present. (optional)\n       * @param {Object} e\n       * @return {boolean}\n       */\n\n\n    remove() {}\n\n  }\n\n  class IndexOutOfBoundsException extends Exception {}\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html\n   */\n\n  class List extends Collection {\n    /**\n       * Returns the element at the specified position in this list.\n       * @param {number} index\n       * @return {Object}\n       */\n    get() {}\n    /**\n       * Replaces the element at the specified position in this list with the\n       * specified element (optional operation).\n       * @param {number} index\n       * @param {Object} e\n       * @return {Object}\n       */\n\n\n    set() {}\n    /**\n       * Returns true if this collection contains no elements.\n       * @return {boolean}\n       */\n\n\n    isEmpty() {}\n\n  }\n\n  class NoSuchElementException extends Exception {}\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html\n   */\n\n  class ArrayList extends List {\n    constructor(o) {\n      super();\n      this.array = [];\n      if (o instanceof Collection) this.addAll(o);\n    }\n\n    get interfaces_() {\n      return [List, Collection];\n    }\n\n    ensureCapacity() {}\n\n    add(e) {\n      if (arguments.length === 1) this.array.push(e);else this.array.splice(arguments[0], 0, arguments[1]);\n      return true;\n    }\n\n    clear() {\n      this.array = [];\n    }\n\n    addAll(c) {\n      for (const e of c) this.array.push(e);\n    }\n\n    set(index, element) {\n      const oldElement = this.array[index];\n      this.array[index] = element;\n      return oldElement;\n    }\n\n    iterator() {\n      return new Iterator(this);\n    }\n\n    get(index) {\n      if (index < 0 || index >= this.size()) throw new IndexOutOfBoundsException();\n      return this.array[index];\n    }\n\n    isEmpty() {\n      return this.array.length === 0;\n    }\n\n    sort(comparator) {\n      if (comparator) this.array.sort((a, b) => comparator.compare(a, b));else this.array.sort();\n    }\n\n    size() {\n      return this.array.length;\n    }\n\n    toArray() {\n      return this.array.slice();\n    }\n\n    remove(o) {\n      for (let i = 0, len = this.array.length; i < len; i++) if (this.array[i] === o) return !!this.array.splice(i, 1);\n\n      return false;\n    }\n\n    [Symbol.iterator]() {\n      return this.array.values();\n    }\n\n  }\n\n  class Iterator {\n    constructor(arrayList) {\n      this.arrayList = arrayList;\n      this.position = 0;\n    }\n\n    next() {\n      if (this.position === this.arrayList.size()) throw new NoSuchElementException();\n      return this.arrayList.get(this.position++);\n    }\n\n    hasNext() {\n      return this.position < this.arrayList.size();\n    }\n\n    set(element) {\n      return this.arrayList.set(this.position - 1, element);\n    }\n\n    remove() {\n      this.arrayList.remove(this.arrayList.get(this.position));\n    }\n\n  }\n\n  class CoordinateList extends ArrayList {\n    constructor() {\n      super();\n      CoordinateList.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      if (arguments.length === 0) ; else if (arguments.length === 1) {\n        const coord = arguments[0];\n        this.ensureCapacity(coord.length);\n        this.add(coord, true);\n      } else if (arguments.length === 2) {\n        const coord = arguments[0],\n              allowRepeated = arguments[1];\n        this.ensureCapacity(coord.length);\n        this.add(coord, allowRepeated);\n      }\n    }\n\n    getCoordinate(i) {\n      return this.get(i);\n    }\n\n    addAll() {\n      if (arguments.length === 2 && typeof arguments[1] === 'boolean' && hasInterface(arguments[0], Collection)) {\n        const coll = arguments[0],\n              allowRepeated = arguments[1];\n        let isChanged = false;\n\n        for (let i = coll.iterator(); i.hasNext();) {\n          this.add(i.next(), allowRepeated);\n          isChanged = true;\n        }\n\n        return isChanged;\n      } else {\n        return super.addAll.apply(this, arguments);\n      }\n    }\n\n    clone() {\n      const clone = super.clone.call(this);\n\n      for (let i = 0; i < this.size(); i++) clone.add(i, this.get(i).clone());\n\n      return clone;\n    }\n\n    toCoordinateArray() {\n      if (arguments.length === 0) {\n        return this.toArray(CoordinateList.coordArrayType);\n      } else if (arguments.length === 1) {\n        const isForward = arguments[0];\n        if (isForward) return this.toArray(CoordinateList.coordArrayType);\n        const size = this.size();\n        const pts = new Array(size).fill(null);\n\n        for (let i = 0; i < size; i++) pts[i] = this.get(size - i - 1);\n\n        return pts;\n      }\n    }\n\n    add() {\n      if (arguments.length === 1) {\n        const coord = arguments[0];\n        return super.add.call(this, coord);\n      } else if (arguments.length === 2) {\n        if (arguments[0] instanceof Array && typeof arguments[1] === 'boolean') {\n          const coord = arguments[0],\n                allowRepeated = arguments[1];\n          this.add(coord, allowRepeated, true);\n          return true;\n        } else if (arguments[0] instanceof Coordinate && typeof arguments[1] === 'boolean') {\n          const coord = arguments[0],\n                allowRepeated = arguments[1];\n          if (!allowRepeated) if (this.size() >= 1) {\n            const last = this.get(this.size() - 1);\n            if (last.equals2D(coord)) return null;\n          }\n          super.add.call(this, coord);\n        } else if (arguments[0] instanceof Object && typeof arguments[1] === 'boolean') {\n          const obj = arguments[0],\n                allowRepeated = arguments[1];\n          this.add(obj, allowRepeated);\n          return true;\n        }\n      } else if (arguments.length === 3) {\n        if (typeof arguments[2] === 'boolean' && arguments[0] instanceof Array && typeof arguments[1] === 'boolean') {\n          const coord = arguments[0],\n                allowRepeated = arguments[1],\n                direction = arguments[2];\n          if (direction) for (let i = 0; i < coord.length; i++) this.add(coord[i], allowRepeated);else for (let i = coord.length - 1; i >= 0; i--) this.add(coord[i], allowRepeated);\n          return true;\n        } else if (typeof arguments[2] === 'boolean' && Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate) {\n          const i = arguments[0],\n                coord = arguments[1],\n                allowRepeated = arguments[2];\n\n          if (!allowRepeated) {\n            const size = this.size();\n\n            if (size > 0) {\n              if (i > 0) {\n                const prev = this.get(i - 1);\n                if (prev.equals2D(coord)) return null;\n              }\n\n              if (i < size) {\n                const next = this.get(i);\n                if (next.equals2D(coord)) return null;\n              }\n            }\n          }\n\n          super.add.call(this, i, coord);\n        }\n      } else if (arguments.length === 4) {\n        const coord = arguments[0],\n              allowRepeated = arguments[1],\n              start = arguments[2],\n              end = arguments[3];\n        let inc = 1;\n        if (start > end) inc = -1;\n\n        for (let i = start; i !== end; i += inc) this.add(coord[i], allowRepeated);\n\n        return true;\n      }\n    }\n\n    closeRing() {\n      if (this.size() > 0) {\n        const duplicate = this.get(0).copy();\n        this.add(duplicate, false);\n      }\n    }\n\n  }\n  CoordinateList.coordArrayType = new Array(0).fill(null);\n\n  class CoordinateSequenceFilter {\n    filter(seq, i) {}\n\n    isDone() {}\n\n    isGeometryChanged() {}\n\n  }\n\n  class Envelope {\n    constructor() {\n      Envelope.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._minx = null;\n      this._maxx = null;\n      this._miny = null;\n      this._maxy = null;\n\n      if (arguments.length === 0) {\n        this.init();\n      } else if (arguments.length === 1) {\n        if (arguments[0] instanceof Coordinate) {\n          const p = arguments[0];\n          this.init(p.x, p.x, p.y, p.y);\n        } else if (arguments[0] instanceof Envelope) {\n          const env = arguments[0];\n          this.init(env);\n        }\n      } else if (arguments.length === 2) {\n        const p1 = arguments[0],\n              p2 = arguments[1];\n        this.init(p1.x, p2.x, p1.y, p2.y);\n      } else if (arguments.length === 4) {\n        const x1 = arguments[0],\n              x2 = arguments[1],\n              y1 = arguments[2],\n              y2 = arguments[3];\n        this.init(x1, x2, y1, y2);\n      }\n    }\n\n    static intersects() {\n      if (arguments.length === 3) {\n        const p1 = arguments[0],\n              p2 = arguments[1],\n              q = arguments[2];\n        if (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y)) return true;\n        return false;\n      } else if (arguments.length === 4) {\n        const p1 = arguments[0],\n              p2 = arguments[1],\n              q1 = arguments[2],\n              q2 = arguments[3];\n        let minq = Math.min(q1.x, q2.x);\n        let maxq = Math.max(q1.x, q2.x);\n        let minp = Math.min(p1.x, p2.x);\n        let maxp = Math.max(p1.x, p2.x);\n        if (minp > maxq) return false;\n        if (maxp < minq) return false;\n        minq = Math.min(q1.y, q2.y);\n        maxq = Math.max(q1.y, q2.y);\n        minp = Math.min(p1.y, p2.y);\n        maxp = Math.max(p1.y, p2.y);\n        if (minp > maxq) return false;\n        if (maxp < minq) return false;\n        return true;\n      }\n    }\n\n    getArea() {\n      return this.getWidth() * this.getHeight();\n    }\n\n    equals(other) {\n      if (!(other instanceof Envelope)) return false;\n      const otherEnvelope = other;\n      if (this.isNull()) return otherEnvelope.isNull();\n      return this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY();\n    }\n\n    intersection(env) {\n      if (this.isNull() || env.isNull() || !this.intersects(env)) return new Envelope();\n      const intMinX = this._minx > env._minx ? this._minx : env._minx;\n      const intMinY = this._miny > env._miny ? this._miny : env._miny;\n      const intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;\n      const intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;\n      return new Envelope(intMinX, intMaxX, intMinY, intMaxY);\n    }\n\n    isNull() {\n      return this._maxx < this._minx;\n    }\n\n    getMaxX() {\n      return this._maxx;\n    }\n\n    covers() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof Coordinate) {\n          const p = arguments[0];\n          return this.covers(p.x, p.y);\n        } else if (arguments[0] instanceof Envelope) {\n          const other = arguments[0];\n          if (this.isNull() || other.isNull()) return false;\n          return other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy;\n        }\n      } else if (arguments.length === 2) {\n        const x = arguments[0],\n              y = arguments[1];\n        if (this.isNull()) return false;\n        return x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy;\n      }\n    }\n\n    intersects() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof Envelope) {\n          const other = arguments[0];\n          if (this.isNull() || other.isNull()) return false;\n          return !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny);\n        } else if (arguments[0] instanceof Coordinate) {\n          const p = arguments[0];\n          return this.intersects(p.x, p.y);\n        }\n      } else if (arguments.length === 2) {\n        if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n          const a = arguments[0],\n                b = arguments[1];\n          if (this.isNull()) return false;\n          const envminx = a.x < b.x ? a.x : b.x;\n          if (envminx > this._maxx) return false;\n          const envmaxx = a.x > b.x ? a.x : b.x;\n          if (envmaxx < this._minx) return false;\n          const envminy = a.y < b.y ? a.y : b.y;\n          if (envminy > this._maxy) return false;\n          const envmaxy = a.y > b.y ? a.y : b.y;\n          if (envmaxy < this._miny) return false;\n          return true;\n        } else if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n          const x = arguments[0],\n                y = arguments[1];\n          if (this.isNull()) return false;\n          return !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny);\n        }\n      }\n    }\n\n    getMinY() {\n      return this._miny;\n    }\n\n    getDiameter() {\n      if (this.isNull()) return 0;\n      const w = this.getWidth();\n      const h = this.getHeight();\n      return Math.sqrt(w * w + h * h);\n    }\n\n    getMinX() {\n      return this._minx;\n    }\n\n    expandToInclude() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof Coordinate) {\n          const p = arguments[0];\n          this.expandToInclude(p.x, p.y);\n        } else if (arguments[0] instanceof Envelope) {\n          const other = arguments[0];\n          if (other.isNull()) return null;\n\n          if (this.isNull()) {\n            this._minx = other.getMinX();\n            this._maxx = other.getMaxX();\n            this._miny = other.getMinY();\n            this._maxy = other.getMaxY();\n          } else {\n            if (other._minx < this._minx) this._minx = other._minx;\n            if (other._maxx > this._maxx) this._maxx = other._maxx;\n            if (other._miny < this._miny) this._miny = other._miny;\n            if (other._maxy > this._maxy) this._maxy = other._maxy;\n          }\n        }\n      } else if (arguments.length === 2) {\n        const x = arguments[0],\n              y = arguments[1];\n\n        if (this.isNull()) {\n          this._minx = x;\n          this._maxx = x;\n          this._miny = y;\n          this._maxy = y;\n        } else {\n          if (x < this._minx) this._minx = x;\n          if (x > this._maxx) this._maxx = x;\n          if (y < this._miny) this._miny = y;\n          if (y > this._maxy) this._maxy = y;\n        }\n      }\n    }\n\n    minExtent() {\n      if (this.isNull()) return 0.0;\n      const w = this.getWidth();\n      const h = this.getHeight();\n      if (w < h) return w;\n      return h;\n    }\n\n    getWidth() {\n      if (this.isNull()) return 0;\n      return this._maxx - this._minx;\n    }\n\n    compareTo(o) {\n      const env = o;\n\n      if (this.isNull()) {\n        if (env.isNull()) return 0;\n        return -1;\n      } else {\n        if (env.isNull()) return 1;\n      }\n\n      if (this._minx < env._minx) return -1;\n      if (this._minx > env._minx) return 1;\n      if (this._miny < env._miny) return -1;\n      if (this._miny > env._miny) return 1;\n      if (this._maxx < env._maxx) return -1;\n      if (this._maxx > env._maxx) return 1;\n      if (this._maxy < env._maxy) return -1;\n      if (this._maxy > env._maxy) return 1;\n      return 0;\n    }\n\n    translate(transX, transY) {\n      if (this.isNull()) return null;\n      this.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);\n    }\n\n    copy() {\n      return new Envelope(this);\n    }\n\n    toString() {\n      return 'Env[' + this._minx + ' : ' + this._maxx + ', ' + this._miny + ' : ' + this._maxy + ']';\n    }\n\n    setToNull() {\n      this._minx = 0;\n      this._maxx = -1;\n      this._miny = 0;\n      this._maxy = -1;\n    }\n\n    disjoint(other) {\n      if (this.isNull() || other.isNull()) return true;\n      return other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny;\n    }\n\n    getHeight() {\n      if (this.isNull()) return 0;\n      return this._maxy - this._miny;\n    }\n\n    maxExtent() {\n      if (this.isNull()) return 0.0;\n      const w = this.getWidth();\n      const h = this.getHeight();\n      if (w > h) return w;\n      return h;\n    }\n\n    expandBy() {\n      if (arguments.length === 1) {\n        const distance = arguments[0];\n        this.expandBy(distance, distance);\n      } else if (arguments.length === 2) {\n        const deltaX = arguments[0],\n              deltaY = arguments[1];\n        if (this.isNull()) return null;\n        this._minx -= deltaX;\n        this._maxx += deltaX;\n        this._miny -= deltaY;\n        this._maxy += deltaY;\n        if (this._minx > this._maxx || this._miny > this._maxy) this.setToNull();\n      }\n    }\n\n    contains() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof Envelope) {\n          const other = arguments[0];\n          return this.covers(other);\n        } else if (arguments[0] instanceof Coordinate) {\n          const p = arguments[0];\n          return this.covers(p);\n        }\n      } else if (arguments.length === 2) {\n        const x = arguments[0],\n              y = arguments[1];\n        return this.covers(x, y);\n      }\n    }\n\n    centre() {\n      if (this.isNull()) return null;\n      return new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0);\n    }\n\n    init() {\n      if (arguments.length === 0) {\n        this.setToNull();\n      } else if (arguments.length === 1) {\n        if (arguments[0] instanceof Coordinate) {\n          const p = arguments[0];\n          this.init(p.x, p.x, p.y, p.y);\n        } else if (arguments[0] instanceof Envelope) {\n          const env = arguments[0];\n          this._minx = env._minx;\n          this._maxx = env._maxx;\n          this._miny = env._miny;\n          this._maxy = env._maxy;\n        }\n      } else if (arguments.length === 2) {\n        const p1 = arguments[0],\n              p2 = arguments[1];\n        this.init(p1.x, p2.x, p1.y, p2.y);\n      } else if (arguments.length === 4) {\n        const x1 = arguments[0],\n              x2 = arguments[1],\n              y1 = arguments[2],\n              y2 = arguments[3];\n\n        if (x1 < x2) {\n          this._minx = x1;\n          this._maxx = x2;\n        } else {\n          this._minx = x2;\n          this._maxx = x1;\n        }\n\n        if (y1 < y2) {\n          this._miny = y1;\n          this._maxy = y2;\n        } else {\n          this._miny = y2;\n          this._maxy = y1;\n        }\n      }\n    }\n\n    getMaxY() {\n      return this._maxy;\n    }\n\n    distance(env) {\n      if (this.intersects(env)) return 0;\n      let dx = 0.0;\n      if (this._maxx < env._minx) dx = env._minx - this._maxx;else if (this._minx > env._maxx) dx = this._minx - env._maxx;\n      let dy = 0.0;\n      if (this._maxy < env._miny) dy = env._miny - this._maxy;else if (this._miny > env._maxy) dy = this._miny - env._maxy;\n      if (dx === 0.0) return dy;\n      if (dy === 0.0) return dx;\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    hashCode() {\n      let result = 17;\n      result = 37 * result + Coordinate.hashCode(this._minx);\n      result = 37 * result + Coordinate.hashCode(this._maxx);\n      result = 37 * result + Coordinate.hashCode(this._miny);\n      result = 37 * result + Coordinate.hashCode(this._maxy);\n      return result;\n    }\n\n    get interfaces_() {\n      return [Comparable, Serializable];\n    }\n\n  }\n\n  class StringBuffer {\n    constructor(str) {\n      this.str = str;\n    }\n\n    append(e) {\n      this.str += e;\n    }\n\n    setCharAt(i, c) {\n      this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);\n    }\n\n    toString() {\n      return this.str;\n    }\n\n  }\n\n  class Integer {\n    constructor(value) {\n      this.value = value;\n    }\n\n    intValue() {\n      return this.value;\n    }\n\n    compareTo(o) {\n      if (this.value < o) return -1;\n      if (this.value > o) return 1;\n      return 0;\n    }\n\n    static compare(x, y) {\n      if (x < y) return -1;\n      if (x > y) return 1;\n      return 0;\n    }\n\n    static isNan(n) {\n      return Number.isNaN(n);\n    }\n\n    static valueOf(value) {\n      return new Integer(value);\n    }\n\n  }\n\n  class Character {\n    static isWhitespace(c) {\n      return c <= 32 && c >= 0 || c === 127;\n    }\n\n    static toUpperCase(c) {\n      return c.toUpperCase();\n    }\n\n  }\n\n  class DD {\n    constructor() {\n      DD.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._hi = 0.0;\n      this._lo = 0.0;\n\n      if (arguments.length === 0) {\n        this.init(0.0);\n      } else if (arguments.length === 1) {\n        if (typeof arguments[0] === 'number') {\n          const x = arguments[0];\n          this.init(x);\n        } else if (arguments[0] instanceof DD) {\n          const dd = arguments[0];\n          this.init(dd);\n        } else if (typeof arguments[0] === 'string') {\n          const str = arguments[0];\n          DD.constructor_.call(this, DD.parse(str));\n        }\n      } else if (arguments.length === 2) {\n        const hi = arguments[0],\n              lo = arguments[1];\n        this.init(hi, lo);\n      }\n    }\n\n    static determinant() {\n      if (typeof arguments[3] === 'number' && typeof arguments[2] === 'number' && typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n        const x1 = arguments[0],\n              y1 = arguments[1],\n              x2 = arguments[2],\n              y2 = arguments[3];\n        return DD.determinant(DD.valueOf(x1), DD.valueOf(y1), DD.valueOf(x2), DD.valueOf(y2));\n      } else if (arguments[3] instanceof DD && arguments[2] instanceof DD && arguments[0] instanceof DD && arguments[1] instanceof DD) {\n        const x1 = arguments[0],\n              y1 = arguments[1],\n              x2 = arguments[2],\n              y2 = arguments[3];\n        const det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n        return det;\n      }\n    }\n\n    static sqr(x) {\n      return DD.valueOf(x).selfMultiply(x);\n    }\n\n    static valueOf() {\n      if (typeof arguments[0] === 'string') {\n        const str = arguments[0];\n        return DD.parse(str);\n      } else if (typeof arguments[0] === 'number') {\n        const x = arguments[0];\n        return new DD(x);\n      }\n    }\n\n    static sqrt(x) {\n      return DD.valueOf(x).sqrt();\n    }\n\n    static parse(str) {\n      let i = 0;\n      const strlen = str.length;\n\n      while (Character.isWhitespace(str.charAt(i))) i++;\n\n      let isNegative = false;\n\n      if (i < strlen) {\n        const signCh = str.charAt(i);\n\n        if (signCh === '-' || signCh === '+') {\n          i++;\n          if (signCh === '-') isNegative = true;\n        }\n      }\n\n      const val = new DD();\n      let numDigits = 0;\n      let numBeforeDec = 0;\n      let exp = 0;\n      let hasDecimalChar = false;\n\n      while (true) {\n        if (i >= strlen) break;\n        const ch = str.charAt(i);\n        i++;\n\n        if (Character.isDigit(ch)) {\n          const d = ch - '0';\n          val.selfMultiply(DD.TEN);\n          val.selfAdd(d);\n          numDigits++;\n          continue;\n        }\n\n        if (ch === '.') {\n          numBeforeDec = numDigits;\n          hasDecimalChar = true;\n          continue;\n        }\n\n        if (ch === 'e' || ch === 'E') {\n          const expStr = str.substring(i);\n\n          try {\n            exp = Integer.parseInt(expStr);\n          } catch (ex) {\n            if (ex instanceof NumberFormatException) throw new NumberFormatException('Invalid exponent ' + expStr + ' in string ' + str);else throw ex;\n          } finally {}\n\n          break;\n        }\n\n        throw new NumberFormatException('Unexpected character \\'' + ch + '\\' at position ' + i + ' in string ' + str);\n      }\n\n      let val2 = val;\n      if (!hasDecimalChar) numBeforeDec = numDigits;\n      const numDecPlaces = numDigits - numBeforeDec - exp;\n\n      if (numDecPlaces === 0) {\n        val2 = val;\n      } else if (numDecPlaces > 0) {\n        const scale = DD.TEN.pow(numDecPlaces);\n        val2 = val.divide(scale);\n      } else if (numDecPlaces < 0) {\n        const scale = DD.TEN.pow(-numDecPlaces);\n        val2 = val.multiply(scale);\n      }\n\n      if (isNegative) return val2.negate();\n      return val2;\n    }\n\n    static createNaN() {\n      return new DD(Double.NaN, Double.NaN);\n    }\n\n    static copy(dd) {\n      return new DD(dd);\n    }\n\n    static magnitude(x) {\n      const xAbs = Math.abs(x);\n      const xLog10 = Math.log(xAbs) / Math.log(10);\n      let xMag = Math.trunc(Math.floor(xLog10));\n      const xApprox = Math.pow(10, xMag);\n      if (xApprox * 10 <= xAbs) xMag += 1;\n      return xMag;\n    }\n\n    static stringOfChar(ch, len) {\n      const buf = new StringBuffer();\n\n      for (let i = 0; i < len; i++) buf.append(ch);\n\n      return buf.toString();\n    }\n\n    le(y) {\n      return this._hi < y._hi || this._hi === y._hi && this._lo <= y._lo;\n    }\n\n    extractSignificantDigits(insertDecimalPoint, magnitude) {\n      let y = this.abs();\n      let mag = DD.magnitude(y._hi);\n      const scale = DD.TEN.pow(mag);\n      y = y.divide(scale);\n\n      if (y.gt(DD.TEN)) {\n        y = y.divide(DD.TEN);\n        mag += 1;\n      } else if (y.lt(DD.ONE)) {\n        y = y.multiply(DD.TEN);\n        mag -= 1;\n      }\n\n      const decimalPointPos = mag + 1;\n      const buf = new StringBuffer();\n      const numDigits = DD.MAX_PRINT_DIGITS - 1;\n\n      for (let i = 0; i <= numDigits; i++) {\n        if (insertDecimalPoint && i === decimalPointPos) buf.append('.');\n        const digit = Math.trunc(y._hi);\n\n        if (digit < 0) break;\n        let rebiasBy10 = false;\n        let digitChar = 0;\n\n        if (digit > 9) {\n          rebiasBy10 = true;\n          digitChar = '9';\n        } else {\n          digitChar = '0' + digit;\n        }\n\n        buf.append(digitChar);\n        y = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);\n        if (rebiasBy10) y.selfAdd(DD.TEN);\n        let continueExtractingDigits = true;\n        const remMag = DD.magnitude(y._hi);\n        if (remMag < 0 && Math.abs(remMag) >= numDigits - i) continueExtractingDigits = false;\n        if (!continueExtractingDigits) break;\n      }\n\n      magnitude[0] = mag;\n      return buf.toString();\n    }\n\n    sqr() {\n      return this.multiply(this);\n    }\n\n    doubleValue() {\n      return this._hi + this._lo;\n    }\n\n    subtract() {\n      if (arguments[0] instanceof DD) {\n        const y = arguments[0];\n        return this.add(y.negate());\n      } else if (typeof arguments[0] === 'number') {\n        const y = arguments[0];\n        return this.add(-y);\n      }\n    }\n\n    equals() {\n      if (arguments.length === 1 && arguments[0] instanceof DD) {\n        const y = arguments[0];\n        return this._hi === y._hi && this._lo === y._lo;\n      }\n    }\n\n    isZero() {\n      return this._hi === 0.0 && this._lo === 0.0;\n    }\n\n    selfSubtract() {\n      if (arguments[0] instanceof DD) {\n        const y = arguments[0];\n        if (this.isNaN()) return this;\n        return this.selfAdd(-y._hi, -y._lo);\n      } else if (typeof arguments[0] === 'number') {\n        const y = arguments[0];\n        if (this.isNaN()) return this;\n        return this.selfAdd(-y, 0.0);\n      }\n    }\n\n    getSpecialNumberString() {\n      if (this.isZero()) return '0.0';\n      if (this.isNaN()) return 'NaN ';\n      return null;\n    }\n\n    min(x) {\n      if (this.le(x)) return this;else return x;\n    }\n\n    selfDivide() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof DD) {\n          const y = arguments[0];\n          return this.selfDivide(y._hi, y._lo);\n        } else if (typeof arguments[0] === 'number') {\n          const y = arguments[0];\n          return this.selfDivide(y, 0.0);\n        }\n      } else if (arguments.length === 2) {\n        const yhi = arguments[0],\n              ylo = arguments[1];\n        let hc = null,\n            tc = null,\n            hy = null,\n            ty = null,\n            C = null,\n            c = null,\n            U = null,\n            u = null;\n        C = this._hi / yhi;\n        c = DD.SPLIT * C;\n        hc = c - C;\n        u = DD.SPLIT * yhi;\n        hc = c - hc;\n        tc = C - hc;\n        hy = u - yhi;\n        U = C * yhi;\n        hy = u - hy;\n        ty = yhi - hy;\n        u = hc * hy - U + hc * ty + tc * hy + tc * ty;\n        c = (this._hi - U - u + this._lo - C * ylo) / yhi;\n        u = C + c;\n        this._hi = u;\n        this._lo = C - u + c;\n        return this;\n      }\n    }\n\n    dump() {\n      return 'DD<' + this._hi + ', ' + this._lo + '>';\n    }\n\n    divide() {\n      if (arguments[0] instanceof DD) {\n        const y = arguments[0];\n        let hc = null,\n            tc = null,\n            hy = null,\n            ty = null,\n            C = null,\n            c = null,\n            U = null,\n            u = null;\n        C = this._hi / y._hi;\n        c = DD.SPLIT * C;\n        hc = c - C;\n        u = DD.SPLIT * y._hi;\n        hc = c - hc;\n        tc = C - hc;\n        hy = u - y._hi;\n        U = C * y._hi;\n        hy = u - hy;\n        ty = y._hi - hy;\n        u = hc * hy - U + hc * ty + tc * hy + tc * ty;\n        c = (this._hi - U - u + this._lo - C * y._lo) / y._hi;\n        u = C + c;\n        const zhi = u;\n        const zlo = C - u + c;\n        return new DD(zhi, zlo);\n      } else if (typeof arguments[0] === 'number') {\n        const y = arguments[0];\n        if (Double.isNaN(y)) return DD.createNaN();\n        return DD.copy(this).selfDivide(y, 0.0);\n      }\n    }\n\n    ge(y) {\n      return this._hi > y._hi || this._hi === y._hi && this._lo >= y._lo;\n    }\n\n    pow(exp) {\n      if (exp === 0.0) return DD.valueOf(1.0);\n      let r = new DD(this);\n      let s = DD.valueOf(1.0);\n      let n = Math.abs(exp);\n      if (n > 1) while (n > 0) {\n        if (n % 2 === 1) s.selfMultiply(r);\n        n /= 2;\n        if (n > 0) r = r.sqr();\n      } else s = r;\n      if (exp < 0) return s.reciprocal();\n      return s;\n    }\n\n    ceil() {\n      if (this.isNaN()) return DD.NaN;\n      const fhi = Math.ceil(this._hi);\n      let flo = 0.0;\n      if (fhi === this._hi) flo = Math.ceil(this._lo);\n      return new DD(fhi, flo);\n    }\n\n    compareTo(o) {\n      const other = o;\n      if (this._hi < other._hi) return -1;\n      if (this._hi > other._hi) return 1;\n      if (this._lo < other._lo) return -1;\n      if (this._lo > other._lo) return 1;\n      return 0;\n    }\n\n    rint() {\n      if (this.isNaN()) return this;\n      const plus5 = this.add(0.5);\n      return plus5.floor();\n    }\n\n    setValue() {\n      if (arguments[0] instanceof DD) {\n        const value = arguments[0];\n        this.init(value);\n        return this;\n      } else if (typeof arguments[0] === 'number') {\n        const value = arguments[0];\n        this.init(value);\n        return this;\n      }\n    }\n\n    max(x) {\n      if (this.ge(x)) return this;else return x;\n    }\n\n    sqrt() {\n      if (this.isZero()) return DD.valueOf(0.0);\n      if (this.isNegative()) return DD.NaN;\n      const x = 1.0 / Math.sqrt(this._hi);\n      const ax = this._hi * x;\n      const axdd = DD.valueOf(ax);\n      const diffSq = this.subtract(axdd.sqr());\n      const d2 = diffSq._hi * (x * 0.5);\n      return axdd.add(d2);\n    }\n\n    selfAdd() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof DD) {\n          const y = arguments[0];\n          return this.selfAdd(y._hi, y._lo);\n        } else if (typeof arguments[0] === 'number') {\n          const y = arguments[0];\n          let H = null,\n              h = null,\n              S = null,\n              s = null,\n              e = null,\n              f = null;\n          S = this._hi + y;\n          e = S - this._hi;\n          s = S - e;\n          s = y - e + (this._hi - s);\n          f = s + this._lo;\n          H = S + f;\n          h = f + (S - H);\n          this._hi = H + h;\n          this._lo = h + (H - this._hi);\n          return this;\n        }\n      } else if (arguments.length === 2) {\n        const yhi = arguments[0],\n              ylo = arguments[1];\n        let H = null,\n            h = null,\n            T = null,\n            t = null,\n            S = null,\n            s = null,\n            e = null,\n            f = null;\n        S = this._hi + yhi;\n        T = this._lo + ylo;\n        e = S - this._hi;\n        f = T - this._lo;\n        s = S - e;\n        t = T - f;\n        s = yhi - e + (this._hi - s);\n        t = ylo - f + (this._lo - t);\n        e = s + T;\n        H = S + e;\n        h = e + (S - H);\n        e = t + h;\n        const zhi = H + e;\n        const zlo = e + (H - zhi);\n        this._hi = zhi;\n        this._lo = zlo;\n        return this;\n      }\n    }\n\n    selfMultiply() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof DD) {\n          const y = arguments[0];\n          return this.selfMultiply(y._hi, y._lo);\n        } else if (typeof arguments[0] === 'number') {\n          const y = arguments[0];\n          return this.selfMultiply(y, 0.0);\n        }\n      } else if (arguments.length === 2) {\n        const yhi = arguments[0],\n              ylo = arguments[1];\n        let hx = null,\n            tx = null,\n            hy = null,\n            ty = null,\n            C = null,\n            c = null;\n        C = DD.SPLIT * this._hi;\n        hx = C - this._hi;\n        c = DD.SPLIT * yhi;\n        hx = C - hx;\n        tx = this._hi - hx;\n        hy = c - yhi;\n        C = this._hi * yhi;\n        hy = c - hy;\n        ty = yhi - hy;\n        c = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);\n        const zhi = C + c;\n        hx = C - zhi;\n        const zlo = c + hx;\n        this._hi = zhi;\n        this._lo = zlo;\n        return this;\n      }\n    }\n\n    selfSqr() {\n      return this.selfMultiply(this);\n    }\n\n    floor() {\n      if (this.isNaN()) return DD.NaN;\n      const fhi = Math.floor(this._hi);\n      let flo = 0.0;\n      if (fhi === this._hi) flo = Math.floor(this._lo);\n      return new DD(fhi, flo);\n    }\n\n    negate() {\n      if (this.isNaN()) return this;\n      return new DD(-this._hi, -this._lo);\n    }\n\n    clone() {\n      try {\n        return null;\n      } catch (ex) {\n        if (ex instanceof CloneNotSupportedException) return null;else throw ex;\n      } finally {}\n    }\n\n    multiply() {\n      if (arguments[0] instanceof DD) {\n        const y = arguments[0];\n        if (y.isNaN()) return DD.createNaN();\n        return DD.copy(this).selfMultiply(y);\n      } else if (typeof arguments[0] === 'number') {\n        const y = arguments[0];\n        if (Double.isNaN(y)) return DD.createNaN();\n        return DD.copy(this).selfMultiply(y, 0.0);\n      }\n    }\n\n    isNaN() {\n      return Double.isNaN(this._hi);\n    }\n\n    intValue() {\n      return Math.trunc(this._hi);\n    }\n\n    toString() {\n      const mag = DD.magnitude(this._hi);\n      if (mag >= -3 && mag <= 20) return this.toStandardNotation();\n      return this.toSciNotation();\n    }\n\n    toStandardNotation() {\n      const specialStr = this.getSpecialNumberString();\n      if (specialStr !== null) return specialStr;\n      const magnitude = new Array(1).fill(null);\n      const sigDigits = this.extractSignificantDigits(true, magnitude);\n      const decimalPointPos = magnitude[0] + 1;\n      let num = sigDigits;\n\n      if (sigDigits.charAt(0) === '.') {\n        num = '0' + sigDigits;\n      } else if (decimalPointPos < 0) {\n        num = '0.' + DD.stringOfChar('0', -decimalPointPos) + sigDigits;\n      } else if (sigDigits.indexOf('.') === -1) {\n        const numZeroes = decimalPointPos - sigDigits.length;\n        const zeroes = DD.stringOfChar('0', numZeroes);\n        num = sigDigits + zeroes + '.0';\n      }\n\n      if (this.isNegative()) return '-' + num;\n      return num;\n    }\n\n    reciprocal() {\n      let hc = null,\n          tc = null,\n          hy = null,\n          ty = null,\n          C = null,\n          c = null,\n          U = null,\n          u = null;\n      C = 1.0 / this._hi;\n      c = DD.SPLIT * C;\n      hc = c - C;\n      u = DD.SPLIT * this._hi;\n      hc = c - hc;\n      tc = C - hc;\n      hy = u - this._hi;\n      U = C * this._hi;\n      hy = u - hy;\n      ty = this._hi - hy;\n      u = hc * hy - U + hc * ty + tc * hy + tc * ty;\n      c = (1.0 - U - u - C * this._lo) / this._hi;\n      const zhi = C + c;\n      const zlo = C - zhi + c;\n      return new DD(zhi, zlo);\n    }\n\n    toSciNotation() {\n      if (this.isZero()) return DD.SCI_NOT_ZERO;\n      const specialStr = this.getSpecialNumberString();\n      if (specialStr !== null) return specialStr;\n      const magnitude = new Array(1).fill(null);\n      const digits = this.extractSignificantDigits(false, magnitude);\n      const expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];\n      if (digits.charAt(0) === '0') throw new IllegalStateException('Found leading zero: ' + digits);\n      let trailingDigits = '';\n      if (digits.length > 1) trailingDigits = digits.substring(1);\n      const digitsWithDecimal = digits.charAt(0) + '.' + trailingDigits;\n      if (this.isNegative()) return '-' + digitsWithDecimal + expStr;\n      return digitsWithDecimal + expStr;\n    }\n\n    abs() {\n      if (this.isNaN()) return DD.NaN;\n      if (this.isNegative()) return this.negate();\n      return new DD(this);\n    }\n\n    isPositive() {\n      return this._hi > 0.0 || this._hi === 0.0 && this._lo > 0.0;\n    }\n\n    lt(y) {\n      return this._hi < y._hi || this._hi === y._hi && this._lo < y._lo;\n    }\n\n    add() {\n      if (arguments[0] instanceof DD) {\n        const y = arguments[0];\n        return DD.copy(this).selfAdd(y);\n      } else if (typeof arguments[0] === 'number') {\n        const y = arguments[0];\n        return DD.copy(this).selfAdd(y);\n      }\n    }\n\n    init() {\n      if (arguments.length === 1) {\n        if (typeof arguments[0] === 'number') {\n          const x = arguments[0];\n          this._hi = x;\n          this._lo = 0.0;\n        } else if (arguments[0] instanceof DD) {\n          const dd = arguments[0];\n          this._hi = dd._hi;\n          this._lo = dd._lo;\n        }\n      } else if (arguments.length === 2) {\n        const hi = arguments[0],\n              lo = arguments[1];\n        this._hi = hi;\n        this._lo = lo;\n      }\n    }\n\n    gt(y) {\n      return this._hi > y._hi || this._hi === y._hi && this._lo > y._lo;\n    }\n\n    isNegative() {\n      return this._hi < 0.0 || this._hi === 0.0 && this._lo < 0.0;\n    }\n\n    trunc() {\n      if (this.isNaN()) return DD.NaN;\n      if (this.isPositive()) return this.floor();else return this.ceil();\n    }\n\n    signum() {\n      if (this._hi > 0) return 1;\n      if (this._hi < 0) return -1;\n      if (this._lo > 0) return 1;\n      if (this._lo < 0) return -1;\n      return 0;\n    }\n\n    get interfaces_() {\n      return [Serializable, Comparable, Clonable];\n    }\n\n  }\n  DD.PI = new DD(3.141592653589793116e+00, 1.224646799147353207e-16);\n  DD.TWO_PI = new DD(6.283185307179586232e+00, 2.449293598294706414e-16);\n  DD.PI_2 = new DD(1.570796326794896558e+00, 6.123233995736766036e-17);\n  DD.E = new DD(2.718281828459045091e+00, 1.445646891729250158e-16);\n  DD.NaN = new DD(Double.NaN, Double.NaN);\n  DD.EPS = 1.23259516440783e-32;\n  DD.SPLIT = 134217729.0;\n  DD.MAX_PRINT_DIGITS = 32;\n  DD.TEN = DD.valueOf(10.0);\n  DD.ONE = DD.valueOf(1.0);\n  DD.SCI_NOT_EXPONENT_CHAR = 'E';\n  DD.SCI_NOT_ZERO = '0.0E0';\n\n  class CGAlgorithmsDD {\n    static orientationIndex(p1, p2, q) {\n      const index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);\n      if (index <= 1) return index;\n      const dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);\n      const dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);\n      const dx2 = DD.valueOf(q.x).selfAdd(-p2.x);\n      const dy2 = DD.valueOf(q.y).selfAdd(-p2.y);\n      return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();\n    }\n\n    static signOfDet2x2() {\n      if (arguments[3] instanceof DD && arguments[2] instanceof DD && arguments[0] instanceof DD && arguments[1] instanceof DD) {\n        const x1 = arguments[0],\n              y1 = arguments[1],\n              x2 = arguments[2],\n              y2 = arguments[3];\n        const det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n        return det.signum();\n      } else if (typeof arguments[3] === 'number' && typeof arguments[2] === 'number' && typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n        const dx1 = arguments[0],\n              dy1 = arguments[1],\n              dx2 = arguments[2],\n              dy2 = arguments[3];\n        const x1 = DD.valueOf(dx1);\n        const y1 = DD.valueOf(dy1);\n        const x2 = DD.valueOf(dx2);\n        const y2 = DD.valueOf(dy2);\n        const det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n        return det.signum();\n      }\n    }\n\n    static intersection(p1, p2, q1, q2) {\n      const px = new DD(p1.y).selfSubtract(p2.y);\n      const py = new DD(p2.x).selfSubtract(p1.x);\n      const pw = new DD(p1.x).selfMultiply(p2.y).selfSubtract(new DD(p2.x).selfMultiply(p1.y));\n      const qx = new DD(q1.y).selfSubtract(q2.y);\n      const qy = new DD(q2.x).selfSubtract(q1.x);\n      const qw = new DD(q1.x).selfMultiply(q2.y).selfSubtract(new DD(q2.x).selfMultiply(q1.y));\n      const x = py.multiply(qw).selfSubtract(qy.multiply(pw));\n      const y = qx.multiply(pw).selfSubtract(px.multiply(qw));\n      const w = px.multiply(qy).selfSubtract(qx.multiply(py));\n      const xInt = x.selfDivide(w).doubleValue();\n      const yInt = y.selfDivide(w).doubleValue();\n      if (Double.isNaN(xInt) || Double.isInfinite(xInt) || Double.isNaN(yInt) || Double.isInfinite(yInt)) return null;\n      return new Coordinate(xInt, yInt);\n    }\n\n    static orientationIndexFilter(pa, pb, pc) {\n      let detsum = null;\n      const detleft = (pa.x - pc.x) * (pb.y - pc.y);\n      const detright = (pa.y - pc.y) * (pb.x - pc.x);\n      const det = detleft - detright;\n      if (detleft > 0.0) {\n        if (detright <= 0.0) return CGAlgorithmsDD.signum(det);else detsum = detleft + detright;\n      } else if (detleft < 0.0) {\n        if (detright >= 0.0) return CGAlgorithmsDD.signum(det);else detsum = -detleft - detright;\n      } else return CGAlgorithmsDD.signum(det);\n      const errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;\n      if (det >= errbound || -det >= errbound) return CGAlgorithmsDD.signum(det);\n      return 2;\n    }\n\n    static signum(x) {\n      if (x > 0) return 1;\n      if (x < 0) return -1;\n      return 0;\n    }\n\n  }\n  CGAlgorithmsDD.DP_SAFE_EPSILON = 1e-15;\n\n  class CoordinateSequence {\n    getM(index) {\n      if (this.hasM()) {\n        const mIndex = this.getDimension() - this.getMeasures();\n        return this.getOrdinate(index, mIndex);\n      } else {\n        return Double.NaN;\n      }\n    }\n\n    setOrdinate(index, ordinateIndex, value) {}\n\n    getZ(index) {\n      if (this.hasZ()) return this.getOrdinate(index, 2);else return Double.NaN;\n    }\n\n    size() {}\n\n    getOrdinate(index, ordinateIndex) {}\n\n    getCoordinate() {\n    }\n\n    getCoordinateCopy(i) {}\n\n    createCoordinate() {}\n\n    getDimension() {}\n\n    hasM() {\n      return this.getMeasures() > 0;\n    }\n\n    getX(index) {}\n\n    hasZ() {\n      return this.getDimension() - this.getMeasures() > 2;\n    }\n\n    getMeasures() {\n      return 0;\n    }\n\n    expandEnvelope(env) {}\n\n    copy() {}\n\n    getY(index) {}\n\n    toCoordinateArray() {}\n\n    get interfaces_() {\n      return [Clonable];\n    }\n\n  }\n  CoordinateSequence.X = 0;\n  CoordinateSequence.Y = 1;\n  CoordinateSequence.Z = 2;\n  CoordinateSequence.M = 3;\n\n  class Orientation {\n    static index(p1, p2, q) {\n      return CGAlgorithmsDD.orientationIndex(p1, p2, q);\n    }\n\n    static isCCW() {\n      if (arguments[0] instanceof Array) {\n        const ring = arguments[0];\n        const nPts = ring.length - 1;\n        if (nPts < 3) throw new IllegalArgumentException('Ring has fewer than 4 points, so orientation cannot be determined');\n        let hiPt = ring[0];\n        let hiIndex = 0;\n\n        for (let i = 1; i <= nPts; i++) {\n          const p = ring[i];\n\n          if (p.y > hiPt.y) {\n            hiPt = p;\n            hiIndex = i;\n          }\n        }\n\n        let iPrev = hiIndex;\n\n        do {\n          iPrev = iPrev - 1;\n          if (iPrev < 0) iPrev = nPts;\n        } while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);\n\n        let iNext = hiIndex;\n\n        do iNext = (iNext + 1) % nPts; while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);\n\n        const prev = ring[iPrev];\n        const next = ring[iNext];\n        if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;\n        const disc = Orientation.index(prev, hiPt, next);\n        let isCCW = null;\n        if (disc === 0) isCCW = prev.x > next.x;else isCCW = disc > 0;\n        return isCCW;\n      } else if (hasInterface(arguments[0], CoordinateSequence)) {\n        const ring = arguments[0];\n        const nPts = ring.size() - 1;\n        if (nPts < 3) throw new IllegalArgumentException('Ring has fewer than 4 points, so orientation cannot be determined');\n        let hiPt = ring.getCoordinate(0);\n        let hiIndex = 0;\n\n        for (let i = 1; i <= nPts; i++) {\n          const p = ring.getCoordinate(i);\n\n          if (p.y > hiPt.y) {\n            hiPt = p;\n            hiIndex = i;\n          }\n        }\n\n        let prev = null;\n        let iPrev = hiIndex;\n\n        do {\n          iPrev = iPrev - 1;\n          if (iPrev < 0) iPrev = nPts;\n          prev = ring.getCoordinate(iPrev);\n        } while (prev.equals2D(hiPt) && iPrev !== hiIndex);\n\n        let next = null;\n        let iNext = hiIndex;\n\n        do {\n          iNext = (iNext + 1) % nPts;\n          next = ring.getCoordinate(iNext);\n        } while (next.equals2D(hiPt) && iNext !== hiIndex);\n\n        if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;\n        const disc = Orientation.index(prev, hiPt, next);\n        let isCCW = null;\n        if (disc === 0) isCCW = prev.x > next.x;else isCCW = disc > 0;\n        return isCCW;\n      }\n    }\n\n  }\n  Orientation.CLOCKWISE = -1;\n  Orientation.RIGHT = Orientation.CLOCKWISE;\n  Orientation.COUNTERCLOCKWISE = 1;\n  Orientation.LEFT = Orientation.COUNTERCLOCKWISE;\n  Orientation.COLLINEAR = 0;\n  Orientation.STRAIGHT = Orientation.COLLINEAR;\n\n  class Intersection {\n    static intersection(p1, p2, q1, q2) {\n      const minX0 = p1.x < p2.x ? p1.x : p2.x;\n      const minY0 = p1.y < p2.y ? p1.y : p2.y;\n      const maxX0 = p1.x > p2.x ? p1.x : p2.x;\n      const maxY0 = p1.y > p2.y ? p1.y : p2.y;\n      const minX1 = q1.x < q2.x ? q1.x : q2.x;\n      const minY1 = q1.y < q2.y ? q1.y : q2.y;\n      const maxX1 = q1.x > q2.x ? q1.x : q2.x;\n      const maxY1 = q1.y > q2.y ? q1.y : q2.y;\n      const intMinX = minX0 > minX1 ? minX0 : minX1;\n      const intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;\n      const intMinY = minY0 > minY1 ? minY0 : minY1;\n      const intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;\n      const midx = (intMinX + intMaxX) / 2.0;\n      const midy = (intMinY + intMaxY) / 2.0;\n      const p1x = p1.x - midx;\n      const p1y = p1.y - midy;\n      const p2x = p2.x - midx;\n      const p2y = p2.y - midy;\n      const q1x = q1.x - midx;\n      const q1y = q1.y - midy;\n      const q2x = q2.x - midx;\n      const q2y = q2.y - midy;\n      const px = p1y - p2y;\n      const py = p2x - p1x;\n      const pw = p1x * p2y - p2x * p1y;\n      const qx = q1y - q2y;\n      const qy = q2x - q1x;\n      const qw = q1x * q2y - q2x * q1y;\n      const x = py * qw - qy * pw;\n      const y = qx * pw - px * qw;\n      const w = px * qy - qx * py;\n      const xInt = x / w;\n      const yInt = y / w;\n      if (Double.isNaN(xInt) || Double.isInfinite(xInt) || Double.isNaN(yInt) || Double.isInfinite(yInt)) return null;\n      return new Coordinate(xInt + midx, yInt + midy);\n    }\n\n  }\n\n  class System {\n    static arraycopy(src, srcPos, dest, destPos, len) {\n      let c = 0;\n\n      for (let i = srcPos; i < srcPos + len; i++) {\n        dest[destPos + c] = src[i];\n        c++;\n      }\n    }\n\n    static getProperty(name) {\n      return {\n        'line.separator': '\\n'\n      }[name];\n    }\n\n  }\n\n  class MathUtil {\n    static log10(x) {\n      const ln = Math.log(x);\n      if (Double.isInfinite(ln)) return ln;\n      if (Double.isNaN(ln)) return ln;\n      return ln / MathUtil.LOG_10;\n    }\n\n    static min(v1, v2, v3, v4) {\n      let min = v1;\n      if (v2 < min) min = v2;\n      if (v3 < min) min = v3;\n      if (v4 < min) min = v4;\n      return min;\n    }\n\n    static clamp() {\n      if (typeof arguments[2] === 'number' && typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n        const x = arguments[0],\n              min = arguments[1],\n              max = arguments[2];\n        if (x < min) return min;\n        if (x > max) return max;\n        return x;\n      } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n        const x = arguments[0],\n              min = arguments[1],\n              max = arguments[2];\n        if (x < min) return min;\n        if (x > max) return max;\n        return x;\n      }\n    }\n\n    static wrap(index, max) {\n      if (index < 0) return max - -index % max;\n      return index % max;\n    }\n\n    static max() {\n      if (arguments.length === 3) {\n        const v1 = arguments[0],\n              v2 = arguments[1],\n              v3 = arguments[2];\n        let max = v1;\n        if (v2 > max) max = v2;\n        if (v3 > max) max = v3;\n        return max;\n      } else if (arguments.length === 4) {\n        const v1 = arguments[0],\n              v2 = arguments[1],\n              v3 = arguments[2],\n              v4 = arguments[3];\n        let max = v1;\n        if (v2 > max) max = v2;\n        if (v3 > max) max = v3;\n        if (v4 > max) max = v4;\n        return max;\n      }\n    }\n\n    static average(x1, x2) {\n      return (x1 + x2) / 2.0;\n    }\n\n  }\n  MathUtil.LOG_10 = Math.log(10);\n\n  class Distance {\n    static segmentToSegment(A, B, C, D) {\n      if (A.equals(B)) return Distance.pointToSegment(A, C, D);\n      if (C.equals(D)) return Distance.pointToSegment(D, A, B);\n      let noIntersection = false;\n\n      if (!Envelope.intersects(A, B, C, D)) {\n        noIntersection = true;\n      } else {\n        const denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);\n\n        if (denom === 0) {\n          noIntersection = true;\n        } else {\n          const r_num = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);\n          const s_num = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);\n          const s = s_num / denom;\n          const r = r_num / denom;\n          if (r < 0 || r > 1 || s < 0 || s > 1) noIntersection = true;\n        }\n      }\n\n      if (noIntersection) return MathUtil.min(Distance.pointToSegment(A, C, D), Distance.pointToSegment(B, C, D), Distance.pointToSegment(C, A, B), Distance.pointToSegment(D, A, B));\n      return 0.0;\n    }\n\n    static pointToSegment(p, A, B) {\n      if (A.x === B.x && A.y === B.y) return p.distance(A);\n      const len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n      const r = ((p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y)) / len2;\n      if (r <= 0.0) return p.distance(A);\n      if (r >= 1.0) return p.distance(B);\n      const s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n      return Math.abs(s) * Math.sqrt(len2);\n    }\n\n    static pointToLinePerpendicular(p, A, B) {\n      const len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n      const s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n      return Math.abs(s) * Math.sqrt(len2);\n    }\n\n    static pointToSegmentString(p, line) {\n      if (line.length === 0) throw new IllegalArgumentException('Line array must contain at least one vertex');\n      let minDistance = p.distance(line[0]);\n\n      for (let i = 0; i < line.length - 1; i++) {\n        const dist = Distance.pointToSegment(p, line[i], line[i + 1]);\n        if (dist < minDistance) minDistance = dist;\n      }\n\n      return minDistance;\n    }\n\n  }\n\n  class CoordinateSequenceFactory {\n    create() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof Array) ; else if (hasInterface(arguments[0], CoordinateSequence)) ;\n      } else if (arguments.length === 2) ; else if (arguments.length === 3) {\n        const size = arguments[0],\n              dimension = arguments[1];\n        return this.create(size, dimension);\n      }\n    }\n\n  }\n\n  class GeometryComponentFilter {\n    filter(geom) {}\n\n  }\n\n  class Geometry {\n    constructor() {\n      Geometry.constructor_.apply(this, arguments);\n    }\n\n    isGeometryCollection() {\n      return this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION;\n    }\n\n    getFactory() {\n      return this._factory;\n    }\n\n    getGeometryN(n) {\n      return this;\n    }\n\n    getArea() {\n      return 0.0;\n    }\n\n    isRectangle() {\n      return false;\n    }\n\n    equalsExact(other) {\n      return this === other || this.equalsExact(other, 0);\n    }\n\n    geometryChanged() {\n      this.apply(Geometry.geometryChangedFilter);\n    }\n\n    geometryChangedAction() {\n      this._envelope = null;\n    }\n\n    equalsNorm(g) {\n      if (g === null) return false;\n      return this.norm().equalsExact(g.norm());\n    }\n\n    getLength() {\n      return 0.0;\n    }\n\n    getNumGeometries() {\n      return 1;\n    }\n\n    compareTo() {\n      let other;\n\n      if (arguments.length === 1) {\n        const o = arguments[0];\n        other = o;\n        if (this.getTypeCode() !== other.getTypeCode()) return this.getTypeCode() - other.getTypeCode();\n        if (this.isEmpty() && other.isEmpty()) return 0;\n        if (this.isEmpty()) return -1;\n        if (other.isEmpty()) return 1;\n        return this.compareToSameClass(o);\n      } else if (arguments.length === 2) {\n        const o = arguments[0];\n        const comp = arguments[1];\n        other = o;\n        if (this.getTypeCode() !== other.getTypeCode()) return this.getTypeCode() - other.getTypeCode();\n        if (this.isEmpty() && other.isEmpty()) return 0;\n        if (this.isEmpty()) return -1;\n        if (other.isEmpty()) return 1;\n        return this.compareToSameClass(o, comp);\n      }\n    }\n\n    getUserData() {\n      return this._userData;\n    }\n\n    getSRID() {\n      return this._SRID;\n    }\n\n    getEnvelope() {\n      return this.getFactory().toGeometry(this.getEnvelopeInternal());\n    }\n\n    checkNotGeometryCollection(g) {\n      if (g.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION) throw new IllegalArgumentException('This method does not support GeometryCollection arguments');\n    }\n\n    equal(a, b, tolerance) {\n      if (tolerance === 0) return a.equals(b);\n      return a.distance(b) <= tolerance;\n    }\n\n    norm() {\n      const copy = this.copy();\n      copy.normalize();\n      return copy;\n    }\n\n    reverse() {\n      const res = this.reverseInternal();\n      if (this.envelope != null) res.envelope = this.envelope.copy();\n      res.setSRID(this.getSRID());\n      return res;\n    }\n\n    copy() {\n      const copy = this.copyInternal();\n      copy.envelope = this._envelope == null ? null : this._envelope.copy();\n      copy._SRID = this._SRID;\n      copy._userData = this._userData;\n      return copy;\n    }\n\n    getPrecisionModel() {\n      return this._factory.getPrecisionModel();\n    }\n\n    getEnvelopeInternal() {\n      if (this._envelope === null) this._envelope = this.computeEnvelopeInternal();\n      return new Envelope(this._envelope);\n    }\n\n    setSRID(SRID) {\n      this._SRID = SRID;\n    }\n\n    setUserData(userData) {\n      this._userData = userData;\n    }\n\n    compare(a, b) {\n      const i = a.iterator();\n      const j = b.iterator();\n\n      while (i.hasNext() && j.hasNext()) {\n        const aElement = i.next();\n        const bElement = j.next();\n        const comparison = aElement.compareTo(bElement);\n        if (comparison !== 0) return comparison;\n      }\n\n      if (i.hasNext()) return 1;\n      if (j.hasNext()) return -1;\n      return 0;\n    }\n\n    hashCode() {\n      return this.getEnvelopeInternal().hashCode();\n    }\n\n    isEquivalentClass(other) {\n      return this.getClass() === other.getClass();\n    }\n\n    isGeometryCollectionOrDerived() {\n      if (this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === Geometry.TYPECODE_MULTIPOINT || this.getTypeCode() === Geometry.TYPECODE_MULTILINESTRING || this.getTypeCode() === Geometry.TYPECODE_MULTIPOLYGON) return true;\n      return false;\n    }\n\n    get interfaces_() {\n      return [Clonable, Comparable, Serializable];\n    }\n\n    getClass() {\n      return Geometry;\n    }\n\n    static hasNonEmptyElements(geometries) {\n      for (let i = 0; i < geometries.length; i++) if (!geometries[i].isEmpty()) return true;\n\n      return false;\n    }\n\n    static hasNullElements(array) {\n      for (let i = 0; i < array.length; i++) if (array[i] === null) return true;\n\n      return false;\n    }\n\n  }\n\n  Geometry.constructor_ = function (factory) {\n    if (!factory) return;\n    this._envelope = null;\n    this._userData = null;\n    this._factory = factory;\n    this._SRID = factory.getSRID();\n  };\n\n  Geometry.TYPECODE_POINT = 0;\n  Geometry.TYPECODE_MULTIPOINT = 1;\n  Geometry.TYPECODE_LINESTRING = 2;\n  Geometry.TYPECODE_LINEARRING = 3;\n  Geometry.TYPECODE_MULTILINESTRING = 4;\n  Geometry.TYPECODE_POLYGON = 5;\n  Geometry.TYPECODE_MULTIPOLYGON = 6;\n  Geometry.TYPECODE_GEOMETRYCOLLECTION = 7;\n  Geometry.TYPENAME_POINT = 'Point';\n  Geometry.TYPENAME_MULTIPOINT = 'MultiPoint';\n  Geometry.TYPENAME_LINESTRING = 'LineString';\n  Geometry.TYPENAME_LINEARRING = 'LinearRing';\n  Geometry.TYPENAME_MULTILINESTRING = 'MultiLineString';\n  Geometry.TYPENAME_POLYGON = 'Polygon';\n  Geometry.TYPENAME_MULTIPOLYGON = 'MultiPolygon';\n  Geometry.TYPENAME_GEOMETRYCOLLECTION = 'GeometryCollection';\n  Geometry.geometryChangedFilter = {\n    get interfaces_() {\n      return [GeometryComponentFilter];\n    },\n\n    filter(geom) {\n      geom.geometryChangedAction();\n    }\n\n  };\n\n  class CoordinateFilter {\n    filter(coord) {}\n\n  }\n\n  class Length {\n    static ofLine(pts) {\n      const n = pts.size();\n      if (n <= 1) return 0.0;\n      let len = 0.0;\n      const p = new Coordinate();\n      pts.getCoordinate(0, p);\n      let x0 = p.x;\n      let y0 = p.y;\n\n      for (let i = 1; i < n; i++) {\n        pts.getCoordinate(i, p);\n        const x1 = p.x;\n        const y1 = p.y;\n        const dx = x1 - x0;\n        const dy = y1 - y0;\n        len += Math.sqrt(dx * dx + dy * dy);\n        x0 = x1;\n        y0 = y1;\n      }\n\n      return len;\n    }\n\n  }\n\n  class Lineal {}\n\n  class CoordinateSequences {\n    static copyCoord(src, srcPos, dest, destPos) {\n      const minDim = Math.min(src.getDimension(), dest.getDimension());\n\n      for (let dim = 0; dim < minDim; dim++) dest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));\n    }\n\n    static isRing(seq) {\n      const n = seq.size();\n      if (n === 0) return true;\n      if (n <= 3) return false;\n      return seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n    }\n\n    static scroll() {\n      if (arguments.length === 2) {\n        if (hasInterface(arguments[0], CoordinateSequence) && Number.isInteger(arguments[1])) {\n          const seq = arguments[0],\n                indexOfFirstCoordinate = arguments[1];\n          CoordinateSequences.scroll(seq, indexOfFirstCoordinate, CoordinateSequences.isRing(seq));\n        } else if (hasInterface(arguments[0], CoordinateSequence) && arguments[1] instanceof Coordinate) {\n          const seq = arguments[0],\n                firstCoordinate = arguments[1];\n          const i = CoordinateSequences.indexOf(firstCoordinate, seq);\n          if (i <= 0) return null;\n          CoordinateSequences.scroll(seq, i);\n        }\n      } else if (arguments.length === 3) {\n        const seq = arguments[0],\n              indexOfFirstCoordinate = arguments[1],\n              ensureRing = arguments[2];\n        const i = indexOfFirstCoordinate;\n        if (i <= 0) return null;\n        const copy = seq.copy();\n        const last = ensureRing ? seq.size() - 1 : seq.size();\n\n        for (let j = 0; j < last; j++) for (let k = 0; k < seq.getDimension(); k++) seq.setOrdinate(j, k, copy.getOrdinate((indexOfFirstCoordinate + j) % last, k));\n\n        if (ensureRing) for (let k = 0; k < seq.getDimension(); k++) seq.setOrdinate(last, k, seq.getOrdinate(0, k));\n      }\n    }\n\n    static isEqual(cs1, cs2) {\n      const cs1Size = cs1.size();\n      const cs2Size = cs2.size();\n      if (cs1Size !== cs2Size) return false;\n      const dim = Math.min(cs1.getDimension(), cs2.getDimension());\n\n      for (let i = 0; i < cs1Size; i++) for (let d = 0; d < dim; d++) {\n        const v1 = cs1.getOrdinate(i, d);\n        const v2 = cs2.getOrdinate(i, d);\n        if (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) continue;\n        if (Double.isNaN(v1) && Double.isNaN(v2)) continue;\n        return false;\n      }\n\n      return true;\n    }\n\n    static minCoordinateIndex() {\n      if (arguments.length === 1) {\n        const seq = arguments[0];\n        return CoordinateSequences.minCoordinateIndex(seq, 0, seq.size() - 1);\n      } else if (arguments.length === 3) {\n        const seq = arguments[0],\n              from = arguments[1],\n              to = arguments[2];\n        let minCoordIndex = -1;\n        let minCoord = null;\n\n        for (let i = from; i <= to; i++) {\n          const testCoord = seq.getCoordinate(i);\n\n          if (minCoord === null || minCoord.compareTo(testCoord) > 0) {\n            minCoord = testCoord;\n            minCoordIndex = i;\n          }\n        }\n\n        return minCoordIndex;\n      }\n    }\n\n    static extend(fact, seq, size) {\n      const newseq = fact.create(size, seq.getDimension());\n      const n = seq.size();\n      CoordinateSequences.copy(seq, 0, newseq, 0, n);\n      if (n > 0) for (let i = n; i < size; i++) CoordinateSequences.copy(seq, n - 1, newseq, i, 1);\n      return newseq;\n    }\n\n    static reverse(seq) {\n      const last = seq.size() - 1;\n      const mid = Math.trunc(last / 2);\n\n      for (let i = 0; i <= mid; i++) CoordinateSequences.swap(seq, i, last - i);\n    }\n\n    static swap(seq, i, j) {\n      if (i === j) return null;\n\n      for (let dim = 0; dim < seq.getDimension(); dim++) {\n        const tmp = seq.getOrdinate(i, dim);\n        seq.setOrdinate(i, dim, seq.getOrdinate(j, dim));\n        seq.setOrdinate(j, dim, tmp);\n      }\n    }\n\n    static copy(src, srcPos, dest, destPos, length) {\n      for (let i = 0; i < length; i++) CoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);\n    }\n\n    static ensureValidRing(fact, seq) {\n      const n = seq.size();\n      if (n === 0) return seq;\n      if (n <= 3) return CoordinateSequences.createClosedRing(fact, seq, 4);\n      const isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n      if (isClosed) return seq;\n      return CoordinateSequences.createClosedRing(fact, seq, n + 1);\n    }\n\n    static indexOf(coordinate, seq) {\n      for (let i = 0; i < seq.size(); i++) if (coordinate.x === seq.getOrdinate(i, CoordinateSequence.X) && coordinate.y === seq.getOrdinate(i, CoordinateSequence.Y)) return i;\n\n      return -1;\n    }\n\n    static createClosedRing(fact, seq, size) {\n      const newseq = fact.create(size, seq.getDimension());\n      const n = seq.size();\n      CoordinateSequences.copy(seq, 0, newseq, 0, n);\n\n      for (let i = n; i < size; i++) CoordinateSequences.copy(seq, 0, newseq, i, 1);\n\n      return newseq;\n    }\n\n    static minCoordinate(seq) {\n      let minCoord = null;\n\n      for (let i = 0; i < seq.size(); i++) {\n        const testCoord = seq.getCoordinate(i);\n        if (minCoord === null || minCoord.compareTo(testCoord) > 0) minCoord = testCoord;\n      }\n\n      return minCoord;\n    }\n\n  }\n\n  class UnsupportedOperationException extends Exception {}\n\n  class Dimension {\n    static toDimensionSymbol(dimensionValue) {\n      switch (dimensionValue) {\n        case Dimension.FALSE:\n          return Dimension.SYM_FALSE;\n\n        case Dimension.TRUE:\n          return Dimension.SYM_TRUE;\n\n        case Dimension.DONTCARE:\n          return Dimension.SYM_DONTCARE;\n\n        case Dimension.P:\n          return Dimension.SYM_P;\n\n        case Dimension.L:\n          return Dimension.SYM_L;\n\n        case Dimension.A:\n          return Dimension.SYM_A;\n      }\n\n      throw new IllegalArgumentException('Unknown dimension value: ' + dimensionValue);\n    }\n\n    static toDimensionValue(dimensionSymbol) {\n      switch (Character.toUpperCase(dimensionSymbol)) {\n        case Dimension.SYM_FALSE:\n          return Dimension.FALSE;\n\n        case Dimension.SYM_TRUE:\n          return Dimension.TRUE;\n\n        case Dimension.SYM_DONTCARE:\n          return Dimension.DONTCARE;\n\n        case Dimension.SYM_P:\n          return Dimension.P;\n\n        case Dimension.SYM_L:\n          return Dimension.L;\n\n        case Dimension.SYM_A:\n          return Dimension.A;\n      }\n\n      throw new IllegalArgumentException('Unknown dimension symbol: ' + dimensionSymbol);\n    }\n\n  }\n  Dimension.P = 0;\n  Dimension.L = 1;\n  Dimension.A = 2;\n  Dimension.FALSE = -1;\n  Dimension.TRUE = -2;\n  Dimension.DONTCARE = -3;\n  Dimension.SYM_FALSE = 'F';\n  Dimension.SYM_TRUE = 'T';\n  Dimension.SYM_DONTCARE = '*';\n  Dimension.SYM_P = '0';\n  Dimension.SYM_L = '1';\n  Dimension.SYM_A = '2';\n\n  class GeometryFilter {\n    filter(geom) {}\n\n  }\n\n  class LineString extends Geometry {\n    constructor() {\n      super();\n      LineString.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._points = null;\n\n      if (arguments.length === 0) ; else if (arguments.length === 2) {\n        const points = arguments[0],\n              factory = arguments[1];\n        Geometry.constructor_.call(this, factory);\n        this.init(points);\n      }\n    }\n\n    computeEnvelopeInternal() {\n      if (this.isEmpty()) return new Envelope();\n      return this._points.expandEnvelope(new Envelope());\n    }\n\n    isRing() {\n      return this.isClosed() && this.isSimple();\n    }\n\n    getCoordinates() {\n      return this._points.toCoordinateArray();\n    }\n\n    copyInternal() {\n      return new LineString(this._points.copy(), this._factory);\n    }\n\n    equalsExact() {\n      if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof Geometry) {\n        const other = arguments[0],\n              tolerance = arguments[1];\n        if (!this.isEquivalentClass(other)) return false;\n        const otherLineString = other;\n        if (this._points.size() !== otherLineString._points.size()) return false;\n\n        for (let i = 0; i < this._points.size(); i++) if (!this.equal(this._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) return false;\n\n        return true;\n      } else {\n        return super.equalsExact.apply(this, arguments);\n      }\n    }\n\n    normalize() {\n      for (let i = 0; i < Math.trunc(this._points.size() / 2); i++) {\n        const j = this._points.size() - 1 - i;\n\n        if (!this._points.getCoordinate(i).equals(this._points.getCoordinate(j))) {\n          if (this._points.getCoordinate(i).compareTo(this._points.getCoordinate(j)) > 0) {\n            const copy = this._points.copy();\n\n            CoordinateSequences.reverse(copy);\n            this._points = copy;\n          }\n\n          return null;\n        }\n      }\n    }\n\n    getCoordinate() {\n      if (this.isEmpty()) return null;\n      return this._points.getCoordinate(0);\n    }\n\n    getBoundaryDimension() {\n      if (this.isClosed()) return Dimension.FALSE;\n      return 0;\n    }\n\n    isClosed() {\n      if (this.isEmpty()) return false;\n      return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));\n    }\n\n    reverseInternal() {\n      const seq = this._points.copy();\n\n      CoordinateSequences.reverse(seq);\n      return this.getFactory().createLineString(seq);\n    }\n\n    getEndPoint() {\n      if (this.isEmpty()) return null;\n      return this.getPointN(this.getNumPoints() - 1);\n    }\n\n    getTypeCode() {\n      return Geometry.TYPECODE_LINESTRING;\n    }\n\n    getDimension() {\n      return 1;\n    }\n\n    getLength() {\n      return Length.ofLine(this._points);\n    }\n\n    getNumPoints() {\n      return this._points.size();\n    }\n\n    compareToSameClass() {\n      if (arguments.length === 1) {\n        const o = arguments[0];\n        const line = o;\n        let i = 0;\n        let j = 0;\n\n        while (i < this._points.size() && j < line._points.size()) {\n          const comparison = this._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));\n\n          if (comparison !== 0) return comparison;\n          i++;\n          j++;\n        }\n\n        if (i < this._points.size()) return 1;\n        if (j < line._points.size()) return -1;\n        return 0;\n      } else if (arguments.length === 2) {\n        const o = arguments[0],\n              comp = arguments[1];\n        const line = o;\n        return comp.compare(this._points, line._points);\n      }\n    }\n\n    apply() {\n      if (hasInterface(arguments[0], CoordinateFilter)) {\n        const filter = arguments[0];\n\n        for (let i = 0; i < this._points.size(); i++) filter.filter(this._points.getCoordinate(i));\n      } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n        const filter = arguments[0];\n        if (this._points.size() === 0) return null;\n\n        for (let i = 0; i < this._points.size(); i++) {\n          filter.filter(this._points, i);\n          if (filter.isDone()) break;\n        }\n\n        if (filter.isGeometryChanged()) this.geometryChanged();\n      } else if (hasInterface(arguments[0], GeometryFilter)) {\n        const filter = arguments[0];\n        filter.filter(this);\n      } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n        const filter = arguments[0];\n        filter.filter(this);\n      }\n    }\n\n    getBoundary() {\n      throw new UnsupportedOperationException();\n    }\n\n    isEquivalentClass(other) {\n      return other instanceof LineString;\n    }\n\n    getCoordinateN(n) {\n      return this._points.getCoordinate(n);\n    }\n\n    getGeometryType() {\n      return Geometry.TYPENAME_LINESTRING;\n    }\n\n    getCoordinateSequence() {\n      return this._points;\n    }\n\n    isEmpty() {\n      return this._points.size() === 0;\n    }\n\n    init(points) {\n      if (points === null) points = this.getFactory().getCoordinateSequenceFactory().create([]);\n      if (points.size() === 1) throw new IllegalArgumentException('Invalid number of points in LineString (found ' + points.size() + ' - must be 0 or >= 2)');\n      this._points = points;\n    }\n\n    isCoordinate(pt) {\n      for (let i = 0; i < this._points.size(); i++) if (this._points.getCoordinate(i).equals(pt)) return true;\n\n      return false;\n    }\n\n    getStartPoint() {\n      if (this.isEmpty()) return null;\n      return this.getPointN(0);\n    }\n\n    getPointN(n) {\n      return this.getFactory().createPoint(this._points.getCoordinate(n));\n    }\n\n    get interfaces_() {\n      return [Lineal];\n    }\n\n  }\n\n  class Puntal {}\n\n  class Point extends Geometry {\n    constructor() {\n      super();\n      Point.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._coordinates = null;\n      const coordinates = arguments[0],\n            factory = arguments[1];\n      Geometry.constructor_.call(this, factory);\n      this.init(coordinates);\n    }\n\n    computeEnvelopeInternal() {\n      if (this.isEmpty()) return new Envelope();\n      const env = new Envelope();\n      env.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));\n      return env;\n    }\n\n    getCoordinates() {\n      return this.isEmpty() ? [] : [this.getCoordinate()];\n    }\n\n    copyInternal() {\n      return new Point(this._coordinates.copy(), this._factory);\n    }\n\n    equalsExact() {\n      if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof Geometry) {\n        const other = arguments[0],\n              tolerance = arguments[1];\n        if (!this.isEquivalentClass(other)) return false;\n        if (this.isEmpty() && other.isEmpty()) return true;\n        if (this.isEmpty() !== other.isEmpty()) return false;\n        return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);\n      } else {\n        return super.equalsExact.apply(this, arguments);\n      }\n    }\n\n    normalize() {}\n\n    getCoordinate() {\n      return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;\n    }\n\n    getBoundaryDimension() {\n      return Dimension.FALSE;\n    }\n\n    reverseInternal() {\n      return this.getFactory().createPoint(this._coordinates.copy());\n    }\n\n    getTypeCode() {\n      return Geometry.TYPECODE_POINT;\n    }\n\n    getDimension() {\n      return 0;\n    }\n\n    getNumPoints() {\n      return this.isEmpty() ? 0 : 1;\n    }\n\n    getX() {\n      if (this.getCoordinate() === null) throw new IllegalStateException('getX called on empty Point');\n      return this.getCoordinate().x;\n    }\n\n    compareToSameClass() {\n      if (arguments.length === 1) {\n        const other = arguments[0];\n        const point = other;\n        return this.getCoordinate().compareTo(point.getCoordinate());\n      } else if (arguments.length === 2) {\n        const other = arguments[0],\n              comp = arguments[1];\n        const point = other;\n        return comp.compare(this._coordinates, point._coordinates);\n      }\n    }\n\n    apply() {\n      if (hasInterface(arguments[0], CoordinateFilter)) {\n        const filter = arguments[0];\n        if (this.isEmpty()) return null;\n        filter.filter(this.getCoordinate());\n      } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n        const filter = arguments[0];\n        if (this.isEmpty()) return null;\n        filter.filter(this._coordinates, 0);\n        if (filter.isGeometryChanged()) this.geometryChanged();\n      } else if (hasInterface(arguments[0], GeometryFilter)) {\n        const filter = arguments[0];\n        filter.filter(this);\n      } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n        const filter = arguments[0];\n        filter.filter(this);\n      }\n    }\n\n    getBoundary() {\n      return this.getFactory().createGeometryCollection();\n    }\n\n    getGeometryType() {\n      return Geometry.TYPENAME_POINT;\n    }\n\n    getCoordinateSequence() {\n      return this._coordinates;\n    }\n\n    getY() {\n      if (this.getCoordinate() === null) throw new IllegalStateException('getY called on empty Point');\n      return this.getCoordinate().y;\n    }\n\n    isEmpty() {\n      return this._coordinates.size() === 0;\n    }\n\n    init(coordinates) {\n      if (coordinates === null) coordinates = this.getFactory().getCoordinateSequenceFactory().create([]);\n      Assert.isTrue(coordinates.size() <= 1);\n      this._coordinates = coordinates;\n    }\n\n    isSimple() {\n      return true;\n    }\n\n    get interfaces_() {\n      return [Puntal];\n    }\n\n  }\n\n  class Area {\n    static ofRing() {\n      if (arguments[0] instanceof Array) {\n        const ring = arguments[0];\n        return Math.abs(Area.ofRingSigned(ring));\n      } else if (hasInterface(arguments[0], CoordinateSequence)) {\n        const ring = arguments[0];\n        return Math.abs(Area.ofRingSigned(ring));\n      }\n    }\n\n    static ofRingSigned() {\n      if (arguments[0] instanceof Array) {\n        const ring = arguments[0];\n        if (ring.length < 3) return 0.0;\n        let sum = 0.0;\n        const x0 = ring[0].x;\n\n        for (let i = 1; i < ring.length - 1; i++) {\n          const x = ring[i].x - x0;\n          const y1 = ring[i + 1].y;\n          const y2 = ring[i - 1].y;\n          sum += x * (y2 - y1);\n        }\n\n        return sum / 2.0;\n      } else if (hasInterface(arguments[0], CoordinateSequence)) {\n        const ring = arguments[0];\n        const n = ring.size();\n        if (n < 3) return 0.0;\n        const p0 = new Coordinate();\n        const p1 = new Coordinate();\n        const p2 = new Coordinate();\n        ring.getCoordinate(0, p1);\n        ring.getCoordinate(1, p2);\n        const x0 = p1.x;\n        p2.x -= x0;\n        let sum = 0.0;\n\n        for (let i = 1; i < n - 1; i++) {\n          p0.y = p1.y;\n          p1.x = p2.x;\n          p1.y = p2.y;\n          ring.getCoordinate(i + 1, p2);\n          p2.x -= x0;\n          sum += p1.x * (p0.y - p2.y);\n        }\n\n        return sum / 2.0;\n      }\n    }\n\n  }\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html\n   */\n\n  class Arrays {\n    static sort() {\n      const a = arguments[0];\n\n      if (arguments.length === 1) {\n        a.sort((a, b) => a.compareTo(b));\n      } else if (arguments.length === 2) {\n        a.sort((a, b) => arguments[1].compare(a, b));\n      } else if (arguments.length === 3) {\n        const t = a.slice(arguments[1], arguments[2]);\n        t.sort();\n        const r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n        a.splice(0, a.length);\n\n        for (const e of r) a.push(e);\n      } else if (arguments.length === 4) {\n        const t = a.slice(arguments[1], arguments[2]);\n        t.sort((a, b) => arguments[3].compare(a, b));\n        const r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n        a.splice(0, a.length);\n\n        for (const e of r) a.push(e);\n      }\n    }\n    /**\n     * @param {Array} array\n     * @return {ArrayList}\n     */\n\n\n    static asList(array) {\n      const arrayList = new ArrayList();\n\n      for (const e of array) arrayList.add(e);\n\n      return arrayList;\n    }\n\n    static copyOf(original, newLength) {\n      return original.slice(0, newLength);\n    }\n\n  }\n\n  class Polygonal {}\n\n  class Polygon extends Geometry {\n    constructor() {\n      super();\n      Polygon.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._shell = null;\n      this._holes = null;\n      let shell = arguments[0],\n          holes = arguments[1],\n          factory = arguments[2];\n      Geometry.constructor_.call(this, factory);\n      if (shell === null) shell = this.getFactory().createLinearRing();\n      if (holes === null) holes = [];\n      if (Geometry.hasNullElements(holes)) throw new IllegalArgumentException('holes must not contain null elements');\n      if (shell.isEmpty() && Geometry.hasNonEmptyElements(holes)) throw new IllegalArgumentException('shell is empty but holes are not');\n      this._shell = shell;\n      this._holes = holes;\n    }\n\n    computeEnvelopeInternal() {\n      return this._shell.getEnvelopeInternal();\n    }\n\n    getCoordinates() {\n      if (this.isEmpty()) return [];\n      const coordinates = new Array(this.getNumPoints()).fill(null);\n      let k = -1;\n\n      const shellCoordinates = this._shell.getCoordinates();\n\n      for (let x = 0; x < shellCoordinates.length; x++) {\n        k++;\n        coordinates[k] = shellCoordinates[x];\n      }\n\n      for (let i = 0; i < this._holes.length; i++) {\n        const childCoordinates = this._holes[i].getCoordinates();\n\n        for (let j = 0; j < childCoordinates.length; j++) {\n          k++;\n          coordinates[k] = childCoordinates[j];\n        }\n      }\n\n      return coordinates;\n    }\n\n    getArea() {\n      let area = 0.0;\n      area += Area.ofRing(this._shell.getCoordinateSequence());\n\n      for (let i = 0; i < this._holes.length; i++) area -= Area.ofRing(this._holes[i].getCoordinateSequence());\n\n      return area;\n    }\n\n    copyInternal() {\n      const shellCopy = this._shell.copy();\n\n      const holeCopies = new Array(this._holes.length).fill(null);\n\n      for (let i = 0; i < this._holes.length; i++) holeCopies[i] = this._holes[i].copy();\n\n      return new Polygon(shellCopy, holeCopies, this._factory);\n    }\n\n    isRectangle() {\n      if (this.getNumInteriorRing() !== 0) return false;\n      if (this._shell === null) return false;\n      if (this._shell.getNumPoints() !== 5) return false;\n\n      const seq = this._shell.getCoordinateSequence();\n\n      const env = this.getEnvelopeInternal();\n\n      for (let i = 0; i < 5; i++) {\n        const x = seq.getX(i);\n        if (!(x === env.getMinX() || x === env.getMaxX())) return false;\n        const y = seq.getY(i);\n        if (!(y === env.getMinY() || y === env.getMaxY())) return false;\n      }\n\n      let prevX = seq.getX(0);\n      let prevY = seq.getY(0);\n\n      for (let i = 1; i <= 4; i++) {\n        const x = seq.getX(i);\n        const y = seq.getY(i);\n        const xChanged = x !== prevX;\n        const yChanged = y !== prevY;\n        if (xChanged === yChanged) return false;\n        prevX = x;\n        prevY = y;\n      }\n\n      return true;\n    }\n\n    equalsExact() {\n      if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof Geometry) {\n        const other = arguments[0],\n              tolerance = arguments[1];\n        if (!this.isEquivalentClass(other)) return false;\n        const otherPolygon = other;\n        const thisShell = this._shell;\n        const otherPolygonShell = otherPolygon._shell;\n        if (!thisShell.equalsExact(otherPolygonShell, tolerance)) return false;\n        if (this._holes.length !== otherPolygon._holes.length) return false;\n\n        for (let i = 0; i < this._holes.length; i++) if (!this._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) return false;\n\n        return true;\n      } else {\n        return super.equalsExact.apply(this, arguments);\n      }\n    }\n\n    normalize() {\n      if (arguments.length === 0) {\n        this._shell = this.normalized(this._shell, true);\n\n        for (let i = 0; i < this._holes.length; i++) this._holes[i] = this.normalized(this._holes[i], false);\n\n        Arrays.sort(this._holes);\n      } else if (arguments.length === 2) {\n        const ring = arguments[0],\n              clockwise = arguments[1];\n        if (ring.isEmpty()) return null;\n        const seq = ring.getCoordinateSequence();\n        const minCoordinateIndex = CoordinateSequences.minCoordinateIndex(seq, 0, seq.size() - 2);\n        CoordinateSequences.scroll(seq, minCoordinateIndex, true);\n        if (Orientation.isCCW(seq) === clockwise) CoordinateSequences.reverse(seq);\n      }\n    }\n\n    getCoordinate() {\n      return this._shell.getCoordinate();\n    }\n\n    getNumInteriorRing() {\n      return this._holes.length;\n    }\n\n    getBoundaryDimension() {\n      return 1;\n    }\n\n    reverseInternal() {\n      const shell = this.getExteriorRing().reverse();\n      const holes = new Array(this.getNumInteriorRing()).fill(null);\n\n      for (let i = 0; i < holes.length; i++) holes[i] = this.getInteriorRingN(i).reverse();\n\n      return this.getFactory().createPolygon(shell, holes);\n    }\n\n    getTypeCode() {\n      return Geometry.TYPECODE_POLYGON;\n    }\n\n    getDimension() {\n      return 2;\n    }\n\n    getLength() {\n      let len = 0.0;\n      len += this._shell.getLength();\n\n      for (let i = 0; i < this._holes.length; i++) len += this._holes[i].getLength();\n\n      return len;\n    }\n\n    getNumPoints() {\n      let numPoints = this._shell.getNumPoints();\n\n      for (let i = 0; i < this._holes.length; i++) numPoints += this._holes[i].getNumPoints();\n\n      return numPoints;\n    }\n\n    convexHull() {\n      return this.getExteriorRing().convexHull();\n    }\n\n    normalized(ring, clockwise) {\n      const res = ring.copy();\n      this.normalize(res, clockwise);\n      return res;\n    }\n\n    compareToSameClass() {\n      if (arguments.length === 1) {\n        const o = arguments[0];\n        const thisShell = this._shell;\n        const otherShell = o._shell;\n        return thisShell.compareToSameClass(otherShell);\n      } else if (arguments.length === 2) {\n        const o = arguments[0],\n              comp = arguments[1];\n        const poly = o;\n        const thisShell = this._shell;\n        const otherShell = poly._shell;\n        const shellComp = thisShell.compareToSameClass(otherShell, comp);\n        if (shellComp !== 0) return shellComp;\n        const nHole1 = this.getNumInteriorRing();\n        const nHole2 = poly.getNumInteriorRing();\n        let i = 0;\n\n        while (i < nHole1 && i < nHole2) {\n          const thisHole = this.getInteriorRingN(i);\n          const otherHole = poly.getInteriorRingN(i);\n          const holeComp = thisHole.compareToSameClass(otherHole, comp);\n          if (holeComp !== 0) return holeComp;\n          i++;\n        }\n\n        if (i < nHole1) return 1;\n        if (i < nHole2) return -1;\n        return 0;\n      }\n    }\n\n    apply() {\n      if (hasInterface(arguments[0], CoordinateFilter)) {\n        const filter = arguments[0];\n\n        this._shell.apply(filter);\n\n        for (let i = 0; i < this._holes.length; i++) this._holes[i].apply(filter);\n      } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n        const filter = arguments[0];\n\n        this._shell.apply(filter);\n\n        if (!filter.isDone()) for (let i = 0; i < this._holes.length; i++) {\n          this._holes[i].apply(filter);\n\n          if (filter.isDone()) break;\n        }\n        if (filter.isGeometryChanged()) this.geometryChanged();\n      } else if (hasInterface(arguments[0], GeometryFilter)) {\n        const filter = arguments[0];\n        filter.filter(this);\n      } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n        const filter = arguments[0];\n        filter.filter(this);\n\n        this._shell.apply(filter);\n\n        for (let i = 0; i < this._holes.length; i++) this._holes[i].apply(filter);\n      }\n    }\n\n    getBoundary() {\n      if (this.isEmpty()) return this.getFactory().createMultiLineString();\n      const rings = new Array(this._holes.length + 1).fill(null);\n      rings[0] = this._shell;\n\n      for (let i = 0; i < this._holes.length; i++) rings[i + 1] = this._holes[i];\n\n      if (rings.length <= 1) return this.getFactory().createLinearRing(rings[0].getCoordinateSequence());\n      return this.getFactory().createMultiLineString(rings);\n    }\n\n    getGeometryType() {\n      return Geometry.TYPENAME_POLYGON;\n    }\n\n    getExteriorRing() {\n      return this._shell;\n    }\n\n    isEmpty() {\n      return this._shell.isEmpty();\n    }\n\n    getInteriorRingN(n) {\n      return this._holes[n];\n    }\n\n    get interfaces_() {\n      return [Polygonal];\n    }\n\n  }\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html\n   *\n   * @extends {Collection}\n   * @constructor\n   * @private\n   */\n\n  class Set extends Collection {\n    /**\n     * Returns true if this set contains the specified element. More formally,\n     * returns true if and only if this set contains an element e such that (o==null ?\n     * e==null : o.equals(e)).\n     * @param {Object} e\n     * @return {boolean}\n     */\n    contains() {}\n\n  }\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html\n   */\n\n  class SortedSet extends Set {}\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html\n   */\n\n  class TreeSet extends SortedSet {\n    constructor(o) {\n      super();\n      this.array = [];\n      if (o instanceof Collection) this.addAll(o);\n    }\n\n    contains(o) {\n      for (const e of this.array) if (e.compareTo(o) === 0) return true;\n\n      return false;\n    }\n\n    add(o) {\n      if (this.contains(o)) return false;\n\n      for (let i = 0, len = this.array.length; i < len; i++) {\n        const e = this.array[i];\n        if (e.compareTo(o) === 1) return !!this.array.splice(i, 0, o);\n      }\n\n      this.array.push(o);\n      return true;\n    }\n\n    addAll(c) {\n      for (const e of c) this.add(e);\n\n      return true;\n    }\n\n    remove() {\n      throw new UnsupportedOperationException();\n    }\n\n    size() {\n      return this.array.length;\n    }\n\n    isEmpty() {\n      return this.array.length === 0;\n    }\n\n    toArray() {\n      return this.array.slice();\n    }\n\n    iterator() {\n      return new Iterator$1(this.array);\n    }\n\n  }\n\n  class Iterator$1 {\n    constructor(array) {\n      this.array = array;\n      this.position = 0;\n    }\n\n    next() {\n      if (this.position === this.array.length) throw new NoSuchElementException();\n      return this.array[this.position++];\n    }\n\n    hasNext() {\n      return this.position < this.array.length;\n    }\n\n    remove() {\n      throw new UnsupportedOperationException();\n    }\n\n  }\n\n  class GeometryCollection extends Geometry {\n    constructor() {\n      super();\n      GeometryCollection.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._geometries = null;\n\n      if (arguments.length === 0) ; else if (arguments.length === 2) {\n        let geometries = arguments[0],\n            factory = arguments[1];\n        Geometry.constructor_.call(this, factory);\n        if (geometries === null) geometries = [];\n        if (Geometry.hasNullElements(geometries)) throw new IllegalArgumentException('geometries must not contain null elements');\n        this._geometries = geometries;\n      }\n    }\n\n    computeEnvelopeInternal() {\n      const envelope = new Envelope();\n\n      for (let i = 0; i < this._geometries.length; i++) envelope.expandToInclude(this._geometries[i].getEnvelopeInternal());\n\n      return envelope;\n    }\n\n    getGeometryN(n) {\n      return this._geometries[n];\n    }\n\n    getCoordinates() {\n      const coordinates = new Array(this.getNumPoints()).fill(null);\n      let k = -1;\n\n      for (let i = 0; i < this._geometries.length; i++) {\n        const childCoordinates = this._geometries[i].getCoordinates();\n\n        for (let j = 0; j < childCoordinates.length; j++) {\n          k++;\n          coordinates[k] = childCoordinates[j];\n        }\n      }\n\n      return coordinates;\n    }\n\n    getArea() {\n      let area = 0.0;\n\n      for (let i = 0; i < this._geometries.length; i++) area += this._geometries[i].getArea();\n\n      return area;\n    }\n\n    copyInternal() {\n      const geometries = new Array(this._geometries.length).fill(null);\n\n      for (let i = 0; i < geometries.length; i++) geometries[i] = this._geometries[i].copy();\n\n      return new GeometryCollection(geometries, this._factory);\n    }\n\n    equalsExact() {\n      if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof Geometry) {\n        const other = arguments[0],\n              tolerance = arguments[1];\n        if (!this.isEquivalentClass(other)) return false;\n        const otherCollection = other;\n        if (this._geometries.length !== otherCollection._geometries.length) return false;\n\n        for (let i = 0; i < this._geometries.length; i++) if (!this._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) return false;\n\n        return true;\n      } else {\n        return super.equalsExact.apply(this, arguments);\n      }\n    }\n\n    normalize() {\n      for (let i = 0; i < this._geometries.length; i++) this._geometries[i].normalize();\n\n      Arrays.sort(this._geometries);\n    }\n\n    getCoordinate() {\n      if (this.isEmpty()) return null;\n      return this._geometries[0].getCoordinate();\n    }\n\n    getBoundaryDimension() {\n      let dimension = Dimension.FALSE;\n\n      for (let i = 0; i < this._geometries.length; i++) dimension = Math.max(dimension, this._geometries[i].getBoundaryDimension());\n\n      return dimension;\n    }\n\n    reverseInternal() {\n      const numGeometries = this._geometries.length;\n      const reversed = new ArrayList(numGeometries);\n\n      for (let i = 0; i < numGeometries; i++) reversed.add(this._geometries[i].reverse());\n\n      return this.getFactory().buildGeometry(reversed);\n    }\n\n    getTypeCode() {\n      return Geometry.TYPECODE_GEOMETRYCOLLECTION;\n    }\n\n    getDimension() {\n      let dimension = Dimension.FALSE;\n\n      for (let i = 0; i < this._geometries.length; i++) dimension = Math.max(dimension, this._geometries[i].getDimension());\n\n      return dimension;\n    }\n\n    getLength() {\n      let sum = 0.0;\n\n      for (let i = 0; i < this._geometries.length; i++) sum += this._geometries[i].getLength();\n\n      return sum;\n    }\n\n    getNumPoints() {\n      let numPoints = 0;\n\n      for (let i = 0; i < this._geometries.length; i++) numPoints += this._geometries[i].getNumPoints();\n\n      return numPoints;\n    }\n\n    getNumGeometries() {\n      return this._geometries.length;\n    }\n\n    compareToSameClass() {\n      if (arguments.length === 1) {\n        const o = arguments[0];\n        const theseElements = new TreeSet(Arrays.asList(this._geometries));\n        const otherElements = new TreeSet(Arrays.asList(o._geometries));\n        return this.compare(theseElements, otherElements);\n      } else if (arguments.length === 2) {\n        const o = arguments[0],\n              comp = arguments[1];\n        const gc = o;\n        const n1 = this.getNumGeometries();\n        const n2 = gc.getNumGeometries();\n        let i = 0;\n\n        while (i < n1 && i < n2) {\n          const thisGeom = this.getGeometryN(i);\n          const otherGeom = gc.getGeometryN(i);\n          const holeComp = thisGeom.compareToSameClass(otherGeom, comp);\n          if (holeComp !== 0) return holeComp;\n          i++;\n        }\n\n        if (i < n1) return 1;\n        if (i < n2) return -1;\n        return 0;\n      }\n    }\n\n    apply() {\n      if (hasInterface(arguments[0], CoordinateFilter)) {\n        const filter = arguments[0];\n\n        for (let i = 0; i < this._geometries.length; i++) this._geometries[i].apply(filter);\n      } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n        const filter = arguments[0];\n        if (this._geometries.length === 0) return null;\n\n        for (let i = 0; i < this._geometries.length; i++) {\n          this._geometries[i].apply(filter);\n\n          if (filter.isDone()) break;\n        }\n\n        if (filter.isGeometryChanged()) this.geometryChanged();\n      } else if (hasInterface(arguments[0], GeometryFilter)) {\n        const filter = arguments[0];\n        filter.filter(this);\n\n        for (let i = 0; i < this._geometries.length; i++) this._geometries[i].apply(filter);\n      } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n        const filter = arguments[0];\n        filter.filter(this);\n\n        for (let i = 0; i < this._geometries.length; i++) this._geometries[i].apply(filter);\n      }\n    }\n\n    getBoundary() {\n      Geometry.checkNotGeometryCollection(this);\n      Assert.shouldNeverReachHere();\n      return null;\n    }\n\n    getGeometryType() {\n      return Geometry.TYPENAME_GEOMETRYCOLLECTION;\n    }\n\n    isEmpty() {\n      for (let i = 0; i < this._geometries.length; i++) if (!this._geometries[i].isEmpty()) return false;\n\n      return true;\n    }\n\n  }\n\n  class MultiPoint extends GeometryCollection {\n    constructor() {\n      super();\n      MultiPoint.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      const points = arguments[0],\n            factory = arguments[1];\n      GeometryCollection.constructor_.call(this, points, factory);\n    }\n\n    copyInternal() {\n      const points = new Array(this._geometries.length).fill(null);\n\n      for (let i = 0; i < points.length; i++) points[i] = this._geometries[i].copy();\n\n      return new MultiPoint(points, this._factory);\n    }\n\n    isValid() {\n      return true;\n    }\n\n    equalsExact() {\n      if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof Geometry) {\n        const other = arguments[0],\n              tolerance = arguments[1];\n        if (!this.isEquivalentClass(other)) return false;\n        return super.equalsExact.call(this, other, tolerance);\n      } else {\n        return super.equalsExact.apply(this, arguments);\n      }\n    }\n\n    getCoordinate() {\n      if (arguments.length === 1 && Number.isInteger(arguments[0])) {\n        const n = arguments[0];\n        return this._geometries[n].getCoordinate();\n      } else {\n        return super.getCoordinate.apply(this, arguments);\n      }\n    }\n\n    getBoundaryDimension() {\n      return Dimension.FALSE;\n    }\n\n    getTypeCode() {\n      return Geometry.TYPECODE_MULTIPOINT;\n    }\n\n    getDimension() {\n      return 0;\n    }\n\n    getBoundary() {\n      return this.getFactory().createGeometryCollection();\n    }\n\n    getGeometryType() {\n      return Geometry.TYPENAME_MULTIPOINT;\n    }\n\n    get interfaces_() {\n      return [Puntal];\n    }\n\n  }\n\n  class LinearRing extends LineString {\n    constructor() {\n      super();\n      LinearRing.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      const points = arguments[0],\n            factory = arguments[1];\n      LineString.constructor_.call(this, points, factory);\n      this.validateConstruction();\n    }\n\n    copyInternal() {\n      return new LinearRing(this._points.copy(), this._factory);\n    }\n\n    getBoundaryDimension() {\n      return Dimension.FALSE;\n    }\n\n    isClosed() {\n      if (this.isEmpty()) return true;\n      return super.isClosed.call(this);\n    }\n\n    reverseInternal() {\n      const seq = this._points.copy();\n\n      CoordinateSequences.reverse(seq);\n      return this.getFactory().createLinearRing(seq);\n    }\n\n    getTypeCode() {\n      return Geometry.TYPECODE_LINEARRING;\n    }\n\n    validateConstruction() {\n      if (!this.isEmpty() && !super.isClosed.call(this)) throw new IllegalArgumentException('Points of LinearRing do not form a closed linestring');\n      if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) throw new IllegalArgumentException('Invalid number of points in LinearRing (found ' + this.getCoordinateSequence().size() + ' - must be 0 or >= 4)');\n    }\n\n    getGeometryType() {\n      return Geometry.TYPENAME_LINEARRING;\n    }\n\n  }\n  LinearRing.MINIMUM_VALID_SIZE = 4;\n\n  class CoordinateXY extends Coordinate {\n    constructor() {\n      super();\n      CoordinateXY.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      if (arguments.length === 0) {\n        Coordinate.constructor_.call(this);\n      } else if (arguments.length === 1) {\n        if (arguments[0] instanceof CoordinateXY) {\n          const coord = arguments[0];\n          Coordinate.constructor_.call(this, coord.x, coord.y);\n        } else if (arguments[0] instanceof Coordinate) {\n          const coord = arguments[0];\n          Coordinate.constructor_.call(this, coord.x, coord.y);\n        }\n      } else if (arguments.length === 2) {\n        const x = arguments[0],\n              y = arguments[1];\n        Coordinate.constructor_.call(this, x, y, Coordinate.NULL_ORDINATE);\n      }\n    }\n\n    setOrdinate(ordinateIndex, value) {\n      switch (ordinateIndex) {\n        case CoordinateXY.X:\n          this.x = value;\n          break;\n\n        case CoordinateXY.Y:\n          this.y = value;\n          break;\n\n        default:\n          throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex);\n      }\n    }\n\n    getZ() {\n      return Coordinate.NULL_ORDINATE;\n    }\n\n    getOrdinate(ordinateIndex) {\n      switch (ordinateIndex) {\n        case CoordinateXY.X:\n          return this.x;\n\n        case CoordinateXY.Y:\n          return this.y;\n      }\n\n      throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex);\n    }\n\n    setZ(z) {\n      throw new IllegalArgumentException('CoordinateXY dimension 2 does not support z-ordinate');\n    }\n\n    copy() {\n      return new CoordinateXY(this);\n    }\n\n    toString() {\n      return '(' + this.x + ', ' + this.y + ')';\n    }\n\n    setCoordinate(other) {\n      this.x = other.x;\n      this.y = other.y;\n      this.z = other.getZ();\n    }\n\n  }\n  CoordinateXY.X = 0;\n  CoordinateXY.Y = 1;\n  CoordinateXY.Z = -1;\n  CoordinateXY.M = -1;\n\n  class CoordinateXYM extends Coordinate {\n    constructor() {\n      super();\n      CoordinateXYM.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._m = null;\n\n      if (arguments.length === 0) {\n        Coordinate.constructor_.call(this);\n        this._m = 0.0;\n      } else if (arguments.length === 1) {\n        if (arguments[0] instanceof CoordinateXYM) {\n          const coord = arguments[0];\n          Coordinate.constructor_.call(this, coord.x, coord.y);\n          this._m = coord._m;\n        } else if (arguments[0] instanceof Coordinate) {\n          const coord = arguments[0];\n          Coordinate.constructor_.call(this, coord.x, coord.y);\n          this._m = this.getM();\n        }\n      } else if (arguments.length === 3) {\n        const x = arguments[0],\n              y = arguments[1],\n              m = arguments[2];\n        Coordinate.constructor_.call(this, x, y, Coordinate.NULL_ORDINATE);\n        this._m = m;\n      }\n    }\n\n    getM() {\n      return this._m;\n    }\n\n    setOrdinate(ordinateIndex, value) {\n      switch (ordinateIndex) {\n        case CoordinateXYM.X:\n          this.x = value;\n          break;\n\n        case CoordinateXYM.Y:\n          this.y = value;\n          break;\n\n        case CoordinateXYM.M:\n          this._m = value;\n          break;\n\n        default:\n          throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex);\n      }\n    }\n\n    setM(m) {\n      this._m = m;\n    }\n\n    getZ() {\n      return Coordinate.NULL_ORDINATE;\n    }\n\n    getOrdinate(ordinateIndex) {\n      switch (ordinateIndex) {\n        case CoordinateXYM.X:\n          return this.x;\n\n        case CoordinateXYM.Y:\n          return this.y;\n\n        case CoordinateXYM.M:\n          return this._m;\n      }\n\n      throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex);\n    }\n\n    setZ(z) {\n      throw new IllegalArgumentException('CoordinateXY dimension 2 does not support z-ordinate');\n    }\n\n    copy() {\n      return new CoordinateXYM(this);\n    }\n\n    toString() {\n      return '(' + this.x + ', ' + this.y + ' m=' + this.getM() + ')';\n    }\n\n    setCoordinate(other) {\n      this.x = other.x;\n      this.y = other.y;\n      this.z = other.getZ();\n      this._m = other.getM();\n    }\n\n  }\n  CoordinateXYM.X = 0;\n  CoordinateXYM.Y = 1;\n  CoordinateXYM.Z = -1;\n  CoordinateXYM.M = 2;\n\n  class CoordinateXYZM extends Coordinate {\n    constructor() {\n      super();\n      CoordinateXYZM.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._m = null;\n\n      if (arguments.length === 0) {\n        Coordinate.constructor_.call(this);\n        this._m = 0.0;\n      } else if (arguments.length === 1) {\n        if (arguments[0] instanceof CoordinateXYZM) {\n          const coord = arguments[0];\n          Coordinate.constructor_.call(this, coord);\n          this._m = coord._m;\n        } else if (arguments[0] instanceof Coordinate) {\n          const coord = arguments[0];\n          Coordinate.constructor_.call(this, coord);\n          this._m = this.getM();\n        }\n      } else if (arguments.length === 4) {\n        const x = arguments[0],\n              y = arguments[1],\n              z = arguments[2],\n              m = arguments[3];\n        Coordinate.constructor_.call(this, x, y, z);\n        this._m = m;\n      }\n    }\n\n    getM() {\n      return this._m;\n    }\n\n    setOrdinate(ordinateIndex, value) {\n      switch (ordinateIndex) {\n        case Coordinate.X:\n          this.x = value;\n          break;\n\n        case Coordinate.Y:\n          this.y = value;\n          break;\n\n        case Coordinate.Z:\n          this.z = value;\n          break;\n\n        case Coordinate.M:\n          this._m = value;\n          break;\n\n        default:\n          throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex);\n      }\n    }\n\n    setM(m) {\n      this._m = m;\n    }\n\n    getOrdinate(ordinateIndex) {\n      switch (ordinateIndex) {\n        case Coordinate.X:\n          return this.x;\n\n        case Coordinate.Y:\n          return this.y;\n\n        case Coordinate.Z:\n          return this.getZ();\n\n        case Coordinate.M:\n          return this.getM();\n      }\n\n      throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex);\n    }\n\n    copy() {\n      return new CoordinateXYZM(this);\n    }\n\n    toString() {\n      return '(' + this.x + ', ' + this.y + ', ' + this.getZ() + ' m=' + this.getM() + ')';\n    }\n\n    setCoordinate(other) {\n      this.x = other.x;\n      this.y = other.y;\n      this.z = other.getZ();\n      this._m = other.getM();\n    }\n\n  }\n\n  class Coordinates {\n    static measures(coordinate) {\n      if (coordinate instanceof CoordinateXY) return 0;else if (coordinate instanceof CoordinateXYM) return 1;else if (coordinate instanceof CoordinateXYZM) return 1;else if (coordinate instanceof Coordinate) return 0;\n      return 0;\n    }\n\n    static dimension(coordinate) {\n      if (coordinate instanceof CoordinateXY) return 2;else if (coordinate instanceof CoordinateXYM) return 3;else if (coordinate instanceof CoordinateXYZM) return 4;else if (coordinate instanceof Coordinate) return 3;\n      return 3;\n    }\n\n    static create() {\n      if (arguments.length === 1) {\n        const dimension = arguments[0];\n        return Coordinates.create(dimension, 0);\n      } else if (arguments.length === 2) {\n        const dimension = arguments[0],\n              measures = arguments[1];\n        if (dimension === 2) return new CoordinateXY();else if (dimension === 3 && measures === 0) return new Coordinate();else if (dimension === 3 && measures === 1) return new CoordinateXYM();else if (dimension === 4 && measures === 1) return new CoordinateXYZM();\n        return new Coordinate();\n      }\n    }\n\n  }\n\n  class CoordinateArrays {\n    static isRing(pts) {\n      if (pts.length < 4) return false;\n      if (!pts[0].equals2D(pts[pts.length - 1])) return false;\n      return true;\n    }\n\n    static ptNotInList(testPts, pts) {\n      for (let i = 0; i < testPts.length; i++) {\n        const testPt = testPts[i];\n        if (CoordinateArrays.indexOf(testPt, pts) < 0) return testPt;\n      }\n\n      return null;\n    }\n\n    static scroll(coordinates, firstCoordinate) {\n      const i = CoordinateArrays.indexOf(firstCoordinate, coordinates);\n      if (i < 0) return null;\n      const newCoordinates = new Array(coordinates.length).fill(null);\n      System.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);\n      System.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);\n      System.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);\n    }\n\n    static equals() {\n      if (arguments.length === 2) {\n        const coord1 = arguments[0],\n              coord2 = arguments[1];\n        if (coord1 === coord2) return true;\n        if (coord1 === null || coord2 === null) return false;\n        if (coord1.length !== coord2.length) return false;\n\n        for (let i = 0; i < coord1.length; i++) if (!coord1[i].equals(coord2[i])) return false;\n\n        return true;\n      } else if (arguments.length === 3) {\n        const coord1 = arguments[0],\n              coord2 = arguments[1],\n              coordinateComparator = arguments[2];\n        if (coord1 === coord2) return true;\n        if (coord1 === null || coord2 === null) return false;\n        if (coord1.length !== coord2.length) return false;\n\n        for (let i = 0; i < coord1.length; i++) if (coordinateComparator.compare(coord1[i], coord2[i]) !== 0) return false;\n\n        return true;\n      }\n    }\n\n    static intersection(coordinates, env) {\n      const coordList = new CoordinateList();\n\n      for (let i = 0; i < coordinates.length; i++) if (env.intersects(coordinates[i])) coordList.add(coordinates[i], true);\n\n      return coordList.toCoordinateArray();\n    }\n\n    static measures(pts) {\n      if (pts === null || pts.length === 0) return 0;\n      let measures = 0;\n\n      for (const coordinate of pts) measures = Math.max(measures, Coordinates.measures(coordinate));\n\n      return measures;\n    }\n\n    static hasRepeatedPoints(coord) {\n      for (let i = 1; i < coord.length; i++) if (coord[i - 1].equals(coord[i])) return true;\n\n      return false;\n    }\n\n    static removeRepeatedPoints(coord) {\n      if (!CoordinateArrays.hasRepeatedPoints(coord)) return coord;\n      const coordList = new CoordinateList(coord, false);\n      return coordList.toCoordinateArray();\n    }\n\n    static reverse(coord) {\n      const last = coord.length - 1;\n      const mid = Math.trunc(last / 2);\n\n      for (let i = 0; i <= mid; i++) {\n        const tmp = coord[i];\n        coord[i] = coord[last - i];\n        coord[last - i] = tmp;\n      }\n    }\n\n    static removeNull(coord) {\n      let nonNull = 0;\n\n      for (let i = 0; i < coord.length; i++) if (coord[i] !== null) nonNull++;\n\n      const newCoord = new Array(nonNull).fill(null);\n      if (nonNull === 0) return newCoord;\n      let j = 0;\n\n      for (let i = 0; i < coord.length; i++) if (coord[i] !== null) newCoord[j++] = coord[i];\n\n      return newCoord;\n    }\n\n    static copyDeep() {\n      if (arguments.length === 1) {\n        const coordinates = arguments[0];\n        const copy = new Array(coordinates.length).fill(null);\n\n        for (let i = 0; i < coordinates.length; i++) copy[i] = coordinates[i].copy();\n\n        return copy;\n      } else if (arguments.length === 5) {\n        const src = arguments[0],\n              srcStart = arguments[1],\n              dest = arguments[2],\n              destStart = arguments[3],\n              length = arguments[4];\n\n        for (let i = 0; i < length; i++) dest[destStart + i] = src[srcStart + i].copy();\n      }\n    }\n\n    static isEqualReversed(pts1, pts2) {\n      for (let i = 0; i < pts1.length; i++) {\n        const p1 = pts1[i];\n        const p2 = pts2[pts1.length - i - 1];\n        if (p1.compareTo(p2) !== 0) return false;\n      }\n\n      return true;\n    }\n\n    static envelope(coordinates) {\n      const env = new Envelope();\n\n      for (let i = 0; i < coordinates.length; i++) env.expandToInclude(coordinates[i]);\n\n      return env;\n    }\n\n    static toCoordinateArray(coordList) {\n      return coordList.toArray(CoordinateArrays.coordArrayType);\n    }\n\n    static dimension(pts) {\n      if (pts === null || pts.length === 0) return 3;\n      let dimension = 0;\n\n      for (const coordinate of pts) dimension = Math.max(dimension, Coordinates.dimension(coordinate));\n\n      return dimension;\n    }\n\n    static atLeastNCoordinatesOrNothing(n, c) {\n      return c.length >= n ? c : [];\n    }\n\n    static indexOf(coordinate, coordinates) {\n      for (let i = 0; i < coordinates.length; i++) if (coordinate.equals(coordinates[i])) return i;\n\n      return -1;\n    }\n\n    static increasingDirection(pts) {\n      for (let i = 0; i < Math.trunc(pts.length / 2); i++) {\n        const j = pts.length - 1 - i;\n        const comp = pts[i].compareTo(pts[j]);\n        if (comp !== 0) return comp;\n      }\n\n      return 1;\n    }\n\n    static compare(pts1, pts2) {\n      let i = 0;\n\n      while (i < pts1.length && i < pts2.length) {\n        const compare = pts1[i].compareTo(pts2[i]);\n        if (compare !== 0) return compare;\n        i++;\n      }\n\n      if (i < pts2.length) return -1;\n      if (i < pts1.length) return 1;\n      return 0;\n    }\n\n    static minCoordinate(coordinates) {\n      let minCoord = null;\n\n      for (let i = 0; i < coordinates.length; i++) if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) minCoord = coordinates[i];\n\n      return minCoord;\n    }\n\n    static extract(pts, start, end) {\n      start = MathUtil.clamp(start, 0, pts.length);\n      end = MathUtil.clamp(end, -1, pts.length);\n      let npts = end - start + 1;\n      if (end < 0) npts = 0;\n      if (start >= pts.length) npts = 0;\n      if (end < start) npts = 0;\n      const extractPts = new Array(npts).fill(null);\n      if (npts === 0) return extractPts;\n      let iPts = 0;\n\n      for (let i = start; i <= end; i++) extractPts[iPts++] = pts[i];\n\n      return extractPts;\n    }\n\n  }\n\n  class ForwardComparator {\n    compare(o1, o2) {\n      const pts1 = o1;\n      const pts2 = o2;\n      return CoordinateArrays.compare(pts1, pts2);\n    }\n\n    get interfaces_() {\n      return [Comparator];\n    }\n\n  }\n\n  class BidirectionalComparator {\n    compare(o1, o2) {\n      const pts1 = o1;\n      const pts2 = o2;\n      if (pts1.length < pts2.length) return -1;\n      if (pts1.length > pts2.length) return 1;\n      if (pts1.length === 0) return 0;\n      const forwardComp = CoordinateArrays.compare(pts1, pts2);\n      const isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);\n      if (isEqualRev) return 0;\n      return forwardComp;\n    }\n\n    OLDcompare(o1, o2) {\n      const pts1 = o1;\n      const pts2 = o2;\n      if (pts1.length < pts2.length) return -1;\n      if (pts1.length > pts2.length) return 1;\n      if (pts1.length === 0) return 0;\n      const dir1 = CoordinateArrays.increasingDirection(pts1);\n      const dir2 = CoordinateArrays.increasingDirection(pts2);\n      let i1 = dir1 > 0 ? 0 : pts1.length - 1;\n      let i2 = dir2 > 0 ? 0 : pts1.length - 1;\n\n      for (let i = 0; i < pts1.length; i++) {\n        const comparePt = pts1[i1].compareTo(pts2[i2]);\n        if (comparePt !== 0) return comparePt;\n        i1 += dir1;\n        i2 += dir2;\n      }\n\n      return 0;\n    }\n\n    get interfaces_() {\n      return [Comparator];\n    }\n\n  }\n\n  CoordinateArrays.ForwardComparator = ForwardComparator;\n  CoordinateArrays.BidirectionalComparator = BidirectionalComparator;\n  CoordinateArrays.coordArrayType = new Array(0).fill(null);\n\n  class StringBuilder {\n    constructor(str) {\n      this.str = str;\n    }\n\n    append(e) {\n      this.str += e;\n    }\n\n    setCharAt(i, c) {\n      this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);\n    }\n\n    toString() {\n      return this.str;\n    }\n\n  }\n\n  class CoordinateArraySequence {\n    constructor() {\n      CoordinateArraySequence.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._dimension = 3;\n      this._measures = 0;\n      this._coordinates = null;\n\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof Array) {\n          const coordinates = arguments[0];\n          CoordinateArraySequence.constructor_.call(this, coordinates, CoordinateArrays.dimension(coordinates), CoordinateArrays.measures(coordinates));\n        } else if (Number.isInteger(arguments[0])) {\n          const size = arguments[0];\n          this._coordinates = new Array(size).fill(null);\n\n          for (let i = 0; i < size; i++) this._coordinates[i] = new Coordinate();\n        } else if (hasInterface(arguments[0], CoordinateSequence)) {\n          const coordSeq = arguments[0];\n\n          if (coordSeq === null) {\n            this._coordinates = new Array(0).fill(null);\n            return null;\n          }\n\n          this._dimension = coordSeq.getDimension();\n          this._measures = coordSeq.getMeasures();\n          this._coordinates = new Array(coordSeq.size()).fill(null);\n\n          for (let i = 0; i < this._coordinates.length; i++) this._coordinates[i] = coordSeq.getCoordinateCopy(i);\n        }\n      } else if (arguments.length === 2) {\n        if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n          const coordinates = arguments[0],\n                dimension = arguments[1];\n          CoordinateArraySequence.constructor_.call(this, coordinates, dimension, CoordinateArrays.measures(coordinates));\n        } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n          const size = arguments[0],\n                dimension = arguments[1];\n          this._coordinates = new Array(size).fill(null);\n          this._dimension = dimension;\n\n          for (let i = 0; i < size; i++) this._coordinates[i] = Coordinates.create(dimension);\n        }\n      } else if (arguments.length === 3) {\n        if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n          const coordinates = arguments[0],\n                dimension = arguments[1],\n                measures = arguments[2];\n          this._dimension = dimension;\n          this._measures = measures;\n          if (coordinates === null) this._coordinates = new Array(0).fill(null);else this._coordinates = coordinates;\n        } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n          const size = arguments[0],\n                dimension = arguments[1],\n                measures = arguments[2];\n          this._coordinates = new Array(size).fill(null);\n          this._dimension = dimension;\n          this._measures = measures;\n\n          for (let i = 0; i < size; i++) this._coordinates[i] = this.createCoordinate();\n        }\n      }\n    }\n\n    getM(index) {\n      if (this.hasM()) return this._coordinates[index].getM();else return Double.NaN;\n    }\n\n    setOrdinate(index, ordinateIndex, value) {\n      switch (ordinateIndex) {\n        case CoordinateSequence.X:\n          this._coordinates[index].x = value;\n          break;\n\n        case CoordinateSequence.Y:\n          this._coordinates[index].y = value;\n          break;\n\n        default:\n          this._coordinates[index].setOrdinate(ordinateIndex, value);\n\n      }\n    }\n\n    getZ(index) {\n      if (this.hasZ()) return this._coordinates[index].getZ();else return Double.NaN;\n    }\n\n    size() {\n      return this._coordinates.length;\n    }\n\n    getOrdinate(index, ordinateIndex) {\n      switch (ordinateIndex) {\n        case CoordinateSequence.X:\n          return this._coordinates[index].x;\n\n        case CoordinateSequence.Y:\n          return this._coordinates[index].y;\n\n        default:\n          return this._coordinates[index].getOrdinate(ordinateIndex);\n      }\n    }\n\n    getCoordinate() {\n      if (arguments.length === 1) {\n        const i = arguments[0];\n        return this._coordinates[i];\n      } else if (arguments.length === 2) {\n        const index = arguments[0],\n              coord = arguments[1];\n        coord.setCoordinate(this._coordinates[index]);\n      }\n    }\n\n    getCoordinateCopy(i) {\n      const copy = this.createCoordinate();\n      copy.setCoordinate(this._coordinates[i]);\n      return copy;\n    }\n\n    createCoordinate() {\n      return Coordinates.create(this.getDimension(), this.getMeasures());\n    }\n\n    getDimension() {\n      return this._dimension;\n    }\n\n    getX(index) {\n      return this._coordinates[index].x;\n    }\n\n    getMeasures() {\n      return this._measures;\n    }\n\n    expandEnvelope(env) {\n      for (let i = 0; i < this._coordinates.length; i++) env.expandToInclude(this._coordinates[i]);\n\n      return env;\n    }\n\n    copy() {\n      const cloneCoordinates = new Array(this.size()).fill(null);\n\n      for (let i = 0; i < this._coordinates.length; i++) {\n        const duplicate = this.createCoordinate();\n        duplicate.setCoordinate(this._coordinates[i]);\n        cloneCoordinates[i] = duplicate;\n      }\n\n      return new CoordinateArraySequence(cloneCoordinates, this._dimension, this._measures);\n    }\n\n    toString() {\n      if (this._coordinates.length > 0) {\n        const strBuilder = new StringBuilder(17 * this._coordinates.length);\n        strBuilder.append('(');\n        strBuilder.append(this._coordinates[0]);\n\n        for (let i = 1; i < this._coordinates.length; i++) {\n          strBuilder.append(', ');\n          strBuilder.append(this._coordinates[i]);\n        }\n\n        strBuilder.append(')');\n        return strBuilder.toString();\n      } else {\n        return '()';\n      }\n    }\n\n    getY(index) {\n      return this._coordinates[index].y;\n    }\n\n    toCoordinateArray() {\n      return this._coordinates;\n    }\n\n    get interfaces_() {\n      return [CoordinateSequence, Serializable];\n    }\n\n  }\n\n  class CoordinateArraySequenceFactory {\n    static instance() {\n      return CoordinateArraySequenceFactory.instanceObject;\n    }\n\n    readResolve() {\n      return CoordinateArraySequenceFactory.instance();\n    }\n\n    create() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof Array) {\n          const coordinates = arguments[0];\n          return new CoordinateArraySequence(coordinates);\n        } else if (hasInterface(arguments[0], CoordinateSequence)) {\n          const coordSeq = arguments[0];\n          return new CoordinateArraySequence(coordSeq);\n        }\n      } else if (arguments.length === 2) {\n        let size = arguments[0],\n            dimension = arguments[1];\n        if (dimension > 3) dimension = 3;\n        if (dimension < 2) dimension = 2;\n        return new CoordinateArraySequence(size, dimension);\n      } else if (arguments.length === 3) {\n        let size = arguments[0],\n            dimension = arguments[1],\n            measures = arguments[2];\n        let spatial = dimension - measures;\n        if (measures > 1) measures = 1;\n        if (spatial > 3) spatial = 3;\n        if (spatial < 2) spatial = 2;\n        return new CoordinateArraySequence(size, spatial + measures, measures);\n      }\n    }\n\n    get interfaces_() {\n      return [CoordinateSequenceFactory, Serializable];\n    }\n\n  }\n  CoordinateArraySequenceFactory.instanceObject = new CoordinateArraySequenceFactory();\n\n  class MultiPolygon extends GeometryCollection {\n    constructor() {\n      super();\n      MultiPolygon.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      const polygons = arguments[0],\n            factory = arguments[1];\n      GeometryCollection.constructor_.call(this, polygons, factory);\n    }\n\n    copyInternal() {\n      const polygons = new Array(this._geometries.length).fill(null);\n\n      for (let i = 0; i < polygons.length; i++) polygons[i] = this._geometries[i].copy();\n\n      return new MultiPolygon(polygons, this._factory);\n    }\n\n    equalsExact() {\n      if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof Geometry) {\n        const other = arguments[0],\n              tolerance = arguments[1];\n        if (!this.isEquivalentClass(other)) return false;\n        return super.equalsExact.call(this, other, tolerance);\n      } else {\n        return super.equalsExact.apply(this, arguments);\n      }\n    }\n\n    getBoundaryDimension() {\n      return 1;\n    }\n\n    getTypeCode() {\n      return Geometry.TYPECODE_MULTIPOLYGON;\n    }\n\n    getDimension() {\n      return 2;\n    }\n\n    getBoundary() {\n      if (this.isEmpty()) return this.getFactory().createMultiLineString();\n      const allRings = new ArrayList();\n\n      for (let i = 0; i < this._geometries.length; i++) {\n        const polygon = this._geometries[i];\n        const rings = polygon.getBoundary();\n\n        for (let j = 0; j < rings.getNumGeometries(); j++) allRings.add(rings.getGeometryN(j));\n      }\n\n      const allRingsArray = new Array(allRings.size()).fill(null);\n      return this.getFactory().createMultiLineString(allRings.toArray(allRingsArray));\n    }\n\n    getGeometryType() {\n      return Geometry.TYPENAME_MULTIPOLYGON;\n    }\n\n    get interfaces_() {\n      return [Polygonal];\n    }\n\n  }\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html\n   */\n  class Map$1 {\n    /**\n       * Returns the value to which the specified key is mapped, or null if this map\n       * contains no mapping for the key.\n       * @param {Object} key\n       * @return {Object}\n       */\n    get() {}\n    /**\n       * Associates the specified value with the specified key in this map (optional\n       * operation).\n       * @param {Object} key\n       * @param {Object} value\n       * @return {Object}\n       */\n\n\n    put() {}\n    /**\n       * Returns the number of key-value mappings in this map.\n       * @return {number}\n       */\n\n\n    size() {}\n    /**\n       * Returns a Collection view of the values contained in this map.\n       * @return {javascript.util.Collection}\n       */\n\n\n    values() {}\n    /**\n       * Returns a {@link Set} view of the mappings contained in this map.\n       * The set is backed by the map, so changes to the map are\n       * reflected in the set, and vice-versa.  If the map is modified\n       * while an iteration over the set is in progress (except through\n       * the iterator's own <tt>remove</tt> operation, or through the\n       * <tt>setValue</tt> operation on a map entry returned by the\n       * iterator) the results of the iteration are undefined.  The set\n       * supports element removal, which removes the corresponding\n       * mapping from the map, via the <tt>Iterator.remove</tt>,\n       * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and\n       * <tt>clear</tt> operations.  It does not support the\n       * <tt>add</tt> or <tt>addAll</tt> operations.\n       *\n       * @return {Set} a set view of the mappings contained in this map\n       */\n\n\n    entrySet() {}\n\n  }\n\n  /**\n   * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html\n   */\n\n  class HashSet extends Set {\n    constructor(o) {\n      super();\n      this.map = new Map();\n      if (o instanceof Collection) this.addAll(o);\n    }\n\n    contains(o) {\n      const hashCode = o.hashCode ? o.hashCode() : o;\n      if (this.map.has(hashCode)) return true;\n      return false;\n    }\n\n    add(o) {\n      const hashCode = o.hashCode ? o.hashCode() : o;\n      if (this.map.has(hashCode)) return false;\n      return !!this.map.set(hashCode, o);\n    }\n\n    addAll(c) {\n      for (const e of c) this.add(e);\n\n      return true;\n    }\n\n    remove() {\n      throw new UnsupportedOperationException();\n    }\n\n    size() {\n      return this.map.size;\n    }\n\n    isEmpty() {\n      return this.map.size === 0;\n    }\n\n    toArray() {\n      return Array.from(this.map.values());\n    }\n\n    iterator() {\n      return new Iterator$2(this.map);\n    }\n\n    [Symbol.iterator]() {\n      return this.map;\n    }\n\n  }\n\n  class Iterator$2 {\n    constructor(map) {\n      this.iterator = map.values();\n      const {\n        done,\n        value\n      } = this.iterator.next();\n      this.done = done;\n      this.value = value;\n    }\n\n    next() {\n      if (this.done) throw new NoSuchElementException();\n      const current = this.value;\n      const {\n        done,\n        value\n      } = this.iterator.next();\n      this.done = done;\n      this.value = value;\n      return current;\n    }\n\n    hasNext() {\n      return !this.done;\n    }\n\n    remove() {\n      throw new UnsupportedOperationException();\n    }\n\n  }\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html\n   */\n\n  class HashMap extends Map$1 {\n    constructor() {\n      super();\n      this.map = new Map();\n    }\n\n    get(key) {\n      return this.map.get(key) || null;\n    }\n\n    put(key, value) {\n      this.map.set(key, value);\n      return value;\n    }\n\n    values() {\n      const arrayList = new ArrayList();\n      const it = this.map.values();\n      let o = it.next();\n\n      while (!o.done) {\n        arrayList.add(o.value);\n        o = it.next();\n      }\n\n      return arrayList;\n    }\n\n    entrySet() {\n      const hashSet = new HashSet();\n      this.map.entries().forEach(entry => hashSet.add(entry));\n      return hashSet;\n    }\n\n    size() {\n      return this.map.size();\n    }\n\n  }\n\n  class PrecisionModel {\n    constructor() {\n      PrecisionModel.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._modelType = null;\n      this._scale = null;\n      if (arguments.length === 0) this._modelType = PrecisionModel.FLOATING;else if (arguments.length === 1) if (arguments[0] instanceof Type) {\n        const modelType = arguments[0];\n        this._modelType = modelType;\n        if (modelType === PrecisionModel.FIXED) this.setScale(1.0);\n      } else if (typeof arguments[0] === 'number') {\n        const scale = arguments[0];\n        this._modelType = PrecisionModel.FIXED;\n        this.setScale(scale);\n      } else if (arguments[0] instanceof PrecisionModel) {\n        const pm = arguments[0];\n        this._modelType = pm._modelType;\n        this._scale = pm._scale;\n      }\n    }\n\n    static mostPrecise(pm1, pm2) {\n      if (pm1.compareTo(pm2) >= 0) return pm1;\n      return pm2;\n    }\n\n    equals(other) {\n      if (!(other instanceof PrecisionModel)) return false;\n      const otherPrecisionModel = other;\n      return this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale;\n    }\n\n    compareTo(o) {\n      const other = o;\n      const sigDigits = this.getMaximumSignificantDigits();\n      const otherSigDigits = other.getMaximumSignificantDigits();\n      return Integer.compare(sigDigits, otherSigDigits);\n    }\n\n    getScale() {\n      return this._scale;\n    }\n\n    isFloating() {\n      return this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE;\n    }\n\n    getType() {\n      return this._modelType;\n    }\n\n    toString() {\n      let description = 'UNKNOWN';\n      if (this._modelType === PrecisionModel.FLOATING) description = 'Floating';else if (this._modelType === PrecisionModel.FLOATING_SINGLE) description = 'Floating-Single';else if (this._modelType === PrecisionModel.FIXED) description = 'Fixed (Scale=' + this.getScale() + ')';\n      return description;\n    }\n\n    makePrecise() {\n      if (typeof arguments[0] === 'number') {\n        const val = arguments[0];\n        if (Double.isNaN(val)) return val;\n\n        if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n          const floatSingleVal = val;\n          return floatSingleVal;\n        }\n\n        if (this._modelType === PrecisionModel.FIXED) return Math.round(val * this._scale) / this._scale;\n        return val;\n      } else if (arguments[0] instanceof Coordinate) {\n        const coord = arguments[0];\n        if (this._modelType === PrecisionModel.FLOATING) return null;\n        coord.x = this.makePrecise(coord.x);\n        coord.y = this.makePrecise(coord.y);\n      }\n    }\n\n    getMaximumSignificantDigits() {\n      let maxSigDigits = 16;\n      if (this._modelType === PrecisionModel.FLOATING) maxSigDigits = 16;else if (this._modelType === PrecisionModel.FLOATING_SINGLE) maxSigDigits = 6;else if (this._modelType === PrecisionModel.FIXED) maxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));\n      return maxSigDigits;\n    }\n\n    setScale(scale) {\n      this._scale = Math.abs(scale);\n    }\n\n    get interfaces_() {\n      return [Serializable, Comparable];\n    }\n\n  }\n\n  class Type {\n    constructor() {\n      Type.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._name = null;\n      const name = arguments[0];\n      this._name = name;\n      Type.nameToTypeMap.put(name, this);\n    }\n\n    readResolve() {\n      return Type.nameToTypeMap.get(this._name);\n    }\n\n    toString() {\n      return this._name;\n    }\n\n    get interfaces_() {\n      return [Serializable];\n    }\n\n  }\n\n  Type.nameToTypeMap = new HashMap();\n  PrecisionModel.Type = Type;\n  PrecisionModel.FIXED = new Type('FIXED');\n  PrecisionModel.FLOATING = new Type('FLOATING');\n  PrecisionModel.FLOATING_SINGLE = new Type('FLOATING SINGLE');\n  PrecisionModel.maximumPreciseValue = 9007199254740992.0;\n\n  class MultiLineString extends GeometryCollection {\n    constructor() {\n      super();\n      MultiLineString.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      const lineStrings = arguments[0],\n            factory = arguments[1];\n      GeometryCollection.constructor_.call(this, lineStrings, factory);\n    }\n\n    copyInternal() {\n      const lineStrings = new Array(this._geometries.length).fill(null);\n\n      for (let i = 0; i < lineStrings.length; i++) lineStrings[i] = this._geometries[i].copy();\n\n      return new MultiLineString(lineStrings, this._factory);\n    }\n\n    equalsExact() {\n      if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof Geometry) {\n        const other = arguments[0],\n              tolerance = arguments[1];\n        if (!this.isEquivalentClass(other)) return false;\n        return super.equalsExact.call(this, other, tolerance);\n      } else {\n        return super.equalsExact.apply(this, arguments);\n      }\n    }\n\n    getBoundaryDimension() {\n      if (this.isClosed()) return Dimension.FALSE;\n      return 0;\n    }\n\n    isClosed() {\n      if (this.isEmpty()) return false;\n\n      for (let i = 0; i < this._geometries.length; i++) if (!this._geometries[i].isClosed()) return false;\n\n      return true;\n    }\n\n    getTypeCode() {\n      return Geometry.TYPECODE_MULTILINESTRING;\n    }\n\n    getDimension() {\n      return 1;\n    }\n\n    getBoundary() {\n      throw new UnsupportedOperationException();\n    }\n\n    getGeometryType() {\n      return Geometry.TYPENAME_MULTILINESTRING;\n    }\n\n    get interfaces_() {\n      return [Lineal];\n    }\n\n  }\n\n  class GeometryFactory {\n    constructor() {\n      GeometryFactory.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._precisionModel = null;\n      this._coordinateSequenceFactory = null;\n      this._SRID = null;\n\n      if (arguments.length === 0) {\n        GeometryFactory.constructor_.call(this, new PrecisionModel(), 0);\n      } else if (arguments.length === 1) {\n        if (hasInterface(arguments[0], CoordinateSequenceFactory)) {\n          const coordinateSequenceFactory = arguments[0];\n          GeometryFactory.constructor_.call(this, new PrecisionModel(), 0, coordinateSequenceFactory);\n        } else if (arguments[0] instanceof PrecisionModel) {\n          const precisionModel = arguments[0];\n          GeometryFactory.constructor_.call(this, precisionModel, 0, GeometryFactory.getDefaultCoordinateSequenceFactory());\n        }\n      } else if (arguments.length === 2) {\n        const precisionModel = arguments[0],\n              SRID = arguments[1];\n        GeometryFactory.constructor_.call(this, precisionModel, SRID, GeometryFactory.getDefaultCoordinateSequenceFactory());\n      } else if (arguments.length === 3) {\n        const precisionModel = arguments[0],\n              SRID = arguments[1],\n              coordinateSequenceFactory = arguments[2];\n        this._precisionModel = precisionModel;\n        this._coordinateSequenceFactory = coordinateSequenceFactory;\n        this._SRID = SRID;\n      }\n    }\n\n    static toMultiPolygonArray(multiPolygons) {\n      const multiPolygonArray = new Array(multiPolygons.size()).fill(null);\n      return multiPolygons.toArray(multiPolygonArray);\n    }\n\n    static toGeometryArray(geometries) {\n      if (geometries === null) return null;\n      const geometryArray = new Array(geometries.size()).fill(null);\n      return geometries.toArray(geometryArray);\n    }\n\n    static getDefaultCoordinateSequenceFactory() {\n      return CoordinateArraySequenceFactory.instance();\n    }\n\n    static toMultiLineStringArray(multiLineStrings) {\n      const multiLineStringArray = new Array(multiLineStrings.size()).fill(null);\n      return multiLineStrings.toArray(multiLineStringArray);\n    }\n\n    static toLineStringArray(lineStrings) {\n      const lineStringArray = new Array(lineStrings.size()).fill(null);\n      return lineStrings.toArray(lineStringArray);\n    }\n\n    static toMultiPointArray(multiPoints) {\n      const multiPointArray = new Array(multiPoints.size()).fill(null);\n      return multiPoints.toArray(multiPointArray);\n    }\n\n    static toLinearRingArray(linearRings) {\n      const linearRingArray = new Array(linearRings.size()).fill(null);\n      return linearRings.toArray(linearRingArray);\n    }\n\n    static toPointArray(points) {\n      const pointArray = new Array(points.size()).fill(null);\n      return points.toArray(pointArray);\n    }\n\n    static toPolygonArray(polygons) {\n      const polygonArray = new Array(polygons.size()).fill(null);\n      return polygons.toArray(polygonArray);\n    }\n\n    static createPointFromInternalCoord(coord, exemplar) {\n      exemplar.getPrecisionModel().makePrecise(coord);\n      return exemplar.getFactory().createPoint(coord);\n    }\n\n    createEmpty(dimension) {\n      switch (dimension) {\n        case -1:\n          return this.createGeometryCollection();\n\n        case 0:\n          return this.createPoint();\n\n        case 1:\n          return this.createLineString();\n\n        case 2:\n          return this.createPolygon();\n\n        default:\n          throw new IllegalArgumentException('Invalid dimension: ' + dimension);\n      }\n    }\n\n    toGeometry(envelope) {\n      if (envelope.isNull()) return this.createPoint();\n      if (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) return this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()));\n      if (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) return this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())]);\n      return this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null);\n    }\n\n    createLineString() {\n      if (arguments.length === 0) return this.createLineString(this.getCoordinateSequenceFactory().create([]));else if (arguments.length === 1) if (arguments[0] instanceof Array) {\n        const coordinates = arguments[0];\n        return this.createLineString(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n      } else if (hasInterface(arguments[0], CoordinateSequence)) {\n        const coordinates = arguments[0];\n        return new LineString(coordinates, this);\n      }\n    }\n\n    createMultiLineString() {\n      if (arguments.length === 0) {\n        return new MultiLineString(null, this);\n      } else if (arguments.length === 1) {\n        const lineStrings = arguments[0];\n        return new MultiLineString(lineStrings, this);\n      }\n    }\n\n    buildGeometry(geomList) {\n      let geomType = null;\n      let isHeterogeneous = false;\n      let hasGeometryCollection = false;\n\n      for (let i = geomList.iterator(); i.hasNext();) {\n        const geom = i.next();\n        const partType = geom.getTypeCode();\n        if (geomType === null) geomType = partType;\n        if (partType !== geomType) isHeterogeneous = true;\n        if (geom instanceof GeometryCollection) hasGeometryCollection = true;\n      }\n\n      if (geomType === null) return this.createGeometryCollection();\n      if (isHeterogeneous || hasGeometryCollection) return this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList));\n      const geom0 = geomList.iterator().next();\n      const isCollection = geomList.size() > 1;\n\n      if (isCollection) {\n        if (geom0 instanceof Polygon) return this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList));else if (geom0 instanceof LineString) return this.createMultiLineString(GeometryFactory.toLineStringArray(geomList));else if (geom0 instanceof Point) return this.createMultiPoint(GeometryFactory.toPointArray(geomList));\n        Assert.shouldNeverReachHere('Unhandled geometry type: ' + geom0.getGeometryType());\n      }\n\n      return geom0;\n    }\n\n    createMultiPointFromCoords(coordinates) {\n      return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n    }\n\n    createPoint() {\n      if (arguments.length === 0) return this.createPoint(this.getCoordinateSequenceFactory().create([]));else if (arguments.length === 1) if (arguments[0] instanceof Coordinate) {\n        const coordinate = arguments[0];\n        return this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null);\n      } else if (hasInterface(arguments[0], CoordinateSequence)) {\n        const coordinates = arguments[0];\n        return new Point(coordinates, this);\n      }\n    }\n\n    getCoordinateSequenceFactory() {\n      return this._coordinateSequenceFactory;\n    }\n\n    createPolygon() {\n      if (arguments.length === 0) {\n        return this.createPolygon(null, null);\n      } else if (arguments.length === 1) {\n        if (hasInterface(arguments[0], CoordinateSequence)) {\n          const shell = arguments[0];\n          return this.createPolygon(this.createLinearRing(shell));\n        } else if (arguments[0] instanceof Array) {\n          const shell = arguments[0];\n          return this.createPolygon(this.createLinearRing(shell));\n        } else if (arguments[0] instanceof LinearRing) {\n          const shell = arguments[0];\n          return this.createPolygon(shell, null);\n        }\n      } else if (arguments.length === 2) {\n        const shell = arguments[0],\n              holes = arguments[1];\n        return new Polygon(shell, holes, this);\n      }\n    }\n\n    getSRID() {\n      return this._SRID;\n    }\n\n    createGeometryCollection() {\n      if (arguments.length === 0) {\n        return new GeometryCollection(null, this);\n      } else if (arguments.length === 1) {\n        const geometries = arguments[0];\n        return new GeometryCollection(geometries, this);\n      }\n    }\n\n    getPrecisionModel() {\n      return this._precisionModel;\n    }\n\n    createLinearRing() {\n      if (arguments.length === 0) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));else if (arguments.length === 1) if (arguments[0] instanceof Array) {\n        const coordinates = arguments[0];\n        return this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);\n      } else if (hasInterface(arguments[0], CoordinateSequence)) {\n        const coordinates = arguments[0];\n        return new LinearRing(coordinates, this);\n      }\n    }\n\n    createMultiPolygon() {\n      if (arguments.length === 0) {\n        return new MultiPolygon(null, this);\n      } else if (arguments.length === 1) {\n        const polygons = arguments[0];\n        return new MultiPolygon(polygons, this);\n      }\n    }\n\n    createMultiPoint() {\n      if (arguments.length === 0) return new MultiPoint(null, this);else if (arguments.length === 1) if (arguments[0] instanceof Array) {\n        const point = arguments[0];\n        return new MultiPoint(point, this);\n      } else if (hasInterface(arguments[0], CoordinateSequence)) {\n        const coordinates = arguments[0];\n        if (coordinates === null) return this.createMultiPoint(new Array(0).fill(null));\n        const points = new Array(coordinates.size()).fill(null);\n\n        for (let i = 0; i < coordinates.size(); i++) {\n          const ptSeq = this.getCoordinateSequenceFactory().create(1, coordinates.getDimension(), coordinates.getMeasures());\n          CoordinateSequences.copy(coordinates, i, ptSeq, 0, 1);\n          points[i] = this.createPoint(ptSeq);\n        }\n\n        return this.createMultiPoint(points);\n      }\n    }\n\n    get interfaces_() {\n      return [Serializable];\n    }\n\n  }\n\n  /**\n   * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\n   * or measure ('M') coordinate is available. Supported values are `'XY'`,\n   * `'XYZ'`, `'XYM'`, `'XYZM'`.\n   * @enum {string}\n   */\n\n  const GeometryLayout = {\n    XY: 'XY',\n    XYZ: 'XYZ',\n    XYM: 'XYM',\n    XYZM: 'XYZM'\n  };\n  /**\n   * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,\n   * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\n   * `'GeometryCollection'`, `'Circle'`.\n   * @enum {string}\n   */\n\n  const GeometryType = {\n    POINT: 'Point',\n    LINE_STRING: 'LineString',\n    LINEAR_RING: 'LinearRing',\n    POLYGON: 'Polygon',\n    MULTI_POINT: 'MultiPoint',\n    MULTI_LINE_STRING: 'MultiLineString',\n    MULTI_POLYGON: 'MultiPolygon',\n    GEOMETRY_COLLECTION: 'GeometryCollection',\n    CIRCLE: 'Circle'\n  };\n  /**\n   * @typedef {Object} Options\n   * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into\n   * multiple features on reading.\n   */\n\n  /**\n   * @typedef {Object} Token\n   * @property {number} type\n   * @property {number|string} [value]\n   * @property {number} position\n   */\n\n  /**\n   * @const\n   * @type {string}\n   */\n\n  const EMPTY = 'EMPTY';\n  /**\n   * @const\n   * @type {string}\n   */\n\n  const Z = 'Z';\n  /**\n   * @const\n   * @type {string}\n   */\n\n  const M = 'M';\n  /**\n   * @const\n   * @type {string}\n   */\n\n  const ZM = 'ZM';\n  /**\n   * @const\n   * @enum {number}\n   */\n\n  const TokenType = {\n    TEXT: 1,\n    LEFT_PAREN: 2,\n    RIGHT_PAREN: 3,\n    NUMBER: 4,\n    COMMA: 5,\n    EOF: 6\n  };\n  /**\n   * @const\n   * @type {Object<string, string>}\n   */\n\n  const WKTGeometryType = {};\n\n  for (const type in GeometryType) WKTGeometryType[type] = GeometryType[type].toUpperCase();\n  /**\n   * Class to tokenize a WKT string.\n   */\n\n\n  class Lexer {\n    /**\n     * @param {string} wkt WKT string.\n     */\n    constructor(wkt) {\n      /**\n       * @type {string}\n       */\n      this.wkt = wkt;\n      /**\n       * @type {number}\n       * @private\n       */\n\n      this.index_ = -1;\n    }\n    /**\n     * @param {string} c Character.\n     * @return {boolean} Whether the character is alphabetic.\n     * @private\n     */\n\n\n    isAlpha_(c) {\n      return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';\n    }\n    /**\n     * @param {string} c Character.\n     * @param {boolean=} opt_decimal Whether the string number\n     *     contains a dot, i.e. is a decimal number.\n     * @return {boolean} Whether the character is numeric.\n     * @private\n     */\n\n\n    isNumeric_(c, opt_decimal) {\n      const decimal = opt_decimal !== undefined ? opt_decimal : false;\n      return c >= '0' && c <= '9' || c == '.' && !decimal;\n    }\n    /**\n     * @param {string} c Character.\n     * @return {boolean} Whether the character is whitespace.\n     * @private\n     */\n\n\n    isWhiteSpace_(c) {\n      return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n    }\n    /**\n     * @return {string} Next string character.\n     * @private\n     */\n\n\n    nextChar_() {\n      return this.wkt.charAt(++this.index_);\n    }\n    /**\n     * Fetch and return the next token.\n     * @return {!Token} Next string token.\n     */\n\n\n    nextToken() {\n      const c = this.nextChar_();\n      const position = this.index_;\n      /** @type {number|string} */\n\n      let value = c;\n      let type;\n\n      if (c == '(') {\n        type = TokenType.LEFT_PAREN;\n      } else if (c == ',') {\n        type = TokenType.COMMA;\n      } else if (c == ')') {\n        type = TokenType.RIGHT_PAREN;\n      } else if (this.isNumeric_(c) || c == '-') {\n        type = TokenType.NUMBER;\n        value = this.readNumber_();\n      } else if (this.isAlpha_(c)) {\n        type = TokenType.TEXT;\n        value = this.readText_();\n      } else if (this.isWhiteSpace_(c)) {\n        return this.nextToken();\n      } else if (c === '') {\n        type = TokenType.EOF;\n      } else {\n        throw new Error('Unexpected character: ' + c);\n      }\n\n      return {\n        position: position,\n        value: value,\n        type: type\n      };\n    }\n    /**\n     * @return {number} Numeric token value.\n     * @private\n     */\n\n\n    readNumber_() {\n      let c;\n      const index = this.index_;\n      let decimal = false;\n      let scientificNotation = false;\n\n      do {\n        if (c == '.') decimal = true;else if (c == 'e' || c == 'E') scientificNotation = true;\n        c = this.nextChar_();\n      } while (this.isNumeric_(c, decimal) || // if we haven't detected a scientific number before, 'e' or 'E'\n      // hint that we should continue to read\n      !scientificNotation && (c == 'e' || c == 'E') || // once we know that we have a scientific number, both '-' and '+'\n      // are allowed\n      scientificNotation && (c == '-' || c == '+'));\n\n      return parseFloat(this.wkt.substring(index, this.index_--));\n    }\n    /**\n     * @return {string} String token value.\n     * @private\n     */\n\n\n    readText_() {\n      let c;\n      const index = this.index_;\n\n      do c = this.nextChar_(); while (this.isAlpha_(c));\n\n      return this.wkt.substring(index, this.index_--).toUpperCase();\n    }\n\n  }\n  /**\n   * Class to parse the tokens from the WKT string.\n   */\n\n\n  class Parser {\n    /**\n     * @param {Lexer} lexer The lexer.\n     */\n    constructor(lexer, factory) {\n      /**\n       * @type {Lexer}\n       * @private\n       */\n      this.lexer_ = lexer;\n      /**\n       * @type {Token}\n       * @private\n       */\n\n      this.token_;\n      /**\n       * @type {import(\"../geom/GeometryLayout.js\").default}\n       * @private\n       */\n\n      this.layout_ = GeometryLayout.XY;\n      this.factory = factory;\n    }\n    /**\n     * Fetch the next token form the lexer and replace the active token.\n     * @private\n     */\n\n\n    consume_() {\n      this.token_ = this.lexer_.nextToken();\n    }\n    /**\n     * Tests if the given type matches the type of the current token.\n     * @param {TokenType} type Token type.\n     * @return {boolean} Whether the token matches the given type.\n     */\n\n\n    isTokenType(type) {\n      const isMatch = this.token_.type == type;\n      return isMatch;\n    }\n    /**\n     * If the given type matches the current token, consume it.\n     * @param {TokenType} type Token type.\n     * @return {boolean} Whether the token matches the given type.\n     */\n\n\n    match(type) {\n      const isMatch = this.isTokenType(type);\n      if (isMatch) this.consume_();\n      return isMatch;\n    }\n    /**\n     * Try to parse the tokens provided by the lexer.\n     * @return {import(\"../geom/Geometry.js\").default} The geometry.\n     */\n\n\n    parse() {\n      this.consume_();\n      const geometry = this.parseGeometry_();\n      return geometry;\n    }\n    /**\n     * Try to parse the dimensional info.\n     * @return {import(\"../geom/GeometryLayout.js\").default} The layout.\n     * @private\n     */\n\n\n    parseGeometryLayout_() {\n      let layout = GeometryLayout.XY;\n      const dimToken = this.token_;\n\n      if (this.isTokenType(TokenType.TEXT)) {\n        const dimInfo = dimToken.value;\n        if (dimInfo === Z) layout = GeometryLayout.XYZ;else if (dimInfo === M) layout = GeometryLayout.XYM;else if (dimInfo === ZM) layout = GeometryLayout.XYZM;\n        if (layout !== GeometryLayout.XY) this.consume_();\n      }\n\n      return layout;\n    }\n    /**\n     * @return {!Array<import(\"../geom/Geometry.js\").default>} A collection of geometries.\n     * @private\n     */\n\n\n    parseGeometryCollectionText_() {\n      if (this.match(TokenType.LEFT_PAREN)) {\n        const geometries = [];\n\n        do geometries.push(this.parseGeometry_()); while (this.match(TokenType.COMMA));\n\n        if (this.match(TokenType.RIGHT_PAREN)) return geometries;\n      } else if (this.isEmptyGeometry_()) {\n        return [];\n      }\n\n      throw new Error(this.formatErrorMessage_());\n    }\n    /**\n     * @return {Array<number>} All values in a point.\n     * @private\n     */\n\n\n    parsePointText_() {\n      if (this.match(TokenType.LEFT_PAREN)) {\n        const coordinates = this.parsePoint_();\n        if (this.match(TokenType.RIGHT_PAREN)) return coordinates;\n      } else if (this.isEmptyGeometry_()) {\n        return null;\n      }\n\n      throw new Error(this.formatErrorMessage_());\n    }\n    /**\n     * @return {!Array<!Array<number>>} All points in a linestring.\n     * @private\n     */\n\n\n    parseLineStringText_() {\n      if (this.match(TokenType.LEFT_PAREN)) {\n        const coordinates = this.parsePointList_();\n        if (this.match(TokenType.RIGHT_PAREN)) return coordinates;\n      } else if (this.isEmptyGeometry_()) {\n        return [];\n      }\n\n      throw new Error(this.formatErrorMessage_());\n    }\n    /**\n     * @return {!Array<!Array<!Array<number>>>} All points in a polygon.\n     * @private\n     */\n\n\n    parsePolygonText_() {\n      if (this.match(TokenType.LEFT_PAREN)) {\n        const coordinates = this.parseLineStringTextList_();\n        if (this.match(TokenType.RIGHT_PAREN)) return coordinates;\n      } else if (this.isEmptyGeometry_()) {\n        return [];\n      }\n\n      throw new Error(this.formatErrorMessage_());\n    }\n    /**\n     * @return {!Array<!Array<number>>} All points in a multipoint.\n     * @private\n     */\n\n\n    parseMultiPointText_() {\n      if (this.match(TokenType.LEFT_PAREN)) {\n        let coordinates;\n        if (this.token_.type == TokenType.LEFT_PAREN) coordinates = this.parsePointTextList_();else coordinates = this.parsePointList_();\n        if (this.match(TokenType.RIGHT_PAREN)) return coordinates;\n      } else if (this.isEmptyGeometry_()) {\n        return [];\n      }\n\n      throw new Error(this.formatErrorMessage_());\n    }\n    /**\n     * @return {!Array<!Array<!Array<number>>>} All linestring points\n     *                                          in a multilinestring.\n     * @private\n     */\n\n\n    parseMultiLineStringText_() {\n      if (this.match(TokenType.LEFT_PAREN)) {\n        const coordinates = this.parseLineStringTextList_();\n        if (this.match(TokenType.RIGHT_PAREN)) return coordinates;\n      } else if (this.isEmptyGeometry_()) {\n        return [];\n      }\n\n      throw new Error(this.formatErrorMessage_());\n    }\n    /**\n     * @return {!Array<!Array<!Array<!Array<number>>>>} All polygon points in a multipolygon.\n     * @private\n     */\n\n\n    parseMultiPolygonText_() {\n      if (this.match(TokenType.LEFT_PAREN)) {\n        const coordinates = this.parsePolygonTextList_();\n        if (this.match(TokenType.RIGHT_PAREN)) return coordinates;\n      } else if (this.isEmptyGeometry_()) {\n        return [];\n      }\n\n      throw new Error(this.formatErrorMessage_());\n    }\n    /**\n     * @return {!Array<number>} A point.\n     * @private\n     */\n\n\n    parsePoint_() {\n      const coordinates = [];\n      const dimensions = this.layout_.length;\n\n      for (let i = 0; i < dimensions; ++i) {\n        const token = this.token_;\n        if (this.match(TokenType.NUMBER)) coordinates.push(\n        /** @type {number} */\n        token.value);else break;\n      }\n\n      if (coordinates.length == dimensions) return coordinates;\n      throw new Error(this.formatErrorMessage_());\n    }\n    /**\n     * @return {!Array<!Array<number>>} An array of points.\n     * @private\n     */\n\n\n    parsePointList_() {\n      const coordinates = [this.parsePoint_()];\n\n      while (this.match(TokenType.COMMA)) coordinates.push(this.parsePoint_());\n\n      return coordinates;\n    }\n    /**\n     * @return {!Array<!Array<number>>} An array of points.\n     * @private\n     */\n\n\n    parsePointTextList_() {\n      const coordinates = [this.parsePointText_()];\n\n      while (this.match(TokenType.COMMA)) coordinates.push(this.parsePointText_());\n\n      return coordinates;\n    }\n    /**\n     * @return {!Array<!Array<!Array<number>>>} An array of points.\n     * @private\n     */\n\n\n    parseLineStringTextList_() {\n      const coordinates = [this.parseLineStringText_()];\n\n      while (this.match(TokenType.COMMA)) coordinates.push(this.parseLineStringText_());\n\n      return coordinates;\n    }\n    /**\n     * @return {!Array<!Array<!Array<!Array<number>>>>} An array of points.\n     * @private\n     */\n\n\n    parsePolygonTextList_() {\n      const coordinates = [this.parsePolygonText_()];\n\n      while (this.match(TokenType.COMMA)) coordinates.push(this.parsePolygonText_());\n\n      return coordinates;\n    }\n    /**\n     * @return {boolean} Whether the token implies an empty geometry.\n     * @private\n     */\n\n\n    isEmptyGeometry_() {\n      const isEmpty = this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;\n      if (isEmpty) this.consume_();\n      return isEmpty;\n    }\n    /**\n     * Create an error message for an unexpected token error.\n     * @return {string} Error message.\n     * @private\n     */\n\n\n    formatErrorMessage_() {\n      return 'Unexpected `' + this.token_.value + '` at position ' + this.token_.position + ' in `' + this.lexer_.wkt + '`';\n    }\n    /**\n     * @return {!import(\"../geom/Geometry.js\").default} The geometry.\n     * @private\n     */\n\n\n    parseGeometry_() {\n      const factory = this.factory;\n\n      const o2c = ordinates => new Coordinate(...ordinates);\n\n      const ca2p = coordinates => {\n        const rings = coordinates.map(a => factory.createLinearRing(a.map(o2c)));\n        if (rings.length > 1) return factory.createPolygon(rings[0], rings.slice(1));else return factory.createPolygon(rings[0]);\n      };\n\n      const token = this.token_;\n\n      if (this.match(TokenType.TEXT)) {\n        const geomType = token.value;\n        this.layout_ = this.parseGeometryLayout_();\n\n        if (geomType == 'GEOMETRYCOLLECTION') {\n          const geometries = this.parseGeometryCollectionText_();\n          return factory.createGeometryCollection(geometries);\n        } else {\n          switch (geomType) {\n            case 'POINT':\n              {\n                const ordinates = this.parsePointText_();\n                if (!ordinates) return factory.createPoint();\n                return factory.createPoint(new Coordinate(...ordinates));\n              }\n\n            case 'LINESTRING':\n              {\n                const coordinates = this.parseLineStringText_();\n                const components = coordinates.map(o2c);\n                return factory.createLineString(components);\n              }\n\n            case 'LINEARRING':\n              {\n                const coordinates = this.parseLineStringText_();\n                const components = coordinates.map(o2c);\n                return factory.createLinearRing(components);\n              }\n\n            case 'POLYGON':\n              {\n                const coordinates = this.parsePolygonText_();\n                if (!coordinates || coordinates.length === 0) return factory.createPolygon();\n                return ca2p(coordinates);\n              }\n\n            case 'MULTIPOINT':\n              {\n                const coordinates = this.parseMultiPointText_();\n                if (!coordinates || coordinates.length === 0) return factory.createMultiPoint();\n                const components = coordinates.map(o2c).map(c => factory.createPoint(c));\n                return factory.createMultiPoint(components);\n              }\n\n            case 'MULTILINESTRING':\n              {\n                const coordinates = this.parseMultiLineStringText_();\n                const components = coordinates.map(a => factory.createLineString(a.map(o2c)));\n                return factory.createMultiLineString(components);\n              }\n\n            case 'MULTIPOLYGON':\n              {\n                const coordinates = this.parseMultiPolygonText_();\n                if (!coordinates || coordinates.length === 0) return factory.createMultiPolygon();\n                const polygons = coordinates.map(ca2p);\n                return factory.createMultiPolygon(polygons);\n              }\n\n            default:\n              {\n                throw new Error('Invalid geometry type: ' + geomType);\n              }\n          }\n        }\n      }\n\n      throw new Error(this.formatErrorMessage_());\n    }\n\n  }\n  /**\n   * @param {Point} geom Point geometry.\n   * @return {string} Coordinates part of Point as WKT.\n   */\n\n\n  function encodePointGeometry(geom) {\n    if (geom.isEmpty()) return '';\n    const coordinate = geom.getCoordinate();\n    const coordinates = [coordinate.x, coordinate.y];\n    if (coordinate.z) coordinates.push(coordinate.z);\n    if (coordinate.m) coordinates.push(coordinate.m);\n    return coordinates.join(' ');\n  }\n  /**\n   * @param {MultiPoint} geom MultiPoint geometry.\n   * @return {string} Coordinates part of MultiPoint as WKT.\n   */\n\n\n  function encodeMultiPointGeometry(geom) {\n    const array = [];\n\n    for (let i = 0, ii = geom.getNumGeometries(); i < ii; ++i) array.push('(' + encodePointGeometry(geom.getGeometryN(i)) + ')');\n\n    return array.join(', ');\n  }\n  /**\n   * @param {GeometryCollection} geom GeometryCollection geometry.\n   * @return {string} Coordinates part of GeometryCollection as WKT.\n   */\n\n\n  function encodeGeometryCollectionGeometry(geom) {\n    const array = [];\n\n    for (let i = 0, ii = geom.getNumGeometries(); i < ii; ++i) array.push(encode(geom.getGeometryN(i)));\n\n    return array.join(', ');\n  }\n  /**\n   * @param {LineString|import(\"../geom/LinearRing.js\").default} geom LineString geometry.\n   * @return {string} Coordinates part of LineString as WKT.\n   */\n\n\n  function encodeLineStringGeometry(geom) {\n    const coordinates = geom.getCoordinates().map(c => [c.x, c.y]);\n    const array = [];\n\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) array.push(coordinates[i].join(' '));\n\n    return array.join(', ');\n  }\n  /**\n   * @param {MultiLineString} geom MultiLineString geometry.\n   * @return {string} Coordinates part of MultiLineString as WKT.\n   */\n\n\n  function encodeMultiLineStringGeometry(geom) {\n    const array = [];\n\n    for (let i = 0, ii = geom.getNumGeometries(); i < ii; ++i) array.push('(' + encodeLineStringGeometry(geom.getGeometryN(i)) + ')');\n\n    return array.join(', ');\n  }\n  /**\n   * @param {Polygon} geom Polygon geometry.\n   * @return {string} Coordinates part of Polygon as WKT.\n   */\n\n\n  function encodePolygonGeometry(geom) {\n    const array = [];\n    array.push('(' + encodeLineStringGeometry(geom.getExteriorRing()) + ')');\n\n    for (let i = 0, ii = geom.getNumInteriorRing(); i < ii; ++i) array.push('(' + encodeLineStringGeometry(geom.getInteriorRingN(i)) + ')');\n\n    return array.join(', ');\n  }\n  /**\n   * @param {MultiPolygon} geom MultiPolygon geometry.\n   * @return {string} Coordinates part of MultiPolygon as WKT.\n   */\n\n\n  function encodeMultiPolygonGeometry(geom) {\n    const array = [];\n\n    for (let i = 0, ii = geom.getNumGeometries(); i < ii; ++i) array.push('(' + encodePolygonGeometry(geom.getGeometryN(i)) + ')');\n\n    return array.join(', ');\n  }\n  /**\n   * @param {Geometry} geom Geometry geometry.\n   * @return {string} Potential dimensional information for WKT type.\n   */\n\n\n  function encodeGeometryLayout(geom) {\n    let dimInfo = '';\n    if (geom.isEmpty()) return dimInfo;\n    const c = geom.getCoordinate();\n    if (c.z) dimInfo += Z;\n    if (c.m) dimInfo += M;\n    return dimInfo;\n  }\n  /**\n   * @const\n   * @type {Object<string, function(import(\"../geom/Geometry.js\").default): string>}\n   */\n\n\n  const GeometryEncoder = {\n    'Point': encodePointGeometry,\n    'LineString': encodeLineStringGeometry,\n    'LinearRing': encodeLineStringGeometry,\n    'Polygon': encodePolygonGeometry,\n    'MultiPoint': encodeMultiPointGeometry,\n    'MultiLineString': encodeMultiLineStringGeometry,\n    'MultiPolygon': encodeMultiPolygonGeometry,\n    'GeometryCollection': encodeGeometryCollectionGeometry\n  };\n  /**\n   * Encode a geometry as WKT.\n   * @param {!import(\"../geom/Geometry.js\").default} geom The geometry to encode.\n   * @return {string} WKT string for the geometry.\n   */\n\n  function encode(geom) {\n    let type = geom.getGeometryType();\n    const geometryEncoder = GeometryEncoder[type];\n    type = type.toUpperCase();\n    const dimInfo = encodeGeometryLayout(geom);\n    if (dimInfo.length > 0) type += ' ' + dimInfo;\n    if (geom.isEmpty()) return type + ' ' + EMPTY;\n    const enc = geometryEncoder(geom);\n    return type + ' (' + enc + ')';\n  }\n  /**\n   * Class for reading and writing Well-Known Text.\n   *\n   * NOTE: Adapted from OpenLayers.\n   */\n\n\n  class WKTParser {\n    /** Create a new parser for WKT\n     *\n     * @param {GeometryFactory} geometryFactory\n     * @return An instance of WKTParser.\n     * @private\n     */\n    constructor(geometryFactory) {\n      this.geometryFactory = geometryFactory || new GeometryFactory();\n      this.precisionModel = this.geometryFactory.getPrecisionModel();\n    }\n    /**\n     * Deserialize a WKT string and return a geometry. Supports WKT for POINT,\n     * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,\n     * and GEOMETRYCOLLECTION.\n     *\n     * @param {String} wkt A WKT string.\n     * @return {Geometry} A geometry instance.\n     * @private\n     */\n\n\n    read(wkt) {\n      const lexer = new Lexer(wkt);\n      const parser = new Parser(lexer, this.geometryFactory);\n      const geometry = parser.parse();\n      return geometry;\n    }\n    /**\n     * Serialize a geometry into a WKT string.\n     *\n     * @param {Geometry} geometry A feature or array of features.\n     * @return {String} The WKT string representation of the input geometries.\n     * @private\n     */\n\n\n    write(geometry) {\n      return encode(geometry);\n    }\n\n  }\n\n  /**\n   * @module org/locationtech/jts/io/WKTWriter\n   */\n  /**\n   * Writes the Well-Known Text representation of a {@link Geometry}. The\n   * Well-Known Text format is defined in the <A\n   * HREF=\"http://www.opengis.org/techno/specs.htm\"> OGC Simple Features\n   * Specification for SQL</A>.\n   * <p>\n   * The <code>WKTWriter</code> outputs coordinates rounded to the precision\n   * model. Only the maximum number of decimal places necessary to represent the\n   * ordinates to the required precision will be output.\n   * <p>\n   * The SFS WKT spec does not define a special tag for {@link LinearRing}s.\n   * Under the spec, rings are output as <code>LINESTRING</code>s.\n   */\n\n  class WKTWriter {\n    /**\n     * @param {GeometryFactory} geometryFactory\n     */\n    constructor(geometryFactory) {\n      this.parser = new WKTParser(geometryFactory);\n    }\n    /**\n     * Converts a <code>Geometry</code> to its Well-known Text representation.\n     *\n     * @param {Geometry} geometry a <code>Geometry</code> to process.\n     * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple\n     *         Features Specification).\n     * @memberof module:org/locationtech/jts/io/WKTWriter#\n     */\n\n\n    write(geometry) {\n      return this.parser.write(geometry);\n    }\n    /**\n     * Generates the WKT for a <tt>LINESTRING</tt> specified by two\n     * {@link Coordinate}s.\n     *\n     * @param p0 the first coordinate.\n     * @param p1 the second coordinate.\n     *\n     * @return the WKT.\n     * @private\n     */\n\n\n    static toLineString(p0, p1) {\n      if (arguments.length !== 2) throw new Error('Not implemented');\n      return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )';\n    }\n\n  }\n\n  class LineIntersector {\n    constructor() {\n      LineIntersector.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._result = null;\n      this._inputLines = Array(2).fill().map(() => Array(2));\n      this._intPt = new Array(2).fill(null);\n      this._intLineIndex = null;\n      this._isProper = null;\n      this._pa = null;\n      this._pb = null;\n      this._precisionModel = null;\n      this._intPt[0] = new Coordinate();\n      this._intPt[1] = new Coordinate();\n      this._pa = this._intPt[0];\n      this._pb = this._intPt[1];\n      this._result = 0;\n    }\n\n    static computeEdgeDistance(p, p0, p1) {\n      const dx = Math.abs(p1.x - p0.x);\n      const dy = Math.abs(p1.y - p0.y);\n      let dist = -1.0;\n\n      if (p.equals(p0)) {\n        dist = 0.0;\n      } else if (p.equals(p1)) {\n        if (dx > dy) dist = dx;else dist = dy;\n      } else {\n        const pdx = Math.abs(p.x - p0.x);\n        const pdy = Math.abs(p.y - p0.y);\n        if (dx > dy) dist = pdx;else dist = pdy;\n        if (dist === 0.0 && !p.equals(p0)) dist = Math.max(pdx, pdy);\n      }\n\n      Assert.isTrue(!(dist === 0.0 && !p.equals(p0)), 'Bad distance calculation');\n      return dist;\n    }\n\n    static nonRobustComputeEdgeDistance(p, p1, p2) {\n      const dx = p.x - p1.x;\n      const dy = p.y - p1.y;\n      const dist = Math.sqrt(dx * dx + dy * dy);\n      Assert.isTrue(!(dist === 0.0 && !p.equals(p1)), 'Invalid distance calculation');\n      return dist;\n    }\n\n    getIndexAlongSegment(segmentIndex, intIndex) {\n      this.computeIntLineIndex();\n      return this._intLineIndex[segmentIndex][intIndex];\n    }\n\n    getTopologySummary() {\n      const catBuilder = new StringBuilder();\n      if (this.isEndPoint()) catBuilder.append(' endpoint');\n      if (this._isProper) catBuilder.append(' proper');\n      if (this.isCollinear()) catBuilder.append(' collinear');\n      return catBuilder.toString();\n    }\n\n    computeIntersection(p1, p2, p3, p4) {\n      this._inputLines[0][0] = p1;\n      this._inputLines[0][1] = p2;\n      this._inputLines[1][0] = p3;\n      this._inputLines[1][1] = p4;\n      this._result = this.computeIntersect(p1, p2, p3, p4);\n    }\n\n    getIntersectionNum() {\n      return this._result;\n    }\n\n    computeIntLineIndex() {\n      if (arguments.length === 0) {\n        if (this._intLineIndex === null) {\n          this._intLineIndex = Array(2).fill().map(() => Array(2));\n          this.computeIntLineIndex(0);\n          this.computeIntLineIndex(1);\n        }\n      } else if (arguments.length === 1) {\n        const segmentIndex = arguments[0];\n        const dist0 = this.getEdgeDistance(segmentIndex, 0);\n        const dist1 = this.getEdgeDistance(segmentIndex, 1);\n\n        if (dist0 > dist1) {\n          this._intLineIndex[segmentIndex][0] = 0;\n          this._intLineIndex[segmentIndex][1] = 1;\n        } else {\n          this._intLineIndex[segmentIndex][0] = 1;\n          this._intLineIndex[segmentIndex][1] = 0;\n        }\n      }\n    }\n\n    isProper() {\n      return this.hasIntersection() && this._isProper;\n    }\n\n    setPrecisionModel(precisionModel) {\n      this._precisionModel = precisionModel;\n    }\n\n    isInteriorIntersection() {\n      if (arguments.length === 0) {\n        if (this.isInteriorIntersection(0)) return true;\n        if (this.isInteriorIntersection(1)) return true;\n        return false;\n      } else if (arguments.length === 1) {\n        const inputLineIndex = arguments[0];\n\n        for (let i = 0; i < this._result; i++) if (!(this._intPt[i].equals2D(this._inputLines[inputLineIndex][0]) || this._intPt[i].equals2D(this._inputLines[inputLineIndex][1]))) return true;\n\n        return false;\n      }\n    }\n\n    getIntersection(intIndex) {\n      return this._intPt[intIndex];\n    }\n\n    isEndPoint() {\n      return this.hasIntersection() && !this._isProper;\n    }\n\n    hasIntersection() {\n      return this._result !== LineIntersector.NO_INTERSECTION;\n    }\n\n    getEdgeDistance(segmentIndex, intIndex) {\n      const dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);\n      return dist;\n    }\n\n    isCollinear() {\n      return this._result === LineIntersector.COLLINEAR_INTERSECTION;\n    }\n\n    toString() {\n      return WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + ' - ' + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();\n    }\n\n    getEndpoint(segmentIndex, ptIndex) {\n      return this._inputLines[segmentIndex][ptIndex];\n    }\n\n    isIntersection(pt) {\n      for (let i = 0; i < this._result; i++) if (this._intPt[i].equals2D(pt)) return true;\n\n      return false;\n    }\n\n    getIntersectionAlongSegment(segmentIndex, intIndex) {\n      this.computeIntLineIndex();\n      return this._intPt[this._intLineIndex[segmentIndex][intIndex]];\n    }\n\n  }\n  LineIntersector.DONT_INTERSECT = 0;\n  LineIntersector.DO_INTERSECT = 1;\n  LineIntersector.COLLINEAR = 2;\n  LineIntersector.NO_INTERSECTION = 0;\n  LineIntersector.POINT_INTERSECTION = 1;\n  LineIntersector.COLLINEAR_INTERSECTION = 2;\n\n  class RobustLineIntersector extends LineIntersector {\n    constructor() {\n      super();\n    }\n\n    static nearestEndpoint(p1, p2, q1, q2) {\n      let nearestPt = p1;\n      let minDist = Distance.pointToSegment(p1, q1, q2);\n      let dist = Distance.pointToSegment(p2, q1, q2);\n\n      if (dist < minDist) {\n        minDist = dist;\n        nearestPt = p2;\n      }\n\n      dist = Distance.pointToSegment(q1, p1, p2);\n\n      if (dist < minDist) {\n        minDist = dist;\n        nearestPt = q1;\n      }\n\n      dist = Distance.pointToSegment(q2, p1, p2);\n\n      if (dist < minDist) {\n        minDist = dist;\n        nearestPt = q2;\n      }\n\n      return nearestPt;\n    }\n\n    isInSegmentEnvelopes(intPt) {\n      const env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);\n      const env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);\n      return env0.contains(intPt) && env1.contains(intPt);\n    }\n\n    computeIntersection() {\n      if (arguments.length === 3) {\n        const p = arguments[0],\n              p1 = arguments[1],\n              p2 = arguments[2];\n        this._isProper = false;\n        if (Envelope.intersects(p1, p2, p)) if (Orientation.index(p1, p2, p) === 0 && Orientation.index(p2, p1, p) === 0) {\n          this._isProper = true;\n          if (p.equals(p1) || p.equals(p2)) this._isProper = false;\n          this._result = LineIntersector.POINT_INTERSECTION;\n          return null;\n        }\n        this._result = LineIntersector.NO_INTERSECTION;\n      } else {\n        return super.computeIntersection.apply(this, arguments);\n      }\n    }\n\n    intersection(p1, p2, q1, q2) {\n      let intPt = this.intersectionSafe(p1, p2, q1, q2);\n      if (!this.isInSegmentEnvelopes(intPt)) intPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));\n      if (this._precisionModel !== null) this._precisionModel.makePrecise(intPt);\n      return intPt;\n    }\n\n    checkDD(p1, p2, q1, q2, intPt) {\n      const intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);\n      const isIn = this.isInSegmentEnvelopes(intPtDD);\n      System.out.println('DD in env = ' + isIn + '  --------------------- ' + intPtDD);\n      if (intPt.distance(intPtDD) > 0.0001) System.out.println('Distance = ' + intPt.distance(intPtDD));\n    }\n\n    intersectionSafe(p1, p2, q1, q2) {\n      let intPt = Intersection.intersection(p1, p2, q1, q2);\n      if (intPt === null) intPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);\n      return intPt;\n    }\n\n    computeCollinearIntersection(p1, p2, q1, q2) {\n      const p1q1p2 = Envelope.intersects(p1, p2, q1);\n      const p1q2p2 = Envelope.intersects(p1, p2, q2);\n      const q1p1q2 = Envelope.intersects(q1, q2, p1);\n      const q1p2q2 = Envelope.intersects(q1, q2, p2);\n\n      if (p1q1p2 && p1q2p2) {\n        this._intPt[0] = q1;\n        this._intPt[1] = q2;\n        return LineIntersector.COLLINEAR_INTERSECTION;\n      }\n\n      if (q1p1q2 && q1p2q2) {\n        this._intPt[0] = p1;\n        this._intPt[1] = p2;\n        return LineIntersector.COLLINEAR_INTERSECTION;\n      }\n\n      if (p1q1p2 && q1p1q2) {\n        this._intPt[0] = q1;\n        this._intPt[1] = p1;\n        return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n      }\n\n      if (p1q1p2 && q1p2q2) {\n        this._intPt[0] = q1;\n        this._intPt[1] = p2;\n        return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n      }\n\n      if (p1q2p2 && q1p1q2) {\n        this._intPt[0] = q2;\n        this._intPt[1] = p1;\n        return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n      }\n\n      if (p1q2p2 && q1p2q2) {\n        this._intPt[0] = q2;\n        this._intPt[1] = p2;\n        return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector.POINT_INTERSECTION : LineIntersector.COLLINEAR_INTERSECTION;\n      }\n\n      return LineIntersector.NO_INTERSECTION;\n    }\n\n    computeIntersect(p1, p2, q1, q2) {\n      this._isProper = false;\n      if (!Envelope.intersects(p1, p2, q1, q2)) return LineIntersector.NO_INTERSECTION;\n      const Pq1 = Orientation.index(p1, p2, q1);\n      const Pq2 = Orientation.index(p1, p2, q2);\n      if (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) return LineIntersector.NO_INTERSECTION;\n      const Qp1 = Orientation.index(q1, q2, p1);\n      const Qp2 = Orientation.index(q1, q2, p2);\n      if (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) return LineIntersector.NO_INTERSECTION;\n      const collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;\n      if (collinear) return this.computeCollinearIntersection(p1, p2, q1, q2);\n\n      if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {\n        this._isProper = false;\n        if (p1.equals2D(q1) || p1.equals2D(q2)) this._intPt[0] = p1;else if (p2.equals2D(q1) || p2.equals2D(q2)) this._intPt[0] = p2;else if (Pq1 === 0) this._intPt[0] = new Coordinate(q1);else if (Pq2 === 0) this._intPt[0] = new Coordinate(q2);else if (Qp1 === 0) this._intPt[0] = new Coordinate(p1);else if (Qp2 === 0) this._intPt[0] = new Coordinate(p2);\n      } else {\n        this._isProper = true;\n        this._intPt[0] = this.intersection(p1, p2, q1, q2);\n      }\n\n      return LineIntersector.POINT_INTERSECTION;\n    }\n\n  }\n\n  class LineSegment {\n    constructor() {\n      LineSegment.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.p0 = null;\n      this.p1 = null;\n\n      if (arguments.length === 0) {\n        LineSegment.constructor_.call(this, new Coordinate(), new Coordinate());\n      } else if (arguments.length === 1) {\n        const ls = arguments[0];\n        LineSegment.constructor_.call(this, ls.p0, ls.p1);\n      } else if (arguments.length === 2) {\n        const p0 = arguments[0],\n              p1 = arguments[1];\n        this.p0 = p0;\n        this.p1 = p1;\n      } else if (arguments.length === 4) {\n        const x0 = arguments[0],\n              y0 = arguments[1],\n              x1 = arguments[2],\n              y1 = arguments[3];\n        LineSegment.constructor_.call(this, new Coordinate(x0, y0), new Coordinate(x1, y1));\n      }\n    }\n\n    static midPoint(p0, p1) {\n      return new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);\n    }\n\n    minX() {\n      return Math.min(this.p0.x, this.p1.x);\n    }\n\n    orientationIndex() {\n      if (arguments[0] instanceof LineSegment) {\n        const seg = arguments[0];\n        const orient0 = Orientation.index(this.p0, this.p1, seg.p0);\n        const orient1 = Orientation.index(this.p0, this.p1, seg.p1);\n        if (orient0 >= 0 && orient1 >= 0) return Math.max(orient0, orient1);\n        if (orient0 <= 0 && orient1 <= 0) return Math.max(orient0, orient1);\n        return 0;\n      } else if (arguments[0] instanceof Coordinate) {\n        const p = arguments[0];\n        return Orientation.index(this.p0, this.p1, p);\n      }\n    }\n\n    toGeometry(geomFactory) {\n      return geomFactory.createLineString([this.p0, this.p1]);\n    }\n\n    isVertical() {\n      return this.p0.x === this.p1.x;\n    }\n\n    equals(o) {\n      if (!(o instanceof LineSegment)) return false;\n      const other = o;\n      return this.p0.equals(other.p0) && this.p1.equals(other.p1);\n    }\n\n    intersection(line) {\n      const li = new RobustLineIntersector();\n      li.computeIntersection(this.p0, this.p1, line.p0, line.p1);\n      if (li.hasIntersection()) return li.getIntersection(0);\n      return null;\n    }\n\n    project() {\n      if (arguments[0] instanceof Coordinate) {\n        const p = arguments[0];\n        if (p.equals(this.p0) || p.equals(this.p1)) return new Coordinate(p);\n        const r = this.projectionFactor(p);\n        const coord = new Coordinate();\n        coord.x = this.p0.x + r * (this.p1.x - this.p0.x);\n        coord.y = this.p0.y + r * (this.p1.y - this.p0.y);\n        return coord;\n      } else if (arguments[0] instanceof LineSegment) {\n        const seg = arguments[0];\n        const pf0 = this.projectionFactor(seg.p0);\n        const pf1 = this.projectionFactor(seg.p1);\n        if (pf0 >= 1.0 && pf1 >= 1.0) return null;\n        if (pf0 <= 0.0 && pf1 <= 0.0) return null;\n        let newp0 = this.project(seg.p0);\n        if (pf0 < 0.0) newp0 = this.p0;\n        if (pf0 > 1.0) newp0 = this.p1;\n        let newp1 = this.project(seg.p1);\n        if (pf1 < 0.0) newp1 = this.p0;\n        if (pf1 > 1.0) newp1 = this.p1;\n        return new LineSegment(newp0, newp1);\n      }\n    }\n\n    normalize() {\n      if (this.p1.compareTo(this.p0) < 0) this.reverse();\n    }\n\n    angle() {\n      return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);\n    }\n\n    getCoordinate(i) {\n      if (i === 0) return this.p0;\n      return this.p1;\n    }\n\n    distancePerpendicular(p) {\n      return Distance.pointToLinePerpendicular(p, this.p0, this.p1);\n    }\n\n    minY() {\n      return Math.min(this.p0.y, this.p1.y);\n    }\n\n    midPoint() {\n      return LineSegment.midPoint(this.p0, this.p1);\n    }\n\n    projectionFactor(p) {\n      if (p.equals(this.p0)) return 0.0;\n      if (p.equals(this.p1)) return 1.0;\n      const dx = this.p1.x - this.p0.x;\n      const dy = this.p1.y - this.p0.y;\n      const len = dx * dx + dy * dy;\n      if (len <= 0.0) return Double.NaN;\n      const r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;\n      return r;\n    }\n\n    closestPoints(line) {\n      const intPt = this.intersection(line);\n      if (intPt !== null) return [intPt, intPt];\n      const closestPt = new Array(2).fill(null);\n      let minDistance = Double.MAX_VALUE;\n      let dist = null;\n      const close00 = this.closestPoint(line.p0);\n      minDistance = close00.distance(line.p0);\n      closestPt[0] = close00;\n      closestPt[1] = line.p0;\n      const close01 = this.closestPoint(line.p1);\n      dist = close01.distance(line.p1);\n\n      if (dist < minDistance) {\n        minDistance = dist;\n        closestPt[0] = close01;\n        closestPt[1] = line.p1;\n      }\n\n      const close10 = line.closestPoint(this.p0);\n      dist = close10.distance(this.p0);\n\n      if (dist < minDistance) {\n        minDistance = dist;\n        closestPt[0] = this.p0;\n        closestPt[1] = close10;\n      }\n\n      const close11 = line.closestPoint(this.p1);\n      dist = close11.distance(this.p1);\n\n      if (dist < minDistance) {\n        minDistance = dist;\n        closestPt[0] = this.p1;\n        closestPt[1] = close11;\n      }\n\n      return closestPt;\n    }\n\n    closestPoint(p) {\n      const factor = this.projectionFactor(p);\n      if (factor > 0 && factor < 1) return this.project(p);\n      const dist0 = this.p0.distance(p);\n      const dist1 = this.p1.distance(p);\n      if (dist0 < dist1) return this.p0;\n      return this.p1;\n    }\n\n    maxX() {\n      return Math.max(this.p0.x, this.p1.x);\n    }\n\n    getLength() {\n      return this.p0.distance(this.p1);\n    }\n\n    compareTo(o) {\n      const other = o;\n      const comp0 = this.p0.compareTo(other.p0);\n      if (comp0 !== 0) return comp0;\n      return this.p1.compareTo(other.p1);\n    }\n\n    reverse() {\n      const temp = this.p0;\n      this.p0 = this.p1;\n      this.p1 = temp;\n    }\n\n    equalsTopo(other) {\n      return this.p0.equals(other.p0) && this.p1.equals(other.p1) || this.p0.equals(other.p1) && this.p1.equals(other.p0);\n    }\n\n    lineIntersection(line) {\n      const intPt = Intersection.intersection(this.p0, this.p1, line.p0, line.p1);\n      return intPt;\n    }\n\n    maxY() {\n      return Math.max(this.p0.y, this.p1.y);\n    }\n\n    pointAlongOffset(segmentLengthFraction, offsetDistance) {\n      const segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n      const segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n      const dx = this.p1.x - this.p0.x;\n      const dy = this.p1.y - this.p0.y;\n      const len = Math.sqrt(dx * dx + dy * dy);\n      let ux = 0.0;\n      let uy = 0.0;\n\n      if (offsetDistance !== 0.0) {\n        if (len <= 0.0) throw new IllegalStateException('Cannot compute offset from zero-length line segment');\n        ux = offsetDistance * dx / len;\n        uy = offsetDistance * dy / len;\n      }\n\n      const offsetx = segx - uy;\n      const offsety = segy + ux;\n      const coord = new Coordinate(offsetx, offsety);\n      return coord;\n    }\n\n    setCoordinates() {\n      if (arguments.length === 1) {\n        const ls = arguments[0];\n        this.setCoordinates(ls.p0, ls.p1);\n      } else if (arguments.length === 2) {\n        const p0 = arguments[0],\n              p1 = arguments[1];\n        this.p0.x = p0.x;\n        this.p0.y = p0.y;\n        this.p1.x = p1.x;\n        this.p1.y = p1.y;\n      }\n    }\n\n    segmentFraction(inputPt) {\n      let segFrac = this.projectionFactor(inputPt);\n      if (segFrac < 0.0) segFrac = 0.0;else if (segFrac > 1.0 || Double.isNaN(segFrac)) segFrac = 1.0;\n      return segFrac;\n    }\n\n    toString() {\n      return 'LINESTRING( ' + this.p0.x + ' ' + this.p0.y + ', ' + this.p1.x + ' ' + this.p1.y + ')';\n    }\n\n    isHorizontal() {\n      return this.p0.y === this.p1.y;\n    }\n\n    reflect(p) {\n      const A = this.p1.getY() - this.p0.getY();\n      const B = this.p0.getX() - this.p1.getX();\n      const C = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY());\n      const A2plusB2 = A * A + B * B;\n      const A2subB2 = A * A - B * B;\n      const x = p.getX();\n      const y = p.getY();\n      const rx = (-A2subB2 * x - 2 * A * B * y - 2 * A * C) / A2plusB2;\n      const ry = (A2subB2 * y - 2 * A * B * x - 2 * B * C) / A2plusB2;\n      return new Coordinate(rx, ry);\n    }\n\n    distance() {\n      if (arguments[0] instanceof LineSegment) {\n        const ls = arguments[0];\n        return Distance.segmentToSegment(this.p0, this.p1, ls.p0, ls.p1);\n      } else if (arguments[0] instanceof Coordinate) {\n        const p = arguments[0];\n        return Distance.pointToSegment(p, this.p0, this.p1);\n      }\n    }\n\n    pointAlong(segmentLengthFraction) {\n      const coord = new Coordinate();\n      coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n      coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n      return coord;\n    }\n\n    hashCode() {\n      let bits0 = Double.doubleToLongBits(this.p0.x);\n      bits0 ^= Double.doubleToLongBits(this.p0.y) * 31;\n      const hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);\n      let bits1 = Double.doubleToLongBits(this.p1.x);\n      bits1 ^= Double.doubleToLongBits(this.p1.y) * 31;\n      const hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);\n      return hash0 ^ hash1;\n    }\n\n    get interfaces_() {\n      return [Comparable, Serializable];\n    }\n\n  }\n\n  class Location {\n    static toLocationSymbol(locationValue) {\n      switch (locationValue) {\n        case Location.EXTERIOR:\n          return 'e';\n\n        case Location.BOUNDARY:\n          return 'b';\n\n        case Location.INTERIOR:\n          return 'i';\n\n        case Location.NONE:\n          return '-';\n      }\n\n      throw new IllegalArgumentException('Unknown location value: ' + locationValue);\n    }\n\n  }\n  Location.INTERIOR = 0;\n  Location.BOUNDARY = 1;\n  Location.EXTERIOR = 2;\n  Location.NONE = -1;\n\n  class IntersectionMatrix {\n    constructor() {\n      IntersectionMatrix.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._matrix = null;\n\n      if (arguments.length === 0) {\n        this._matrix = Array(3).fill().map(() => Array(3));\n        this.setAll(Dimension.FALSE);\n      } else if (arguments.length === 1) {\n        if (typeof arguments[0] === 'string') {\n          const elements = arguments[0];\n          IntersectionMatrix.constructor_.call(this);\n          this.set(elements);\n        } else if (arguments[0] instanceof IntersectionMatrix) {\n          const other = arguments[0];\n          IntersectionMatrix.constructor_.call(this);\n          this._matrix[Location.INTERIOR][Location.INTERIOR] = other._matrix[Location.INTERIOR][Location.INTERIOR];\n          this._matrix[Location.INTERIOR][Location.BOUNDARY] = other._matrix[Location.INTERIOR][Location.BOUNDARY];\n          this._matrix[Location.INTERIOR][Location.EXTERIOR] = other._matrix[Location.INTERIOR][Location.EXTERIOR];\n          this._matrix[Location.BOUNDARY][Location.INTERIOR] = other._matrix[Location.BOUNDARY][Location.INTERIOR];\n          this._matrix[Location.BOUNDARY][Location.BOUNDARY] = other._matrix[Location.BOUNDARY][Location.BOUNDARY];\n          this._matrix[Location.BOUNDARY][Location.EXTERIOR] = other._matrix[Location.BOUNDARY][Location.EXTERIOR];\n          this._matrix[Location.EXTERIOR][Location.INTERIOR] = other._matrix[Location.EXTERIOR][Location.INTERIOR];\n          this._matrix[Location.EXTERIOR][Location.BOUNDARY] = other._matrix[Location.EXTERIOR][Location.BOUNDARY];\n          this._matrix[Location.EXTERIOR][Location.EXTERIOR] = other._matrix[Location.EXTERIOR][Location.EXTERIOR];\n        }\n      }\n    }\n\n    static matches() {\n      if (Number.isInteger(arguments[0]) && typeof arguments[1] === 'string') {\n        const actualDimensionValue = arguments[0],\n              requiredDimensionSymbol = arguments[1];\n        if (requiredDimensionSymbol === Dimension.SYM_DONTCARE) return true;\n        if (requiredDimensionSymbol === Dimension.SYM_TRUE && (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE)) return true;\n        if (requiredDimensionSymbol === Dimension.SYM_FALSE && actualDimensionValue === Dimension.FALSE) return true;\n        if (requiredDimensionSymbol === Dimension.SYM_P && actualDimensionValue === Dimension.P) return true;\n        if (requiredDimensionSymbol === Dimension.SYM_L && actualDimensionValue === Dimension.L) return true;\n        if (requiredDimensionSymbol === Dimension.SYM_A && actualDimensionValue === Dimension.A) return true;\n        return false;\n      } else if (typeof arguments[0] === 'string' && typeof arguments[1] === 'string') {\n        const actualDimensionSymbols = arguments[0],\n              requiredDimensionSymbols = arguments[1];\n        const m = new IntersectionMatrix(actualDimensionSymbols);\n        return m.matches(requiredDimensionSymbols);\n      }\n    }\n\n    static isTrue(actualDimensionValue) {\n      if (actualDimensionValue >= 0 || actualDimensionValue === Dimension.TRUE) return true;\n      return false;\n    }\n\n    isIntersects() {\n      return !this.isDisjoint();\n    }\n\n    isCovers() {\n      const hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);\n      return hasPointInCommon && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n    }\n\n    isCoveredBy() {\n      const hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]);\n      return hasPointInCommon && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n    }\n\n    set() {\n      if (arguments.length === 1) {\n        const dimensionSymbols = arguments[0];\n\n        for (let i = 0; i < dimensionSymbols.length; i++) {\n          const row = Math.trunc(i / 3);\n          const col = i % 3;\n          this._matrix[row][col] = Dimension.toDimensionValue(dimensionSymbols.charAt(i));\n        }\n      } else if (arguments.length === 3) {\n        const row = arguments[0],\n              column = arguments[1],\n              dimensionValue = arguments[2];\n        this._matrix[row][column] = dimensionValue;\n      }\n    }\n\n    isContains() {\n      return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n    }\n\n    setAtLeast() {\n      if (arguments.length === 1) {\n        const minimumDimensionSymbols = arguments[0];\n\n        for (let i = 0; i < minimumDimensionSymbols.length; i++) {\n          const row = Math.trunc(i / 3);\n          const col = i % 3;\n          this.setAtLeast(row, col, Dimension.toDimensionValue(minimumDimensionSymbols.charAt(i)));\n        }\n      } else if (arguments.length === 3) {\n        const row = arguments[0],\n              column = arguments[1],\n              minimumDimensionValue = arguments[2];\n        if (this._matrix[row][column] < minimumDimensionValue) this._matrix[row][column] = minimumDimensionValue;\n      }\n    }\n\n    setAtLeastIfValid(row, column, minimumDimensionValue) {\n      if (row >= 0 && column >= 0) this.setAtLeast(row, column, minimumDimensionValue);\n    }\n\n    isWithin() {\n      return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE;\n    }\n\n    isTouches(dimensionOfGeometryA, dimensionOfGeometryB) {\n      if (dimensionOfGeometryA > dimensionOfGeometryB) return this.isTouches(dimensionOfGeometryB, dimensionOfGeometryA);\n      if (dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L) return this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && (IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[Location.BOUNDARY][Location.BOUNDARY]));\n      return false;\n    }\n\n    isOverlaps(dimensionOfGeometryA, dimensionOfGeometryB) {\n      if (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.A) return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n      if (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) return this._matrix[Location.INTERIOR][Location.INTERIOR] === 1 && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n      return false;\n    }\n\n    isEquals(dimensionOfGeometryA, dimensionOfGeometryB) {\n      if (dimensionOfGeometryA !== dimensionOfGeometryB) return false;\n      return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && this._matrix[Location.INTERIOR][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.EXTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.EXTERIOR][Location.BOUNDARY] === Dimension.FALSE;\n    }\n\n    toString() {\n      const builder = new StringBuilder('123456789');\n\n      for (let ai = 0; ai < 3; ai++) for (let bi = 0; bi < 3; bi++) builder.setCharAt(3 * ai + bi, Dimension.toDimensionSymbol(this._matrix[ai][bi]));\n\n      return builder.toString();\n    }\n\n    setAll(dimensionValue) {\n      for (let ai = 0; ai < 3; ai++) for (let bi = 0; bi < 3; bi++) this._matrix[ai][bi] = dimensionValue;\n    }\n\n    get(row, column) {\n      return this._matrix[row][column];\n    }\n\n    transpose() {\n      let temp = this._matrix[1][0];\n      this._matrix[1][0] = this._matrix[0][1];\n      this._matrix[0][1] = temp;\n      temp = this._matrix[2][0];\n      this._matrix[2][0] = this._matrix[0][2];\n      this._matrix[0][2] = temp;\n      temp = this._matrix[2][1];\n      this._matrix[2][1] = this._matrix[1][2];\n      this._matrix[1][2] = temp;\n      return this;\n    }\n\n    matches(requiredDimensionSymbols) {\n      if (requiredDimensionSymbols.length !== 9) throw new IllegalArgumentException('Should be length 9: ' + requiredDimensionSymbols);\n\n      for (let ai = 0; ai < 3; ai++) for (let bi = 0; bi < 3; bi++) if (!IntersectionMatrix.matches(this._matrix[ai][bi], requiredDimensionSymbols.charAt(3 * ai + bi))) return false;\n\n      return true;\n    }\n\n    add(im) {\n      for (let i = 0; i < 3; i++) for (let j = 0; j < 3; j++) this.setAtLeast(i, j, im.get(i, j));\n    }\n\n    isDisjoint() {\n      return this._matrix[Location.INTERIOR][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.INTERIOR][Location.BOUNDARY] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.INTERIOR] === Dimension.FALSE && this._matrix[Location.BOUNDARY][Location.BOUNDARY] === Dimension.FALSE;\n    }\n\n    isCrosses(dimensionOfGeometryA, dimensionOfGeometryB) {\n      if (dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.L || dimensionOfGeometryA === Dimension.P && dimensionOfGeometryB === Dimension.A || dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.A) return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.EXTERIOR]);\n      if (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.P || dimensionOfGeometryA === Dimension.A && dimensionOfGeometryB === Dimension.L) return IntersectionMatrix.isTrue(this._matrix[Location.INTERIOR][Location.INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[Location.EXTERIOR][Location.INTERIOR]);\n      if (dimensionOfGeometryA === Dimension.L && dimensionOfGeometryB === Dimension.L) return this._matrix[Location.INTERIOR][Location.INTERIOR] === 0;\n      return false;\n    }\n\n    get interfaces_() {\n      return [Clonable];\n    }\n\n  }\n\n  class Angle {\n    static toDegrees(radians) {\n      return radians * 180 / Math.PI;\n    }\n\n    static normalize(angle) {\n      while (angle > Math.PI) angle -= Angle.PI_TIMES_2;\n\n      while (angle <= -Math.PI) angle += Angle.PI_TIMES_2;\n\n      return angle;\n    }\n\n    static angle() {\n      if (arguments.length === 1) {\n        const p = arguments[0];\n        return Math.atan2(p.y, p.x);\n      } else if (arguments.length === 2) {\n        const p0 = arguments[0],\n              p1 = arguments[1];\n        const dx = p1.x - p0.x;\n        const dy = p1.y - p0.y;\n        return Math.atan2(dy, dx);\n      }\n    }\n\n    static isAcute(p0, p1, p2) {\n      const dx0 = p0.x - p1.x;\n      const dy0 = p0.y - p1.y;\n      const dx1 = p2.x - p1.x;\n      const dy1 = p2.y - p1.y;\n      const dotprod = dx0 * dx1 + dy0 * dy1;\n      return dotprod > 0;\n    }\n\n    static isObtuse(p0, p1, p2) {\n      const dx0 = p0.x - p1.x;\n      const dy0 = p0.y - p1.y;\n      const dx1 = p2.x - p1.x;\n      const dy1 = p2.y - p1.y;\n      const dotprod = dx0 * dx1 + dy0 * dy1;\n      return dotprod < 0;\n    }\n\n    static interiorAngle(p0, p1, p2) {\n      const anglePrev = Angle.angle(p1, p0);\n      const angleNext = Angle.angle(p1, p2);\n      return Math.abs(angleNext - anglePrev);\n    }\n\n    static normalizePositive(angle) {\n      if (angle < 0.0) {\n        while (angle < 0.0) angle += Angle.PI_TIMES_2;\n\n        if (angle >= Angle.PI_TIMES_2) angle = 0.0;\n      } else {\n        while (angle >= Angle.PI_TIMES_2) angle -= Angle.PI_TIMES_2;\n\n        if (angle < 0.0) angle = 0.0;\n      }\n\n      return angle;\n    }\n\n    static angleBetween(tip1, tail, tip2) {\n      const a1 = Angle.angle(tail, tip1);\n      const a2 = Angle.angle(tail, tip2);\n      return Angle.diff(a1, a2);\n    }\n\n    static diff(ang1, ang2) {\n      let delAngle = null;\n      if (ang1 < ang2) delAngle = ang2 - ang1;else delAngle = ang1 - ang2;\n      if (delAngle > Math.PI) delAngle = 2 * Math.PI - delAngle;\n      return delAngle;\n    }\n\n    static toRadians(angleDegrees) {\n      return angleDegrees * Math.PI / 180.0;\n    }\n\n    static getTurn(ang1, ang2) {\n      const crossproduct = Math.sin(ang2 - ang1);\n      if (crossproduct > 0) return Angle.COUNTERCLOCKWISE;\n      if (crossproduct < 0) return Angle.CLOCKWISE;\n      return Angle.NONE;\n    }\n\n    static angleBetweenOriented(tip1, tail, tip2) {\n      const a1 = Angle.angle(tail, tip1);\n      const a2 = Angle.angle(tail, tip2);\n      const angDel = a2 - a1;\n      if (angDel <= -Math.PI) return angDel + Angle.PI_TIMES_2;\n      if (angDel > Math.PI) return angDel - Angle.PI_TIMES_2;\n      return angDel;\n    }\n\n  }\n  Angle.PI_TIMES_2 = 2.0 * Math.PI;\n  Angle.PI_OVER_2 = Math.PI / 2.0;\n  Angle.PI_OVER_4 = Math.PI / 4.0;\n  Angle.COUNTERCLOCKWISE = Orientation.COUNTERCLOCKWISE;\n  Angle.CLOCKWISE = Orientation.CLOCKWISE;\n  Angle.NONE = Orientation.COLLINEAR;\n\n  class NotRepresentableException extends Exception {\n    constructor() {\n      super();\n      NotRepresentableException.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      Exception.constructor_.call(this, 'Projective point not representable on the Cartesian plane.');\n    }\n\n  }\n\n  class HCoordinate {\n    constructor() {\n      HCoordinate.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.x = null;\n      this.y = null;\n      this.w = null;\n\n      if (arguments.length === 0) {\n        this.x = 0.0;\n        this.y = 0.0;\n        this.w = 1.0;\n      } else if (arguments.length === 1) {\n        const p = arguments[0];\n        this.x = p.x;\n        this.y = p.y;\n        this.w = 1.0;\n      } else if (arguments.length === 2) {\n        if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n          const _x = arguments[0],\n                _y = arguments[1];\n          this.x = _x;\n          this.y = _y;\n          this.w = 1.0;\n        } else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {\n          const p1 = arguments[0],\n                p2 = arguments[1];\n          this.x = p1.y * p2.w - p2.y * p1.w;\n          this.y = p2.x * p1.w - p1.x * p2.w;\n          this.w = p1.x * p2.y - p2.x * p1.y;\n        } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n          const p1 = arguments[0],\n                p2 = arguments[1];\n          this.x = p1.y - p2.y;\n          this.y = p2.x - p1.x;\n          this.w = p1.x * p2.y - p2.x * p1.y;\n        }\n      } else if (arguments.length === 3) {\n        const _x = arguments[0],\n              _y = arguments[1],\n              _w = arguments[2];\n        this.x = _x;\n        this.y = _y;\n        this.w = _w;\n      } else if (arguments.length === 4) {\n        const p1 = arguments[0],\n              p2 = arguments[1],\n              q1 = arguments[2],\n              q2 = arguments[3];\n        const px = p1.y - p2.y;\n        const py = p2.x - p1.x;\n        const pw = p1.x * p2.y - p2.x * p1.y;\n        const qx = q1.y - q2.y;\n        const qy = q2.x - q1.x;\n        const qw = q1.x * q2.y - q2.x * q1.y;\n        this.x = py * qw - qy * pw;\n        this.y = qx * pw - px * qw;\n        this.w = px * qy - qx * py;\n      }\n    }\n\n    getY() {\n      const a = this.y / this.w;\n      if (Double.isNaN(a) || Double.isInfinite(a)) throw new NotRepresentableException();\n      return a;\n    }\n\n    getX() {\n      const a = this.x / this.w;\n      if (Double.isNaN(a) || Double.isInfinite(a)) throw new NotRepresentableException();\n      return a;\n    }\n\n    getCoordinate() {\n      const p = new Coordinate();\n      p.x = this.getX();\n      p.y = this.getY();\n      return p;\n    }\n\n  }\n\n  class Triangle {\n    constructor() {\n      Triangle.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.p0 = null;\n      this.p1 = null;\n      this.p2 = null;\n      const p0 = arguments[0],\n            p1 = arguments[1],\n            p2 = arguments[2];\n      this.p0 = p0;\n      this.p1 = p1;\n      this.p2 = p2;\n    }\n\n    static area(a, b, c) {\n      return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2);\n    }\n\n    static signedArea(a, b, c) {\n      return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2;\n    }\n\n    static det(m00, m01, m10, m11) {\n      return m00 * m11 - m01 * m10;\n    }\n\n    static interpolateZ(p, v0, v1, v2) {\n      const x0 = v0.x;\n      const y0 = v0.y;\n      const a = v1.x - x0;\n      const b = v2.x - x0;\n      const c = v1.y - y0;\n      const d = v2.y - y0;\n      const det = a * d - b * c;\n      const dx = p.x - x0;\n      const dy = p.y - y0;\n      const t = (d * dx - b * dy) / det;\n      const u = (-c * dx + a * dy) / det;\n      const z = v0.getZ() + t * (v1.getZ() - v0.getZ()) + u * (v2.getZ() - v0.getZ());\n      return z;\n    }\n\n    static longestSideLength(a, b, c) {\n      const lenAB = a.distance(b);\n      const lenBC = b.distance(c);\n      const lenCA = c.distance(a);\n      let maxLen = lenAB;\n      if (lenBC > maxLen) maxLen = lenBC;\n      if (lenCA > maxLen) maxLen = lenCA;\n      return maxLen;\n    }\n\n    static circumcentreDD(a, b, c) {\n      const ax = DD.valueOf(a.x).subtract(c.x);\n      const ay = DD.valueOf(a.y).subtract(c.y);\n      const bx = DD.valueOf(b.x).subtract(c.x);\n      const by = DD.valueOf(b.y).subtract(c.y);\n      const denom = DD.determinant(ax, ay, bx, by).multiply(2);\n      const asqr = ax.sqr().add(ay.sqr());\n      const bsqr = bx.sqr().add(by.sqr());\n      const numx = DD.determinant(ay, asqr, by, bsqr);\n      const numy = DD.determinant(ax, asqr, bx, bsqr);\n      const ccx = DD.valueOf(c.x).subtract(numx.divide(denom)).doubleValue();\n      const ccy = DD.valueOf(c.y).add(numy.divide(denom)).doubleValue();\n      return new Coordinate(ccx, ccy);\n    }\n\n    static isAcute(a, b, c) {\n      if (!Angle.isAcute(a, b, c)) return false;\n      if (!Angle.isAcute(b, c, a)) return false;\n      if (!Angle.isAcute(c, a, b)) return false;\n      return true;\n    }\n\n    static circumcentre(a, b, c) {\n      const cx = c.x;\n      const cy = c.y;\n      const ax = a.x - cx;\n      const ay = a.y - cy;\n      const bx = b.x - cx;\n      const by = b.y - cy;\n      const denom = 2 * Triangle.det(ax, ay, bx, by);\n      const numx = Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);\n      const numy = Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);\n      const ccx = cx - numx / denom;\n      const ccy = cy + numy / denom;\n      return new Coordinate(ccx, ccy);\n    }\n\n    static perpendicularBisector(a, b) {\n      const dx = b.x - a.x;\n      const dy = b.y - a.y;\n      const l1 = new HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);\n      const l2 = new HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);\n      return new HCoordinate(l1, l2);\n    }\n\n    static angleBisector(a, b, c) {\n      const len0 = b.distance(a);\n      const len2 = b.distance(c);\n      const frac = len0 / (len0 + len2);\n      const dx = c.x - a.x;\n      const dy = c.y - a.y;\n      const splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);\n      return splitPt;\n    }\n\n    static area3D(a, b, c) {\n      const ux = b.x - a.x;\n      const uy = b.y - a.y;\n      const uz = b.getZ() - a.getZ();\n      const vx = c.x - a.x;\n      const vy = c.y - a.y;\n      const vz = c.getZ() - a.getZ();\n      const crossx = uy * vz - uz * vy;\n      const crossy = uz * vx - ux * vz;\n      const crossz = ux * vy - uy * vx;\n      const absSq = crossx * crossx + crossy * crossy + crossz * crossz;\n      const area3D = Math.sqrt(absSq) / 2;\n      return area3D;\n    }\n\n    static centroid(a, b, c) {\n      const x = (a.x + b.x + c.x) / 3;\n      const y = (a.y + b.y + c.y) / 3;\n      return new Coordinate(x, y);\n    }\n\n    static inCentre(a, b, c) {\n      const len0 = b.distance(c);\n      const len1 = a.distance(c);\n      const len2 = a.distance(b);\n      const circum = len0 + len1 + len2;\n      const inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;\n      const inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;\n      return new Coordinate(inCentreX, inCentreY);\n    }\n\n    area() {\n      return Triangle.area(this.p0, this.p1, this.p2);\n    }\n\n    signedArea() {\n      return Triangle.signedArea(this.p0, this.p1, this.p2);\n    }\n\n    interpolateZ(p) {\n      if (p === null) throw new IllegalArgumentException('Supplied point is null.');\n      return Triangle.interpolateZ(p, this.p0, this.p1, this.p2);\n    }\n\n    longestSideLength() {\n      return Triangle.longestSideLength(this.p0, this.p1, this.p2);\n    }\n\n    isAcute() {\n      return Triangle.isAcute(this.p0, this.p1, this.p2);\n    }\n\n    circumcentre() {\n      return Triangle.circumcentre(this.p0, this.p1, this.p2);\n    }\n\n    area3D() {\n      return Triangle.area3D(this.p0, this.p1, this.p2);\n    }\n\n    centroid() {\n      return Triangle.centroid(this.p0, this.p1, this.p2);\n    }\n\n    inCentre() {\n      return Triangle.inCentre(this.p0, this.p1, this.p2);\n    }\n\n  }\n\n  class NoninvertibleTransformationException extends Exception {\n    constructor() {\n      super();\n      NoninvertibleTransformationException.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      if (arguments.length === 0) {\n        Exception.constructor_.call(this);\n      } else if (arguments.length === 1) {\n        const msg = arguments[0];\n        Exception.constructor_.call(this, msg);\n      }\n    }\n\n  }\n\n  class AffineTransformation {\n    constructor() {\n      AffineTransformation.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._m00 = null;\n      this._m01 = null;\n      this._m02 = null;\n      this._m10 = null;\n      this._m11 = null;\n      this._m12 = null;\n\n      if (arguments.length === 0) {\n        this.setToIdentity();\n      } else if (arguments.length === 1) {\n        if (arguments[0] instanceof Array) {\n          const matrix = arguments[0];\n          this._m00 = matrix[0];\n          this._m01 = matrix[1];\n          this._m02 = matrix[2];\n          this._m10 = matrix[3];\n          this._m11 = matrix[4];\n          this._m12 = matrix[5];\n        } else if (arguments[0] instanceof AffineTransformation) {\n          const trans = arguments[0];\n          this.setTransformation(trans);\n        }\n      } else if (arguments.length === 6) {\n        if (typeof arguments[5] === 'number' && typeof arguments[4] === 'number' && typeof arguments[3] === 'number' && typeof arguments[2] === 'number' && typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n          const m00 = arguments[0],\n                m01 = arguments[1],\n                m02 = arguments[2],\n                m10 = arguments[3],\n                m11 = arguments[4],\n                m12 = arguments[5];\n          this.setTransformation(m00, m01, m02, m10, m11, m12);\n        }\n      }\n    }\n\n    static translationInstance(x, y) {\n      const trans = new AffineTransformation();\n      trans.setToTranslation(x, y);\n      return trans;\n    }\n\n    static shearInstance(xShear, yShear) {\n      const trans = new AffineTransformation();\n      trans.setToShear(xShear, yShear);\n      return trans;\n    }\n\n    static reflectionInstance() {\n      if (arguments.length === 2) {\n        const x = arguments[0],\n              y = arguments[1];\n        const trans = new AffineTransformation();\n        trans.setToReflection(x, y);\n        return trans;\n      } else if (arguments.length === 4) {\n        const x0 = arguments[0],\n              y0 = arguments[1],\n              x1 = arguments[2],\n              y1 = arguments[3];\n        const trans = new AffineTransformation();\n        trans.setToReflection(x0, y0, x1, y1);\n        return trans;\n      }\n    }\n\n    static rotationInstance() {\n      if (arguments.length === 1) {\n        const theta = arguments[0];\n        return AffineTransformation.rotationInstance(Math.sin(theta), Math.cos(theta));\n      } else if (arguments.length === 2) {\n        const sinTheta = arguments[0],\n              cosTheta = arguments[1];\n        const trans = new AffineTransformation();\n        trans.setToRotation(sinTheta, cosTheta);\n        return trans;\n      } else if (arguments.length === 3) {\n        const theta = arguments[0],\n              x = arguments[1],\n              y = arguments[2];\n        return AffineTransformation.rotationInstance(Math.sin(theta), Math.cos(theta), x, y);\n      } else if (arguments.length === 4) {\n        const sinTheta = arguments[0],\n              cosTheta = arguments[1],\n              x = arguments[2],\n              y = arguments[3];\n        const trans = new AffineTransformation();\n        trans.setToRotation(sinTheta, cosTheta, x, y);\n        return trans;\n      }\n    }\n\n    static scaleInstance() {\n      if (arguments.length === 2) {\n        const xScale = arguments[0],\n              yScale = arguments[1];\n        const trans = new AffineTransformation();\n        trans.setToScale(xScale, yScale);\n        return trans;\n      } else if (arguments.length === 4) {\n        const xScale = arguments[0],\n              yScale = arguments[1],\n              x = arguments[2],\n              y = arguments[3];\n        const trans = new AffineTransformation();\n        trans.translate(-x, -y);\n        trans.scale(xScale, yScale);\n        trans.translate(x, y);\n        return trans;\n      }\n    }\n\n    setToReflectionBasic(x0, y0, x1, y1) {\n      if (x0 === x1 && y0 === y1) throw new IllegalArgumentException('Reflection line points must be distinct');\n      const dx = x1 - x0;\n      const dy = y1 - y0;\n      const d = Math.sqrt(dx * dx + dy * dy);\n      const sin = dy / d;\n      const cos = dx / d;\n      const cs2 = 2 * sin * cos;\n      const c2s2 = cos * cos - sin * sin;\n      this._m00 = c2s2;\n      this._m01 = cs2;\n      this._m02 = 0.0;\n      this._m10 = cs2;\n      this._m11 = -c2s2;\n      this._m12 = 0.0;\n      return this;\n    }\n\n    getInverse() {\n      const det = this.getDeterminant();\n      if (det === 0) throw new NoninvertibleTransformationException('Transformation is non-invertible');\n      const im00 = this._m11 / det;\n      const im10 = -this._m10 / det;\n      const im01 = -this._m01 / det;\n      const im11 = this._m00 / det;\n      const im02 = (this._m01 * this._m12 - this._m02 * this._m11) / det;\n      const im12 = (-this._m00 * this._m12 + this._m10 * this._m02) / det;\n      return new AffineTransformation(im00, im01, im02, im10, im11, im12);\n    }\n\n    compose(trans) {\n      const mp00 = trans._m00 * this._m00 + trans._m01 * this._m10;\n      const mp01 = trans._m00 * this._m01 + trans._m01 * this._m11;\n      const mp02 = trans._m00 * this._m02 + trans._m01 * this._m12 + trans._m02;\n      const mp10 = trans._m10 * this._m00 + trans._m11 * this._m10;\n      const mp11 = trans._m10 * this._m01 + trans._m11 * this._m11;\n      const mp12 = trans._m10 * this._m02 + trans._m11 * this._m12 + trans._m12;\n      this._m00 = mp00;\n      this._m01 = mp01;\n      this._m02 = mp02;\n      this._m10 = mp10;\n      this._m11 = mp11;\n      this._m12 = mp12;\n      return this;\n    }\n\n    equals(obj) {\n      if (obj === null) return false;\n      if (!(obj instanceof AffineTransformation)) return false;\n      const trans = obj;\n      return this._m00 === trans._m00 && this._m01 === trans._m01 && this._m02 === trans._m02 && this._m10 === trans._m10 && this._m11 === trans._m11 && this._m12 === trans._m12;\n    }\n\n    setToScale(xScale, yScale) {\n      this._m00 = xScale;\n      this._m01 = 0.0;\n      this._m02 = 0.0;\n      this._m10 = 0.0;\n      this._m11 = yScale;\n      this._m12 = 0.0;\n      return this;\n    }\n\n    isIdentity() {\n      return this._m00 === 1 && this._m01 === 0 && this._m02 === 0 && this._m10 === 0 && this._m11 === 1 && this._m12 === 0;\n    }\n\n    scale(xScale, yScale) {\n      this.compose(AffineTransformation.scaleInstance(xScale, yScale));\n      return this;\n    }\n\n    setToIdentity() {\n      this._m00 = 1.0;\n      this._m01 = 0.0;\n      this._m02 = 0.0;\n      this._m10 = 0.0;\n      this._m11 = 1.0;\n      this._m12 = 0.0;\n      return this;\n    }\n\n    isGeometryChanged() {\n      return true;\n    }\n\n    setTransformation() {\n      if (arguments.length === 1) {\n        const trans = arguments[0];\n        this._m00 = trans._m00;\n        this._m01 = trans._m01;\n        this._m02 = trans._m02;\n        this._m10 = trans._m10;\n        this._m11 = trans._m11;\n        this._m12 = trans._m12;\n        return this;\n      } else if (arguments.length === 6) {\n        const m00 = arguments[0],\n              m01 = arguments[1],\n              m02 = arguments[2],\n              m10 = arguments[3],\n              m11 = arguments[4],\n              m12 = arguments[5];\n        this._m00 = m00;\n        this._m01 = m01;\n        this._m02 = m02;\n        this._m10 = m10;\n        this._m11 = m11;\n        this._m12 = m12;\n        return this;\n      }\n    }\n\n    setToRotation() {\n      if (arguments.length === 1) {\n        const theta = arguments[0];\n        this.setToRotation(Math.sin(theta), Math.cos(theta));\n        return this;\n      } else if (arguments.length === 2) {\n        const sinTheta = arguments[0],\n              cosTheta = arguments[1];\n        this._m00 = cosTheta;\n        this._m01 = -sinTheta;\n        this._m02 = 0.0;\n        this._m10 = sinTheta;\n        this._m11 = cosTheta;\n        this._m12 = 0.0;\n        return this;\n      } else if (arguments.length === 3) {\n        const theta = arguments[0],\n              x = arguments[1],\n              y = arguments[2];\n        this.setToRotation(Math.sin(theta), Math.cos(theta), x, y);\n        return this;\n      } else if (arguments.length === 4) {\n        const sinTheta = arguments[0],\n              cosTheta = arguments[1],\n              x = arguments[2],\n              y = arguments[3];\n        this._m00 = cosTheta;\n        this._m01 = -sinTheta;\n        this._m02 = x - x * cosTheta + y * sinTheta;\n        this._m10 = sinTheta;\n        this._m11 = cosTheta;\n        this._m12 = y - x * sinTheta - y * cosTheta;\n        return this;\n      }\n    }\n\n    getMatrixEntries() {\n      return [this._m00, this._m01, this._m02, this._m10, this._m11, this._m12];\n    }\n\n    filter(seq, i) {\n      this.transform(seq, i);\n    }\n\n    rotate() {\n      if (arguments.length === 1) {\n        const theta = arguments[0];\n        this.compose(AffineTransformation.rotationInstance(theta));\n        return this;\n      } else if (arguments.length === 2) {\n        const sinTheta = arguments[0],\n              cosTheta = arguments[1];\n        this.compose(AffineTransformation.rotationInstance(sinTheta, cosTheta));\n        return this;\n      } else if (arguments.length === 3) {\n        const theta = arguments[0],\n              x = arguments[1],\n              y = arguments[2];\n        this.compose(AffineTransformation.rotationInstance(theta, x, y));\n        return this;\n      } else if (arguments.length === 4) {\n        const sinTheta = arguments[0],\n              cosTheta = arguments[1],\n              x = arguments[2],\n              y = arguments[3];\n        this.compose(AffineTransformation.rotationInstance(sinTheta, cosTheta, x, y));\n        return this;\n      }\n    }\n\n    getDeterminant() {\n      return this._m00 * this._m11 - this._m01 * this._m10;\n    }\n\n    composeBefore(trans) {\n      const mp00 = this._m00 * trans._m00 + this._m01 * trans._m10;\n      const mp01 = this._m00 * trans._m01 + this._m01 * trans._m11;\n      const mp02 = this._m00 * trans._m02 + this._m01 * trans._m12 + this._m02;\n      const mp10 = this._m10 * trans._m00 + this._m11 * trans._m10;\n      const mp11 = this._m10 * trans._m01 + this._m11 * trans._m11;\n      const mp12 = this._m10 * trans._m02 + this._m11 * trans._m12 + this._m12;\n      this._m00 = mp00;\n      this._m01 = mp01;\n      this._m02 = mp02;\n      this._m10 = mp10;\n      this._m11 = mp11;\n      this._m12 = mp12;\n      return this;\n    }\n\n    setToShear(xShear, yShear) {\n      this._m00 = 1.0;\n      this._m01 = xShear;\n      this._m02 = 0.0;\n      this._m10 = yShear;\n      this._m11 = 1.0;\n      this._m12 = 0.0;\n      return this;\n    }\n\n    isDone() {\n      return false;\n    }\n\n    clone() {\n      try {\n        return null;\n      } catch (ex) {\n        if (ex instanceof Exception) Assert.shouldNeverReachHere();else throw ex;\n      } finally {}\n\n      return null;\n    }\n\n    translate(x, y) {\n      this.compose(AffineTransformation.translationInstance(x, y));\n      return this;\n    }\n\n    setToReflection() {\n      if (arguments.length === 2) {\n        const x = arguments[0],\n              y = arguments[1];\n        if (x === 0.0 && y === 0.0) throw new IllegalArgumentException('Reflection vector must be non-zero');\n\n        if (x === y) {\n          this._m00 = 0.0;\n          this._m01 = 1.0;\n          this._m02 = 0.0;\n          this._m10 = 1.0;\n          this._m11 = 0.0;\n          this._m12 = 0.0;\n          return this;\n        }\n\n        const d = Math.sqrt(x * x + y * y);\n        const sin = y / d;\n        const cos = x / d;\n        this.rotate(-sin, cos);\n        this.scale(1, -1);\n        this.rotate(sin, cos);\n        return this;\n      } else if (arguments.length === 4) {\n        const x0 = arguments[0],\n              y0 = arguments[1],\n              x1 = arguments[2],\n              y1 = arguments[3];\n        if (x0 === x1 && y0 === y1) throw new IllegalArgumentException('Reflection line points must be distinct');\n        this.setToTranslation(-x0, -y0);\n        const dx = x1 - x0;\n        const dy = y1 - y0;\n        const d = Math.sqrt(dx * dx + dy * dy);\n        const sin = dy / d;\n        const cos = dx / d;\n        this.rotate(-sin, cos);\n        this.scale(1, -1);\n        this.rotate(sin, cos);\n        this.translate(x0, y0);\n        return this;\n      }\n    }\n\n    toString() {\n      return 'AffineTransformation[[' + this._m00 + ', ' + this._m01 + ', ' + this._m02 + '], [' + this._m10 + ', ' + this._m11 + ', ' + this._m12 + ']]';\n    }\n\n    setToTranslation(dx, dy) {\n      this._m00 = 1.0;\n      this._m01 = 0.0;\n      this._m02 = dx;\n      this._m10 = 0.0;\n      this._m11 = 1.0;\n      this._m12 = dy;\n      return this;\n    }\n\n    shear(xShear, yShear) {\n      this.compose(AffineTransformation.shearInstance(xShear, yShear));\n      return this;\n    }\n\n    transform() {\n      if (arguments.length === 1) {\n        const g = arguments[0];\n        const g2 = g.copy();\n        g2.apply(this);\n        return g2;\n      } else if (arguments.length === 2) {\n        if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n          const src = arguments[0],\n                dest = arguments[1];\n          const xp = this._m00 * src.x + this._m01 * src.y + this._m02;\n          const yp = this._m10 * src.x + this._m11 * src.y + this._m12;\n          dest.x = xp;\n          dest.y = yp;\n          return dest;\n        } else if (hasInterface(arguments[0], CoordinateSequence) && Number.isInteger(arguments[1])) {\n          const seq = arguments[0],\n                i = arguments[1];\n\n          const xp = this._m00 * seq.getOrdinate(i, 0) + this._m01 * seq.getOrdinate(i, 1) + this._m02;\n\n          const yp = this._m10 * seq.getOrdinate(i, 0) + this._m11 * seq.getOrdinate(i, 1) + this._m12;\n\n          seq.setOrdinate(i, 0, xp);\n          seq.setOrdinate(i, 1, yp);\n        }\n      }\n    }\n\n    reflect() {\n      if (arguments.length === 2) {\n        const x = arguments[0],\n              y = arguments[1];\n        this.compose(AffineTransformation.reflectionInstance(x, y));\n        return this;\n      } else if (arguments.length === 4) {\n        const x0 = arguments[0],\n              y0 = arguments[1],\n              x1 = arguments[2],\n              y1 = arguments[3];\n        this.compose(AffineTransformation.reflectionInstance(x0, y0, x1, y1));\n        return this;\n      }\n    }\n\n    get interfaces_() {\n      return [Clonable, CoordinateSequenceFilter];\n    }\n\n  }\n\n  class Matrix {\n    static solve(a, b) {\n      const n = b.length;\n      if (a.length !== n || a[0].length !== n) throw new IllegalArgumentException('Matrix A is incorrectly sized');\n\n      for (let i = 0; i < n; i++) {\n        let maxElementRow = i;\n\n        for (let j = i + 1; j < n; j++) if (Math.abs(a[j][i]) > Math.abs(a[maxElementRow][i])) maxElementRow = j;\n\n        if (a[maxElementRow][i] === 0.0) return null;\n        Matrix.swapRows(a, i, maxElementRow);\n        Matrix.swapRows(b, i, maxElementRow);\n\n        for (let j = i + 1; j < n; j++) {\n          const rowFactor = a[j][i] / a[i][i];\n\n          for (let k = n - 1; k >= i; k--) a[j][k] -= a[i][k] * rowFactor;\n\n          b[j] -= b[i] * rowFactor;\n        }\n      }\n\n      const solution = new Array(n).fill(null);\n\n      for (let j = n - 1; j >= 0; j--) {\n        let t = 0.0;\n\n        for (let k = j + 1; k < n; k++) t += a[j][k] * solution[k];\n\n        solution[j] = (b[j] - t) / a[j][j];\n      }\n\n      return solution;\n    }\n\n    static swapRows() {\n      if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n        const m = arguments[0],\n              i = arguments[1],\n              j = arguments[2];\n        if (i === j) return null;\n\n        for (let col = 0; col < m[0].length; col++) {\n          const temp = m[i][col];\n          m[i][col] = m[j][col];\n          m[j][col] = temp;\n        }\n      } else if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n        const m = arguments[0],\n              i = arguments[1],\n              j = arguments[2];\n        if (i === j) return null;\n        const temp = m[i];\n        m[i] = m[j];\n        m[j] = temp;\n      }\n    }\n\n  }\n\n  class AffineTransformationBuilder {\n    constructor() {\n      AffineTransformationBuilder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._src0 = null;\n      this._src1 = null;\n      this._src2 = null;\n      this._dest0 = null;\n      this._dest1 = null;\n      this._dest2 = null;\n      this._m00 = null;\n      this._m01 = null;\n      this._m02 = null;\n      this._m10 = null;\n      this._m11 = null;\n      this._m12 = null;\n      const src0 = arguments[0],\n            src1 = arguments[1],\n            src2 = arguments[2],\n            dest0 = arguments[3],\n            dest1 = arguments[4],\n            dest2 = arguments[5];\n      this._src0 = src0;\n      this._src1 = src1;\n      this._src2 = src2;\n      this._dest0 = dest0;\n      this._dest1 = dest1;\n      this._dest2 = dest2;\n    }\n\n    solve(b) {\n      const a = [[this._src0.x, this._src0.y, 1], [this._src1.x, this._src1.y, 1], [this._src2.x, this._src2.y, 1]];\n      return Matrix.solve(a, b);\n    }\n\n    compute() {\n      const bx = [this._dest0.x, this._dest1.x, this._dest2.x];\n      const row0 = this.solve(bx);\n      if (row0 === null) return false;\n      this._m00 = row0[0];\n      this._m01 = row0[1];\n      this._m02 = row0[2];\n      const by = [this._dest0.y, this._dest1.y, this._dest2.y];\n      const row1 = this.solve(by);\n      if (row1 === null) return false;\n      this._m10 = row1[0];\n      this._m11 = row1[1];\n      this._m12 = row1[2];\n      return true;\n    }\n\n    getTransformation() {\n      const isSolvable = this.compute();\n      if (isSolvable) return new AffineTransformation(this._m00, this._m01, this._m02, this._m10, this._m11, this._m12);\n      return null;\n    }\n\n  }\n\n  class AffineTransformationFactory {\n    static createFromBaseLines(src0, src1, dest0, dest1) {\n      const rotPt = new Coordinate(src0.x + dest1.x - dest0.x, src0.y + dest1.y - dest0.y);\n      const ang = Angle.angleBetweenOriented(src1, src0, rotPt);\n      const srcDist = src1.distance(src0);\n      const destDist = dest1.distance(dest0);\n      if (srcDist === 0.0) return new AffineTransformation();\n      const scale = destDist / srcDist;\n      const trans = AffineTransformation.translationInstance(-src0.x, -src0.y);\n      trans.rotate(ang);\n      trans.scale(scale, scale);\n      trans.translate(dest0.x, dest0.y);\n      return trans;\n    }\n\n    static createFromControlVectors() {\n      if (arguments.length === 2) {\n        if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n          const src0 = arguments[0],\n                dest0 = arguments[1];\n          const dx = dest0.x - src0.x;\n          const dy = dest0.y - src0.y;\n          return AffineTransformation.translationInstance(dx, dy);\n        } else if (arguments[0] instanceof Array && arguments[1] instanceof Array) {\n          const src = arguments[0],\n                dest = arguments[1];\n          if (src.length !== dest.length) throw new IllegalArgumentException('Src and Dest arrays are not the same length');\n          if (src.length <= 0) throw new IllegalArgumentException('Too few control points');\n          if (src.length > 3) throw new IllegalArgumentException('Too many control points');\n          if (src.length === 1) return AffineTransformationFactory.createFromControlVectors(src[0], dest[0]);\n          if (src.length === 2) return AffineTransformationFactory.createFromControlVectors(src[0], src[1], dest[0], dest[1]);\n          return AffineTransformationFactory.createFromControlVectors(src[0], src[1], src[2], dest[0], dest[1], dest[2]);\n        }\n      } else if (arguments.length === 4) {\n        const src0 = arguments[0],\n              src1 = arguments[1],\n              dest0 = arguments[2],\n              dest1 = arguments[3];\n        const rotPt = new Coordinate(dest1.x - dest0.x, dest1.y - dest0.y);\n        const ang = Angle.angleBetweenOriented(src1, src0, rotPt);\n        const srcDist = src1.distance(src0);\n        const destDist = dest1.distance(dest0);\n        if (srcDist === 0.0) return null;\n        const scale = destDist / srcDist;\n        const trans = AffineTransformation.translationInstance(-src0.x, -src0.y);\n        trans.rotate(ang);\n        trans.scale(scale, scale);\n        trans.translate(dest0.x, dest0.y);\n        return trans;\n      } else if (arguments.length === 6) {\n        const src0 = arguments[0],\n              src1 = arguments[1],\n              src2 = arguments[2],\n              dest0 = arguments[3],\n              dest1 = arguments[4],\n              dest2 = arguments[5];\n        const builder = new AffineTransformationBuilder(src0, src1, src2, dest0, dest1, dest2);\n        return builder.getTransformation();\n      }\n    }\n\n  }\n\n  class ComponentCoordinateExtracter {\n    constructor() {\n      ComponentCoordinateExtracter.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._coords = null;\n      const coords = arguments[0];\n      this._coords = coords;\n    }\n\n    static getCoordinates(geom) {\n      const coords = new ArrayList();\n      geom.apply(new ComponentCoordinateExtracter(coords));\n      return coords;\n    }\n\n    filter(geom) {\n      if (geom instanceof LineString || geom instanceof Point) this._coords.add(geom.getCoordinate());\n    }\n\n    get interfaces_() {\n      return [GeometryComponentFilter];\n    }\n\n  }\n\n  class GeometryCollectionMapper {\n    constructor() {\n      GeometryCollectionMapper.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._mapOp = null;\n      const mapOp = arguments[0];\n      this._mapOp = mapOp;\n    }\n\n    static map(gc, op) {\n      const mapper = new GeometryCollectionMapper(op);\n      return mapper.map(gc);\n    }\n\n    map(gc) {\n      const mapped = new ArrayList();\n\n      for (let i = 0; i < gc.getNumGeometries(); i++) {\n        const g = this._mapOp.map(gc.getGeometryN(i));\n\n        if (!g.isEmpty()) mapped.add(g);\n      }\n\n      return gc.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(mapped));\n    }\n\n  }\n\n  class GeometryCombiner {\n    constructor() {\n      GeometryCombiner.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._geomFactory = null;\n      this._skipEmpty = false;\n      this._inputGeoms = null;\n      const geoms = arguments[0];\n      this._geomFactory = GeometryCombiner.extractFactory(geoms);\n      this._inputGeoms = geoms;\n    }\n\n    static combine() {\n      if (arguments.length === 1) {\n        const geoms = arguments[0];\n        const combiner = new GeometryCombiner(geoms);\n        return combiner.combine();\n      } else if (arguments.length === 2) {\n        const g0 = arguments[0],\n              g1 = arguments[1];\n        const combiner = new GeometryCombiner(GeometryCombiner.createList(g0, g1));\n        return combiner.combine();\n      } else if (arguments.length === 3) {\n        const g0 = arguments[0],\n              g1 = arguments[1],\n              g2 = arguments[2];\n        const combiner = new GeometryCombiner(GeometryCombiner.createList(g0, g1, g2));\n        return combiner.combine();\n      }\n    }\n\n    static extractFactory(geoms) {\n      if (geoms.isEmpty()) return null;\n      return geoms.iterator().next().getFactory();\n    }\n\n    static createList() {\n      if (arguments.length === 2) {\n        const obj0 = arguments[0],\n              obj1 = arguments[1];\n        const list = new ArrayList();\n        list.add(obj0);\n        list.add(obj1);\n        return list;\n      } else if (arguments.length === 3) {\n        const obj0 = arguments[0],\n              obj1 = arguments[1],\n              obj2 = arguments[2];\n        const list = new ArrayList();\n        list.add(obj0);\n        list.add(obj1);\n        list.add(obj2);\n        return list;\n      }\n    }\n\n    extractElements(geom, elems) {\n      if (geom === null) return null;\n\n      for (let i = 0; i < geom.getNumGeometries(); i++) {\n        const elemGeom = geom.getGeometryN(i);\n        if (this._skipEmpty && elemGeom.isEmpty()) continue;\n        elems.add(elemGeom);\n      }\n    }\n\n    combine() {\n      const elems = new ArrayList();\n\n      for (let i = this._inputGeoms.iterator(); i.hasNext();) {\n        const g = i.next();\n        this.extractElements(g, elems);\n      }\n\n      if (elems.size() === 0) {\n        if (this._geomFactory !== null) return this._geomFactory.createGeometryCollection();\n        return null;\n      }\n\n      return this._geomFactory.buildGeometry(elems);\n    }\n\n  }\n\n  class GeometryEditor {\n    constructor() {\n      GeometryEditor.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._factory = null;\n      this._isUserDataCopied = false;\n\n      if (arguments.length === 0) ; else if (arguments.length === 1) {\n        const factory = arguments[0];\n        this._factory = factory;\n      }\n    }\n\n    setCopyUserData(isUserDataCopied) {\n      this._isUserDataCopied = isUserDataCopied;\n    }\n\n    edit(geometry, operation) {\n      if (geometry === null) return null;\n      const result = this.editInternal(geometry, operation);\n      if (this._isUserDataCopied) result.setUserData(geometry.getUserData());\n      return result;\n    }\n\n    editInternal(geometry, operation) {\n      if (this._factory === null) this._factory = geometry.getFactory();\n      if (geometry instanceof GeometryCollection) return this.editGeometryCollection(geometry, operation);\n      if (geometry instanceof Polygon) return this.editPolygon(geometry, operation);\n      if (geometry instanceof Point) return operation.edit(geometry, this._factory);\n      if (geometry instanceof LineString) return operation.edit(geometry, this._factory);\n      Assert.shouldNeverReachHere('Unsupported Geometry type: ' + geometry.getGeometryType());\n      return null;\n    }\n\n    editGeometryCollection(collection, operation) {\n      const collectionForType = operation.edit(collection, this._factory);\n      const geometries = new ArrayList();\n\n      for (let i = 0; i < collectionForType.getNumGeometries(); i++) {\n        const geometry = this.edit(collectionForType.getGeometryN(i), operation);\n        if (geometry === null || geometry.isEmpty()) continue;\n        geometries.add(geometry);\n      }\n\n      if (collectionForType.getGeometryType() === Geometry.TYPENAME_MULTIPOINT) return this._factory.createMultiPoint(geometries.toArray([]));\n      if (collectionForType.getGeometryType() === Geometry.TYPENAME_MULTILINESTRING) return this._factory.createMultiLineString(geometries.toArray([]));\n      if (collectionForType.getGeometryType() === Geometry.TYPENAME_MULTIPOLYGON) return this._factory.createMultiPolygon(geometries.toArray([]));\n      return this._factory.createGeometryCollection(geometries.toArray([]));\n    }\n\n    editPolygon(polygon, operation) {\n      let newPolygon = operation.edit(polygon, this._factory);\n      if (newPolygon === null) newPolygon = this._factory.createPolygon();\n      if (newPolygon.isEmpty()) return newPolygon;\n      const shell = this.edit(newPolygon.getExteriorRing(), operation);\n      if (shell === null || shell.isEmpty()) return this._factory.createPolygon();\n      const holes = new ArrayList();\n\n      for (let i = 0; i < newPolygon.getNumInteriorRing(); i++) {\n        const hole = this.edit(newPolygon.getInteriorRingN(i), operation);\n        if (hole === null || hole.isEmpty()) continue;\n        holes.add(hole);\n      }\n\n      return this._factory.createPolygon(shell, holes.toArray([]));\n    }\n\n  }\n\n  function GeometryEditorOperation() {}\n\n  GeometryEditor.GeometryEditorOperation = GeometryEditorOperation;\n\n  class NoOpGeometryOperation {\n    edit(geometry, factory) {\n      return geometry;\n    }\n\n    get interfaces_() {\n      return [GeometryEditorOperation];\n    }\n\n  }\n\n  class CoordinateOperation {\n    edit(geometry, factory) {\n      const coordinates = this.edit(geometry.getCoordinates(), geometry);\n      if (geometry instanceof LinearRing) if (coordinates === null) return factory.createLinearRing();else return factory.createLinearRing(coordinates);\n      if (geometry instanceof LineString) if (coordinates === null) return factory.createLineString();else return factory.createLineString(coordinates);\n      if (geometry instanceof Point) if (coordinates === null || coordinates.length === 0) return factory.createPoint();else return factory.createPoint(coordinates[0]);\n      return geometry;\n    }\n\n    get interfaces_() {\n      return [GeometryEditorOperation];\n    }\n\n  }\n\n  class CoordinateSequenceOperation {\n    edit(geometry, factory) {\n      if (geometry instanceof LinearRing) return factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry));\n      if (geometry instanceof LineString) return factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry));\n      if (geometry instanceof Point) return factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry));\n      return geometry;\n    }\n\n    get interfaces_() {\n      return [GeometryEditorOperation];\n    }\n\n  }\n\n  GeometryEditor.NoOpGeometryOperation = NoOpGeometryOperation;\n  GeometryEditor.CoordinateOperation = CoordinateOperation;\n  GeometryEditor.CoordinateSequenceOperation = CoordinateSequenceOperation;\n\n  class GeometryExtracter {\n    constructor() {\n      GeometryExtracter.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._geometryType = null;\n      this._comps = null;\n      const geometryType = arguments[0],\n            comps = arguments[1];\n      this._geometryType = geometryType;\n      this._comps = comps;\n    }\n\n    static isOfType(geom, geometryType) {\n      if (geom.getGeometryType() === geometryType) return true;\n      if (geometryType === Geometry.TYPENAME_LINESTRING && geom.getGeometryType() === Geometry.TYPENAME_LINEARRING) return true;\n      return false;\n    }\n\n    static extract() {\n      if (arguments.length === 2) {\n        const geom = arguments[0],\n              geometryType = arguments[1];\n        return GeometryExtracter.extract(geom, geometryType, new ArrayList());\n      } else if (arguments.length === 3) {\n        const geom = arguments[0],\n              geometryType = arguments[1],\n              list = arguments[2];\n        if (geom.getGeometryType() === geometryType) list.add(geom);else if (geom instanceof GeometryCollection) geom.apply(new GeometryExtracter(geometryType, list));\n        return list;\n      }\n    }\n\n    filter(geom) {\n      if (this._geometryType === null || GeometryExtracter.isOfType(geom, this._geometryType)) this._comps.add(geom);\n    }\n\n    get interfaces_() {\n      return [GeometryFilter];\n    }\n\n  }\n\n  class GeometryMapper {\n    static map() {\n      if (arguments[0] instanceof Geometry && hasInterface(arguments[1], MapOp$1)) {\n        const geom = arguments[0],\n              op = arguments[1];\n        const mapped = new ArrayList();\n\n        for (let i = 0; i < geom.getNumGeometries(); i++) {\n          const g = op.map(geom.getGeometryN(i));\n          if (g !== null) mapped.add(g);\n        }\n\n        return geom.getFactory().buildGeometry(mapped);\n      } else if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], MapOp$1)) {\n        const geoms = arguments[0],\n              op = arguments[1];\n        const mapped = new ArrayList();\n\n        for (let i = geoms.iterator(); i.hasNext();) {\n          const g = i.next();\n          const gr = op.map(g);\n          if (gr !== null) mapped.add(gr);\n        }\n\n        return mapped;\n      }\n    }\n\n  }\n\n  function MapOp$1() {}\n\n  GeometryMapper.MapOp = MapOp$1;\n\n  class GeometryTransformer {\n    constructor() {\n      GeometryTransformer.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._inputGeom = null;\n      this._factory = null;\n      this._pruneEmptyGeometry = true;\n      this._preserveGeometryCollectionType = true;\n      this._preserveCollections = false;\n      this._preserveType = false;\n    }\n\n    transformPoint(geom, parent) {\n      return this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom));\n    }\n\n    transformPolygon(geom, parent) {\n      let isAllValidLinearRings = true;\n      const shell = this.transformLinearRing(geom.getExteriorRing(), geom);\n      if (shell === null || !(shell instanceof LinearRing) || shell.isEmpty()) isAllValidLinearRings = false;\n      const holes = new ArrayList();\n\n      for (let i = 0; i < geom.getNumInteriorRing(); i++) {\n        const hole = this.transformLinearRing(geom.getInteriorRingN(i), geom);\n        if (hole === null || hole.isEmpty()) continue;\n        if (!(hole instanceof LinearRing)) isAllValidLinearRings = false;\n        holes.add(hole);\n      }\n\n      if (isAllValidLinearRings) {\n        return this._factory.createPolygon(shell, holes.toArray([]));\n      } else {\n        const components = new ArrayList();\n        if (shell !== null) components.add(shell);\n        components.addAll(holes);\n        return this._factory.buildGeometry(components);\n      }\n    }\n\n    createCoordinateSequence(coords) {\n      return this._factory.getCoordinateSequenceFactory().create(coords);\n    }\n\n    getInputGeometry() {\n      return this._inputGeom;\n    }\n\n    transformMultiLineString(geom, parent) {\n      const transGeomList = new ArrayList();\n\n      for (let i = 0; i < geom.getNumGeometries(); i++) {\n        const transformGeom = this.transformLineString(geom.getGeometryN(i), geom);\n        if (transformGeom === null) continue;\n        if (transformGeom.isEmpty()) continue;\n        transGeomList.add(transformGeom);\n      }\n\n      return this._factory.buildGeometry(transGeomList);\n    }\n\n    transformCoordinates(coords, parent) {\n      return this.copy(coords);\n    }\n\n    transformLineString(geom, parent) {\n      return this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom));\n    }\n\n    transformMultiPoint(geom, parent) {\n      const transGeomList = new ArrayList();\n\n      for (let i = 0; i < geom.getNumGeometries(); i++) {\n        const transformGeom = this.transformPoint(geom.getGeometryN(i), geom);\n        if (transformGeom === null) continue;\n        if (transformGeom.isEmpty()) continue;\n        transGeomList.add(transformGeom);\n      }\n\n      return this._factory.buildGeometry(transGeomList);\n    }\n\n    transformMultiPolygon(geom, parent) {\n      const transGeomList = new ArrayList();\n\n      for (let i = 0; i < geom.getNumGeometries(); i++) {\n        const transformGeom = this.transformPolygon(geom.getGeometryN(i), geom);\n        if (transformGeom === null) continue;\n        if (transformGeom.isEmpty()) continue;\n        transGeomList.add(transformGeom);\n      }\n\n      return this._factory.buildGeometry(transGeomList);\n    }\n\n    copy(seq) {\n      return seq.copy();\n    }\n\n    transformGeometryCollection(geom, parent) {\n      const transGeomList = new ArrayList();\n\n      for (let i = 0; i < geom.getNumGeometries(); i++) {\n        const transformGeom = this.transform(geom.getGeometryN(i));\n        if (transformGeom === null) continue;\n        if (this._pruneEmptyGeometry && transformGeom.isEmpty()) continue;\n        transGeomList.add(transformGeom);\n      }\n\n      if (this._preserveGeometryCollectionType) return this._factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList));\n      return this._factory.buildGeometry(transGeomList);\n    }\n\n    transform(inputGeom) {\n      this._inputGeom = inputGeom;\n      this._factory = inputGeom.getFactory();\n      if (inputGeom instanceof Point) return this.transformPoint(inputGeom, null);\n      if (inputGeom instanceof MultiPoint) return this.transformMultiPoint(inputGeom, null);\n      if (inputGeom instanceof LinearRing) return this.transformLinearRing(inputGeom, null);\n      if (inputGeom instanceof LineString) return this.transformLineString(inputGeom, null);\n      if (inputGeom instanceof MultiLineString) return this.transformMultiLineString(inputGeom, null);\n      if (inputGeom instanceof Polygon) return this.transformPolygon(inputGeom, null);\n      if (inputGeom instanceof MultiPolygon) return this.transformMultiPolygon(inputGeom, null);\n      if (inputGeom instanceof GeometryCollection) return this.transformGeometryCollection(inputGeom, null);\n      throw new IllegalArgumentException('Unknown Geometry subtype: ' + inputGeom.getGeometryType());\n    }\n\n    transformLinearRing(geom, parent) {\n      const seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);\n      if (seq === null) return this._factory.createLinearRing(null);\n      const seqSize = seq.size();\n      if (seqSize > 0 && seqSize < 4 && !this._preserveType) return this._factory.createLineString(seq);\n      return this._factory.createLinearRing(seq);\n    }\n\n  }\n\n  class LineStringExtracter {\n    constructor() {\n      LineStringExtracter.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._comps = null;\n      const comps = arguments[0];\n      this._comps = comps;\n    }\n\n    static getGeometry(geom) {\n      return geom.getFactory().buildGeometry(LineStringExtracter.getLines(geom));\n    }\n\n    static getLines() {\n      if (arguments.length === 1) {\n        const geom = arguments[0];\n        return LineStringExtracter.getLines(geom, new ArrayList());\n      } else if (arguments.length === 2) {\n        const geom = arguments[0],\n              lines = arguments[1];\n        if (geom instanceof LineString) lines.add(geom);else if (geom instanceof GeometryCollection) geom.apply(new LineStringExtracter(lines));\n        return lines;\n      }\n    }\n\n    filter(geom) {\n      if (geom instanceof LineString) this._comps.add(geom);\n    }\n\n    get interfaces_() {\n      return [GeometryFilter];\n    }\n\n  }\n\n  class LinearComponentExtracter {\n    constructor() {\n      LinearComponentExtracter.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._lines = null;\n      this._isForcedToLineString = false;\n\n      if (arguments.length === 1) {\n        const lines = arguments[0];\n        this._lines = lines;\n      } else if (arguments.length === 2) {\n        const lines = arguments[0],\n              isForcedToLineString = arguments[1];\n        this._lines = lines;\n        this._isForcedToLineString = isForcedToLineString;\n      }\n    }\n\n    static getGeometry() {\n      if (arguments.length === 1) {\n        const geom = arguments[0];\n        return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom));\n      } else if (arguments.length === 2) {\n        const geom = arguments[0],\n              forceToLineString = arguments[1];\n        return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom, forceToLineString));\n      }\n    }\n\n    static getLines() {\n      if (arguments.length === 1) {\n        const geom = arguments[0];\n        return LinearComponentExtracter.getLines(geom, false);\n      } else if (arguments.length === 2) {\n        if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n          const geoms = arguments[0],\n                lines = arguments[1];\n\n          for (let i = geoms.iterator(); i.hasNext();) {\n            const g = i.next();\n            LinearComponentExtracter.getLines(g, lines);\n          }\n\n          return lines;\n        } else if (arguments[0] instanceof Geometry && typeof arguments[1] === 'boolean') {\n          const geom = arguments[0],\n                forceToLineString = arguments[1];\n          const lines = new ArrayList();\n          geom.apply(new LinearComponentExtracter(lines, forceToLineString));\n          return lines;\n        } else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n          const geom = arguments[0],\n                lines = arguments[1];\n          if (geom instanceof LineString) lines.add(geom);else geom.apply(new LinearComponentExtracter(lines));\n          return lines;\n        }\n      } else if (arguments.length === 3) {\n        if (typeof arguments[2] === 'boolean' && hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n          const geoms = arguments[0],\n                lines = arguments[1],\n                forceToLineString = arguments[2];\n\n          for (let i = geoms.iterator(); i.hasNext();) {\n            const g = i.next();\n            LinearComponentExtracter.getLines(g, lines, forceToLineString);\n          }\n\n          return lines;\n        } else if (typeof arguments[2] === 'boolean' && arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n          const geom = arguments[0],\n                lines = arguments[1],\n                forceToLineString = arguments[2];\n          geom.apply(new LinearComponentExtracter(lines, forceToLineString));\n          return lines;\n        }\n      }\n    }\n\n    filter(geom) {\n      if (this._isForcedToLineString && geom instanceof LinearRing) {\n        const line = geom.getFactory().createLineString(geom.getCoordinateSequence());\n\n        this._lines.add(line);\n\n        return null;\n      }\n\n      if (geom instanceof LineString) this._lines.add(geom);\n    }\n\n    setForceToLineString(isForcedToLineString) {\n      this._isForcedToLineString = isForcedToLineString;\n    }\n\n    get interfaces_() {\n      return [GeometryComponentFilter];\n    }\n\n  }\n\n  const Collections = {\n    reverseOrder: function reverseOrder() {\n      return {\n        compare(a, b) {\n          return b.compareTo(a);\n        }\n\n      };\n    },\n    min: function min(l) {\n      Collections.sort(l);\n      return l.get(0);\n    },\n    sort: function sort(l, c) {\n      const a = l.toArray();\n      if (c) Arrays.sort(a, c);else Arrays.sort(a);\n      const i = l.iterator();\n\n      for (let pos = 0, alen = a.length; pos < alen; pos++) {\n        i.next();\n        i.set(a[pos]);\n      }\n    },\n    singletonList: function singletonList(o) {\n      const arrayList = new ArrayList();\n      arrayList.add(o);\n      return arrayList;\n    }\n  };\n\n  class PointExtracter {\n    constructor() {\n      PointExtracter.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._pts = null;\n      const pts = arguments[0];\n      this._pts = pts;\n    }\n\n    static getPoints() {\n      if (arguments.length === 1) {\n        const geom = arguments[0];\n        if (geom instanceof Point) return Collections.singletonList(geom);\n        return PointExtracter.getPoints(geom, new ArrayList());\n      } else if (arguments.length === 2) {\n        const geom = arguments[0],\n              list = arguments[1];\n        if (geom instanceof Point) list.add(geom);else if (geom instanceof GeometryCollection) geom.apply(new PointExtracter(list));\n        return list;\n      }\n    }\n\n    filter(geom) {\n      if (geom instanceof Point) this._pts.add(geom);\n    }\n\n    get interfaces_() {\n      return [GeometryFilter];\n    }\n\n  }\n\n  class PolygonExtracter {\n    constructor() {\n      PolygonExtracter.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._comps = null;\n      const comps = arguments[0];\n      this._comps = comps;\n    }\n\n    static getPolygons() {\n      if (arguments.length === 1) {\n        const geom = arguments[0];\n        return PolygonExtracter.getPolygons(geom, new ArrayList());\n      } else if (arguments.length === 2) {\n        const geom = arguments[0],\n              list = arguments[1];\n        if (geom instanceof Polygon) list.add(geom);else if (geom instanceof GeometryCollection) geom.apply(new PolygonExtracter(list));\n        return list;\n      }\n    }\n\n    filter(geom) {\n      if (geom instanceof Polygon) this._comps.add(geom);\n    }\n\n    get interfaces_() {\n      return [GeometryFilter];\n    }\n\n  }\n\n  class ShortCircuitedGeometryVisitor {\n    constructor() {\n      ShortCircuitedGeometryVisitor.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._isDone = false;\n    }\n\n    applyTo(geom) {\n      for (let i = 0; i < geom.getNumGeometries() && !this._isDone; i++) {\n        const element = geom.getGeometryN(i);\n\n        if (!(element instanceof GeometryCollection)) {\n          this.visit(element);\n\n          if (this.isDone()) {\n            this._isDone = true;\n            return null;\n          }\n        } else {\n          this.applyTo(element);\n        }\n      }\n    }\n\n  }\n\n  class GeometricShapeFactory {\n    constructor() {\n      GeometricShapeFactory.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._geomFact = null;\n      this._precModel = null;\n      this._dim = new Dimensions();\n      this._nPts = 100;\n      this._rotationAngle = 0.0;\n\n      if (arguments.length === 0) {\n        GeometricShapeFactory.constructor_.call(this, new GeometryFactory());\n      } else if (arguments.length === 1) {\n        const geomFact = arguments[0];\n        this._geomFact = geomFact;\n        this._precModel = geomFact.getPrecisionModel();\n      }\n    }\n\n    createSupercircle(power) {\n      const recipPow = 1.0 / power;\n      const radius = this._dim.getMinSize() / 2;\n\n      const centre = this._dim.getCentre();\n\n      const r4 = Math.pow(radius, power);\n      const y0 = radius;\n      const xyInt = Math.pow(r4 / 2, recipPow);\n      const nSegsInOct = Math.trunc(this._nPts / 8);\n      const totPts = nSegsInOct * 8 + 1;\n      const pts = new Array(totPts).fill(null);\n      const xInc = xyInt / nSegsInOct;\n\n      for (let i = 0; i <= nSegsInOct; i++) {\n        let x = 0.0;\n        let y = y0;\n\n        if (i !== 0) {\n          x = xInc * i;\n          const x4 = Math.pow(x, power);\n          y = Math.pow(r4 - x4, recipPow);\n        }\n\n        pts[i] = this.coordTrans(x, y, centre);\n        pts[2 * nSegsInOct - i] = this.coordTrans(y, x, centre);\n        pts[2 * nSegsInOct + i] = this.coordTrans(y, -x, centre);\n        pts[4 * nSegsInOct - i] = this.coordTrans(x, -y, centre);\n        pts[4 * nSegsInOct + i] = this.coordTrans(-x, -y, centre);\n        pts[6 * nSegsInOct - i] = this.coordTrans(-y, -x, centre);\n        pts[6 * nSegsInOct + i] = this.coordTrans(-y, x, centre);\n        pts[8 * nSegsInOct - i] = this.coordTrans(-x, y, centre);\n      }\n\n      pts[pts.length - 1] = new Coordinate(pts[0]);\n\n      const ring = this._geomFact.createLinearRing(pts);\n\n      const poly = this._geomFact.createPolygon(ring);\n\n      return this.rotate(poly);\n    }\n\n    setNumPoints(nPts) {\n      this._nPts = nPts;\n    }\n\n    setBase(base) {\n      this._dim.setBase(base);\n    }\n\n    setRotation(radians) {\n      this._rotationAngle = radians;\n    }\n\n    setWidth(width) {\n      this._dim.setWidth(width);\n    }\n\n    createEllipse() {\n      const env = this._dim.getEnvelope();\n\n      const xRadius = env.getWidth() / 2.0;\n      const yRadius = env.getHeight() / 2.0;\n      const centreX = env.getMinX() + xRadius;\n      const centreY = env.getMinY() + yRadius;\n      const pts = new Array(this._nPts + 1).fill(null);\n      let iPt = 0;\n\n      for (let i = 0; i < this._nPts; i++) {\n        const ang = i * (2 * Math.PI / this._nPts);\n        const x = xRadius * Math.cos(ang) + centreX;\n        const y = yRadius * Math.sin(ang) + centreY;\n        pts[iPt++] = this.coord(x, y);\n      }\n\n      pts[iPt] = new Coordinate(pts[0]);\n\n      const ring = this._geomFact.createLinearRing(pts);\n\n      const poly = this._geomFact.createPolygon(ring);\n\n      return this.rotate(poly);\n    }\n\n    coordTrans(x, y, trans) {\n      return this.coord(x + trans.x, y + trans.y);\n    }\n\n    createSquircle() {\n      return this.createSupercircle(4);\n    }\n\n    setEnvelope(env) {\n      this._dim.setEnvelope(env);\n    }\n\n    setCentre(centre) {\n      this._dim.setCentre(centre);\n    }\n\n    createArc(startAng, angExtent) {\n      const env = this._dim.getEnvelope();\n\n      const xRadius = env.getWidth() / 2.0;\n      const yRadius = env.getHeight() / 2.0;\n      const centreX = env.getMinX() + xRadius;\n      const centreY = env.getMinY() + yRadius;\n      let angSize = angExtent;\n      if (angSize <= 0.0 || angSize > 2 * Math.PI) angSize = 2 * Math.PI;\n      const angInc = angSize / (this._nPts - 1);\n      const pts = new Array(this._nPts).fill(null);\n      let iPt = 0;\n\n      for (let i = 0; i < this._nPts; i++) {\n        const ang = startAng + i * angInc;\n        const x = xRadius * Math.cos(ang) + centreX;\n        const y = yRadius * Math.sin(ang) + centreY;\n        pts[iPt++] = this.coord(x, y);\n      }\n\n      const line = this._geomFact.createLineString(pts);\n\n      return this.rotate(line);\n    }\n\n    rotate(geom) {\n      if (this._rotationAngle !== 0.0) {\n        const trans = AffineTransformation.rotationInstance(this._rotationAngle, this._dim.getCentre().x, this._dim.getCentre().y);\n        geom.apply(trans);\n      }\n\n      return geom;\n    }\n\n    coord(x, y) {\n      const pt = new Coordinate(x, y);\n\n      this._precModel.makePrecise(pt);\n\n      return pt;\n    }\n\n    createArcPolygon(startAng, angExtent) {\n      const env = this._dim.getEnvelope();\n\n      const xRadius = env.getWidth() / 2.0;\n      const yRadius = env.getHeight() / 2.0;\n      const centreX = env.getMinX() + xRadius;\n      const centreY = env.getMinY() + yRadius;\n      let angSize = angExtent;\n      if (angSize <= 0.0 || angSize > 2 * Math.PI) angSize = 2 * Math.PI;\n      const angInc = angSize / (this._nPts - 1);\n      const pts = new Array(this._nPts + 2).fill(null);\n      let iPt = 0;\n      pts[iPt++] = this.coord(centreX, centreY);\n\n      for (let i = 0; i < this._nPts; i++) {\n        const ang = startAng + angInc * i;\n        const x = xRadius * Math.cos(ang) + centreX;\n        const y = yRadius * Math.sin(ang) + centreY;\n        pts[iPt++] = this.coord(x, y);\n      }\n\n      pts[iPt++] = this.coord(centreX, centreY);\n\n      const ring = this._geomFact.createLinearRing(pts);\n\n      const poly = this._geomFact.createPolygon(ring);\n\n      return this.rotate(poly);\n    }\n\n    createRectangle() {\n      let i = null;\n      let ipt = 0;\n      let nSide = Math.trunc(this._nPts / 4);\n      if (nSide < 1) nSide = 1;\n      const XsegLen = this._dim.getEnvelope().getWidth() / nSide;\n      const YsegLen = this._dim.getEnvelope().getHeight() / nSide;\n      const pts = new Array(4 * nSide + 1).fill(null);\n\n      const env = this._dim.getEnvelope();\n\n      for (i = 0; i < nSide; i++) {\n        const x = env.getMinX() + i * XsegLen;\n        const y = env.getMinY();\n        pts[ipt++] = this.coord(x, y);\n      }\n\n      for (i = 0; i < nSide; i++) {\n        const x = env.getMaxX();\n        const y = env.getMinY() + i * YsegLen;\n        pts[ipt++] = this.coord(x, y);\n      }\n\n      for (i = 0; i < nSide; i++) {\n        const x = env.getMaxX() - i * XsegLen;\n        const y = env.getMaxY();\n        pts[ipt++] = this.coord(x, y);\n      }\n\n      for (i = 0; i < nSide; i++) {\n        const x = env.getMinX();\n        const y = env.getMaxY() - i * YsegLen;\n        pts[ipt++] = this.coord(x, y);\n      }\n\n      pts[ipt++] = new Coordinate(pts[0]);\n\n      const ring = this._geomFact.createLinearRing(pts);\n\n      const poly = this._geomFact.createPolygon(ring);\n\n      return this.rotate(poly);\n    }\n\n    createCircle() {\n      return this.createEllipse();\n    }\n\n    setHeight(height) {\n      this._dim.setHeight(height);\n    }\n\n    setSize(size) {\n      this._dim.setSize(size);\n    }\n\n  }\n\n  class Dimensions {\n    constructor() {\n      Dimensions.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.base = null;\n      this.centre = null;\n      this.width = null;\n      this.height = null;\n    }\n\n    setBase(base) {\n      this.base = base;\n    }\n\n    setWidth(width) {\n      this.width = width;\n    }\n\n    getBase() {\n      return this.base;\n    }\n\n    getWidth() {\n      return this.width;\n    }\n\n    setEnvelope(env) {\n      this.width = env.getWidth();\n      this.height = env.getHeight();\n      this.base = new Coordinate(env.getMinX(), env.getMinY());\n      this.centre = new Coordinate(env.centre());\n    }\n\n    setCentre(centre) {\n      this.centre = centre;\n    }\n\n    getMinSize() {\n      return Math.min(this.width, this.height);\n    }\n\n    getEnvelope() {\n      if (this.base !== null) return new Envelope(this.base.x, this.base.x + this.width, this.base.y, this.base.y + this.height);\n      if (this.centre !== null) return new Envelope(this.centre.x - this.width / 2, this.centre.x + this.width / 2, this.centre.y - this.height / 2, this.centre.y + this.height / 2);\n      return new Envelope(0, this.width, 0, this.height);\n    }\n\n    getCentre() {\n      if (this.centre === null) this.centre = new Coordinate(this.base.x + this.width / 2, this.base.y + this.height / 2);\n      return this.centre;\n    }\n\n    getHeight() {\n      return this.height;\n    }\n\n    setHeight(height) {\n      this.height = height;\n    }\n\n    setSize(size) {\n      this.height = size;\n      this.width = size;\n    }\n\n  }\n\n  GeometricShapeFactory.Dimensions = Dimensions;\n\n  class SineStarFactory extends GeometricShapeFactory {\n    constructor() {\n      super();\n      SineStarFactory.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._numArms = 8;\n      this._armLengthRatio = 0.5;\n\n      if (arguments.length === 0) {\n        GeometricShapeFactory.constructor_.call(this);\n      } else if (arguments.length === 1) {\n        const geomFact = arguments[0];\n        GeometricShapeFactory.constructor_.call(this, geomFact);\n      }\n    }\n\n    static create(origin, size, nPts, nArms, armLengthRatio) {\n      const gsf = new SineStarFactory();\n      gsf.setCentre(origin);\n      gsf.setSize(size);\n      gsf.setNumPoints(nPts);\n      gsf.setArmLengthRatio(armLengthRatio);\n      gsf.setNumArms(nArms);\n      const poly = gsf.createSineStar();\n      return poly;\n    }\n\n    setNumArms(numArms) {\n      this._numArms = numArms;\n    }\n\n    setArmLengthRatio(armLengthRatio) {\n      this._armLengthRatio = armLengthRatio;\n    }\n\n    createSineStar() {\n      const env = this._dim.getEnvelope();\n\n      const radius = env.getWidth() / 2.0;\n      let armRatio = this._armLengthRatio;\n      if (armRatio < 0.0) armRatio = 0.0;\n      if (armRatio > 1.0) armRatio = 1.0;\n      const armMaxLen = armRatio * radius;\n      const insideRadius = (1 - armRatio) * radius;\n      const centreX = env.getMinX() + radius;\n      const centreY = env.getMinY() + radius;\n      const pts = new Array(this._nPts + 1).fill(null);\n      let iPt = 0;\n\n      for (let i = 0; i < this._nPts; i++) {\n        const ptArcFrac = i / this._nPts * this._numArms;\n        const armAngFrac = ptArcFrac - Math.floor(ptArcFrac);\n        const armAng = 2 * Math.PI * armAngFrac;\n        const armLenFrac = (Math.cos(armAng) + 1.0) / 2.0;\n        const curveRadius = insideRadius + armMaxLen * armLenFrac;\n        const ang = i * (2 * Math.PI / this._nPts);\n        const x = curveRadius * Math.cos(ang) + centreX;\n        const y = curveRadius * Math.sin(ang) + centreY;\n        pts[iPt++] = this.coord(x, y);\n      }\n\n      pts[iPt] = new Coordinate(pts[0]);\n\n      const ring = this._geomFact.createLinearRing(pts);\n\n      const poly = this._geomFact.createPolygon(ring);\n\n      return poly;\n    }\n\n  }\n\n  var util = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    AffineTransformation: AffineTransformation,\n    AffineTransformationBuilder: AffineTransformationBuilder,\n    AffineTransformationFactory: AffineTransformationFactory,\n    ComponentCoordinateExtracter: ComponentCoordinateExtracter,\n    GeometryCollectionMapper: GeometryCollectionMapper,\n    GeometryCombiner: GeometryCombiner,\n    GeometryEditor: GeometryEditor,\n    GeometryExtracter: GeometryExtracter,\n    GeometryMapper: GeometryMapper,\n    GeometryTransformer: GeometryTransformer,\n    LineStringExtracter: LineStringExtracter,\n    LinearComponentExtracter: LinearComponentExtracter,\n    PointExtracter: PointExtracter,\n    PolygonExtracter: PolygonExtracter,\n    ShortCircuitedGeometryVisitor: ShortCircuitedGeometryVisitor,\n    SineStarFactory: SineStarFactory\n  });\n\n  var geom = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Coordinate: Coordinate,\n    CoordinateList: CoordinateList,\n    CoordinateSequenceFilter: CoordinateSequenceFilter,\n    Envelope: Envelope,\n    LineSegment: LineSegment,\n    GeometryFactory: GeometryFactory,\n    Geometry: Geometry,\n    Point: Point,\n    LineString: LineString,\n    LinearRing: LinearRing,\n    Polygon: Polygon,\n    GeometryCollection: GeometryCollection,\n    MultiPoint: MultiPoint,\n    MultiLineString: MultiLineString,\n    MultiPolygon: MultiPolygon,\n    Dimension: Dimension,\n    IntersectionMatrix: IntersectionMatrix,\n    PrecisionModel: PrecisionModel,\n    Location: Location,\n    Triangle: Triangle,\n    util: util\n  });\n\n  class PointPairDistance {\n    constructor() {\n      PointPairDistance.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._pt = [new Coordinate(), new Coordinate()];\n      this._distance = Double.NaN;\n      this._isNull = true;\n    }\n\n    getCoordinates() {\n      return this._pt;\n    }\n\n    getCoordinate(i) {\n      return this._pt[i];\n    }\n\n    setMinimum() {\n      if (arguments.length === 1) {\n        const ptDist = arguments[0];\n        this.setMinimum(ptDist._pt[0], ptDist._pt[1]);\n      } else if (arguments.length === 2) {\n        const p0 = arguments[0],\n              p1 = arguments[1];\n\n        if (this._isNull) {\n          this.initialize(p0, p1);\n          return null;\n        }\n\n        const dist = p0.distance(p1);\n        if (dist < this._distance) this.initialize(p0, p1, dist);\n      }\n    }\n\n    initialize() {\n      if (arguments.length === 0) {\n        this._isNull = true;\n      } else if (arguments.length === 2) {\n        const p0 = arguments[0],\n              p1 = arguments[1];\n\n        this._pt[0].setCoordinate(p0);\n\n        this._pt[1].setCoordinate(p1);\n\n        this._distance = p0.distance(p1);\n        this._isNull = false;\n      } else if (arguments.length === 3) {\n        const p0 = arguments[0],\n              p1 = arguments[1],\n              distance = arguments[2];\n\n        this._pt[0].setCoordinate(p0);\n\n        this._pt[1].setCoordinate(p1);\n\n        this._distance = distance;\n        this._isNull = false;\n      }\n    }\n\n    toString() {\n      return WKTWriter.toLineString(this._pt[0], this._pt[1]);\n    }\n\n    getDistance() {\n      return this._distance;\n    }\n\n    setMaximum() {\n      if (arguments.length === 1) {\n        const ptDist = arguments[0];\n        this.setMaximum(ptDist._pt[0], ptDist._pt[1]);\n      } else if (arguments.length === 2) {\n        const p0 = arguments[0],\n              p1 = arguments[1];\n\n        if (this._isNull) {\n          this.initialize(p0, p1);\n          return null;\n        }\n\n        const dist = p0.distance(p1);\n        if (dist > this._distance) this.initialize(p0, p1, dist);\n      }\n    }\n\n  }\n\n  class DistanceToPoint {\n    static computeDistance() {\n      if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof LineString && arguments[1] instanceof Coordinate) {\n        const line = arguments[0],\n              pt = arguments[1],\n              ptDist = arguments[2];\n        const tempSegment = new LineSegment();\n        const coords = line.getCoordinates();\n\n        for (let i = 0; i < coords.length - 1; i++) {\n          tempSegment.setCoordinates(coords[i], coords[i + 1]);\n          const closestPt = tempSegment.closestPoint(pt);\n          ptDist.setMinimum(closestPt, pt);\n        }\n      } else if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate) {\n        const poly = arguments[0],\n              pt = arguments[1],\n              ptDist = arguments[2];\n        DistanceToPoint.computeDistance(poly.getExteriorRing(), pt, ptDist);\n\n        for (let i = 0; i < poly.getNumInteriorRing(); i++) DistanceToPoint.computeDistance(poly.getInteriorRingN(i), pt, ptDist);\n      } else if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate) {\n        const geom = arguments[0],\n              pt = arguments[1],\n              ptDist = arguments[2];\n\n        if (geom instanceof LineString) {\n          DistanceToPoint.computeDistance(geom, pt, ptDist);\n        } else if (geom instanceof Polygon) {\n          DistanceToPoint.computeDistance(geom, pt, ptDist);\n        } else if (geom instanceof GeometryCollection) {\n          const gc = geom;\n\n          for (let i = 0; i < gc.getNumGeometries(); i++) {\n            const g = gc.getGeometryN(i);\n            DistanceToPoint.computeDistance(g, pt, ptDist);\n          }\n        } else {\n          ptDist.setMinimum(geom.getCoordinate(), pt);\n        }\n      } else if (arguments[2] instanceof PointPairDistance && arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate) {\n        const segment = arguments[0],\n              pt = arguments[1],\n              ptDist = arguments[2];\n        const closestPt = segment.closestPoint(pt);\n        ptDist.setMinimum(closestPt, pt);\n      }\n    }\n\n  }\n\n  class DiscreteHausdorffDistance {\n    constructor() {\n      DiscreteHausdorffDistance.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._g0 = null;\n      this._g1 = null;\n      this._ptDist = new PointPairDistance();\n      this._densifyFrac = 0.0;\n      const g0 = arguments[0],\n            g1 = arguments[1];\n      this._g0 = g0;\n      this._g1 = g1;\n    }\n\n    static distance() {\n      if (arguments.length === 2) {\n        const g0 = arguments[0],\n              g1 = arguments[1];\n        const dist = new DiscreteHausdorffDistance(g0, g1);\n        return dist.distance();\n      } else if (arguments.length === 3) {\n        const g0 = arguments[0],\n              g1 = arguments[1],\n              densifyFrac = arguments[2];\n        const dist = new DiscreteHausdorffDistance(g0, g1);\n        dist.setDensifyFraction(densifyFrac);\n        return dist.distance();\n      }\n    }\n\n    getCoordinates() {\n      return this._ptDist.getCoordinates();\n    }\n\n    setDensifyFraction(densifyFrac) {\n      if (densifyFrac > 1.0 || densifyFrac <= 0.0) throw new IllegalArgumentException('Fraction is not in range (0.0 - 1.0]');\n      this._densifyFrac = densifyFrac;\n    }\n\n    compute(g0, g1) {\n      this.computeOrientedDistance(g0, g1, this._ptDist);\n      this.computeOrientedDistance(g1, g0, this._ptDist);\n    }\n\n    distance() {\n      this.compute(this._g0, this._g1);\n      return this._ptDist.getDistance();\n    }\n\n    computeOrientedDistance(discreteGeom, geom, ptDist) {\n      const distFilter = new MaxPointDistanceFilter(geom);\n      discreteGeom.apply(distFilter);\n      ptDist.setMaximum(distFilter.getMaxPointDistance());\n\n      if (this._densifyFrac > 0) {\n        const fracFilter = new MaxDensifiedByFractionDistanceFilter(geom, this._densifyFrac);\n        discreteGeom.apply(fracFilter);\n        ptDist.setMaximum(fracFilter.getMaxPointDistance());\n      }\n    }\n\n    orientedDistance() {\n      this.computeOrientedDistance(this._g0, this._g1, this._ptDist);\n      return this._ptDist.getDistance();\n    }\n\n  }\n\n  class MaxPointDistanceFilter {\n    constructor() {\n      MaxPointDistanceFilter.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._maxPtDist = new PointPairDistance();\n      this._minPtDist = new PointPairDistance();\n      this._euclideanDist = new DistanceToPoint();\n      this._geom = null;\n      const geom = arguments[0];\n      this._geom = geom;\n    }\n\n    filter(pt) {\n      this._minPtDist.initialize();\n\n      DistanceToPoint.computeDistance(this._geom, pt, this._minPtDist);\n\n      this._maxPtDist.setMaximum(this._minPtDist);\n    }\n\n    getMaxPointDistance() {\n      return this._maxPtDist;\n    }\n\n    get interfaces_() {\n      return [CoordinateFilter];\n    }\n\n  }\n\n  class MaxDensifiedByFractionDistanceFilter {\n    constructor() {\n      MaxDensifiedByFractionDistanceFilter.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._maxPtDist = new PointPairDistance();\n      this._minPtDist = new PointPairDistance();\n      this._geom = null;\n      this._numSubSegs = 0;\n      const geom = arguments[0],\n            fraction = arguments[1];\n      this._geom = geom;\n      this._numSubSegs = Math.trunc(Math.round(1.0 / fraction));\n    }\n\n    filter(seq, index) {\n      if (index === 0) return null;\n      const p0 = seq.getCoordinate(index - 1);\n      const p1 = seq.getCoordinate(index);\n      const delx = (p1.x - p0.x) / this._numSubSegs;\n      const dely = (p1.y - p0.y) / this._numSubSegs;\n\n      for (let i = 0; i < this._numSubSegs; i++) {\n        const x = p0.x + i * delx;\n        const y = p0.y + i * dely;\n        const pt = new Coordinate(x, y);\n\n        this._minPtDist.initialize();\n\n        DistanceToPoint.computeDistance(this._geom, pt, this._minPtDist);\n\n        this._maxPtDist.setMaximum(this._minPtDist);\n      }\n    }\n\n    isDone() {\n      return false;\n    }\n\n    isGeometryChanged() {\n      return false;\n    }\n\n    getMaxPointDistance() {\n      return this._maxPtDist;\n    }\n\n    get interfaces_() {\n      return [CoordinateSequenceFilter];\n    }\n\n  }\n\n  DiscreteHausdorffDistance.MaxPointDistanceFilter = MaxPointDistanceFilter;\n  DiscreteHausdorffDistance.MaxDensifiedByFractionDistanceFilter = MaxDensifiedByFractionDistanceFilter;\n\n  var distance_module = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    DiscreteHausdorffDistance: DiscreteHausdorffDistance,\n    DistanceToPoint: DistanceToPoint,\n    PointPairDistance: PointPairDistance\n  });\n\n  class ItemVisitor {\n    visitItem(item) {}\n\n  }\n\n  class PointOnGeometryLocator {\n    locate(p) {}\n\n  }\n\n  class IntervalRTreeNode {\n    constructor() {\n      IntervalRTreeNode.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._min = Double.POSITIVE_INFINITY;\n      this._max = Double.NEGATIVE_INFINITY;\n    }\n\n    getMin() {\n      return this._min;\n    }\n\n    intersects(queryMin, queryMax) {\n      if (this._min > queryMax || this._max < queryMin) return false;\n      return true;\n    }\n\n    getMax() {\n      return this._max;\n    }\n\n    toString() {\n      return WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0));\n    }\n\n  }\n\n  class NodeComparator {\n    compare(o1, o2) {\n      const n1 = o1;\n      const n2 = o2;\n      const mid1 = (n1._min + n1._max) / 2;\n      const mid2 = (n2._min + n2._max) / 2;\n      if (mid1 < mid2) return -1;\n      if (mid1 > mid2) return 1;\n      return 0;\n    }\n\n    get interfaces_() {\n      return [Comparator];\n    }\n\n  }\n\n  IntervalRTreeNode.NodeComparator = NodeComparator;\n\n  class IntervalRTreeLeafNode extends IntervalRTreeNode {\n    constructor() {\n      super();\n      IntervalRTreeLeafNode.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._item = null;\n      const min = arguments[0],\n            max = arguments[1],\n            item = arguments[2];\n      this._min = min;\n      this._max = max;\n      this._item = item;\n    }\n\n    query(queryMin, queryMax, visitor) {\n      if (!this.intersects(queryMin, queryMax)) return null;\n      visitor.visitItem(this._item);\n    }\n\n  }\n\n  class IntervalRTreeBranchNode extends IntervalRTreeNode {\n    constructor() {\n      super();\n      IntervalRTreeBranchNode.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._node1 = null;\n      this._node2 = null;\n      const n1 = arguments[0],\n            n2 = arguments[1];\n      this._node1 = n1;\n      this._node2 = n2;\n      this.buildExtent(this._node1, this._node2);\n    }\n\n    buildExtent(n1, n2) {\n      this._min = Math.min(n1._min, n2._min);\n      this._max = Math.max(n1._max, n2._max);\n    }\n\n    query(queryMin, queryMax, visitor) {\n      if (!this.intersects(queryMin, queryMax)) return null;\n      if (this._node1 !== null) this._node1.query(queryMin, queryMax, visitor);\n      if (this._node2 !== null) this._node2.query(queryMin, queryMax, visitor);\n    }\n\n  }\n\n  class SortedPackedIntervalRTree {\n    constructor() {\n      SortedPackedIntervalRTree.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._leaves = new ArrayList();\n      this._root = null;\n      this._level = 0;\n    }\n\n    buildTree() {\n      Collections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());\n      let src = this._leaves;\n      let temp = null;\n      let dest = new ArrayList();\n\n      while (true) {\n        this.buildLevel(src, dest);\n        if (dest.size() === 1) return dest.get(0);\n        temp = src;\n        src = dest;\n        dest = temp;\n      }\n    }\n\n    insert(min, max, item) {\n      if (this._root !== null) throw new IllegalStateException('Index cannot be added to once it has been queried');\n\n      this._leaves.add(new IntervalRTreeLeafNode(min, max, item));\n    }\n\n    query(min, max, visitor) {\n      this.init();\n      if (this._root === null) return null;\n\n      this._root.query(min, max, visitor);\n    }\n\n    buildRoot() {\n      if (this._root !== null) return null;\n      this._root = this.buildTree();\n    }\n\n    printNode(node) {\n      System.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));\n    }\n\n    init() {\n      if (this._root !== null) return null;\n      if (this._leaves.size() === 0) return null;\n      this.buildRoot();\n    }\n\n    buildLevel(src, dest) {\n      this._level++;\n      dest.clear();\n\n      for (let i = 0; i < src.size(); i += 2) {\n        const n1 = src.get(i);\n        const n2 = i + 1 < src.size() ? src.get(i) : null;\n\n        if (n2 === null) {\n          dest.add(n1);\n        } else {\n          const node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));\n          dest.add(node);\n        }\n      }\n    }\n\n  }\n\n  class ArrayListVisitor {\n    constructor() {\n      ArrayListVisitor.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._items = new ArrayList();\n    }\n\n    visitItem(item) {\n      this._items.add(item);\n    }\n\n    getItems() {\n      return this._items;\n    }\n\n    get interfaces_() {\n      return [ItemVisitor];\n    }\n\n  }\n\n  class RayCrossingCounter {\n    constructor() {\n      RayCrossingCounter.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._p = null;\n      this._crossingCount = 0;\n      this._isPointOnSegment = false;\n      const p = arguments[0];\n      this._p = p;\n    }\n\n    static locatePointInRing() {\n      if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n        const p = arguments[0],\n              ring = arguments[1];\n        const counter = new RayCrossingCounter(p);\n        const p1 = new Coordinate();\n        const p2 = new Coordinate();\n\n        for (let i = 1; i < ring.size(); i++) {\n          ring.getCoordinate(i, p1);\n          ring.getCoordinate(i - 1, p2);\n          counter.countSegment(p1, p2);\n          if (counter.isOnSegment()) return counter.getLocation();\n        }\n\n        return counter.getLocation();\n      } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n        const p = arguments[0],\n              ring = arguments[1];\n        const counter = new RayCrossingCounter(p);\n\n        for (let i = 1; i < ring.length; i++) {\n          const p1 = ring[i];\n          const p2 = ring[i - 1];\n          counter.countSegment(p1, p2);\n          if (counter.isOnSegment()) return counter.getLocation();\n        }\n\n        return counter.getLocation();\n      }\n    }\n\n    countSegment(p1, p2) {\n      if (p1.x < this._p.x && p2.x < this._p.x) return null;\n\n      if (this._p.x === p2.x && this._p.y === p2.y) {\n        this._isPointOnSegment = true;\n        return null;\n      }\n\n      if (p1.y === this._p.y && p2.y === this._p.y) {\n        let minx = p1.x;\n        let maxx = p2.x;\n\n        if (minx > maxx) {\n          minx = p2.x;\n          maxx = p1.x;\n        }\n\n        if (this._p.x >= minx && this._p.x <= maxx) this._isPointOnSegment = true;\n        return null;\n      }\n\n      if (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {\n        let orient = Orientation.index(p1, p2, this._p);\n\n        if (orient === Orientation.COLLINEAR) {\n          this._isPointOnSegment = true;\n          return null;\n        }\n\n        if (p2.y < p1.y) orient = -orient;\n        if (orient === Orientation.LEFT) this._crossingCount++;\n      }\n    }\n\n    isPointInPolygon() {\n      return this.getLocation() !== Location.EXTERIOR;\n    }\n\n    getLocation() {\n      if (this._isPointOnSegment) return Location.BOUNDARY;\n      if (this._crossingCount % 2 === 1) return Location.INTERIOR;\n      return Location.EXTERIOR;\n    }\n\n    isOnSegment() {\n      return this._isPointOnSegment;\n    }\n\n  }\n\n  class IndexedPointInAreaLocator {\n    constructor() {\n      IndexedPointInAreaLocator.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._geom = null;\n      this._index = null;\n      const g = arguments[0];\n      if (!(hasInterface(g, Polygonal) || g instanceof LinearRing)) throw new IllegalArgumentException('Argument must be Polygonal or LinearRing');\n      this._geom = g;\n    }\n\n    locate(p) {\n      if (this._index === null) {\n        this._index = new IntervalIndexedGeometry(this._geom);\n        this._geom = null;\n      }\n\n      const rcc = new RayCrossingCounter(p);\n      const visitor = new SegmentVisitor(rcc);\n\n      this._index.query(p.y, p.y, visitor);\n\n      return rcc.getLocation();\n    }\n\n    get interfaces_() {\n      return [PointOnGeometryLocator];\n    }\n\n  }\n\n  class SegmentVisitor {\n    constructor() {\n      SegmentVisitor.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._counter = null;\n      const counter = arguments[0];\n      this._counter = counter;\n    }\n\n    visitItem(item) {\n      const seg = item;\n\n      this._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));\n    }\n\n    get interfaces_() {\n      return [ItemVisitor];\n    }\n\n  }\n\n  class IntervalIndexedGeometry {\n    constructor() {\n      IntervalIndexedGeometry.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._isEmpty = false;\n      this._index = new SortedPackedIntervalRTree();\n      const geom = arguments[0];\n      if (geom.isEmpty()) this._isEmpty = true;else this.init(geom);\n    }\n\n    init(geom) {\n      const lines = LinearComponentExtracter.getLines(geom);\n\n      for (let i = lines.iterator(); i.hasNext();) {\n        const line = i.next();\n        const pts = line.getCoordinates();\n        this.addLine(pts);\n      }\n    }\n\n    addLine(pts) {\n      for (let i = 1; i < pts.length; i++) {\n        const seg = new LineSegment(pts[i - 1], pts[i]);\n        const min = Math.min(seg.p0.y, seg.p1.y);\n        const max = Math.max(seg.p0.y, seg.p1.y);\n\n        this._index.insert(min, max, seg);\n      }\n    }\n\n    query() {\n      if (arguments.length === 2) {\n        const min = arguments[0],\n              max = arguments[1];\n        if (this._isEmpty) return new ArrayList();\n        const visitor = new ArrayListVisitor();\n\n        this._index.query(min, max, visitor);\n\n        return visitor.getItems();\n      } else if (arguments.length === 3) {\n        const min = arguments[0],\n              max = arguments[1],\n              visitor = arguments[2];\n        if (this._isEmpty) return null;\n\n        this._index.query(min, max, visitor);\n      }\n    }\n\n  }\n\n  IndexedPointInAreaLocator.SegmentVisitor = SegmentVisitor;\n  IndexedPointInAreaLocator.IntervalIndexedGeometry = IntervalIndexedGeometry;\n\n  class PointLocation {\n    static isOnLine() {\n      if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n        const p = arguments[0],\n              line = arguments[1];\n        const lineIntersector = new RobustLineIntersector();\n        const p0 = new Coordinate();\n        const p1 = new Coordinate();\n        const n = line.size();\n\n        for (let i = 1; i < n; i++) {\n          line.getCoordinate(i - 1, p0);\n          line.getCoordinate(i, p1);\n          lineIntersector.computeIntersection(p, p0, p1);\n          if (lineIntersector.hasIntersection()) return true;\n        }\n\n        return false;\n      } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n        const p = arguments[0],\n              line = arguments[1];\n        const lineIntersector = new RobustLineIntersector();\n\n        for (let i = 1; i < line.length; i++) {\n          const p0 = line[i - 1];\n          const p1 = line[i];\n          lineIntersector.computeIntersection(p, p0, p1);\n          if (lineIntersector.hasIntersection()) return true;\n        }\n\n        return false;\n      }\n    }\n\n    static locateInRing(p, ring) {\n      return RayCrossingCounter.locatePointInRing(p, ring);\n    }\n\n    static isInRing(p, ring) {\n      return PointLocation.locateInRing(p, ring) !== Location.EXTERIOR;\n    }\n\n  }\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html\n   * @constructor\n   * @private\n   */\n  class Iterator$3 {\n    /**\n       * Returns true if the iteration has more elements.\n       * @return {boolean}\n       */\n    hasNext() {}\n    /**\n       * Returns the next element in the iteration.\n       * @return {Object}\n       */\n\n\n    next() {}\n    /**\n       * Removes from the underlying collection the last element returned by the\n       * iterator (optional operation).\n       */\n\n\n    remove() {}\n\n  }\n\n  class GeometryCollectionIterator {\n    constructor() {\n      GeometryCollectionIterator.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._parent = null;\n      this._atStart = null;\n      this._max = null;\n      this._index = null;\n      this._subcollectionIterator = null;\n      const parent = arguments[0];\n      this._parent = parent;\n      this._atStart = true;\n      this._index = 0;\n      this._max = parent.getNumGeometries();\n    }\n\n    static isAtomic(geom) {\n      return !(geom instanceof GeometryCollection);\n    }\n\n    next() {\n      if (this._atStart) {\n        this._atStart = false;\n        if (GeometryCollectionIterator.isAtomic(this._parent)) this._index++;\n        return this._parent;\n      }\n\n      if (this._subcollectionIterator !== null) if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();else this._subcollectionIterator = null;\n      if (this._index >= this._max) throw new NoSuchElementException();\n\n      const obj = this._parent.getGeometryN(this._index++);\n\n      if (obj instanceof GeometryCollection) {\n        this._subcollectionIterator = new GeometryCollectionIterator(obj);\n        return this._subcollectionIterator.next();\n      }\n\n      return obj;\n    }\n\n    remove() {\n      throw new UnsupportedOperationException(this.getClass().getName());\n    }\n\n    hasNext() {\n      if (this._atStart) return true;\n\n      if (this._subcollectionIterator !== null) {\n        if (this._subcollectionIterator.hasNext()) return true;\n        this._subcollectionIterator = null;\n      }\n\n      if (this._index >= this._max) return false;\n      return true;\n    }\n\n    get interfaces_() {\n      return [Iterator$3];\n    }\n\n  }\n\n  class SimplePointInAreaLocator {\n    constructor() {\n      SimplePointInAreaLocator.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._geom = null;\n      const geom = arguments[0];\n      this._geom = geom;\n    }\n\n    static locatePointInPolygon(p, poly) {\n      if (poly.isEmpty()) return Location.EXTERIOR;\n      const shell = poly.getExteriorRing();\n      const shellLoc = SimplePointInAreaLocator.locatePointInRing(p, shell);\n      if (shellLoc !== Location.INTERIOR) return shellLoc;\n\n      for (let i = 0; i < poly.getNumInteriorRing(); i++) {\n        const hole = poly.getInteriorRingN(i);\n        const holeLoc = SimplePointInAreaLocator.locatePointInRing(p, hole);\n        if (holeLoc === Location.BOUNDARY) return Location.BOUNDARY;\n        if (holeLoc === Location.INTERIOR) return Location.EXTERIOR;\n      }\n\n      return Location.INTERIOR;\n    }\n\n    static locatePointInRing(p, ring) {\n      if (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n      return PointLocation.locateInRing(p, ring.getCoordinates());\n    }\n\n    static containsPointInPolygon(p, poly) {\n      return Location.EXTERIOR !== SimplePointInAreaLocator.locatePointInPolygon(p, poly);\n    }\n\n    static locateInGeometry(p, geom) {\n      if (geom instanceof Polygon) return SimplePointInAreaLocator.locatePointInPolygon(p, geom);\n\n      if (geom instanceof GeometryCollection) {\n        const geomi = new GeometryCollectionIterator(geom);\n\n        while (geomi.hasNext()) {\n          const g2 = geomi.next();\n\n          if (g2 !== geom) {\n            const loc = SimplePointInAreaLocator.locateInGeometry(p, g2);\n            if (loc !== Location.EXTERIOR) return loc;\n          }\n        }\n      }\n\n      return Location.EXTERIOR;\n    }\n\n    static isContained(p, geom) {\n      return Location.EXTERIOR !== SimplePointInAreaLocator.locate(p, geom);\n    }\n\n    static locate(p, geom) {\n      if (geom.isEmpty()) return Location.EXTERIOR;\n      if (!geom.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n      return SimplePointInAreaLocator.locateInGeometry(p, geom);\n    }\n\n    locate(p) {\n      return SimplePointInAreaLocator.locate(p, this._geom);\n    }\n\n    get interfaces_() {\n      return [PointOnGeometryLocator];\n    }\n\n  }\n\n  var locate = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    IndexedPointInAreaLocator: IndexedPointInAreaLocator,\n    PointOnGeometryLocator: PointOnGeometryLocator,\n    SimplePointInAreaLocator: SimplePointInAreaLocator\n  });\n\n  class SimilarityMeasure {\n    measure(g1, g2) {}\n\n  }\n\n  class AreaSimilarityMeasure {\n    measure(g1, g2) {\n      const areaInt = g1.intersection(g2).getArea();\n      const areaUnion = g1.union(g2).getArea();\n      return areaInt / areaUnion;\n    }\n\n    get interfaces_() {\n      return [SimilarityMeasure];\n    }\n\n  }\n\n  class HausdorffSimilarityMeasure {\n    static diagonalSize(env) {\n      if (env.isNull()) return 0.0;\n      const width = env.getWidth();\n      const hgt = env.getHeight();\n      return Math.sqrt(width * width + hgt * hgt);\n    }\n\n    measure(g1, g2) {\n      const distance = DiscreteHausdorffDistance.distance(g1, g2, HausdorffSimilarityMeasure.DENSIFY_FRACTION);\n      const env = new Envelope(g1.getEnvelopeInternal());\n      env.expandToInclude(g2.getEnvelopeInternal());\n      const envSize = HausdorffSimilarityMeasure.diagonalSize(env);\n      const measure = 1 - distance / envSize;\n      return measure;\n    }\n\n    get interfaces_() {\n      return [SimilarityMeasure];\n    }\n\n  }\n  HausdorffSimilarityMeasure.DENSIFY_FRACTION = 0.25;\n\n  class SimilarityMeasureCombiner {\n    static combine(measure1, measure2) {\n      return Math.min(measure1, measure2);\n    }\n\n  }\n\n  var match = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    AreaSimilarityMeasure: AreaSimilarityMeasure,\n    HausdorffSimilarityMeasure: HausdorffSimilarityMeasure,\n    SimilarityMeasure: SimilarityMeasure,\n    SimilarityMeasureCombiner: SimilarityMeasureCombiner\n  });\n\n  class Centroid {\n    constructor() {\n      Centroid.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._areaBasePt = null;\n      this._triangleCent3 = new Coordinate();\n      this._areasum2 = 0;\n      this._cg3 = new Coordinate();\n      this._lineCentSum = new Coordinate();\n      this._totalLength = 0.0;\n      this._ptCount = 0;\n      this._ptCentSum = new Coordinate();\n      const geom = arguments[0];\n      this._areaBasePt = null;\n      this.add(geom);\n    }\n\n    static area2(p1, p2, p3) {\n      return (p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y);\n    }\n\n    static centroid3(p1, p2, p3, c) {\n      c.x = p1.x + p2.x + p3.x;\n      c.y = p1.y + p2.y + p3.y;\n      return null;\n    }\n\n    static getCentroid(geom) {\n      const cent = new Centroid(geom);\n      return cent.getCentroid();\n    }\n\n    setAreaBasePoint(basePt) {\n      this._areaBasePt = basePt;\n    }\n\n    addPoint(pt) {\n      this._ptCount += 1;\n      this._ptCentSum.x += pt.x;\n      this._ptCentSum.y += pt.y;\n    }\n\n    addLineSegments(pts) {\n      let lineLen = 0.0;\n\n      for (let i = 0; i < pts.length - 1; i++) {\n        const segmentLen = pts[i].distance(pts[i + 1]);\n        if (segmentLen === 0.0) continue;\n        lineLen += segmentLen;\n        const midx = (pts[i].x + pts[i + 1].x) / 2;\n        this._lineCentSum.x += segmentLen * midx;\n        const midy = (pts[i].y + pts[i + 1].y) / 2;\n        this._lineCentSum.y += segmentLen * midy;\n      }\n\n      this._totalLength += lineLen;\n      if (lineLen === 0.0 && pts.length > 0) this.addPoint(pts[0]);\n    }\n\n    addHole(pts) {\n      const isPositiveArea = Orientation.isCCW(pts);\n\n      for (let i = 0; i < pts.length - 1; i++) this.addTriangle(this._areaBasePt, pts[i], pts[i + 1], isPositiveArea);\n\n      this.addLineSegments(pts);\n    }\n\n    getCentroid() {\n      const cent = new Coordinate();\n\n      if (Math.abs(this._areasum2) > 0.0) {\n        cent.x = this._cg3.x / 3 / this._areasum2;\n        cent.y = this._cg3.y / 3 / this._areasum2;\n      } else if (this._totalLength > 0.0) {\n        cent.x = this._lineCentSum.x / this._totalLength;\n        cent.y = this._lineCentSum.y / this._totalLength;\n      } else if (this._ptCount > 0) {\n        cent.x = this._ptCentSum.x / this._ptCount;\n        cent.y = this._ptCentSum.y / this._ptCount;\n      } else {\n        return null;\n      }\n\n      return cent;\n    }\n\n    addShell(pts) {\n      if (pts.length > 0) this.setAreaBasePoint(pts[0]);\n      const isPositiveArea = !Orientation.isCCW(pts);\n\n      for (let i = 0; i < pts.length - 1; i++) this.addTriangle(this._areaBasePt, pts[i], pts[i + 1], isPositiveArea);\n\n      this.addLineSegments(pts);\n    }\n\n    addTriangle(p0, p1, p2, isPositiveArea) {\n      const sign = isPositiveArea ? 1.0 : -1.0;\n      Centroid.centroid3(p0, p1, p2, this._triangleCent3);\n      const area2 = Centroid.area2(p0, p1, p2);\n      this._cg3.x += sign * area2 * this._triangleCent3.x;\n      this._cg3.y += sign * area2 * this._triangleCent3.y;\n      this._areasum2 += sign * area2;\n    }\n\n    add() {\n      if (arguments[0] instanceof Polygon) {\n        const poly = arguments[0];\n        this.addShell(poly.getExteriorRing().getCoordinates());\n\n        for (let i = 0; i < poly.getNumInteriorRing(); i++) this.addHole(poly.getInteriorRingN(i).getCoordinates());\n      } else if (arguments[0] instanceof Geometry) {\n        const geom = arguments[0];\n        if (geom.isEmpty()) return null;\n\n        if (geom instanceof Point) {\n          this.addPoint(geom.getCoordinate());\n        } else if (geom instanceof LineString) {\n          this.addLineSegments(geom.getCoordinates());\n        } else if (geom instanceof Polygon) {\n          const poly = geom;\n          this.add(poly);\n        } else if (geom instanceof GeometryCollection) {\n          const gc = geom;\n\n          for (let i = 0; i < gc.getNumGeometries(); i++) this.add(gc.getGeometryN(i));\n        }\n      }\n    }\n\n  }\n\n  class EmptyStackException extends Exception {}\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/Stack.html\n   */\n\n  class Stack extends List {\n    constructor() {\n      super();\n      this.array = [];\n    }\n\n    add(e) {\n      this.array.push(e);\n      return true;\n    }\n\n    get(index) {\n      if (index < 0 || index >= this.size()) throw new IndexOutOfBoundsException();\n      return this.array[index];\n    }\n    /**\n     * Pushes an item onto the top of this stack.\n     * @param {Object} e\n     * @return {Object}\n     */\n\n\n    push(e) {\n      this.array.push(e);\n      return e;\n    }\n    /**\n     * Removes the object at the top of this stack and returns that object as the value of this function.\n     * @return {Object}\n     */\n\n\n    pop() {\n      if (this.array.length === 0) throw new EmptyStackException();\n      return this.array.pop();\n    }\n    /**\n     * Looks at the object at the top of this stack without removing it from the\n     * stack.\n     * @return {Object}\n     */\n\n\n    peek() {\n      if (this.array.length === 0) throw new EmptyStackException();\n      return this.array[this.array.length - 1];\n    }\n    /**\n     * Tests if this stack is empty.\n     * @return {boolean} true if and only if this stack contains no items; false\n     *         otherwise.\n     */\n\n\n    empty() {\n      return this.array.length === 0;\n    }\n    /**\n     * @return {boolean}\n     */\n\n\n    isEmpty() {\n      return this.empty();\n    }\n    /**\n     * Returns the 1-based position where an object is on this stack. If the object\n     * o occurs as an item in this stack, this method returns the distance from the\n     * top of the stack of the occurrence nearest the top of the stack; the topmost\n     * item on the stack is considered to be at distance 1. The equals method is\n     * used to compare o to the items in this stack.\n     *\n     * NOTE: does not currently actually use equals. (=== is used)\n     *\n     * @param {Object} o\n     * @return {number} the 1-based position from the top of the stack where the\n     *         object is located; the return value -1 indicates that the object is\n     *         not on the stack.\n     */\n\n\n    search(o) {\n      return this.array.indexOf(o);\n    }\n    /**\n     * @return {number}\n     */\n\n\n    size() {\n      return this.array.length;\n    }\n    /**\n     * @return {Array}\n     */\n\n\n    toArray() {\n      return this.array.slice();\n    }\n\n  }\n\n  class UniqueCoordinateArrayFilter {\n    constructor() {\n      UniqueCoordinateArrayFilter.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._coordSet = new HashSet();\n      this._list = new ArrayList();\n    }\n\n    static filterCoordinates(coords) {\n      const filter = new UniqueCoordinateArrayFilter();\n\n      for (let i = 0; i < coords.length; i++) filter.filter(coords[i]);\n\n      return filter.getCoordinates();\n    }\n\n    filter(coord) {\n      if (this._coordSet.add(coord)) this._list.add(coord);\n    }\n\n    getCoordinates() {\n      const coordinates = new Array(this._list.size()).fill(null);\n      return this._list.toArray(coordinates);\n    }\n\n    get interfaces_() {\n      return [CoordinateFilter];\n    }\n\n  }\n\n  class ConvexHull {\n    constructor() {\n      ConvexHull.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._geomFactory = null;\n      this._inputPts = null;\n\n      if (arguments.length === 1) {\n        const geometry = arguments[0];\n        ConvexHull.constructor_.call(this, ConvexHull.extractCoordinates(geometry), geometry.getFactory());\n      } else if (arguments.length === 2) {\n        const pts = arguments[0],\n              geomFactory = arguments[1];\n        this._inputPts = UniqueCoordinateArrayFilter.filterCoordinates(pts);\n        this._geomFactory = geomFactory;\n      }\n    }\n\n    static extractCoordinates(geom) {\n      const filter = new UniqueCoordinateArrayFilter();\n      geom.apply(filter);\n      return filter.getCoordinates();\n    }\n\n    preSort(pts) {\n      let t = null;\n\n      for (let i = 1; i < pts.length; i++) if (pts[i].y < pts[0].y || pts[i].y === pts[0].y && pts[i].x < pts[0].x) {\n        t = pts[0];\n        pts[0] = pts[i];\n        pts[i] = t;\n      }\n\n      Arrays.sort(pts, 1, pts.length, new RadialComparator(pts[0]));\n      return pts;\n    }\n\n    computeOctRing(inputPts) {\n      const octPts = this.computeOctPts(inputPts);\n      const coordList = new CoordinateList();\n      coordList.add(octPts, false);\n      if (coordList.size() < 3) return null;\n      coordList.closeRing();\n      return coordList.toCoordinateArray();\n    }\n\n    lineOrPolygon(coordinates) {\n      coordinates = this.cleanRing(coordinates);\n      if (coordinates.length === 3) return this._geomFactory.createLineString([coordinates[0], coordinates[1]]);\n\n      const linearRing = this._geomFactory.createLinearRing(coordinates);\n\n      return this._geomFactory.createPolygon(linearRing);\n    }\n\n    cleanRing(original) {\n      Assert.equals(original[0], original[original.length - 1]);\n      const cleanedRing = new ArrayList();\n      let previousDistinctCoordinate = null;\n\n      for (let i = 0; i <= original.length - 2; i++) {\n        const currentCoordinate = original[i];\n        const nextCoordinate = original[i + 1];\n        if (currentCoordinate.equals(nextCoordinate)) continue;\n        if (previousDistinctCoordinate !== null && this.isBetween(previousDistinctCoordinate, currentCoordinate, nextCoordinate)) continue;\n        cleanedRing.add(currentCoordinate);\n        previousDistinctCoordinate = currentCoordinate;\n      }\n\n      cleanedRing.add(original[original.length - 1]);\n      const cleanedRingCoordinates = new Array(cleanedRing.size()).fill(null);\n      return cleanedRing.toArray(cleanedRingCoordinates);\n    }\n\n    isBetween(c1, c2, c3) {\n      if (Orientation.index(c1, c2, c3) !== 0) return false;\n\n      if (c1.x !== c3.x) {\n        if (c1.x <= c2.x && c2.x <= c3.x) return true;\n        if (c3.x <= c2.x && c2.x <= c1.x) return true;\n      }\n\n      if (c1.y !== c3.y) {\n        if (c1.y <= c2.y && c2.y <= c3.y) return true;\n        if (c3.y <= c2.y && c2.y <= c1.y) return true;\n      }\n\n      return false;\n    }\n\n    reduce(inputPts) {\n      const polyPts = this.computeOctRing(inputPts);\n      if (polyPts === null) return inputPts;\n      const reducedSet = new TreeSet();\n\n      for (let i = 0; i < polyPts.length; i++) reducedSet.add(polyPts[i]);\n\n      for (let i = 0; i < inputPts.length; i++) if (!PointLocation.isInRing(inputPts[i], polyPts)) reducedSet.add(inputPts[i]);\n\n      const reducedPts = CoordinateArrays.toCoordinateArray(reducedSet);\n      if (reducedPts.length < 3) return this.padArray3(reducedPts);\n      return reducedPts;\n    }\n\n    getConvexHull() {\n      if (this._inputPts.length === 0) return this._geomFactory.createGeometryCollection();\n      if (this._inputPts.length === 1) return this._geomFactory.createPoint(this._inputPts[0]);\n      if (this._inputPts.length === 2) return this._geomFactory.createLineString(this._inputPts);\n      let reducedPts = this._inputPts;\n      if (this._inputPts.length > 50) reducedPts = this.reduce(this._inputPts);\n      const sortedPts = this.preSort(reducedPts);\n      const cHS = this.grahamScan(sortedPts);\n      const cH = this.toCoordinateArray(cHS);\n      return this.lineOrPolygon(cH);\n    }\n\n    padArray3(pts) {\n      const pad = new Array(3).fill(null);\n\n      for (let i = 0; i < pad.length; i++) if (i < pts.length) pad[i] = pts[i];else pad[i] = pts[0];\n\n      return pad;\n    }\n\n    computeOctPts(inputPts) {\n      const pts = new Array(8).fill(null);\n\n      for (let j = 0; j < pts.length; j++) pts[j] = inputPts[0];\n\n      for (let i = 1; i < inputPts.length; i++) {\n        if (inputPts[i].x < pts[0].x) pts[0] = inputPts[i];\n        if (inputPts[i].x - inputPts[i].y < pts[1].x - pts[1].y) pts[1] = inputPts[i];\n        if (inputPts[i].y > pts[2].y) pts[2] = inputPts[i];\n        if (inputPts[i].x + inputPts[i].y > pts[3].x + pts[3].y) pts[3] = inputPts[i];\n        if (inputPts[i].x > pts[4].x) pts[4] = inputPts[i];\n        if (inputPts[i].x - inputPts[i].y > pts[5].x - pts[5].y) pts[5] = inputPts[i];\n        if (inputPts[i].y < pts[6].y) pts[6] = inputPts[i];\n        if (inputPts[i].x + inputPts[i].y < pts[7].x + pts[7].y) pts[7] = inputPts[i];\n      }\n\n      return pts;\n    }\n\n    toCoordinateArray(stack) {\n      const coordinates = new Array(stack.size()).fill(null);\n\n      for (let i = 0; i < stack.size(); i++) {\n        const coordinate = stack.get(i);\n        coordinates[i] = coordinate;\n      }\n\n      return coordinates;\n    }\n\n    grahamScan(c) {\n      let p = null;\n      const ps = new Stack();\n      ps.push(c[0]);\n      ps.push(c[1]);\n      ps.push(c[2]);\n\n      for (let i = 3; i < c.length; i++) {\n        p = ps.pop();\n\n        while (!ps.empty() && Orientation.index(ps.peek(), p, c[i]) > 0) p = ps.pop();\n\n        ps.push(p);\n        ps.push(c[i]);\n      }\n\n      ps.push(c[0]);\n      return ps;\n    }\n\n  }\n\n  class RadialComparator {\n    constructor() {\n      RadialComparator.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._origin = null;\n      const origin = arguments[0];\n      this._origin = origin;\n    }\n\n    static polarCompare(o, p, q) {\n      const dxp = p.x - o.x;\n      const dyp = p.y - o.y;\n      const dxq = q.x - o.x;\n      const dyq = q.y - o.y;\n      const orient = Orientation.index(o, p, q);\n      if (orient === Orientation.COUNTERCLOCKWISE) return 1;\n      if (orient === Orientation.CLOCKWISE) return -1;\n      const op = dxp * dxp + dyp * dyp;\n      const oq = dxq * dxq + dyq * dyq;\n      if (op < oq) return -1;\n      if (op > oq) return 1;\n      return 0;\n    }\n\n    compare(o1, o2) {\n      const p1 = o1;\n      const p2 = o2;\n      return RadialComparator.polarCompare(this._origin, p1, p2);\n    }\n\n    get interfaces_() {\n      return [Comparator];\n    }\n\n  }\n\n  ConvexHull.RadialComparator = RadialComparator;\n\n  class InteriorPointArea {\n    constructor() {\n      InteriorPointArea.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._interiorPoint = null;\n      this._maxWidth = -1;\n      const g = arguments[0];\n      this.process(g);\n    }\n\n    static getInteriorPoint(geom) {\n      const intPt = new InteriorPointArea(geom);\n      return intPt.getInteriorPoint();\n    }\n\n    static avg(a, b) {\n      return (a + b) / 2.0;\n    }\n\n    getInteriorPoint() {\n      return this._interiorPoint;\n    }\n\n    process(geom) {\n      if (geom.isEmpty()) return null;\n\n      if (geom instanceof Polygon) {\n        this.processPolygon(geom);\n      } else if (geom instanceof GeometryCollection) {\n        const gc = geom;\n\n        for (let i = 0; i < gc.getNumGeometries(); i++) this.process(gc.getGeometryN(i));\n      }\n    }\n\n    processPolygon(polygon) {\n      const intPtPoly = new InteriorPointPolygon(polygon);\n      intPtPoly.process();\n      const width = intPtPoly.getWidth();\n\n      if (width > this._maxWidth) {\n        this._maxWidth = width;\n        this._interiorPoint = intPtPoly.getInteriorPoint();\n      }\n    }\n\n  }\n\n  class InteriorPointPolygon {\n    constructor() {\n      InteriorPointPolygon.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._polygon = null;\n      this._interiorPointY = null;\n      this._interiorSectionWidth = 0.0;\n      this._interiorPoint = null;\n      const polygon = arguments[0];\n      this._polygon = polygon;\n      this._interiorPointY = ScanLineYOrdinateFinder.getScanLineY(polygon);\n    }\n\n    static isEdgeCrossingCounted(p0, p1, scanY) {\n      const y0 = p0.getY();\n      const y1 = p1.getY();\n      if (y0 === y1) return false;\n      if (y0 === scanY && y1 < scanY) return false;\n      if (y1 === scanY && y0 < scanY) return false;\n      return true;\n    }\n\n    static intersectsHorizontalLine() {\n      if (arguments.length === 2) {\n        const env = arguments[0],\n              y = arguments[1];\n        if (y < env.getMinY()) return false;\n        if (y > env.getMaxY()) return false;\n        return true;\n      } else if (arguments.length === 3) {\n        const p0 = arguments[0],\n              p1 = arguments[1],\n              y = arguments[2];\n        if (p0.getY() > y && p1.getY() > y) return false;\n        if (p0.getY() < y && p1.getY() < y) return false;\n        return true;\n      }\n    }\n\n    static intersection(p0, p1, Y) {\n      const x0 = p0.getX();\n      const x1 = p1.getX();\n      if (x0 === x1) return x0;\n      const segDX = x1 - x0;\n      const segDY = p1.getY() - p0.getY();\n      const m = segDY / segDX;\n      const x = x0 + (Y - p0.getY()) / m;\n      return x;\n    }\n\n    findBestMidpoint(crossings) {\n      if (crossings.size() === 0) return null;\n      Assert.isTrue(0 === crossings.size() % 2, 'Interior Point robustness failure: odd number of scanline crossings');\n      crossings.sort(new DoubleComparator());\n\n      for (let i = 0; i < crossings.size(); i += 2) {\n        const x1 = crossings.get(i);\n        const x2 = crossings.get(i + 1);\n        const width = x2 - x1;\n\n        if (width > this._interiorSectionWidth) {\n          this._interiorSectionWidth = width;\n          const interiorPointX = InteriorPointArea.avg(x1, x2);\n          this._interiorPoint = new Coordinate(interiorPointX, this._interiorPointY);\n        }\n      }\n    }\n\n    process() {\n      if (this._polygon.isEmpty()) return null;\n      this._interiorPoint = new Coordinate(this._polygon.getCoordinate());\n      const crossings = new ArrayList();\n      this.scanRing(this._polygon.getExteriorRing(), crossings);\n\n      for (let i = 0; i < this._polygon.getNumInteriorRing(); i++) this.scanRing(this._polygon.getInteriorRingN(i), crossings);\n\n      this.findBestMidpoint(crossings);\n    }\n\n    scanRing(ring, crossings) {\n      if (!InteriorPointPolygon.intersectsHorizontalLine(ring.getEnvelopeInternal(), this._interiorPointY)) return null;\n      const seq = ring.getCoordinateSequence();\n\n      for (let i = 1; i < seq.size(); i++) {\n        const ptPrev = seq.getCoordinate(i - 1);\n        const pt = seq.getCoordinate(i);\n        this.addEdgeCrossing(ptPrev, pt, this._interiorPointY, crossings);\n      }\n    }\n\n    getWidth() {\n      return this._interiorSectionWidth;\n    }\n\n    getInteriorPoint() {\n      return this._interiorPoint;\n    }\n\n    addEdgeCrossing(p0, p1, scanY, crossings) {\n      if (!InteriorPointPolygon.intersectsHorizontalLine(p0, p1, scanY)) return null;\n      if (!InteriorPointPolygon.isEdgeCrossingCounted(p0, p1, scanY)) return null;\n      const xInt = InteriorPointPolygon.intersection(p0, p1, scanY);\n      crossings.add(xInt);\n    }\n\n  }\n\n  class DoubleComparator {\n    compare(v1, v2) {\n      return v1 < v2 ? -1 : v1 > v2 ? +1 : 0;\n    }\n\n    get interfaces_() {\n      return [Comparator];\n    }\n\n  }\n\n  InteriorPointPolygon.DoubleComparator = DoubleComparator;\n\n  class ScanLineYOrdinateFinder {\n    constructor() {\n      ScanLineYOrdinateFinder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._poly = null;\n      this._centreY = null;\n      this._hiY = Double.MAX_VALUE;\n      this._loY = -Double.MAX_VALUE;\n      const poly = arguments[0];\n      this._poly = poly;\n      this._hiY = poly.getEnvelopeInternal().getMaxY();\n      this._loY = poly.getEnvelopeInternal().getMinY();\n      this._centreY = InteriorPointArea.avg(this._loY, this._hiY);\n    }\n\n    static getScanLineY(poly) {\n      const finder = new ScanLineYOrdinateFinder(poly);\n      return finder.getScanLineY();\n    }\n\n    updateInterval(y) {\n      if (y <= this._centreY) {\n        if (y > this._loY) this._loY = y;\n      } else if (y > this._centreY) {\n        if (y < this._hiY) this._hiY = y;\n      }\n    }\n\n    getScanLineY() {\n      this.process(this._poly.getExteriorRing());\n\n      for (let i = 0; i < this._poly.getNumInteriorRing(); i++) this.process(this._poly.getInteriorRingN(i));\n\n      const scanLineY = InteriorPointArea.avg(this._hiY, this._loY);\n      return scanLineY;\n    }\n\n    process(line) {\n      const seq = line.getCoordinateSequence();\n\n      for (let i = 0; i < seq.size(); i++) {\n        const y = seq.getY(i);\n        this.updateInterval(y);\n      }\n    }\n\n  }\n\n  InteriorPointArea.InteriorPointPolygon = InteriorPointPolygon;\n  InteriorPointArea.ScanLineYOrdinateFinder = ScanLineYOrdinateFinder;\n\n  class InteriorPointLine {\n    constructor() {\n      InteriorPointLine.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._centroid = null;\n      this._minDistance = Double.MAX_VALUE;\n      this._interiorPoint = null;\n      const g = arguments[0];\n\n      if (g.isEmpty()) {\n        this._centroid = null;\n      } else {\n        this._centroid = Centroid.getCentroid(g);\n        g.getPrecisionModel().makePrecise(this._centroid);\n      }\n\n      this.addInterior(g);\n      if (this._interiorPoint === null) this.addEndpoints(g);\n    }\n\n    static getInteriorPoint(geom) {\n      const intPt = new InteriorPointLine(geom);\n      return intPt.getInteriorPoint();\n    }\n\n    addEndpoints() {\n      if (arguments[0] instanceof Geometry) {\n        const geom = arguments[0];\n\n        if (geom instanceof LineString) {\n          this.addEndpoints(geom.getCoordinates());\n        } else if (geom instanceof GeometryCollection) {\n          const gc = geom;\n\n          for (let i = 0; i < gc.getNumGeometries(); i++) this.addEndpoints(gc.getGeometryN(i));\n        }\n      } else if (arguments[0] instanceof Array) {\n        const pts = arguments[0];\n        this.add(pts[0]);\n        this.add(pts[pts.length - 1]);\n      }\n    }\n\n    getInteriorPoint() {\n      return this._interiorPoint;\n    }\n\n    addInterior() {\n      if (arguments[0] instanceof Geometry) {\n        const geom = arguments[0];\n\n        if (geom instanceof LineString) {\n          this.addInterior(geom.getCoordinates());\n        } else if (geom instanceof GeometryCollection) {\n          const gc = geom;\n\n          for (let i = 0; i < gc.getNumGeometries(); i++) this.addInterior(gc.getGeometryN(i));\n        }\n      } else if (arguments[0] instanceof Array) {\n        const pts = arguments[0];\n\n        for (let i = 1; i < pts.length - 1; i++) this.add(pts[i]);\n      }\n    }\n\n    add(point) {\n      const dist = point.distance(this._centroid);\n\n      if (dist < this._minDistance) {\n        this._interiorPoint = new Coordinate(point);\n        this._minDistance = dist;\n      }\n    }\n\n  }\n\n  class InteriorPointPoint {\n    constructor() {\n      InteriorPointPoint.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._centroid = null;\n      this._minDistance = Double.MAX_VALUE;\n      this._interiorPoint = null;\n      const g = arguments[0];\n      this._centroid = Centroid.getCentroid(g);\n      this.add(g);\n    }\n\n    static getInteriorPoint(geom) {\n      const intPt = new InteriorPointPoint(geom);\n      return intPt.getInteriorPoint();\n    }\n\n    getInteriorPoint() {\n      return this._interiorPoint;\n    }\n\n    add() {\n      if (arguments[0] instanceof Geometry) {\n        const geom = arguments[0];\n\n        if (geom instanceof Point) {\n          this.add(geom.getCoordinate());\n        } else if (geom instanceof GeometryCollection) {\n          const gc = geom;\n\n          for (let i = 0; i < gc.getNumGeometries(); i++) this.add(gc.getGeometryN(i));\n        }\n      } else if (arguments[0] instanceof Coordinate) {\n        const point = arguments[0];\n        const dist = point.distance(this._centroid);\n\n        if (dist < this._minDistance) {\n          this._interiorPoint = new Coordinate(point);\n          this._minDistance = dist;\n        }\n      }\n    }\n\n  }\n\n  class BoundaryNodeRule {\n    isInBoundary(boundaryCount) {}\n\n  }\n\n  class Mod2BoundaryNodeRule {\n    isInBoundary(boundaryCount) {\n      return boundaryCount % 2 === 1;\n    }\n\n    get interfaces_() {\n      return [BoundaryNodeRule];\n    }\n\n  }\n\n  class EndPointBoundaryNodeRule {\n    isInBoundary(boundaryCount) {\n      return boundaryCount > 0;\n    }\n\n    get interfaces_() {\n      return [BoundaryNodeRule];\n    }\n\n  }\n\n  class MultiValentEndPointBoundaryNodeRule {\n    isInBoundary(boundaryCount) {\n      return boundaryCount > 1;\n    }\n\n    get interfaces_() {\n      return [BoundaryNodeRule];\n    }\n\n  }\n\n  class MonoValentEndPointBoundaryNodeRule {\n    isInBoundary(boundaryCount) {\n      return boundaryCount === 1;\n    }\n\n    get interfaces_() {\n      return [BoundaryNodeRule];\n    }\n\n  }\n\n  BoundaryNodeRule.Mod2BoundaryNodeRule = Mod2BoundaryNodeRule;\n  BoundaryNodeRule.EndPointBoundaryNodeRule = EndPointBoundaryNodeRule;\n  BoundaryNodeRule.MultiValentEndPointBoundaryNodeRule = MultiValentEndPointBoundaryNodeRule;\n  BoundaryNodeRule.MonoValentEndPointBoundaryNodeRule = MonoValentEndPointBoundaryNodeRule;\n  BoundaryNodeRule.MOD2_BOUNDARY_RULE = new Mod2BoundaryNodeRule();\n  BoundaryNodeRule.ENDPOINT_BOUNDARY_RULE = new EndPointBoundaryNodeRule();\n  BoundaryNodeRule.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new MultiValentEndPointBoundaryNodeRule();\n  BoundaryNodeRule.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new MonoValentEndPointBoundaryNodeRule();\n  BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE = BoundaryNodeRule.MOD2_BOUNDARY_RULE;\n\n  class PointLocator {\n    constructor() {\n      PointLocator.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n      this._isIn = null;\n      this._numBoundaries = null;\n\n      if (arguments.length === 0) ; else if (arguments.length === 1) {\n        const boundaryRule = arguments[0];\n        if (boundaryRule === null) throw new IllegalArgumentException('Rule must be non-null');\n        this._boundaryRule = boundaryRule;\n      }\n    }\n\n    locateInPolygonRing(p, ring) {\n      if (!ring.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n      return PointLocation.locateInRing(p, ring.getCoordinates());\n    }\n\n    intersects(p, geom) {\n      return this.locate(p, geom) !== Location.EXTERIOR;\n    }\n\n    updateLocationInfo(loc) {\n      if (loc === Location.INTERIOR) this._isIn = true;\n      if (loc === Location.BOUNDARY) this._numBoundaries++;\n    }\n\n    computeLocation(p, geom) {\n      if (geom instanceof Point) this.updateLocationInfo(this.locateOnPoint(p, geom));\n\n      if (geom instanceof LineString) {\n        this.updateLocationInfo(this.locateOnLineString(p, geom));\n      } else if (geom instanceof Polygon) {\n        this.updateLocationInfo(this.locateInPolygon(p, geom));\n      } else if (geom instanceof MultiLineString) {\n        const ml = geom;\n\n        for (let i = 0; i < ml.getNumGeometries(); i++) {\n          const l = ml.getGeometryN(i);\n          this.updateLocationInfo(this.locateOnLineString(p, l));\n        }\n      } else if (geom instanceof MultiPolygon) {\n        const mpoly = geom;\n\n        for (let i = 0; i < mpoly.getNumGeometries(); i++) {\n          const poly = mpoly.getGeometryN(i);\n          this.updateLocationInfo(this.locateInPolygon(p, poly));\n        }\n      } else if (geom instanceof GeometryCollection) {\n        const geomi = new GeometryCollectionIterator(geom);\n\n        while (geomi.hasNext()) {\n          const g2 = geomi.next();\n          if (g2 !== geom) this.computeLocation(p, g2);\n        }\n      }\n    }\n\n    locateOnPoint(p, pt) {\n      const ptCoord = pt.getCoordinate();\n      if (ptCoord.equals2D(p)) return Location.INTERIOR;\n      return Location.EXTERIOR;\n    }\n\n    locateOnLineString(p, l) {\n      if (!l.getEnvelopeInternal().intersects(p)) return Location.EXTERIOR;\n      const seq = l.getCoordinateSequence();\n      if (!l.isClosed()) if (p.equals(seq.getCoordinate(0)) || p.equals(seq.getCoordinate(seq.size() - 1))) return Location.BOUNDARY;\n      if (PointLocation.isOnLine(p, seq)) return Location.INTERIOR;\n      return Location.EXTERIOR;\n    }\n\n    locateInPolygon(p, poly) {\n      if (poly.isEmpty()) return Location.EXTERIOR;\n      const shell = poly.getExteriorRing();\n      const shellLoc = this.locateInPolygonRing(p, shell);\n      if (shellLoc === Location.EXTERIOR) return Location.EXTERIOR;\n      if (shellLoc === Location.BOUNDARY) return Location.BOUNDARY;\n\n      for (let i = 0; i < poly.getNumInteriorRing(); i++) {\n        const hole = poly.getInteriorRingN(i);\n        const holeLoc = this.locateInPolygonRing(p, hole);\n        if (holeLoc === Location.INTERIOR) return Location.EXTERIOR;\n        if (holeLoc === Location.BOUNDARY) return Location.BOUNDARY;\n      }\n\n      return Location.INTERIOR;\n    }\n\n    locate(p, geom) {\n      if (geom.isEmpty()) return Location.EXTERIOR;\n      if (geom instanceof LineString) return this.locateOnLineString(p, geom);else if (geom instanceof Polygon) return this.locateInPolygon(p, geom);\n      this._isIn = false;\n      this._numBoundaries = 0;\n      this.computeLocation(p, geom);\n      if (this._boundaryRule.isInBoundary(this._numBoundaries)) return Location.BOUNDARY;\n      if (this._numBoundaries > 0 || this._isIn) return Location.INTERIOR;\n      return Location.EXTERIOR;\n    }\n\n  }\n\n  class MinimumBoundingCircle {\n    constructor() {\n      MinimumBoundingCircle.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._input = null;\n      this._extremalPts = null;\n      this._centre = null;\n      this._radius = 0.0;\n      const geom = arguments[0];\n      this._input = geom;\n    }\n\n    static farthestPoints(pts) {\n      const dist01 = pts[0].distance(pts[1]);\n      const dist12 = pts[1].distance(pts[2]);\n      const dist20 = pts[2].distance(pts[0]);\n      if (dist01 >= dist12 && dist01 >= dist20) return [pts[0], pts[1]];\n      if (dist12 >= dist01 && dist12 >= dist20) return [pts[1], pts[2]];\n      return [pts[2], pts[0]];\n    }\n\n    static pointWitMinAngleWithX(pts, P) {\n      let minSin = Double.MAX_VALUE;\n      let minAngPt = null;\n\n      for (let i = 0; i < pts.length; i++) {\n        const p = pts[i];\n        if (p === P) continue;\n        const dx = p.x - P.x;\n        let dy = p.y - P.y;\n        if (dy < 0) dy = -dy;\n        const len = Math.sqrt(dx * dx + dy * dy);\n        const sin = dy / len;\n\n        if (sin < minSin) {\n          minSin = sin;\n          minAngPt = p;\n        }\n      }\n\n      return minAngPt;\n    }\n\n    static lowestPoint(pts) {\n      let min = pts[0];\n\n      for (let i = 1; i < pts.length; i++) if (pts[i].y < min.y) min = pts[i];\n\n      return min;\n    }\n\n    static pointWithMinAngleWithSegment(pts, P, Q) {\n      let minAng = Double.MAX_VALUE;\n      let minAngPt = null;\n\n      for (let i = 0; i < pts.length; i++) {\n        const p = pts[i];\n        if (p === P) continue;\n        if (p === Q) continue;\n        const ang = Angle.angleBetween(P, p, Q);\n\n        if (ang < minAng) {\n          minAng = ang;\n          minAngPt = p;\n        }\n      }\n\n      return minAngPt;\n    }\n\n    getRadius() {\n      this.compute();\n      return this._radius;\n    }\n\n    getDiameter() {\n      this.compute();\n\n      switch (this._extremalPts.length) {\n        case 0:\n          return this._input.getFactory().createLineString();\n\n        case 1:\n          return this._input.getFactory().createPoint(this._centre);\n      }\n\n      const p0 = this._extremalPts[0];\n      const p1 = this._extremalPts[1];\n      return this._input.getFactory().createLineString([p0, p1]);\n    }\n\n    getExtremalPoints() {\n      this.compute();\n      return this._extremalPts;\n    }\n\n    computeCirclePoints() {\n      if (this._input.isEmpty()) {\n        this._extremalPts = new Array(0).fill(null);\n        return null;\n      }\n\n      if (this._input.getNumPoints() === 1) {\n        const pts = this._input.getCoordinates();\n\n        this._extremalPts = [new Coordinate(pts[0])];\n        return null;\n      }\n\n      const convexHull = this._input.convexHull();\n\n      const hullPts = convexHull.getCoordinates();\n      let pts = hullPts;\n\n      if (hullPts[0].equals2D(hullPts[hullPts.length - 1])) {\n        pts = new Array(hullPts.length - 1).fill(null);\n        CoordinateArrays.copyDeep(hullPts, 0, pts, 0, hullPts.length - 1);\n      }\n\n      if (pts.length <= 2) {\n        this._extremalPts = CoordinateArrays.copyDeep(pts);\n        return null;\n      }\n\n      let P = MinimumBoundingCircle.lowestPoint(pts);\n      let Q = MinimumBoundingCircle.pointWitMinAngleWithX(pts, P);\n\n      for (let i = 0; i < pts.length; i++) {\n        const R = MinimumBoundingCircle.pointWithMinAngleWithSegment(pts, P, Q);\n\n        if (Angle.isObtuse(P, R, Q)) {\n          this._extremalPts = [new Coordinate(P), new Coordinate(Q)];\n          return null;\n        }\n\n        if (Angle.isObtuse(R, P, Q)) {\n          P = R;\n          continue;\n        }\n\n        if (Angle.isObtuse(R, Q, P)) {\n          Q = R;\n          continue;\n        }\n\n        this._extremalPts = [new Coordinate(P), new Coordinate(Q), new Coordinate(R)];\n        return null;\n      }\n\n      Assert.shouldNeverReachHere('Logic failure in Minimum Bounding Circle algorithm!');\n    }\n\n    compute() {\n      if (this._extremalPts !== null) return null;\n      this.computeCirclePoints();\n      this.computeCentre();\n      if (this._centre !== null) this._radius = this._centre.distance(this._extremalPts[0]);\n    }\n\n    getCircle() {\n      this.compute();\n      if (this._centre === null) return this._input.getFactory().createPolygon();\n\n      const centrePoint = this._input.getFactory().createPoint(this._centre);\n\n      if (this._radius === 0.0) return centrePoint;\n      return centrePoint.buffer(this._radius);\n    }\n\n    getCentre() {\n      this.compute();\n      return this._centre;\n    }\n\n    getMaximumDiameter() {\n      this.compute();\n\n      switch (this._extremalPts.length) {\n        case 0:\n          return this._input.getFactory().createLineString();\n\n        case 1:\n          return this._input.getFactory().createPoint(this._centre);\n\n        case 2:\n          return this._input.getFactory().createLineString([this._extremalPts[0], this._extremalPts[1]]);\n\n        default:\n          const maxDiameter = MinimumBoundingCircle.farthestPoints(this._extremalPts);\n          return this._input.getFactory().createLineString(maxDiameter);\n      }\n    }\n\n    computeCentre() {\n      switch (this._extremalPts.length) {\n        case 0:\n          this._centre = null;\n          break;\n\n        case 1:\n          this._centre = this._extremalPts[0];\n          break;\n\n        case 2:\n          this._centre = new Coordinate((this._extremalPts[0].x + this._extremalPts[1].x) / 2.0, (this._extremalPts[0].y + this._extremalPts[1].y) / 2.0);\n          break;\n\n        case 3:\n          this._centre = Triangle.circumcentre(this._extremalPts[0], this._extremalPts[1], this._extremalPts[2]);\n          break;\n      }\n    }\n\n  }\n\n  class MinimumDiameter {\n    constructor() {\n      MinimumDiameter.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._inputGeom = null;\n      this._isConvex = null;\n      this._convexHullPts = null;\n      this._minBaseSeg = new LineSegment();\n      this._minWidthPt = null;\n      this._minPtIndex = null;\n      this._minWidth = 0.0;\n\n      if (arguments.length === 1) {\n        const inputGeom = arguments[0];\n        MinimumDiameter.constructor_.call(this, inputGeom, false);\n      } else if (arguments.length === 2) {\n        const inputGeom = arguments[0],\n              isConvex = arguments[1];\n        this._inputGeom = inputGeom;\n        this._isConvex = isConvex;\n      }\n    }\n\n    static nextIndex(pts, index) {\n      index++;\n      if (index >= pts.length) index = 0;\n      return index;\n    }\n\n    static computeC(a, b, p) {\n      return a * p.y - b * p.x;\n    }\n\n    static getMinimumDiameter(geom) {\n      return new MinimumDiameter(geom).getDiameter();\n    }\n\n    static getMinimumRectangle(geom) {\n      return new MinimumDiameter(geom).getMinimumRectangle();\n    }\n\n    static computeSegmentForLine(a, b, c) {\n      let p0 = null;\n      let p1 = null;\n\n      if (Math.abs(b) > Math.abs(a)) {\n        p0 = new Coordinate(0.0, c / b);\n        p1 = new Coordinate(1.0, c / b - a / b);\n      } else {\n        p0 = new Coordinate(c / a, 0.0);\n        p1 = new Coordinate(c / a - b / a, 1.0);\n      }\n\n      return new LineSegment(p0, p1);\n    }\n\n    getWidthCoordinate() {\n      this.computeMinimumDiameter();\n      return this._minWidthPt;\n    }\n\n    getSupportingSegment() {\n      this.computeMinimumDiameter();\n      return this._inputGeom.getFactory().createLineString([this._minBaseSeg.p0, this._minBaseSeg.p1]);\n    }\n\n    getDiameter() {\n      this.computeMinimumDiameter();\n      if (this._minWidthPt === null) return this._inputGeom.getFactory().createLineString();\n\n      const basePt = this._minBaseSeg.project(this._minWidthPt);\n\n      return this._inputGeom.getFactory().createLineString([basePt, this._minWidthPt]);\n    }\n\n    computeWidthConvex(convexGeom) {\n      if (convexGeom instanceof Polygon) this._convexHullPts = convexGeom.getExteriorRing().getCoordinates();else this._convexHullPts = convexGeom.getCoordinates();\n\n      if (this._convexHullPts.length === 0) {\n        this._minWidth = 0.0;\n        this._minWidthPt = null;\n        this._minBaseSeg = null;\n      } else if (this._convexHullPts.length === 1) {\n        this._minWidth = 0.0;\n        this._minWidthPt = this._convexHullPts[0];\n        this._minBaseSeg.p0 = this._convexHullPts[0];\n        this._minBaseSeg.p1 = this._convexHullPts[0];\n      } else if (this._convexHullPts.length === 2 || this._convexHullPts.length === 3) {\n        this._minWidth = 0.0;\n        this._minWidthPt = this._convexHullPts[0];\n        this._minBaseSeg.p0 = this._convexHullPts[0];\n        this._minBaseSeg.p1 = this._convexHullPts[1];\n      } else {\n        this.computeConvexRingMinDiameter(this._convexHullPts);\n      }\n    }\n\n    computeConvexRingMinDiameter(pts) {\n      this._minWidth = Double.MAX_VALUE;\n      let currMaxIndex = 1;\n      const seg = new LineSegment();\n\n      for (let i = 0; i < pts.length - 1; i++) {\n        seg.p0 = pts[i];\n        seg.p1 = pts[i + 1];\n        currMaxIndex = this.findMaxPerpDistance(pts, seg, currMaxIndex);\n      }\n    }\n\n    computeMinimumDiameter() {\n      if (this._minWidthPt !== null) return null;\n\n      if (this._isConvex) {\n        this.computeWidthConvex(this._inputGeom);\n      } else {\n        const convexGeom = new ConvexHull(this._inputGeom).getConvexHull();\n        this.computeWidthConvex(convexGeom);\n      }\n    }\n\n    getLength() {\n      this.computeMinimumDiameter();\n      return this._minWidth;\n    }\n\n    findMaxPerpDistance(pts, seg, startIndex) {\n      let maxPerpDistance = seg.distancePerpendicular(pts[startIndex]);\n      let nextPerpDistance = maxPerpDistance;\n      let maxIndex = startIndex;\n      let nextIndex = maxIndex;\n\n      while (nextPerpDistance >= maxPerpDistance) {\n        maxPerpDistance = nextPerpDistance;\n        maxIndex = nextIndex;\n        nextIndex = MinimumDiameter.nextIndex(pts, maxIndex);\n        nextPerpDistance = seg.distancePerpendicular(pts[nextIndex]);\n      }\n\n      if (maxPerpDistance < this._minWidth) {\n        this._minPtIndex = maxIndex;\n        this._minWidth = maxPerpDistance;\n        this._minWidthPt = pts[this._minPtIndex];\n        this._minBaseSeg = new LineSegment(seg);\n      }\n\n      return maxIndex;\n    }\n\n    getMinimumRectangle() {\n      this.computeMinimumDiameter();\n\n      if (this._minWidth === 0.0) {\n        if (this._minBaseSeg.p0.equals2D(this._minBaseSeg.p1)) return this._inputGeom.getFactory().createPoint(this._minBaseSeg.p0);\n        return this._minBaseSeg.toGeometry(this._inputGeom.getFactory());\n      }\n\n      const dx = this._minBaseSeg.p1.x - this._minBaseSeg.p0.x;\n      const dy = this._minBaseSeg.p1.y - this._minBaseSeg.p0.y;\n      let minPara = Double.MAX_VALUE;\n      let maxPara = -Double.MAX_VALUE;\n      let minPerp = Double.MAX_VALUE;\n      let maxPerp = -Double.MAX_VALUE;\n\n      for (let i = 0; i < this._convexHullPts.length; i++) {\n        const paraC = MinimumDiameter.computeC(dx, dy, this._convexHullPts[i]);\n        if (paraC > maxPara) maxPara = paraC;\n        if (paraC < minPara) minPara = paraC;\n        const perpC = MinimumDiameter.computeC(-dy, dx, this._convexHullPts[i]);\n        if (perpC > maxPerp) maxPerp = perpC;\n        if (perpC < minPerp) minPerp = perpC;\n      }\n\n      const maxPerpLine = MinimumDiameter.computeSegmentForLine(-dx, -dy, maxPerp);\n      const minPerpLine = MinimumDiameter.computeSegmentForLine(-dx, -dy, minPerp);\n      const maxParaLine = MinimumDiameter.computeSegmentForLine(-dy, dx, maxPara);\n      const minParaLine = MinimumDiameter.computeSegmentForLine(-dy, dx, minPara);\n      const p0 = maxParaLine.lineIntersection(maxPerpLine);\n      const p1 = minParaLine.lineIntersection(maxPerpLine);\n      const p2 = minParaLine.lineIntersection(minPerpLine);\n      const p3 = maxParaLine.lineIntersection(minPerpLine);\n\n      const shell = this._inputGeom.getFactory().createLinearRing([p0, p1, p2, p3, p0]);\n\n      return this._inputGeom.getFactory().createPolygon(shell);\n    }\n\n  }\n\n  var algorithm = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    distance: distance_module,\n    locate: locate,\n    match: match,\n    Angle: Angle,\n    Area: Area,\n    Centroid: Centroid,\n    ConvexHull: ConvexHull,\n    Distance: Distance,\n    InteriorPointArea: InteriorPointArea,\n    InteriorPointLine: InteriorPointLine,\n    InteriorPointPoint: InteriorPointPoint,\n    Length: Length,\n    Orientation: Orientation,\n    PointLocation: PointLocation,\n    PointLocator: PointLocator,\n    RobustLineIntersector: RobustLineIntersector,\n    MinimumBoundingCircle: MinimumBoundingCircle,\n    MinimumDiameter: MinimumDiameter\n  });\n\n  class Densifier {\n    constructor() {\n      Densifier.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._inputGeom = null;\n      this._distanceTolerance = null;\n      const inputGeom = arguments[0];\n      this._inputGeom = inputGeom;\n    }\n\n    static densifyPoints(pts, distanceTolerance, precModel) {\n      const seg = new LineSegment();\n      const coordList = new CoordinateList();\n\n      for (let i = 0; i < pts.length - 1; i++) {\n        seg.p0 = pts[i];\n        seg.p1 = pts[i + 1];\n        coordList.add(seg.p0, false);\n        const len = seg.getLength();\n        const densifiedSegCount = Math.trunc(len / distanceTolerance) + 1;\n\n        if (densifiedSegCount > 1) {\n          const densifiedSegLen = len / densifiedSegCount;\n\n          for (let j = 1; j < densifiedSegCount; j++) {\n            const segFract = j * densifiedSegLen / len;\n            const p = seg.pointAlong(segFract);\n            precModel.makePrecise(p);\n            coordList.add(p, false);\n          }\n        }\n      }\n\n      coordList.add(pts[pts.length - 1], false);\n      return coordList.toCoordinateArray();\n    }\n\n    static densify(geom, distanceTolerance) {\n      const densifier = new Densifier(geom);\n      densifier.setDistanceTolerance(distanceTolerance);\n      return densifier.getResultGeometry();\n    }\n\n    getResultGeometry() {\n      return new DensifyTransformer(this._distanceTolerance).transform(this._inputGeom);\n    }\n\n    setDistanceTolerance(distanceTolerance) {\n      if (distanceTolerance <= 0.0) throw new IllegalArgumentException('Tolerance must be positive');\n      this._distanceTolerance = distanceTolerance;\n    }\n\n  }\n\n  class DensifyTransformer extends GeometryTransformer {\n    constructor() {\n      super();\n      DensifyTransformer.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.distanceTolerance = null;\n      const distanceTolerance = arguments[0];\n      this.distanceTolerance = distanceTolerance;\n    }\n\n    transformMultiPolygon(geom, parent) {\n      const roughGeom = super.transformMultiPolygon.call(this, geom, parent);\n      return this.createValidArea(roughGeom);\n    }\n\n    transformPolygon(geom, parent) {\n      const roughGeom = super.transformPolygon.call(this, geom, parent);\n      if (parent instanceof MultiPolygon) return roughGeom;\n      return this.createValidArea(roughGeom);\n    }\n\n    transformCoordinates(coords, parent) {\n      const inputPts = coords.toCoordinateArray();\n      let newPts = Densifier.densifyPoints(inputPts, this.distanceTolerance, parent.getPrecisionModel());\n      if (parent instanceof LineString && newPts.length === 1) newPts = new Array(0).fill(null);\n      return this._factory.getCoordinateSequenceFactory().create(newPts);\n    }\n\n    createValidArea(roughAreaGeom) {\n      return roughAreaGeom.buffer(0.0);\n    }\n\n  }\n\n  Densifier.DensifyTransformer = DensifyTransformer;\n\n  var densify = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Densifier: Densifier\n  });\n\n  class Quadrant {\n    static isNorthern(quad) {\n      return quad === Quadrant.NE || quad === Quadrant.NW;\n    }\n\n    static isOpposite(quad1, quad2) {\n      if (quad1 === quad2) return false;\n      const diff = (quad1 - quad2 + 4) % 4;\n      if (diff === 2) return true;\n      return false;\n    }\n\n    static commonHalfPlane(quad1, quad2) {\n      if (quad1 === quad2) return quad1;\n      const diff = (quad1 - quad2 + 4) % 4;\n      if (diff === 2) return -1;\n      const min = quad1 < quad2 ? quad1 : quad2;\n      const max = quad1 > quad2 ? quad1 : quad2;\n      if (min === 0 && max === 3) return 3;\n      return min;\n    }\n\n    static isInHalfPlane(quad, halfPlane) {\n      if (halfPlane === Quadrant.SE) return quad === Quadrant.SE || quad === Quadrant.SW;\n      return quad === halfPlane || quad === halfPlane + 1;\n    }\n\n    static quadrant() {\n      if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n        const dx = arguments[0],\n              dy = arguments[1];\n        if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException('Cannot compute the quadrant for point ( ' + dx + ', ' + dy + ' )');\n        if (dx >= 0.0) {\n          if (dy >= 0.0) return Quadrant.NE;else return Quadrant.SE;\n        } else if (dy >= 0.0) return Quadrant.NW;else return Quadrant.SW;\n      } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n        const p0 = arguments[0],\n              p1 = arguments[1];\n        if (p1.x === p0.x && p1.y === p0.y) throw new IllegalArgumentException('Cannot compute the quadrant for two identical points ' + p0);\n        if (p1.x >= p0.x) {\n          if (p1.y >= p0.y) return Quadrant.NE;else return Quadrant.SE;\n        } else if (p1.y >= p0.y) return Quadrant.NW;else return Quadrant.SW;\n      }\n    }\n\n  }\n  Quadrant.NE = 0;\n  Quadrant.NW = 1;\n  Quadrant.SW = 2;\n  Quadrant.SE = 3;\n\n  class HalfEdge {\n    constructor() {\n      HalfEdge.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._orig = null;\n      this._sym = null;\n      this._next = null;\n      const orig = arguments[0];\n      this._orig = orig;\n    }\n\n    static create(p0, p1) {\n      const e0 = new HalfEdge(p0);\n      const e1 = new HalfEdge(p1);\n      e0.link(e1);\n      return e0;\n    }\n\n    find(dest) {\n      let oNext = this;\n\n      do {\n        if (oNext === null) return null;\n        if (oNext.dest().equals2D(dest)) return oNext;\n        oNext = oNext.oNext();\n      } while (oNext !== this);\n\n      return null;\n    }\n\n    dest() {\n      return this._sym._orig;\n    }\n\n    isEdgesSorted() {\n      const lowest = this.findLowest();\n      let e = lowest;\n\n      do {\n        const eNext = e.oNext();\n        if (eNext === lowest) break;\n        const isSorted = eNext.compareTo(e) > 0;\n        if (!isSorted) return false;\n        e = eNext;\n      } while (e !== lowest);\n\n      return true;\n    }\n\n    oNext() {\n      return this._sym._next;\n    }\n\n    directionY() {\n      return this.directionPt().getY() - this._orig.getY();\n    }\n\n    insert(eAdd) {\n      if (this.oNext() === this) {\n        this.insertAfter(eAdd);\n        return null;\n      }\n\n      const ePrev = this.insertionEdge(eAdd);\n      ePrev.insertAfter(eAdd);\n    }\n\n    insertAfter(e) {\n      Assert.equals(this._orig, e.orig());\n      const save = this.oNext();\n\n      this._sym.setNext(e);\n\n      e.sym().setNext(save);\n    }\n\n    degree() {\n      let degree = 0;\n      let e = this;\n\n      do {\n        degree++;\n        e = e.oNext();\n      } while (e !== this);\n\n      return degree;\n    }\n\n    equals() {\n      if (arguments.length === 2 && arguments[1] instanceof Coordinate && arguments[0] instanceof Coordinate) {\n        const p0 = arguments[0],\n              p1 = arguments[1];\n        return this._orig.equals2D(p0) && this._sym._orig.equals(p1);\n      }\n    }\n\n    findLowest() {\n      let lowest = this;\n      let e = this.oNext();\n\n      do {\n        if (e.compareTo(lowest) < 0) lowest = e;\n        e = e.oNext();\n      } while (e !== this);\n\n      return lowest;\n    }\n\n    directionPt() {\n      return this.dest();\n    }\n\n    sym() {\n      return this._sym;\n    }\n\n    prev() {\n      return this._sym.next()._sym;\n    }\n\n    compareAngularDirection(e) {\n      const dx = this.directionX();\n      const dy = this.directionY();\n      const dx2 = e.directionX();\n      const dy2 = e.directionY();\n      if (dx === dx2 && dy === dy2) return 0;\n      const quadrant = Quadrant.quadrant(dx, dy);\n      const quadrant2 = Quadrant.quadrant(dx2, dy2);\n      if (quadrant > quadrant2) return 1;\n      if (quadrant < quadrant2) return -1;\n      const dir1 = this.directionPt();\n      const dir2 = e.directionPt();\n      return Orientation.index(e._orig, dir2, dir1);\n    }\n\n    prevNode() {\n      let e = this;\n\n      while (e.degree() === 2) {\n        e = e.prev();\n        if (e === this) return null;\n      }\n\n      return e;\n    }\n\n    directionX() {\n      return this.directionPt().getX() - this._orig.getX();\n    }\n\n    insertionEdge(eAdd) {\n      let ePrev = this;\n\n      do {\n        const eNext = ePrev.oNext();\n        if (eNext.compareTo(ePrev) > 0 && eAdd.compareTo(ePrev) >= 0 && eAdd.compareTo(eNext) <= 0) return ePrev;\n        if (eNext.compareTo(ePrev) <= 0 && (eAdd.compareTo(eNext) <= 0 || eAdd.compareTo(ePrev) >= 0)) return ePrev;\n        ePrev = eNext;\n      } while (ePrev !== this);\n\n      Assert.shouldNeverReachHere();\n      return null;\n    }\n\n    compareTo(obj) {\n      const e = obj;\n      const comp = this.compareAngularDirection(e);\n      return comp;\n    }\n\n    toStringNode() {\n      const orig = this.orig();\n      const dest = this.dest();\n      const sb = new StringBuilder();\n      sb.append('Node( ' + WKTWriter.format(orig) + ' )' + '\\n');\n      let e = this;\n\n      do {\n        sb.append('  -> ' + e);\n        sb.append('\\n');\n        e = e.oNext();\n      } while (e !== this);\n\n      return sb.toString();\n    }\n\n    link(sym) {\n      this.setSym(sym);\n      sym.setSym(this);\n      this.setNext(sym);\n      sym.setNext(this);\n    }\n\n    next() {\n      return this._next;\n    }\n\n    setSym(e) {\n      this._sym = e;\n    }\n\n    orig() {\n      return this._orig;\n    }\n\n    toString() {\n      return 'HE(' + this._orig.x + ' ' + this._orig.y + ', ' + this._sym._orig.x + ' ' + this._sym._orig.y + ')';\n    }\n\n    toStringNodeEdge() {\n      return '  -> (' + WKTWriter.format(this.dest());\n    }\n\n    setNext(e) {\n      this._next = e;\n    }\n\n  }\n\n  class MarkHalfEdge extends HalfEdge {\n    constructor() {\n      super();\n      MarkHalfEdge.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._isMarked = false;\n      const orig = arguments[0];\n      HalfEdge.constructor_.call(this, orig);\n    }\n\n    static setMarkBoth(e, isMarked) {\n      e.setMark(isMarked);\n      e.sym().setMark(isMarked);\n    }\n\n    static isMarked(e) {\n      return e.isMarked();\n    }\n\n    static setMark(e, isMarked) {\n      e.setMark(isMarked);\n    }\n\n    static markBoth(e) {\n      e.mark();\n      e.sym().mark();\n    }\n\n    static mark(e) {\n      e.mark();\n    }\n\n    mark() {\n      this._isMarked = true;\n    }\n\n    setMark(isMarked) {\n      this._isMarked = isMarked;\n    }\n\n    isMarked() {\n      return this._isMarked;\n    }\n\n  }\n\n  class EdgeGraph {\n    constructor() {\n      EdgeGraph.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._vertexMap = new HashMap();\n    }\n\n    static isValidEdge(orig, dest) {\n      const cmp = dest.compareTo(orig);\n      return cmp !== 0;\n    }\n\n    insert(orig, dest, eAdj) {\n      const e = this.create(orig, dest);\n      if (eAdj !== null) eAdj.insert(e);else this._vertexMap.put(orig, e);\n\n      const eAdjDest = this._vertexMap.get(dest);\n\n      if (eAdjDest !== null) eAdjDest.insert(e.sym());else this._vertexMap.put(dest, e.sym());\n      return e;\n    }\n\n    create(p0, p1) {\n      const e0 = this.createEdge(p0);\n      const e1 = this.createEdge(p1);\n      e0.link(e1);\n      return e0;\n    }\n\n    createEdge(orig) {\n      return new HalfEdge(orig);\n    }\n\n    addEdge(orig, dest) {\n      if (!EdgeGraph.isValidEdge(orig, dest)) return null;\n\n      const eAdj = this._vertexMap.get(orig);\n\n      let eSame = null;\n      if (eAdj !== null) eSame = eAdj.find(dest);\n      if (eSame !== null) return eSame;\n      const e = this.insert(orig, dest, eAdj);\n      return e;\n    }\n\n    getVertexEdges() {\n      return this._vertexMap.values();\n    }\n\n    findEdge(orig, dest) {\n      const e = this._vertexMap.get(orig);\n\n      if (e === null) return null;\n      return e.find(dest);\n    }\n\n  }\n\n  class DissolveHalfEdge extends MarkHalfEdge {\n    constructor() {\n      super();\n      DissolveHalfEdge.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._isStart = false;\n      const orig = arguments[0];\n      MarkHalfEdge.constructor_.call(this, orig);\n    }\n\n    setStart() {\n      this._isStart = true;\n    }\n\n    isStart() {\n      return this._isStart;\n    }\n\n  }\n\n  class DissolveEdgeGraph extends EdgeGraph {\n    constructor() {\n      super();\n    }\n\n    createEdge(p0) {\n      return new DissolveHalfEdge(p0);\n    }\n\n  }\n\n  class LineDissolver {\n    constructor() {\n      LineDissolver.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._result = null;\n      this._factory = null;\n      this._graph = null;\n      this._lines = new ArrayList();\n      this._nodeEdgeStack = new Stack();\n      this._ringStartEdge = null;\n      this._graph = new DissolveEdgeGraph();\n    }\n\n    static dissolve(g) {\n      const d = new LineDissolver();\n      d.add(g);\n      return d.getResult();\n    }\n\n    addLine(line) {\n      this._lines.add(this._factory.createLineString(line.toCoordinateArray()));\n    }\n\n    updateRingStartEdge(e) {\n      if (!e.isStart()) {\n        e = e.sym();\n        if (!e.isStart()) return null;\n      }\n\n      if (this._ringStartEdge === null) {\n        this._ringStartEdge = e;\n        return null;\n      }\n\n      if (e.orig().compareTo(this._ringStartEdge.orig()) < 0) this._ringStartEdge = e;\n    }\n\n    getResult() {\n      if (this._result === null) this.computeResult();\n      return this._result;\n    }\n\n    process(e) {\n      let eNode = e.prevNode();\n      if (eNode === null) eNode = e;\n      this.stackEdges(eNode);\n      this.buildLines();\n    }\n\n    buildRing(eStartRing) {\n      const line = new CoordinateList();\n      let e = eStartRing;\n      line.add(e.orig().copy(), false);\n\n      while (e.sym().degree() === 2) {\n        const eNext = e.next();\n        if (eNext === eStartRing) break;\n        line.add(eNext.orig().copy(), false);\n        e = eNext;\n      }\n\n      line.add(e.dest().copy(), false);\n      this.addLine(line);\n    }\n\n    buildLine(eStart) {\n      const line = new CoordinateList();\n      let e = eStart;\n      this._ringStartEdge = null;\n      MarkHalfEdge.markBoth(e);\n      line.add(e.orig().copy(), false);\n\n      while (e.sym().degree() === 2) {\n        this.updateRingStartEdge(e);\n        const eNext = e.next();\n\n        if (eNext === eStart) {\n          this.buildRing(this._ringStartEdge);\n          return null;\n        }\n\n        line.add(eNext.orig().copy(), false);\n        e = eNext;\n        MarkHalfEdge.markBoth(e);\n      }\n\n      line.add(e.dest().clone(), false);\n      this.stackEdges(e.sym());\n      this.addLine(line);\n    }\n\n    stackEdges(node) {\n      let e = node;\n\n      do {\n        if (!MarkHalfEdge.isMarked(e)) this._nodeEdgeStack.add(e);\n        e = e.oNext();\n      } while (e !== node);\n    }\n\n    computeResult() {\n      const edges = this._graph.getVertexEdges();\n\n      for (let i = edges.iterator(); i.hasNext();) {\n        const e = i.next();\n        if (MarkHalfEdge.isMarked(e)) continue;\n        this.process(e);\n      }\n\n      this._result = this._factory.buildGeometry(this._lines);\n    }\n\n    buildLines() {\n      while (!this._nodeEdgeStack.empty()) {\n        const e = this._nodeEdgeStack.pop();\n\n        if (MarkHalfEdge.isMarked(e)) continue;\n        this.buildLine(e);\n      }\n    }\n\n    add() {\n      if (arguments[0] instanceof Geometry) {\n        const geometry = arguments[0];\n        geometry.apply(new class {\n          get interfaces_() {\n            return [GeometryComponentFilter];\n          }\n\n          filter(component) {\n            if (component instanceof LineString) this.add(component);\n          }\n\n        }());\n      } else if (hasInterface(arguments[0], Collection)) {\n        const geometries = arguments[0];\n\n        for (let i = geometries.iterator(); i.hasNext();) {\n          const geometry = i.next();\n          this.add(geometry);\n        }\n      } else if (arguments[0] instanceof LineString) {\n        const lineString = arguments[0];\n        if (this._factory === null) this._factory = lineString.getFactory();\n        const seq = lineString.getCoordinateSequence();\n        let doneStart = false;\n\n        for (let i = 1; i < seq.size(); i++) {\n          const e = this._graph.addEdge(seq.getCoordinate(i - 1), seq.getCoordinate(i));\n\n          if (e === null) continue;\n\n          if (!doneStart) {\n            e.setStart();\n            doneStart = true;\n          }\n        }\n      }\n    }\n\n  }\n\n  var dissolve = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    LineDissolver: LineDissolver\n  });\n\n  class Position {\n    static opposite(position) {\n      if (position === Position.LEFT) return Position.RIGHT;\n      if (position === Position.RIGHT) return Position.LEFT;\n      return position;\n    }\n\n  }\n  Position.ON = 0;\n  Position.LEFT = 1;\n  Position.RIGHT = 2;\n\n  class MonotoneChain {\n    constructor() {\n      MonotoneChain.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.mce = null;\n      this.chainIndex = null;\n      const mce = arguments[0],\n            chainIndex = arguments[1];\n      this.mce = mce;\n      this.chainIndex = chainIndex;\n    }\n\n    computeIntersections(mc, si) {\n      this.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);\n    }\n\n  }\n\n  class SweepLineEvent {\n    constructor() {\n      SweepLineEvent.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._label = null;\n      this._xValue = null;\n      this._eventType = null;\n      this._insertEvent = null;\n      this._deleteEventIndex = null;\n      this._obj = null;\n\n      if (arguments.length === 2) {\n        const x = arguments[0],\n              insertEvent = arguments[1];\n        this._eventType = SweepLineEvent.DELETE;\n        this._xValue = x;\n        this._insertEvent = insertEvent;\n      } else if (arguments.length === 3) {\n        const label = arguments[0],\n              x = arguments[1],\n              obj = arguments[2];\n        this._eventType = SweepLineEvent.INSERT;\n        this._label = label;\n        this._xValue = x;\n        this._obj = obj;\n      }\n    }\n\n    isDelete() {\n      return this._eventType === SweepLineEvent.DELETE;\n    }\n\n    setDeleteEventIndex(deleteEventIndex) {\n      this._deleteEventIndex = deleteEventIndex;\n    }\n\n    getObject() {\n      return this._obj;\n    }\n\n    compareTo(o) {\n      const pe = o;\n      if (this._xValue < pe._xValue) return -1;\n      if (this._xValue > pe._xValue) return 1;\n      if (this._eventType < pe._eventType) return -1;\n      if (this._eventType > pe._eventType) return 1;\n      return 0;\n    }\n\n    getInsertEvent() {\n      return this._insertEvent;\n    }\n\n    isInsert() {\n      return this._eventType === SweepLineEvent.INSERT;\n    }\n\n    isSameLabel(ev) {\n      if (this._label === null) return false;\n      return this._label === ev._label;\n    }\n\n    getDeleteEventIndex() {\n      return this._deleteEventIndex;\n    }\n\n    get interfaces_() {\n      return [Comparable];\n    }\n\n  }\n  SweepLineEvent.INSERT = 1;\n  SweepLineEvent.DELETE = 2;\n\n  class EdgeSetIntersector {}\n\n  class SegmentIntersector {\n    constructor() {\n      SegmentIntersector.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._hasIntersection = false;\n      this._hasProper = false;\n      this._hasProperInterior = false;\n      this._properIntersectionPoint = null;\n      this._li = null;\n      this._includeProper = null;\n      this._recordIsolated = null;\n      this._isSelfIntersection = null;\n      this._numIntersections = 0;\n      this.numTests = 0;\n      this._bdyNodes = null;\n      this._isDone = false;\n      this._isDoneWhenProperInt = false;\n      const li = arguments[0],\n            includeProper = arguments[1],\n            recordIsolated = arguments[2];\n      this._li = li;\n      this._includeProper = includeProper;\n      this._recordIsolated = recordIsolated;\n    }\n\n    static isAdjacentSegments(i1, i2) {\n      return Math.abs(i1 - i2) === 1;\n    }\n\n    isTrivialIntersection(e0, segIndex0, e1, segIndex1) {\n      if (e0 === e1) if (this._li.getIntersectionNum() === 1) {\n        if (SegmentIntersector.isAdjacentSegments(segIndex0, segIndex1)) return true;\n\n        if (e0.isClosed()) {\n          const maxSegIndex = e0.getNumPoints() - 1;\n          if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) return true;\n        }\n      }\n      return false;\n    }\n\n    getProperIntersectionPoint() {\n      return this._properIntersectionPoint;\n    }\n\n    setIsDoneIfProperInt(isDoneWhenProperInt) {\n      this._isDoneWhenProperInt = isDoneWhenProperInt;\n    }\n\n    hasProperInteriorIntersection() {\n      return this._hasProperInterior;\n    }\n\n    isBoundaryPointInternal(li, bdyNodes) {\n      for (let i = bdyNodes.iterator(); i.hasNext();) {\n        const node = i.next();\n        const pt = node.getCoordinate();\n        if (li.isIntersection(pt)) return true;\n      }\n\n      return false;\n    }\n\n    hasProperIntersection() {\n      return this._hasProper;\n    }\n\n    hasIntersection() {\n      return this._hasIntersection;\n    }\n\n    isDone() {\n      return this._isDone;\n    }\n\n    isBoundaryPoint(li, bdyNodes) {\n      if (bdyNodes === null) return false;\n      if (this.isBoundaryPointInternal(li, bdyNodes[0])) return true;\n      if (this.isBoundaryPointInternal(li, bdyNodes[1])) return true;\n      return false;\n    }\n\n    setBoundaryNodes(bdyNodes0, bdyNodes1) {\n      this._bdyNodes = new Array(2).fill(null);\n      this._bdyNodes[0] = bdyNodes0;\n      this._bdyNodes[1] = bdyNodes1;\n    }\n\n    addIntersections(e0, segIndex0, e1, segIndex1) {\n      if (e0 === e1 && segIndex0 === segIndex1) return null;\n      this.numTests++;\n      const p00 = e0.getCoordinates()[segIndex0];\n      const p01 = e0.getCoordinates()[segIndex0 + 1];\n      const p10 = e1.getCoordinates()[segIndex1];\n      const p11 = e1.getCoordinates()[segIndex1 + 1];\n\n      this._li.computeIntersection(p00, p01, p10, p11);\n\n      if (this._li.hasIntersection()) {\n        if (this._recordIsolated) {\n          e0.setIsolated(false);\n          e1.setIsolated(false);\n        }\n\n        this._numIntersections++;\n\n        if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n          this._hasIntersection = true;\n\n          if (this._includeProper || !this._li.isProper()) {\n            e0.addIntersections(this._li, segIndex0, 0);\n            e1.addIntersections(this._li, segIndex1, 1);\n          }\n\n          if (this._li.isProper()) {\n            this._properIntersectionPoint = this._li.getIntersection(0).copy();\n            this._hasProper = true;\n            if (this._isDoneWhenProperInt) this._isDone = true;\n            if (!this.isBoundaryPoint(this._li, this._bdyNodes)) this._hasProperInterior = true;\n          }\n        }\n      }\n    }\n\n  }\n\n  class SimpleMCSweepLineIntersector extends EdgeSetIntersector {\n    constructor() {\n      super();\n      SimpleMCSweepLineIntersector.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.events = new ArrayList();\n      this.nOverlaps = null;\n    }\n\n    prepareEvents() {\n      Collections.sort(this.events);\n\n      for (let i = 0; i < this.events.size(); i++) {\n        const ev = this.events.get(i);\n        if (ev.isDelete()) ev.getInsertEvent().setDeleteEventIndex(i);\n      }\n    }\n\n    computeIntersections() {\n      if (arguments.length === 1) {\n        const si = arguments[0];\n        this.nOverlaps = 0;\n        this.prepareEvents();\n\n        for (let i = 0; i < this.events.size(); i++) {\n          const ev = this.events.get(i);\n          if (ev.isInsert()) this.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);\n          if (si.isDone()) break;\n        }\n      } else if (arguments.length === 3) {\n        if (arguments[2] instanceof SegmentIntersector && hasInterface(arguments[0], List) && hasInterface(arguments[1], List)) {\n          const edges0 = arguments[0],\n                edges1 = arguments[1],\n                si = arguments[2];\n          this.addEdges(edges0, edges0);\n          this.addEdges(edges1, edges1);\n          this.computeIntersections(si);\n        } else if (typeof arguments[2] === 'boolean' && hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector) {\n          const edges = arguments[0],\n                si = arguments[1],\n                testAllSegments = arguments[2];\n          if (testAllSegments) this.addEdges(edges, null);else this.addEdges(edges);\n          this.computeIntersections(si);\n        }\n      }\n    }\n\n    addEdge(edge, edgeSet) {\n      const mce = edge.getMonotoneChainEdge();\n      const startIndex = mce.getStartIndexes();\n\n      for (let i = 0; i < startIndex.length - 1; i++) {\n        const mc = new MonotoneChain(mce, i);\n        const insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);\n        this.events.add(insertEvent);\n        this.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));\n      }\n    }\n\n    processOverlaps(start, end, ev0, si) {\n      const mc0 = ev0.getObject();\n\n      for (let i = start; i < end; i++) {\n        const ev1 = this.events.get(i);\n\n        if (ev1.isInsert()) {\n          const mc1 = ev1.getObject();\n\n          if (!ev0.isSameLabel(ev1)) {\n            mc0.computeIntersections(mc1, si);\n            this.nOverlaps++;\n          }\n        }\n      }\n    }\n\n    addEdges() {\n      if (arguments.length === 1) {\n        const edges = arguments[0];\n\n        for (let i = edges.iterator(); i.hasNext();) {\n          const edge = i.next();\n          this.addEdge(edge, edge);\n        }\n      } else if (arguments.length === 2) {\n        const edges = arguments[0],\n              edgeSet = arguments[1];\n\n        for (let i = edges.iterator(); i.hasNext();) {\n          const edge = i.next();\n          this.addEdge(edge, edgeSet);\n        }\n      }\n    }\n\n  }\n\n  class TopologyLocation {\n    constructor() {\n      TopologyLocation.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.location = null;\n\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof Array) {\n          const location = arguments[0];\n          this.init(location.length);\n        } else if (Number.isInteger(arguments[0])) {\n          const on = arguments[0];\n          this.init(1);\n          this.location[Position.ON] = on;\n        } else if (arguments[0] instanceof TopologyLocation) {\n          const gl = arguments[0];\n          this.init(gl.location.length);\n          if (gl !== null) for (let i = 0; i < this.location.length; i++) this.location[i] = gl.location[i];\n        }\n      } else if (arguments.length === 3) {\n        const on = arguments[0],\n              left = arguments[1],\n              right = arguments[2];\n        this.init(3);\n        this.location[Position.ON] = on;\n        this.location[Position.LEFT] = left;\n        this.location[Position.RIGHT] = right;\n      }\n    }\n\n    setAllLocations(locValue) {\n      for (let i = 0; i < this.location.length; i++) this.location[i] = locValue;\n    }\n\n    isNull() {\n      for (let i = 0; i < this.location.length; i++) if (this.location[i] !== Location.NONE) return false;\n\n      return true;\n    }\n\n    setAllLocationsIfNull(locValue) {\n      for (let i = 0; i < this.location.length; i++) if (this.location[i] === Location.NONE) this.location[i] = locValue;\n    }\n\n    isLine() {\n      return this.location.length === 1;\n    }\n\n    merge(gl) {\n      if (gl.location.length > this.location.length) {\n        const newLoc = new Array(3).fill(null);\n        newLoc[Position.ON] = this.location[Position.ON];\n        newLoc[Position.LEFT] = Location.NONE;\n        newLoc[Position.RIGHT] = Location.NONE;\n        this.location = newLoc;\n      }\n\n      for (let i = 0; i < this.location.length; i++) if (this.location[i] === Location.NONE && i < gl.location.length) this.location[i] = gl.location[i];\n    }\n\n    getLocations() {\n      return this.location;\n    }\n\n    flip() {\n      if (this.location.length <= 1) return null;\n      const temp = this.location[Position.LEFT];\n      this.location[Position.LEFT] = this.location[Position.RIGHT];\n      this.location[Position.RIGHT] = temp;\n    }\n\n    toString() {\n      const buf = new StringBuffer();\n      if (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.LEFT]));\n      buf.append(Location.toLocationSymbol(this.location[Position.ON]));\n      if (this.location.length > 1) buf.append(Location.toLocationSymbol(this.location[Position.RIGHT]));\n      return buf.toString();\n    }\n\n    setLocations(on, left, right) {\n      this.location[Position.ON] = on;\n      this.location[Position.LEFT] = left;\n      this.location[Position.RIGHT] = right;\n    }\n\n    get(posIndex) {\n      if (posIndex < this.location.length) return this.location[posIndex];\n      return Location.NONE;\n    }\n\n    isArea() {\n      return this.location.length > 1;\n    }\n\n    isAnyNull() {\n      for (let i = 0; i < this.location.length; i++) if (this.location[i] === Location.NONE) return true;\n\n      return false;\n    }\n\n    setLocation() {\n      if (arguments.length === 1) {\n        const locValue = arguments[0];\n        this.setLocation(Position.ON, locValue);\n      } else if (arguments.length === 2) {\n        const locIndex = arguments[0],\n              locValue = arguments[1];\n        this.location[locIndex] = locValue;\n      }\n    }\n\n    init(size) {\n      this.location = new Array(size).fill(null);\n      this.setAllLocations(Location.NONE);\n    }\n\n    isEqualOnSide(le, locIndex) {\n      return this.location[locIndex] === le.location[locIndex];\n    }\n\n    allPositionsEqual(loc) {\n      for (let i = 0; i < this.location.length; i++) if (this.location[i] !== loc) return false;\n\n      return true;\n    }\n\n  }\n\n  class Label {\n    constructor() {\n      Label.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.elt = new Array(2).fill(null);\n\n      if (arguments.length === 1) {\n        if (Number.isInteger(arguments[0])) {\n          const onLoc = arguments[0];\n          this.elt[0] = new TopologyLocation(onLoc);\n          this.elt[1] = new TopologyLocation(onLoc);\n        } else if (arguments[0] instanceof Label) {\n          const lbl = arguments[0];\n          this.elt[0] = new TopologyLocation(lbl.elt[0]);\n          this.elt[1] = new TopologyLocation(lbl.elt[1]);\n        }\n      } else if (arguments.length === 2) {\n        const geomIndex = arguments[0],\n              onLoc = arguments[1];\n        this.elt[0] = new TopologyLocation(Location.NONE);\n        this.elt[1] = new TopologyLocation(Location.NONE);\n        this.elt[geomIndex].setLocation(onLoc);\n      } else if (arguments.length === 3) {\n        const onLoc = arguments[0],\n              leftLoc = arguments[1],\n              rightLoc = arguments[2];\n        this.elt[0] = new TopologyLocation(onLoc, leftLoc, rightLoc);\n        this.elt[1] = new TopologyLocation(onLoc, leftLoc, rightLoc);\n      } else if (arguments.length === 4) {\n        const geomIndex = arguments[0],\n              onLoc = arguments[1],\n              leftLoc = arguments[2],\n              rightLoc = arguments[3];\n        this.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n        this.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n        this.elt[geomIndex].setLocations(onLoc, leftLoc, rightLoc);\n      }\n    }\n\n    static toLineLabel(label) {\n      const lineLabel = new Label(Location.NONE);\n\n      for (let i = 0; i < 2; i++) lineLabel.setLocation(i, label.getLocation(i));\n\n      return lineLabel;\n    }\n\n    getGeometryCount() {\n      let count = 0;\n      if (!this.elt[0].isNull()) count++;\n      if (!this.elt[1].isNull()) count++;\n      return count;\n    }\n\n    setAllLocations(geomIndex, location) {\n      this.elt[geomIndex].setAllLocations(location);\n    }\n\n    isNull(geomIndex) {\n      return this.elt[geomIndex].isNull();\n    }\n\n    setAllLocationsIfNull() {\n      if (arguments.length === 1) {\n        const location = arguments[0];\n        this.setAllLocationsIfNull(0, location);\n        this.setAllLocationsIfNull(1, location);\n      } else if (arguments.length === 2) {\n        const geomIndex = arguments[0],\n              location = arguments[1];\n        this.elt[geomIndex].setAllLocationsIfNull(location);\n      }\n    }\n\n    isLine(geomIndex) {\n      return this.elt[geomIndex].isLine();\n    }\n\n    merge(lbl) {\n      for (let i = 0; i < 2; i++) if (this.elt[i] === null && lbl.elt[i] !== null) this.elt[i] = new TopologyLocation(lbl.elt[i]);else this.elt[i].merge(lbl.elt[i]);\n    }\n\n    flip() {\n      this.elt[0].flip();\n      this.elt[1].flip();\n    }\n\n    getLocation() {\n      if (arguments.length === 1) {\n        const geomIndex = arguments[0];\n        return this.elt[geomIndex].get(Position.ON);\n      } else if (arguments.length === 2) {\n        const geomIndex = arguments[0],\n              posIndex = arguments[1];\n        return this.elt[geomIndex].get(posIndex);\n      }\n    }\n\n    toString() {\n      const buf = new StringBuffer();\n\n      if (this.elt[0] !== null) {\n        buf.append('A:');\n        buf.append(this.elt[0].toString());\n      }\n\n      if (this.elt[1] !== null) {\n        buf.append(' B:');\n        buf.append(this.elt[1].toString());\n      }\n\n      return buf.toString();\n    }\n\n    isArea() {\n      if (arguments.length === 0) {\n        return this.elt[0].isArea() || this.elt[1].isArea();\n      } else if (arguments.length === 1) {\n        const geomIndex = arguments[0];\n        return this.elt[geomIndex].isArea();\n      }\n    }\n\n    isAnyNull(geomIndex) {\n      return this.elt[geomIndex].isAnyNull();\n    }\n\n    setLocation() {\n      if (arguments.length === 2) {\n        const geomIndex = arguments[0],\n              location = arguments[1];\n        this.elt[geomIndex].setLocation(Position.ON, location);\n      } else if (arguments.length === 3) {\n        const geomIndex = arguments[0],\n              posIndex = arguments[1],\n              location = arguments[2];\n        this.elt[geomIndex].setLocation(posIndex, location);\n      }\n    }\n\n    isEqualOnSide(lbl, side) {\n      return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side);\n    }\n\n    allPositionsEqual(geomIndex, loc) {\n      return this.elt[geomIndex].allPositionsEqual(loc);\n    }\n\n    toLine(geomIndex) {\n      if (this.elt[geomIndex].isArea()) this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]);\n    }\n\n  }\n\n  class EdgeIntersection {\n    constructor() {\n      EdgeIntersection.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.coord = null;\n      this.segmentIndex = null;\n      this.dist = null;\n      const coord = arguments[0],\n            segmentIndex = arguments[1],\n            dist = arguments[2];\n      this.coord = new Coordinate(coord);\n      this.segmentIndex = segmentIndex;\n      this.dist = dist;\n    }\n\n    getSegmentIndex() {\n      return this.segmentIndex;\n    }\n\n    getCoordinate() {\n      return this.coord;\n    }\n\n    print(out) {\n      out.print(this.coord);\n      out.print(' seg # = ' + this.segmentIndex);\n      out.println(' dist = ' + this.dist);\n    }\n\n    compareTo(obj) {\n      const other = obj;\n      return this.compare(other.segmentIndex, other.dist);\n    }\n\n    isEndPoint(maxSegmentIndex) {\n      if (this.segmentIndex === 0 && this.dist === 0.0) return true;\n      if (this.segmentIndex === maxSegmentIndex) return true;\n      return false;\n    }\n\n    toString() {\n      return this.coord + ' seg # = ' + this.segmentIndex + ' dist = ' + this.dist;\n    }\n\n    getDistance() {\n      return this.dist;\n    }\n\n    compare(segmentIndex, dist) {\n      if (this.segmentIndex < segmentIndex) return -1;\n      if (this.segmentIndex > segmentIndex) return 1;\n      if (this.dist < dist) return -1;\n      if (this.dist > dist) return 1;\n      return 0;\n    }\n\n    get interfaces_() {\n      return [Comparable];\n    }\n\n  }\n\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html\n   */\n\n  class SortedMap extends Map$1 {}\n\n  const BLACK = 0;\n  const RED = 1;\n\n  function colorOf(p) {\n    return p == null ? BLACK : p.color;\n  }\n\n  function parentOf(p) {\n    return p == null ? null : p.parent;\n  }\n\n  function setColor(p, c) {\n    if (p !== null) p.color = c;\n  }\n\n  function leftOf(p) {\n    return p == null ? null : p.left;\n  }\n\n  function rightOf(p) {\n    return p == null ? null : p.right;\n  }\n  /**\n   * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html\n   */\n\n\n  class TreeMap extends SortedMap {\n    constructor() {\n      super();\n      this.root_ = null;\n      this.size_ = 0;\n    }\n\n    get(key) {\n      let p = this.root_;\n\n      while (p !== null) {\n        const cmp = key.compareTo(p.key);\n        if (cmp < 0) p = p.left;else if (cmp > 0) p = p.right;else return p.value;\n      }\n\n      return null;\n    }\n\n    put(key, value) {\n      if (this.root_ === null) {\n        this.root_ = {\n          key: key,\n          value: value,\n          left: null,\n          right: null,\n          parent: null,\n          color: BLACK,\n\n          getValue() {\n            return this.value;\n          },\n\n          getKey() {\n            return this.key;\n          }\n\n        };\n        this.size_ = 1;\n        return null;\n      }\n\n      let t = this.root_;\n      let parent;\n      let cmp;\n\n      do {\n        parent = t;\n        cmp = key.compareTo(t.key);\n\n        if (cmp < 0) {\n          t = t.left;\n        } else if (cmp > 0) {\n          t = t.right;\n        } else {\n          const oldValue = t.value;\n          t.value = value;\n          return oldValue;\n        }\n      } while (t !== null);\n\n      const e = {\n        key: key,\n        left: null,\n        right: null,\n        value: value,\n        parent: parent,\n        color: BLACK,\n\n        getValue() {\n          return this.value;\n        },\n\n        getKey() {\n          return this.key;\n        }\n\n      };\n      if (cmp < 0) parent.left = e;else parent.right = e;\n      this.fixAfterInsertion(e);\n      this.size_++;\n      return null;\n    }\n    /**\n     * @param {Object} x\n     */\n\n\n    fixAfterInsertion(x) {\n      let y;\n      x.color = RED;\n\n      while (x != null && x !== this.root_ && x.parent.color === RED) if (parentOf(x) === leftOf(parentOf(parentOf(x)))) {\n        y = rightOf(parentOf(parentOf(x)));\n\n        if (colorOf(y) === RED) {\n          setColor(parentOf(x), BLACK);\n          setColor(y, BLACK);\n          setColor(parentOf(parentOf(x)), RED);\n          x = parentOf(parentOf(x));\n        } else {\n          if (x === rightOf(parentOf(x))) {\n            x = parentOf(x);\n            this.rotateLeft(x);\n          }\n\n          setColor(parentOf(x), BLACK);\n          setColor(parentOf(parentOf(x)), RED);\n          this.rotateRight(parentOf(parentOf(x)));\n        }\n      } else {\n        y = leftOf(parentOf(parentOf(x)));\n\n        if (colorOf(y) === RED) {\n          setColor(parentOf(x), BLACK);\n          setColor(y, BLACK);\n          setColor(parentOf(parentOf(x)), RED);\n          x = parentOf(parentOf(x));\n        } else {\n          if (x === leftOf(parentOf(x))) {\n            x = parentOf(x);\n            this.rotateRight(x);\n          }\n\n          setColor(parentOf(x), BLACK);\n          setColor(parentOf(parentOf(x)), RED);\n          this.rotateLeft(parentOf(parentOf(x)));\n        }\n      }\n\n      this.root_.color = BLACK;\n    }\n\n    values() {\n      const arrayList = new ArrayList();\n      let p = this.getFirstEntry();\n\n      if (p !== null) {\n        arrayList.add(p.value);\n\n        while ((p = TreeMap.successor(p)) !== null) arrayList.add(p.value);\n      }\n\n      return arrayList;\n    }\n\n    entrySet() {\n      const hashSet = new HashSet();\n      let p = this.getFirstEntry();\n\n      if (p !== null) {\n        hashSet.add(p);\n\n        while ((p = TreeMap.successor(p)) !== null) hashSet.add(p);\n      }\n\n      return hashSet;\n    }\n    /**\n     * @param {Object} p\n     */\n\n\n    rotateLeft(p) {\n      if (p != null) {\n        const r = p.right;\n        p.right = r.left;\n        if (r.left != null) r.left.parent = p;\n        r.parent = p.parent;\n        if (p.parent == null) this.root_ = r;else if (p.parent.left === p) p.parent.left = r;else p.parent.right = r;\n        r.left = p;\n        p.parent = r;\n      }\n    }\n    /**\n     * @param {Object} p\n     */\n\n\n    rotateRight(p) {\n      if (p != null) {\n        const l = p.left;\n        p.left = l.right;\n        if (l.right != null) l.right.parent = p;\n        l.parent = p.parent;\n        if (p.parent == null) this.root_ = l;else if (p.parent.right === p) p.parent.right = l;else p.parent.left = l;\n        l.right = p;\n        p.parent = l;\n      }\n    }\n    /**\n     * @return {Object}\n     */\n\n\n    getFirstEntry() {\n      let p = this.root_;\n      if (p != null) while (p.left != null) p = p.left;\n      return p;\n    }\n    /**\n     * @param {Object} t\n     * @return {Object}\n     * @private\n     */\n\n\n    static successor(t) {\n      let p;\n\n      if (t === null) {\n        return null;\n      } else if (t.right !== null) {\n        p = t.right;\n\n        while (p.left !== null) p = p.left;\n\n        return p;\n      } else {\n        p = t.parent;\n        let ch = t;\n\n        while (p !== null && ch === p.right) {\n          ch = p;\n          p = p.parent;\n        }\n\n        return p;\n      }\n    }\n\n    size() {\n      return this.size_;\n    }\n\n    containsKey(key) {\n      let p = this.root_;\n\n      while (p !== null) {\n        const cmp = key.compareTo(p.key);\n        if (cmp < 0) p = p.left;else if (cmp > 0) p = p.right;else return true;\n      }\n\n      return false;\n    }\n\n  }\n\n  class EdgeIntersectionList {\n    constructor() {\n      EdgeIntersectionList.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._nodeMap = new TreeMap();\n      this.edge = null;\n      const edge = arguments[0];\n      this.edge = edge;\n    }\n\n    print(out) {\n      out.println('Intersections:');\n\n      for (let it = this.iterator(); it.hasNext();) {\n        const ei = it.next();\n        ei.print(out);\n      }\n    }\n\n    iterator() {\n      return this._nodeMap.values().iterator();\n    }\n\n    addSplitEdges(edgeList) {\n      this.addEndpoints();\n      const it = this.iterator();\n      let eiPrev = it.next();\n\n      while (it.hasNext()) {\n        const ei = it.next();\n        const newEdge = this.createSplitEdge(eiPrev, ei);\n        edgeList.add(newEdge);\n        eiPrev = ei;\n      }\n    }\n\n    addEndpoints() {\n      const maxSegIndex = this.edge.pts.length - 1;\n      this.add(this.edge.pts[0], 0, 0.0);\n      this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);\n    }\n\n    createSplitEdge(ei0, ei1) {\n      let npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n      const lastSegStartPt = this.edge.pts[ei1.segmentIndex];\n      const useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);\n      if (!useIntPt1) npts--;\n      const pts = new Array(npts).fill(null);\n      let ipt = 0;\n      pts[ipt++] = new Coordinate(ei0.coord);\n\n      for (let i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) pts[ipt++] = this.edge.pts[i];\n\n      if (useIntPt1) pts[ipt] = ei1.coord;\n      return new Edge(pts, new Label(this.edge._label));\n    }\n\n    add(intPt, segmentIndex, dist) {\n      const eiNew = new EdgeIntersection(intPt, segmentIndex, dist);\n\n      const ei = this._nodeMap.get(eiNew);\n\n      if (ei !== null) return ei;\n\n      this._nodeMap.put(eiNew, eiNew);\n\n      return eiNew;\n    }\n\n    isIntersection(pt) {\n      for (let it = this.iterator(); it.hasNext();) {\n        const ei = it.next();\n        if (ei.coord.equals(pt)) return true;\n      }\n\n      return false;\n    }\n\n  }\n\n  class IntArrayList {\n    constructor() {\n      IntArrayList.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._data = null;\n      this._size = 0;\n\n      if (arguments.length === 0) {\n        IntArrayList.constructor_.call(this, 10);\n      } else if (arguments.length === 1) {\n        const initialCapacity = arguments[0];\n        this._data = new Array(initialCapacity).fill(null);\n      }\n    }\n\n    size() {\n      return this._size;\n    }\n\n    addAll(values) {\n      if (values === null) return null;\n      if (values.length === 0) return null;\n      this.ensureCapacity(this._size + values.length);\n      System.arraycopy(values, 0, this._data, this._size, values.length);\n      this._size += values.length;\n    }\n\n    ensureCapacity(capacity) {\n      if (capacity <= this._data.length) return null;\n      const newLength = Math.max(capacity, this._data.length * 2);\n      this._data = Arrays.copyOf(this._data, newLength);\n    }\n\n    toArray() {\n      const array = new Array(this._size).fill(null);\n      System.arraycopy(this._data, 0, array, 0, this._size);\n      return array;\n    }\n\n    add(value) {\n      this.ensureCapacity(this._size + 1);\n      this._data[this._size] = value;\n      ++this._size;\n    }\n\n  }\n\n  class MonotoneChainIndexer {\n    static toIntArray(list) {\n      const array = new Array(list.size()).fill(null);\n\n      for (let i = 0; i < array.length; i++) array[i] = list.get(i).intValue();\n\n      return array;\n    }\n\n    getChainStartIndices(pts) {\n      let start = 0;\n      const startIndexList = new IntArrayList(Math.trunc(pts.length / 2));\n      startIndexList.add(start);\n\n      do {\n        const last = this.findChainEnd(pts, start);\n        startIndexList.add(last);\n        start = last;\n      } while (start < pts.length - 1);\n\n      return startIndexList.toArray();\n    }\n\n    findChainEnd(pts, start) {\n      const chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);\n      let last = start + 1;\n\n      while (last < pts.length) {\n        const quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n        if (quad !== chainQuad) break;\n        last++;\n      }\n\n      return last - 1;\n    }\n\n    OLDgetChainStartIndices(pts) {\n      let start = 0;\n      const startIndexList = new ArrayList();\n      startIndexList.add(start);\n\n      do {\n        const last = this.findChainEnd(pts, start);\n        startIndexList.add(last);\n        start = last;\n      } while (start < pts.length - 1);\n\n      const startIndex = MonotoneChainIndexer.toIntArray(startIndexList);\n      return startIndex;\n    }\n\n  }\n\n  class MonotoneChainEdge {\n    constructor() {\n      MonotoneChainEdge.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.e = null;\n      this.pts = null;\n      this.startIndex = null;\n      const e = arguments[0];\n      this.e = e;\n      this.pts = e.getCoordinates();\n      const mcb = new MonotoneChainIndexer();\n      this.startIndex = mcb.getChainStartIndices(this.pts);\n    }\n\n    getCoordinates() {\n      return this.pts;\n    }\n\n    getMaxX(chainIndex) {\n      const x1 = this.pts[this.startIndex[chainIndex]].x;\n      const x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n      return x1 > x2 ? x1 : x2;\n    }\n\n    getMinX(chainIndex) {\n      const x1 = this.pts[this.startIndex[chainIndex]].x;\n      const x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n      return x1 < x2 ? x1 : x2;\n    }\n\n    computeIntersectsForChain() {\n      if (arguments.length === 4) {\n        const chainIndex0 = arguments[0],\n              mce = arguments[1],\n              chainIndex1 = arguments[2],\n              si = arguments[3];\n        this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);\n      } else if (arguments.length === 6) {\n        const start0 = arguments[0],\n              end0 = arguments[1],\n              mce = arguments[2],\n              start1 = arguments[3],\n              end1 = arguments[4],\n              ei = arguments[5];\n\n        if (end0 - start0 === 1 && end1 - start1 === 1) {\n          ei.addIntersections(this.e, start0, mce.e, start1);\n          return null;\n        }\n\n        if (!this.overlaps(start0, end0, mce, start1, end1)) return null;\n        const mid0 = Math.trunc((start0 + end0) / 2);\n        const mid1 = Math.trunc((start1 + end1) / 2);\n\n        if (start0 < mid0) {\n          if (start1 < mid1) this.computeIntersectsForChain(start0, mid0, mce, start1, mid1, ei);\n          if (mid1 < end1) this.computeIntersectsForChain(start0, mid0, mce, mid1, end1, ei);\n        }\n\n        if (mid0 < end0) {\n          if (start1 < mid1) this.computeIntersectsForChain(mid0, end0, mce, start1, mid1, ei);\n          if (mid1 < end1) this.computeIntersectsForChain(mid0, end0, mce, mid1, end1, ei);\n        }\n      }\n    }\n\n    overlaps(start0, end0, mce, start1, end1) {\n      return Envelope.intersects(this.pts[start0], this.pts[end0], mce.pts[start1], mce.pts[end1]);\n    }\n\n    getStartIndexes() {\n      return this.startIndex;\n    }\n\n    computeIntersects(mce, si) {\n      for (let i = 0; i < this.startIndex.length - 1; i++) for (let j = 0; j < mce.startIndex.length - 1; j++) this.computeIntersectsForChain(i, mce, j, si);\n    }\n\n  }\n\n  class Depth {\n    constructor() {\n      Depth.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._depth = Array(2).fill().map(() => Array(3));\n\n      for (let i = 0; i < 2; i++) for (let j = 0; j < 3; j++) this._depth[i][j] = Depth.NULL_VALUE;\n    }\n\n    static depthAtLocation(location) {\n      if (location === Location.EXTERIOR) return 0;\n      if (location === Location.INTERIOR) return 1;\n      return Depth.NULL_VALUE;\n    }\n\n    getDepth(geomIndex, posIndex) {\n      return this._depth[geomIndex][posIndex];\n    }\n\n    setDepth(geomIndex, posIndex, depthValue) {\n      this._depth[geomIndex][posIndex] = depthValue;\n    }\n\n    isNull() {\n      if (arguments.length === 0) {\n        for (let i = 0; i < 2; i++) for (let j = 0; j < 3; j++) if (this._depth[i][j] !== Depth.NULL_VALUE) return false;\n\n        return true;\n      } else if (arguments.length === 1) {\n        const geomIndex = arguments[0];\n        return this._depth[geomIndex][1] === Depth.NULL_VALUE;\n      } else if (arguments.length === 2) {\n        const geomIndex = arguments[0],\n              posIndex = arguments[1];\n        return this._depth[geomIndex][posIndex] === Depth.NULL_VALUE;\n      }\n    }\n\n    normalize() {\n      for (let i = 0; i < 2; i++) if (!this.isNull(i)) {\n        let minDepth = this._depth[i][1];\n        if (this._depth[i][2] < minDepth) minDepth = this._depth[i][2];\n        if (minDepth < 0) minDepth = 0;\n\n        for (let j = 1; j < 3; j++) {\n          let newValue = 0;\n          if (this._depth[i][j] > minDepth) newValue = 1;\n          this._depth[i][j] = newValue;\n        }\n      }\n    }\n\n    getDelta(geomIndex) {\n      return this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT];\n    }\n\n    getLocation(geomIndex, posIndex) {\n      if (this._depth[geomIndex][posIndex] <= 0) return Location.EXTERIOR;\n      return Location.INTERIOR;\n    }\n\n    toString() {\n      return 'A: ' + this._depth[0][1] + ',' + this._depth[0][2] + ' B: ' + this._depth[1][1] + ',' + this._depth[1][2];\n    }\n\n    add() {\n      if (arguments.length === 1) {\n        const lbl = arguments[0];\n\n        for (let i = 0; i < 2; i++) for (let j = 1; j < 3; j++) {\n          const loc = lbl.getLocation(i, j);\n          if (loc === Location.EXTERIOR || loc === Location.INTERIOR) if (this.isNull(i, j)) this._depth[i][j] = Depth.depthAtLocation(loc);else this._depth[i][j] += Depth.depthAtLocation(loc);\n        }\n      } else if (arguments.length === 3) {\n        const geomIndex = arguments[0],\n              posIndex = arguments[1],\n              location = arguments[2];\n        if (location === Location.INTERIOR) this._depth[geomIndex][posIndex]++;\n      }\n    }\n\n  }\n  Depth.NULL_VALUE = -1;\n\n  class GraphComponent {\n    constructor() {\n      GraphComponent.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._label = null;\n      this._isInResult = false;\n      this._isCovered = false;\n      this._isCoveredSet = false;\n      this._isVisited = false;\n\n      if (arguments.length === 0) ; else if (arguments.length === 1) {\n        const label = arguments[0];\n        this._label = label;\n      }\n    }\n\n    setVisited(isVisited) {\n      this._isVisited = isVisited;\n    }\n\n    setInResult(isInResult) {\n      this._isInResult = isInResult;\n    }\n\n    isCovered() {\n      return this._isCovered;\n    }\n\n    isCoveredSet() {\n      return this._isCoveredSet;\n    }\n\n    setLabel(label) {\n      this._label = label;\n    }\n\n    getLabel() {\n      return this._label;\n    }\n\n    setCovered(isCovered) {\n      this._isCovered = isCovered;\n      this._isCoveredSet = true;\n    }\n\n    updateIM(im) {\n      Assert.isTrue(this._label.getGeometryCount() >= 2, 'found partial label');\n      this.computeIM(im);\n    }\n\n    isInResult() {\n      return this._isInResult;\n    }\n\n    isVisited() {\n      return this._isVisited;\n    }\n\n  }\n\n  class Edge extends GraphComponent {\n    constructor() {\n      super();\n      Edge.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.pts = null;\n      this._env = null;\n      this.eiList = new EdgeIntersectionList(this);\n      this._name = null;\n      this._mce = null;\n      this._isIsolated = true;\n      this._depth = new Depth();\n      this._depthDelta = 0;\n\n      if (arguments.length === 1) {\n        const pts = arguments[0];\n        Edge.constructor_.call(this, pts, null);\n      } else if (arguments.length === 2) {\n        const pts = arguments[0],\n              label = arguments[1];\n        this.pts = pts;\n        this._label = label;\n      }\n    }\n\n    static updateIM() {\n      if (arguments.length === 2 && arguments[1] instanceof IntersectionMatrix && arguments[0] instanceof Label) {\n        const label = arguments[0],\n              im = arguments[1];\n        im.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);\n\n        if (label.isArea()) {\n          im.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);\n          im.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);\n        }\n      } else {\n        return super.updateIM.apply(this, arguments);\n      }\n    }\n\n    getDepth() {\n      return this._depth;\n    }\n\n    getCollapsedEdge() {\n      const newPts = new Array(2).fill(null);\n      newPts[0] = this.pts[0];\n      newPts[1] = this.pts[1];\n      const newe = new Edge(newPts, Label.toLineLabel(this._label));\n      return newe;\n    }\n\n    isIsolated() {\n      return this._isIsolated;\n    }\n\n    getCoordinates() {\n      return this.pts;\n    }\n\n    setIsolated(isIsolated) {\n      this._isIsolated = isIsolated;\n    }\n\n    setName(name) {\n      this._name = name;\n    }\n\n    equals(o) {\n      if (!(o instanceof Edge)) return false;\n      const e = o;\n      if (this.pts.length !== e.pts.length) return false;\n      let isEqualForward = true;\n      let isEqualReverse = true;\n      let iRev = this.pts.length;\n\n      for (let i = 0; i < this.pts.length; i++) {\n        if (!this.pts[i].equals2D(e.pts[i])) isEqualForward = false;\n        if (!this.pts[i].equals2D(e.pts[--iRev])) isEqualReverse = false;\n        if (!isEqualForward && !isEqualReverse) return false;\n      }\n\n      return true;\n    }\n\n    getCoordinate() {\n      if (arguments.length === 0) {\n        if (this.pts.length > 0) return this.pts[0];\n        return null;\n      } else if (arguments.length === 1) {\n        const i = arguments[0];\n        return this.pts[i];\n      }\n    }\n\n    print(out) {\n      out.print('edge ' + this._name + ': ');\n      out.print('LINESTRING (');\n\n      for (let i = 0; i < this.pts.length; i++) {\n        if (i > 0) out.print(',');\n        out.print(this.pts[i].x + ' ' + this.pts[i].y);\n      }\n\n      out.print(')  ' + this._label + ' ' + this._depthDelta);\n    }\n\n    computeIM(im) {\n      Edge.updateIM(this._label, im);\n    }\n\n    isCollapsed() {\n      if (!this._label.isArea()) return false;\n      if (this.pts.length !== 3) return false;\n      if (this.pts[0].equals(this.pts[2])) return true;\n      return false;\n    }\n\n    isClosed() {\n      return this.pts[0].equals(this.pts[this.pts.length - 1]);\n    }\n\n    getMaximumSegmentIndex() {\n      return this.pts.length - 1;\n    }\n\n    getDepthDelta() {\n      return this._depthDelta;\n    }\n\n    getNumPoints() {\n      return this.pts.length;\n    }\n\n    printReverse(out) {\n      out.print('edge ' + this._name + ': ');\n\n      for (let i = this.pts.length - 1; i >= 0; i--) out.print(this.pts[i] + ' ');\n\n      out.println('');\n    }\n\n    getMonotoneChainEdge() {\n      if (this._mce === null) this._mce = new MonotoneChainEdge(this);\n      return this._mce;\n    }\n\n    getEnvelope() {\n      if (this._env === null) {\n        this._env = new Envelope();\n\n        for (let i = 0; i < this.pts.length; i++) this._env.expandToInclude(this.pts[i]);\n      }\n\n      return this._env;\n    }\n\n    addIntersection(li, segmentIndex, geomIndex, intIndex) {\n      const intPt = new Coordinate(li.getIntersection(intIndex));\n      let normalizedSegmentIndex = segmentIndex;\n      let dist = li.getEdgeDistance(geomIndex, intIndex);\n      const nextSegIndex = normalizedSegmentIndex + 1;\n\n      if (nextSegIndex < this.pts.length) {\n        const nextPt = this.pts[nextSegIndex];\n\n        if (intPt.equals2D(nextPt)) {\n          normalizedSegmentIndex = nextSegIndex;\n          dist = 0.0;\n        }\n      }\n\n      const ei = this.eiList.add(intPt, normalizedSegmentIndex, dist);\n    }\n\n    toString() {\n      const builder = new StringBuilder();\n      builder.append('edge ' + this._name + ': ');\n      builder.append('LINESTRING (');\n\n      for (let i = 0; i < this.pts.length; i++) {\n        if (i > 0) builder.append(',');\n        builder.append(this.pts[i].x + ' ' + this.pts[i].y);\n      }\n\n      builder.append(')  ' + this._label + ' ' + this._depthDelta);\n      return builder.toString();\n    }\n\n    isPointwiseEqual(e) {\n      if (this.pts.length !== e.pts.length) return false;\n\n      for (let i = 0; i < this.pts.length; i++) if (!this.pts[i].equals2D(e.pts[i])) return false;\n\n      return true;\n    }\n\n    setDepthDelta(depthDelta) {\n      this._depthDelta = depthDelta;\n    }\n\n    getEdgeIntersectionList() {\n      return this.eiList;\n    }\n\n    addIntersections(li, segmentIndex, geomIndex) {\n      for (let i = 0; i < li.getIntersectionNum(); i++) this.addIntersection(li, segmentIndex, geomIndex, i);\n    }\n\n  }\n\n  class Node extends GraphComponent {\n    constructor() {\n      super();\n      Node.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._coord = null;\n      this._edges = null;\n      const coord = arguments[0],\n            edges = arguments[1];\n      this._coord = coord;\n      this._edges = edges;\n      this._label = new Label(0, Location.NONE);\n    }\n\n    isIncidentEdgeInResult() {\n      for (let it = this.getEdges().getEdges().iterator(); it.hasNext();) {\n        const de = it.next();\n        if (de.getEdge().isInResult()) return true;\n      }\n\n      return false;\n    }\n\n    isIsolated() {\n      return this._label.getGeometryCount() === 1;\n    }\n\n    getCoordinate() {\n      return this._coord;\n    }\n\n    print(out) {\n      out.println('node ' + this._coord + ' lbl: ' + this._label);\n    }\n\n    computeIM(im) {}\n\n    computeMergedLocation(label2, eltIndex) {\n      let loc = Location.NONE;\n      loc = this._label.getLocation(eltIndex);\n\n      if (!label2.isNull(eltIndex)) {\n        const nLoc = label2.getLocation(eltIndex);\n        if (loc !== Location.BOUNDARY) loc = nLoc;\n      }\n\n      return loc;\n    }\n\n    setLabel() {\n      if (arguments.length === 2 && Number.isInteger(arguments[1]) && Number.isInteger(arguments[0])) {\n        const argIndex = arguments[0],\n              onLocation = arguments[1];\n        if (this._label === null) this._label = new Label(argIndex, onLocation);else this._label.setLocation(argIndex, onLocation);\n      } else {\n        return super.setLabel.apply(this, arguments);\n      }\n    }\n\n    getEdges() {\n      return this._edges;\n    }\n\n    mergeLabel() {\n      if (arguments[0] instanceof Node) {\n        const n = arguments[0];\n        this.mergeLabel(n._label);\n      } else if (arguments[0] instanceof Label) {\n        const label2 = arguments[0];\n\n        for (let i = 0; i < 2; i++) {\n          const loc = this.computeMergedLocation(label2, i);\n\n          const thisLoc = this._label.getLocation(i);\n\n          if (thisLoc === Location.NONE) this._label.setLocation(i, loc);\n        }\n      }\n    }\n\n    add(e) {\n      this._edges.insert(e);\n\n      e.setNode(this);\n    }\n\n    setLabelBoundary(argIndex) {\n      if (this._label === null) return null;\n      let loc = Location.NONE;\n      if (this._label !== null) loc = this._label.getLocation(argIndex);\n      let newLoc = null;\n\n      switch (loc) {\n        case Location.BOUNDARY:\n          newLoc = Location.INTERIOR;\n          break;\n\n        case Location.INTERIOR:\n          newLoc = Location.BOUNDARY;\n          break;\n\n        default:\n          newLoc = Location.BOUNDARY;\n          break;\n      }\n\n      this._label.setLocation(argIndex, newLoc);\n    }\n\n  }\n\n  class NodeMap {\n    constructor() {\n      NodeMap.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.nodeMap = new TreeMap();\n      this.nodeFact = null;\n      const nodeFact = arguments[0];\n      this.nodeFact = nodeFact;\n    }\n\n    find(coord) {\n      return this.nodeMap.get(coord);\n    }\n\n    addNode() {\n      if (arguments[0] instanceof Coordinate) {\n        const coord = arguments[0];\n        let node = this.nodeMap.get(coord);\n\n        if (node === null) {\n          node = this.nodeFact.createNode(coord);\n          this.nodeMap.put(coord, node);\n        }\n\n        return node;\n      } else if (arguments[0] instanceof Node) {\n        const n = arguments[0];\n        const node = this.nodeMap.get(n.getCoordinate());\n\n        if (node === null) {\n          this.nodeMap.put(n.getCoordinate(), n);\n          return n;\n        }\n\n        node.mergeLabel(n);\n        return node;\n      }\n    }\n\n    print(out) {\n      for (let it = this.iterator(); it.hasNext();) {\n        const n = it.next();\n        n.print(out);\n      }\n    }\n\n    iterator() {\n      return this.nodeMap.values().iterator();\n    }\n\n    values() {\n      return this.nodeMap.values();\n    }\n\n    getBoundaryNodes(geomIndex) {\n      const bdyNodes = new ArrayList();\n\n      for (let i = this.iterator(); i.hasNext();) {\n        const node = i.next();\n        if (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) bdyNodes.add(node);\n      }\n\n      return bdyNodes;\n    }\n\n    add(e) {\n      const p = e.getCoordinate();\n      const n = this.addNode(p);\n      n.add(e);\n    }\n\n  }\n\n  class EdgeEnd {\n    constructor() {\n      EdgeEnd.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._edge = null;\n      this._label = null;\n      this._node = null;\n      this._p0 = null;\n      this._p1 = null;\n      this._dx = null;\n      this._dy = null;\n      this._quadrant = null;\n\n      if (arguments.length === 1) {\n        const edge = arguments[0];\n        this._edge = edge;\n      } else if (arguments.length === 3) {\n        const edge = arguments[0],\n              p0 = arguments[1],\n              p1 = arguments[2];\n        EdgeEnd.constructor_.call(this, edge, p0, p1, null);\n      } else if (arguments.length === 4) {\n        const edge = arguments[0],\n              p0 = arguments[1],\n              p1 = arguments[2],\n              label = arguments[3];\n        EdgeEnd.constructor_.call(this, edge);\n        this.init(p0, p1);\n        this._label = label;\n      }\n    }\n\n    compareDirection(e) {\n      if (this._dx === e._dx && this._dy === e._dy) return 0;\n      if (this._quadrant > e._quadrant) return 1;\n      if (this._quadrant < e._quadrant) return -1;\n      return Orientation.index(e._p0, e._p1, this._p1);\n    }\n\n    getDy() {\n      return this._dy;\n    }\n\n    getCoordinate() {\n      return this._p0;\n    }\n\n    setNode(node) {\n      this._node = node;\n    }\n\n    print(out) {\n      const angle = Math.atan2(this._dy, this._dx);\n      const className = this.getClass().getName();\n      const lastDotPos = className.lastIndexOf('.');\n      const name = className.substring(lastDotPos + 1);\n      out.print('  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label);\n    }\n\n    compareTo(obj) {\n      const e = obj;\n      return this.compareDirection(e);\n    }\n\n    getDirectedCoordinate() {\n      return this._p1;\n    }\n\n    getDx() {\n      return this._dx;\n    }\n\n    getLabel() {\n      return this._label;\n    }\n\n    getEdge() {\n      return this._edge;\n    }\n\n    getQuadrant() {\n      return this._quadrant;\n    }\n\n    getNode() {\n      return this._node;\n    }\n\n    toString() {\n      const angle = Math.atan2(this._dy, this._dx);\n      const className = this.getClass().getName();\n      const lastDotPos = className.lastIndexOf('.');\n      const name = className.substring(lastDotPos + 1);\n      return '  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label;\n    }\n\n    computeLabel(boundaryNodeRule) {}\n\n    init(p0, p1) {\n      this._p0 = p0;\n      this._p1 = p1;\n      this._dx = p1.x - p0.x;\n      this._dy = p1.y - p0.y;\n      this._quadrant = Quadrant.quadrant(this._dx, this._dy);\n      Assert.isTrue(!(this._dx === 0 && this._dy === 0), 'EdgeEnd with identical endpoints found');\n    }\n\n    get interfaces_() {\n      return [Comparable];\n    }\n\n  }\n\n  class TopologyException extends RuntimeException {\n    constructor(msg, pt) {\n      super(pt ? msg + ' [ ' + pt + ' ]' : msg);\n      this.pt = pt ? new Coordinate(pt) : undefined;\n    }\n\n    getCoordinate() {\n      return this.pt;\n    }\n\n  }\n\n  class DirectedEdge extends EdgeEnd {\n    constructor() {\n      super();\n      DirectedEdge.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._isForward = null;\n      this._isInResult = false;\n      this._isVisited = false;\n      this._sym = null;\n      this._next = null;\n      this._nextMin = null;\n      this._edgeRing = null;\n      this._minEdgeRing = null;\n      this._depth = [0, -999, -999];\n      const edge = arguments[0],\n            isForward = arguments[1];\n      EdgeEnd.constructor_.call(this, edge);\n      this._isForward = isForward;\n\n      if (isForward) {\n        this.init(edge.getCoordinate(0), edge.getCoordinate(1));\n      } else {\n        const n = edge.getNumPoints() - 1;\n        this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));\n      }\n\n      this.computeDirectedLabel();\n    }\n\n    static depthFactor(currLocation, nextLocation) {\n      if (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) return 1;else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) return -1;\n      return 0;\n    }\n\n    getNextMin() {\n      return this._nextMin;\n    }\n\n    getDepth(position) {\n      return this._depth[position];\n    }\n\n    setVisited(isVisited) {\n      this._isVisited = isVisited;\n    }\n\n    computeDirectedLabel() {\n      this._label = new Label(this._edge.getLabel());\n      if (!this._isForward) this._label.flip();\n    }\n\n    getNext() {\n      return this._next;\n    }\n\n    setDepth(position, depthVal) {\n      if (this._depth[position] !== -999) if (this._depth[position] !== depthVal) throw new TopologyException('assigned depths do not match', this.getCoordinate());\n      this._depth[position] = depthVal;\n    }\n\n    isInteriorAreaEdge() {\n      let isInteriorAreaEdge = true;\n\n      for (let i = 0; i < 2; i++) if (!(this._label.isArea(i) && this._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) isInteriorAreaEdge = false;\n\n      return isInteriorAreaEdge;\n    }\n\n    setNextMin(nextMin) {\n      this._nextMin = nextMin;\n    }\n\n    print(out) {\n      super.print.call(this, out);\n      out.print(' ' + this._depth[Position.LEFT] + '/' + this._depth[Position.RIGHT]);\n      out.print(' (' + this.getDepthDelta() + ')');\n      if (this._isInResult) out.print(' inResult');\n    }\n\n    setMinEdgeRing(minEdgeRing) {\n      this._minEdgeRing = minEdgeRing;\n    }\n\n    isLineEdge() {\n      const isLine = this._label.isLine(0) || this._label.isLine(1);\n\n      const isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);\n\n      const isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);\n\n      return isLine && isExteriorIfArea0 && isExteriorIfArea1;\n    }\n\n    setEdgeRing(edgeRing) {\n      this._edgeRing = edgeRing;\n    }\n\n    getMinEdgeRing() {\n      return this._minEdgeRing;\n    }\n\n    getDepthDelta() {\n      let depthDelta = this._edge.getDepthDelta();\n\n      if (!this._isForward) depthDelta = -depthDelta;\n      return depthDelta;\n    }\n\n    setInResult(isInResult) {\n      this._isInResult = isInResult;\n    }\n\n    getSym() {\n      return this._sym;\n    }\n\n    isForward() {\n      return this._isForward;\n    }\n\n    getEdge() {\n      return this._edge;\n    }\n\n    printEdge(out) {\n      this.print(out);\n      out.print(' ');\n      if (this._isForward) this._edge.print(out);else this._edge.printReverse(out);\n    }\n\n    setSym(de) {\n      this._sym = de;\n    }\n\n    setVisitedEdge(isVisited) {\n      this.setVisited(isVisited);\n\n      this._sym.setVisited(isVisited);\n    }\n\n    setEdgeDepths(position, depth) {\n      let depthDelta = this.getEdge().getDepthDelta();\n      if (!this._isForward) depthDelta = -depthDelta;\n      let directionFactor = 1;\n      if (position === Position.LEFT) directionFactor = -1;\n      const oppositePos = Position.opposite(position);\n      const delta = depthDelta * directionFactor;\n      const oppositeDepth = depth + delta;\n      this.setDepth(position, depth);\n      this.setDepth(oppositePos, oppositeDepth);\n    }\n\n    getEdgeRing() {\n      return this._edgeRing;\n    }\n\n    isInResult() {\n      return this._isInResult;\n    }\n\n    setNext(next) {\n      this._next = next;\n    }\n\n    isVisited() {\n      return this._isVisited;\n    }\n\n  }\n\n  class NodeFactory {\n    createNode(coord) {\n      return new Node(coord, null);\n    }\n\n  }\n\n  class PlanarGraph {\n    constructor() {\n      PlanarGraph.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._edges = new ArrayList();\n      this._nodes = null;\n      this._edgeEndList = new ArrayList();\n\n      if (arguments.length === 0) {\n        this._nodes = new NodeMap(new NodeFactory());\n      } else if (arguments.length === 1) {\n        const nodeFact = arguments[0];\n        this._nodes = new NodeMap(nodeFact);\n      }\n    }\n\n    static linkResultDirectedEdges(nodes) {\n      for (let nodeit = nodes.iterator(); nodeit.hasNext();) {\n        const node = nodeit.next();\n        node.getEdges().linkResultDirectedEdges();\n      }\n    }\n\n    printEdges(out) {\n      out.println('Edges:');\n\n      for (let i = 0; i < this._edges.size(); i++) {\n        out.println('edge ' + i + ':');\n\n        const e = this._edges.get(i);\n\n        e.print(out);\n        e.eiList.print(out);\n      }\n    }\n\n    find(coord) {\n      return this._nodes.find(coord);\n    }\n\n    addNode() {\n      if (arguments[0] instanceof Node) {\n        const node = arguments[0];\n        return this._nodes.addNode(node);\n      } else if (arguments[0] instanceof Coordinate) {\n        const coord = arguments[0];\n        return this._nodes.addNode(coord);\n      }\n    }\n\n    getNodeIterator() {\n      return this._nodes.iterator();\n    }\n\n    linkResultDirectedEdges() {\n      for (let nodeit = this._nodes.iterator(); nodeit.hasNext();) {\n        const node = nodeit.next();\n        node.getEdges().linkResultDirectedEdges();\n      }\n    }\n\n    debugPrintln(o) {\n      System.out.println(o);\n    }\n\n    isBoundaryNode(geomIndex, coord) {\n      const node = this._nodes.find(coord);\n\n      if (node === null) return false;\n      const label = node.getLabel();\n      if (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) return true;\n      return false;\n    }\n\n    linkAllDirectedEdges() {\n      for (let nodeit = this._nodes.iterator(); nodeit.hasNext();) {\n        const node = nodeit.next();\n        node.getEdges().linkAllDirectedEdges();\n      }\n    }\n\n    matchInSameDirection(p0, p1, ep0, ep1) {\n      if (!p0.equals(ep0)) return false;\n      if (Orientation.index(p0, p1, ep1) === Orientation.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) return true;\n      return false;\n    }\n\n    getEdgeEnds() {\n      return this._edgeEndList;\n    }\n\n    debugPrint(o) {\n      System.out.print(o);\n    }\n\n    getEdgeIterator() {\n      return this._edges.iterator();\n    }\n\n    findEdgeInSameDirection(p0, p1) {\n      for (let i = 0; i < this._edges.size(); i++) {\n        const e = this._edges.get(i);\n\n        const eCoord = e.getCoordinates();\n        if (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) return e;\n        if (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) return e;\n      }\n\n      return null;\n    }\n\n    insertEdge(e) {\n      this._edges.add(e);\n    }\n\n    findEdgeEnd(e) {\n      for (let i = this.getEdgeEnds().iterator(); i.hasNext();) {\n        const ee = i.next();\n        if (ee.getEdge() === e) return ee;\n      }\n\n      return null;\n    }\n\n    addEdges(edgesToAdd) {\n      for (let it = edgesToAdd.iterator(); it.hasNext();) {\n        const e = it.next();\n\n        this._edges.add(e);\n\n        const de1 = new DirectedEdge(e, true);\n        const de2 = new DirectedEdge(e, false);\n        de1.setSym(de2);\n        de2.setSym(de1);\n        this.add(de1);\n        this.add(de2);\n      }\n    }\n\n    add(e) {\n      this._nodes.add(e);\n\n      this._edgeEndList.add(e);\n    }\n\n    getNodes() {\n      return this._nodes.values();\n    }\n\n    findEdge(p0, p1) {\n      for (let i = 0; i < this._edges.size(); i++) {\n        const e = this._edges.get(i);\n\n        const eCoord = e.getCoordinates();\n        if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) return e;\n      }\n\n      return null;\n    }\n\n  }\n\n  class GeometryGraph extends PlanarGraph {\n    constructor() {\n      super();\n      GeometryGraph.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._parentGeom = null;\n      this._lineEdgeMap = new HashMap();\n      this._boundaryNodeRule = null;\n      this._useBoundaryDeterminationRule = true;\n      this._argIndex = null;\n      this._boundaryNodes = null;\n      this._hasTooFewPoints = false;\n      this._invalidPoint = null;\n      this._areaPtLocator = null;\n      this._ptLocator = new PointLocator();\n\n      if (arguments.length === 2) {\n        const argIndex = arguments[0],\n              parentGeom = arguments[1];\n        GeometryGraph.constructor_.call(this, argIndex, parentGeom, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n      } else if (arguments.length === 3) {\n        const argIndex = arguments[0],\n              parentGeom = arguments[1],\n              boundaryNodeRule = arguments[2];\n        this._argIndex = argIndex;\n        this._parentGeom = parentGeom;\n        this._boundaryNodeRule = boundaryNodeRule;\n        if (parentGeom !== null) this.add(parentGeom);\n      }\n    }\n\n    static determineBoundary(boundaryNodeRule, boundaryCount) {\n      return boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR;\n    }\n\n    insertBoundaryPoint(argIndex, coord) {\n      const n = this._nodes.addNode(coord);\n\n      const lbl = n.getLabel();\n      let boundaryCount = 1;\n      let loc = Location.NONE;\n      loc = lbl.getLocation(argIndex, Position.ON);\n      if (loc === Location.BOUNDARY) boundaryCount++;\n      const newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);\n      lbl.setLocation(argIndex, newLoc);\n    }\n\n    computeSelfNodes() {\n      if (arguments.length === 2) {\n        const li = arguments[0],\n              computeRingSelfNodes = arguments[1];\n        return this.computeSelfNodes(li, computeRingSelfNodes, false);\n      } else if (arguments.length === 3) {\n        const li = arguments[0],\n              computeRingSelfNodes = arguments[1],\n              isDoneIfProperInt = arguments[2];\n        const si = new SegmentIntersector(li, true, false);\n        si.setIsDoneIfProperInt(isDoneIfProperInt);\n        const esi = this.createEdgeSetIntersector();\n        const isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;\n        const computeAllSegments = computeRingSelfNodes || !isRings;\n        esi.computeIntersections(this._edges, si, computeAllSegments);\n        this.addSelfIntersectionNodes(this._argIndex);\n        return si;\n      }\n    }\n\n    computeSplitEdges(edgelist) {\n      for (let i = this._edges.iterator(); i.hasNext();) {\n        const e = i.next();\n        e.eiList.addSplitEdges(edgelist);\n      }\n    }\n\n    computeEdgeIntersections(g, li, includeProper) {\n      const si = new SegmentIntersector(li, includeProper, true);\n      si.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());\n      const esi = this.createEdgeSetIntersector();\n      esi.computeIntersections(this._edges, g._edges, si);\n      return si;\n    }\n\n    getGeometry() {\n      return this._parentGeom;\n    }\n\n    getBoundaryNodeRule() {\n      return this._boundaryNodeRule;\n    }\n\n    hasTooFewPoints() {\n      return this._hasTooFewPoints;\n    }\n\n    addPoint() {\n      if (arguments[0] instanceof Point) {\n        const p = arguments[0];\n        const coord = p.getCoordinate();\n        this.insertPoint(this._argIndex, coord, Location.INTERIOR);\n      } else if (arguments[0] instanceof Coordinate) {\n        const pt = arguments[0];\n        this.insertPoint(this._argIndex, pt, Location.INTERIOR);\n      }\n    }\n\n    addPolygon(p) {\n      this.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);\n\n      for (let i = 0; i < p.getNumInteriorRing(); i++) {\n        const hole = p.getInteriorRingN(i);\n        this.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);\n      }\n    }\n\n    addEdge(e) {\n      this.insertEdge(e);\n      const coord = e.getCoordinates();\n      this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n      this.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);\n    }\n\n    addLineString(line) {\n      const coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n\n      if (coord.length < 2) {\n        this._hasTooFewPoints = true;\n        this._invalidPoint = coord[0];\n        return null;\n      }\n\n      const e = new Edge(coord, new Label(this._argIndex, Location.INTERIOR));\n\n      this._lineEdgeMap.put(line, e);\n\n      this.insertEdge(e);\n      Assert.isTrue(coord.length >= 2, 'found LineString with single point');\n      this.insertBoundaryPoint(this._argIndex, coord[0]);\n      this.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);\n    }\n\n    getInvalidPoint() {\n      return this._invalidPoint;\n    }\n\n    getBoundaryPoints() {\n      const coll = this.getBoundaryNodes();\n      const pts = new Array(coll.size()).fill(null);\n      let i = 0;\n\n      for (let it = coll.iterator(); it.hasNext();) {\n        const node = it.next();\n        pts[i++] = node.getCoordinate().copy();\n      }\n\n      return pts;\n    }\n\n    getBoundaryNodes() {\n      if (this._boundaryNodes === null) this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex);\n      return this._boundaryNodes;\n    }\n\n    addSelfIntersectionNode(argIndex, coord, loc) {\n      if (this.isBoundaryNode(argIndex, coord)) return null;\n      if (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) this.insertBoundaryPoint(argIndex, coord);else this.insertPoint(argIndex, coord, loc);\n    }\n\n    addPolygonRing(lr, cwLeft, cwRight) {\n      if (lr.isEmpty()) return null;\n      const coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());\n\n      if (coord.length < 4) {\n        this._hasTooFewPoints = true;\n        this._invalidPoint = coord[0];\n        return null;\n      }\n\n      let left = cwLeft;\n      let right = cwRight;\n\n      if (Orientation.isCCW(coord)) {\n        left = cwRight;\n        right = cwLeft;\n      }\n\n      const e = new Edge(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));\n\n      this._lineEdgeMap.put(lr, e);\n\n      this.insertEdge(e);\n      this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n    }\n\n    insertPoint(argIndex, coord, onLocation) {\n      const n = this._nodes.addNode(coord);\n\n      const lbl = n.getLabel();\n      if (lbl === null) n._label = new Label(argIndex, onLocation);else lbl.setLocation(argIndex, onLocation);\n    }\n\n    createEdgeSetIntersector() {\n      return new SimpleMCSweepLineIntersector();\n    }\n\n    addSelfIntersectionNodes(argIndex) {\n      for (let i = this._edges.iterator(); i.hasNext();) {\n        const e = i.next();\n        const eLoc = e.getLabel().getLocation(argIndex);\n\n        for (let eiIt = e.eiList.iterator(); eiIt.hasNext();) {\n          const ei = eiIt.next();\n          this.addSelfIntersectionNode(argIndex, ei.coord, eLoc);\n        }\n      }\n    }\n\n    add() {\n      if (arguments.length === 1 && arguments[0] instanceof Geometry) {\n        const g = arguments[0];\n        if (g.isEmpty()) return null;\n        if (g instanceof MultiPolygon) this._useBoundaryDeterminationRule = false;\n        if (g instanceof Polygon) this.addPolygon(g);else if (g instanceof LineString) this.addLineString(g);else if (g instanceof Point) this.addPoint(g);else if (g instanceof MultiPoint) this.addCollection(g);else if (g instanceof MultiLineString) this.addCollection(g);else if (g instanceof MultiPolygon) this.addCollection(g);else if (g instanceof GeometryCollection) this.addCollection(g);else throw new UnsupportedOperationException(g.getGeometryType());\n      } else {\n        return super.add.apply(this, arguments);\n      }\n    }\n\n    addCollection(gc) {\n      for (let i = 0; i < gc.getNumGeometries(); i++) {\n        const g = gc.getGeometryN(i);\n        this.add(g);\n      }\n    }\n\n    locate(pt) {\n      if (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {\n        if (this._areaPtLocator === null) this._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);\n        return this._areaPtLocator.locate(pt);\n      }\n\n      return this._ptLocator.locate(pt, this._parentGeom);\n    }\n\n    findEdge() {\n      if (arguments.length === 1 && arguments[0] instanceof LineString) {\n        const line = arguments[0];\n        return this._lineEdgeMap.get(line);\n      } else {\n        return super.findEdge.apply(this, arguments);\n      }\n    }\n\n  }\n\n  var geomgraph = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    GeometryGraph: GeometryGraph\n  });\n\n  class KdNodeVisitor {\n    visit(node) {}\n\n  }\n\n  class KdNode {\n    constructor() {\n      KdNode.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._p = null;\n      this._data = null;\n      this._left = null;\n      this._right = null;\n      this._count = null;\n\n      if (arguments.length === 2) {\n        const p = arguments[0],\n              data = arguments[1];\n        this._p = new Coordinate(p);\n        this._left = null;\n        this._right = null;\n        this._count = 1;\n        this._data = data;\n      } else if (arguments.length === 3) {\n        const _x = arguments[0],\n              _y = arguments[1],\n              data = arguments[2];\n        this._p = new Coordinate(_x, _y);\n        this._left = null;\n        this._right = null;\n        this._count = 1;\n        this._data = data;\n      }\n    }\n\n    isRepeated() {\n      return this._count > 1;\n    }\n\n    getRight() {\n      return this._right;\n    }\n\n    getCoordinate() {\n      return this._p;\n    }\n\n    setLeft(_left) {\n      this._left = _left;\n    }\n\n    getX() {\n      return this._p.x;\n    }\n\n    getData() {\n      return this._data;\n    }\n\n    getCount() {\n      return this._count;\n    }\n\n    getLeft() {\n      return this._left;\n    }\n\n    getY() {\n      return this._p.y;\n    }\n\n    increment() {\n      this._count = this._count + 1;\n    }\n\n    setRight(_right) {\n      this._right = _right;\n    }\n\n  }\n\n  class KdTree {\n    constructor() {\n      KdTree.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._root = null;\n      this._numberOfNodes = null;\n      this._tolerance = null;\n\n      if (arguments.length === 0) {\n        KdTree.constructor_.call(this, 0.0);\n      } else if (arguments.length === 1) {\n        const tolerance = arguments[0];\n        this._tolerance = tolerance;\n      }\n    }\n\n    static toCoordinates() {\n      if (arguments.length === 1) {\n        const kdnodes = arguments[0];\n        return KdTree.toCoordinates(kdnodes, false);\n      } else if (arguments.length === 2) {\n        const kdnodes = arguments[0],\n              includeRepeated = arguments[1];\n        const coord = new CoordinateList();\n\n        for (let it = kdnodes.iterator(); it.hasNext();) {\n          const node = it.next();\n          const count = includeRepeated ? node.getCount() : 1;\n\n          for (let i = 0; i < count; i++) coord.add(node.getCoordinate(), true);\n        }\n\n        return coord.toCoordinateArray();\n      }\n    }\n\n    insert() {\n      if (arguments.length === 1) {\n        const p = arguments[0];\n        return this.insert(p, null);\n      } else if (arguments.length === 2) {\n        const p = arguments[0],\n              data = arguments[1];\n\n        if (this._root === null) {\n          this._root = new KdNode(p, data);\n          return this._root;\n        }\n\n        if (this._tolerance > 0) {\n          const matchNode = this.findBestMatchNode(p);\n\n          if (matchNode !== null) {\n            matchNode.increment();\n            return matchNode;\n          }\n        }\n\n        return this.insertExact(p, data);\n      }\n    }\n\n    query() {\n      if (arguments.length === 1) {\n        const queryEnv = arguments[0];\n        const result = new ArrayList();\n        this.query(queryEnv, result);\n        return result;\n      } else if (arguments.length === 2) {\n        if (arguments[0] instanceof Envelope && hasInterface(arguments[1], List)) {\n          const queryEnv = arguments[0],\n                result = arguments[1];\n          this.queryNode(this._root, queryEnv, true, new class {\n            get interfaces_() {\n              return [KdNodeVisitor];\n            }\n\n            visit(node) {\n              result.add(node);\n            }\n\n          }());\n        } else if (arguments[0] instanceof Envelope && hasInterface(arguments[1], KdNodeVisitor)) {\n          const queryEnv = arguments[0],\n                visitor = arguments[1];\n          this.queryNode(this._root, queryEnv, true, visitor);\n        }\n      }\n    }\n\n    queryNode(currentNode, queryEnv, odd, visitor) {\n      if (currentNode === null) return null;\n      let min = null;\n      let max = null;\n      let discriminant = null;\n\n      if (odd) {\n        min = queryEnv.getMinX();\n        max = queryEnv.getMaxX();\n        discriminant = currentNode.getX();\n      } else {\n        min = queryEnv.getMinY();\n        max = queryEnv.getMaxY();\n        discriminant = currentNode.getY();\n      }\n\n      const searchLeft = min < discriminant;\n      const searchRight = discriminant <= max;\n      if (searchLeft) this.queryNode(currentNode.getLeft(), queryEnv, !odd, visitor);\n      if (queryEnv.contains(currentNode.getCoordinate())) visitor.visit(currentNode);\n      if (searchRight) this.queryNode(currentNode.getRight(), queryEnv, !odd, visitor);\n    }\n\n    findBestMatchNode(p) {\n      const visitor = new BestMatchVisitor(p, this._tolerance);\n      this.query(visitor.queryEnvelope(), visitor);\n      return visitor.getNode();\n    }\n\n    isEmpty() {\n      if (this._root === null) return true;\n      return false;\n    }\n\n    insertExact(p, data) {\n      let currentNode = this._root;\n      let leafNode = this._root;\n      let isOddLevel = true;\n      let isLessThan = true;\n\n      while (currentNode !== null) {\n        if (currentNode !== null) {\n          const isInTolerance = p.distance(currentNode.getCoordinate()) <= this._tolerance;\n\n          if (isInTolerance) {\n            currentNode.increment();\n            return currentNode;\n          }\n        }\n\n        if (isOddLevel) isLessThan = p.x < currentNode.getX();else isLessThan = p.y < currentNode.getY();\n        leafNode = currentNode;\n        if (isLessThan) currentNode = currentNode.getLeft();else currentNode = currentNode.getRight();\n        isOddLevel = !isOddLevel;\n      }\n\n      this._numberOfNodes = this._numberOfNodes + 1;\n      const node = new KdNode(p, data);\n      if (isLessThan) leafNode.setLeft(node);else leafNode.setRight(node);\n      return node;\n    }\n\n  }\n\n  class BestMatchVisitor {\n    constructor() {\n      BestMatchVisitor.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._tolerance = null;\n      this._matchNode = null;\n      this._matchDist = 0.0;\n      this._p = null;\n      const p = arguments[0],\n            tolerance = arguments[1];\n      this._p = p;\n      this._tolerance = tolerance;\n    }\n\n    visit(node) {\n      const dist = this._p.distance(node.getCoordinate());\n\n      const isInTolerance = dist <= this._tolerance;\n      if (!isInTolerance) return null;\n      let update = false;\n      if (this._matchNode === null || dist < this._matchDist || this._matchNode !== null && dist === this._matchDist && node.getCoordinate().compareTo(this._matchNode.getCoordinate()) < 1) update = true;\n\n      if (update) {\n        this._matchNode = node;\n        this._matchDist = dist;\n      }\n    }\n\n    queryEnvelope() {\n      const queryEnv = new Envelope(this._p);\n      queryEnv.expandBy(this._tolerance);\n      return queryEnv;\n    }\n\n    getNode() {\n      return this._matchNode;\n    }\n\n    get interfaces_() {\n      return [KdNodeVisitor];\n    }\n\n  }\n\n  KdTree.BestMatchVisitor = BestMatchVisitor;\n\n  var kdtree = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    KdTree: KdTree\n  });\n\n  class NodeBase {\n    constructor() {\n      NodeBase.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._items = new ArrayList();\n      this._subnode = new Array(4).fill(null);\n    }\n\n    static getSubnodeIndex(env, centrex, centrey) {\n      let subnodeIndex = -1;\n\n      if (env.getMinX() >= centrex) {\n        if (env.getMinY() >= centrey) subnodeIndex = 3;\n        if (env.getMaxY() <= centrey) subnodeIndex = 1;\n      }\n\n      if (env.getMaxX() <= centrex) {\n        if (env.getMinY() >= centrey) subnodeIndex = 2;\n        if (env.getMaxY() <= centrey) subnodeIndex = 0;\n      }\n\n      return subnodeIndex;\n    }\n\n    hasChildren() {\n      for (let i = 0; i < 4; i++) if (this._subnode[i] !== null) return true;\n\n      return false;\n    }\n\n    isPrunable() {\n      return !(this.hasChildren() || this.hasItems());\n    }\n\n    addAllItems(resultItems) {\n      resultItems.addAll(this._items);\n\n      for (let i = 0; i < 4; i++) if (this._subnode[i] !== null) this._subnode[i].addAllItems(resultItems);\n\n      return resultItems;\n    }\n\n    getNodeCount() {\n      let subSize = 0;\n\n      for (let i = 0; i < 4; i++) if (this._subnode[i] !== null) subSize += this._subnode[i].size();\n\n      return subSize + 1;\n    }\n\n    size() {\n      let subSize = 0;\n\n      for (let i = 0; i < 4; i++) if (this._subnode[i] !== null) subSize += this._subnode[i].size();\n\n      return subSize + this._items.size();\n    }\n\n    addAllItemsFromOverlapping(searchEnv, resultItems) {\n      if (!this.isSearchMatch(searchEnv)) return null;\n      resultItems.addAll(this._items);\n\n      for (let i = 0; i < 4; i++) if (this._subnode[i] !== null) this._subnode[i].addAllItemsFromOverlapping(searchEnv, resultItems);\n    }\n\n    visitItems(searchEnv, visitor) {\n      for (let i = this._items.iterator(); i.hasNext();) visitor.visitItem(i.next());\n    }\n\n    hasItems() {\n      return !this._items.isEmpty();\n    }\n\n    remove(itemEnv, item) {\n      if (!this.isSearchMatch(itemEnv)) return false;\n      let found = false;\n\n      for (let i = 0; i < 4; i++) if (this._subnode[i] !== null) {\n        found = this._subnode[i].remove(itemEnv, item);\n\n        if (found) {\n          if (this._subnode[i].isPrunable()) this._subnode[i] = null;\n          break;\n        }\n      }\n\n      if (found) return found;\n      found = this._items.remove(item);\n      return found;\n    }\n\n    visit(searchEnv, visitor) {\n      if (!this.isSearchMatch(searchEnv)) return null;\n      this.visitItems(searchEnv, visitor);\n\n      for (let i = 0; i < 4; i++) if (this._subnode[i] !== null) this._subnode[i].visit(searchEnv, visitor);\n    }\n\n    getItems() {\n      return this._items;\n    }\n\n    depth() {\n      let maxSubDepth = 0;\n\n      for (let i = 0; i < 4; i++) if (this._subnode[i] !== null) {\n        const sqd = this._subnode[i].depth();\n\n        if (sqd > maxSubDepth) maxSubDepth = sqd;\n      }\n\n      return maxSubDepth + 1;\n    }\n\n    isEmpty() {\n      let isEmpty = true;\n      if (!this._items.isEmpty()) isEmpty = false;else for (let i = 0; i < 4; i++) if (this._subnode[i] !== null) if (!this._subnode[i].isEmpty()) {\n        isEmpty = false;\n        break;\n      }\n      return isEmpty;\n    }\n\n    add(item) {\n      this._items.add(item);\n    }\n\n    get interfaces_() {\n      return [Serializable];\n    }\n\n  }\n\n  function DoubleBits() {}\n\n  DoubleBits.exponent = function (d) {\n    return CVTFWD(64, d) - 1023;\n  };\n\n  DoubleBits.powerOf2 = function (exp) {\n    return Math.pow(2, exp);\n  };\n  /**\n   * Calculates the exponent of the bit-pattern for a number. Uses code from:\n   * http://www.merlyn.demon.co.uk/js-exact.htm\n   *\n   * @param {Number}\n   *          NumW 32 or 64 to denote the number of bits.\n   * @param {Number}\n   *          Qty the number to calculate the bit pattern for.\n   * @return {Number} The integer value of the exponent.\n   * @private\n   */\n\n\n  function CVTFWD(NumW, Qty) {\n    let Sign;\n    let Expo;\n    let Mant;\n    let Bin;\n    const Inf = {\n      32: {\n        d: 0x7F,\n        c: 0x80,\n        b: 0,\n        a: 0\n      },\n      64: {\n        d: 0x7FF0,\n        c: 0,\n        b: 0,\n        a: 0\n      }\n    };\n    const ExW = {\n      32: 8,\n      64: 11\n    }[NumW];\n\n    if (!Bin) {\n      Sign = Qty < 0 || 1 / Qty < 0; // OK for +-0\n\n      if (!isFinite(Qty)) {\n        Bin = Inf[NumW];\n        if (Sign) Bin.d += 1 << NumW / 4 - 1;\n        Expo = Math.pow(2, ExW) - 1;\n        Mant = 0;\n      }\n    }\n\n    if (!Bin) {\n      Expo = {\n        32: 127,\n        64: 1023\n      }[NumW];\n      Mant = Math.abs(Qty);\n\n      while (Mant >= 2) {\n        Expo++;\n        Mant /= 2;\n      }\n\n      while (Mant < 1 && Expo > 0) {\n        Expo--;\n        Mant *= 2;\n      }\n\n      if (Expo <= 0) Mant /= 2;\n\n      if (NumW === 32 && Expo > 254) {\n        Bin = {\n          d: Sign ? 0xFF : 0x7F,\n          c: 0x80,\n          b: 0,\n          a: 0\n        };\n        Expo = Math.pow(2, ExW) - 1;\n        Mant = 0;\n      }\n    }\n\n    return Expo;\n  }\n\n  class Key {\n    constructor() {\n      Key.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._pt = new Coordinate();\n      this._level = 0;\n      this._env = null;\n      const itemEnv = arguments[0];\n      this.computeKey(itemEnv);\n    }\n\n    static computeQuadLevel(env) {\n      const dx = env.getWidth();\n      const dy = env.getHeight();\n      const dMax = dx > dy ? dx : dy;\n      const level = DoubleBits.exponent(dMax) + 1;\n      return level;\n    }\n\n    getLevel() {\n      return this._level;\n    }\n\n    computeKey() {\n      if (arguments.length === 1) {\n        const itemEnv = arguments[0];\n        this._level = Key.computeQuadLevel(itemEnv);\n        this._env = new Envelope();\n        this.computeKey(this._level, itemEnv);\n\n        while (!this._env.contains(itemEnv)) {\n          this._level += 1;\n          this.computeKey(this._level, itemEnv);\n        }\n      } else if (arguments.length === 2) {\n        const level = arguments[0],\n              itemEnv = arguments[1];\n        const quadSize = DoubleBits.powerOf2(level);\n        this._pt.x = Math.floor(itemEnv.getMinX() / quadSize) * quadSize;\n        this._pt.y = Math.floor(itemEnv.getMinY() / quadSize) * quadSize;\n\n        this._env.init(this._pt.x, this._pt.x + quadSize, this._pt.y, this._pt.y + quadSize);\n      }\n    }\n\n    getEnvelope() {\n      return this._env;\n    }\n\n    getCentre() {\n      return new Coordinate((this._env.getMinX() + this._env.getMaxX()) / 2, (this._env.getMinY() + this._env.getMaxY()) / 2);\n    }\n\n    getPoint() {\n      return this._pt;\n    }\n\n  }\n\n  class Node$1 extends NodeBase {\n    constructor() {\n      super();\n      Node$1.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._env = null;\n      this._centrex = null;\n      this._centrey = null;\n      this._level = null;\n      const env = arguments[0],\n            level = arguments[1];\n      this._env = env;\n      this._level = level;\n      this._centrex = (env.getMinX() + env.getMaxX()) / 2;\n      this._centrey = (env.getMinY() + env.getMaxY()) / 2;\n    }\n\n    static createNode(env) {\n      const key = new Key(env);\n      const node = new Node$1(key.getEnvelope(), key.getLevel());\n      return node;\n    }\n\n    static createExpanded(node, addEnv) {\n      const expandEnv = new Envelope(addEnv);\n      if (node !== null) expandEnv.expandToInclude(node._env);\n      const largerNode = Node$1.createNode(expandEnv);\n      if (node !== null) largerNode.insertNode(node);\n      return largerNode;\n    }\n\n    find(searchEnv) {\n      const subnodeIndex = NodeBase.getSubnodeIndex(searchEnv, this._centrex, this._centrey);\n      if (subnodeIndex === -1) return this;\n\n      if (this._subnode[subnodeIndex] !== null) {\n        const node = this._subnode[subnodeIndex];\n        return node.find(searchEnv);\n      }\n\n      return this;\n    }\n\n    isSearchMatch(searchEnv) {\n      if (searchEnv === null) return false;\n      return this._env.intersects(searchEnv);\n    }\n\n    getSubnode(index) {\n      if (this._subnode[index] === null) this._subnode[index] = this.createSubnode(index);\n      return this._subnode[index];\n    }\n\n    getEnvelope() {\n      return this._env;\n    }\n\n    getNode(searchEnv) {\n      const subnodeIndex = NodeBase.getSubnodeIndex(searchEnv, this._centrex, this._centrey);\n\n      if (subnodeIndex !== -1) {\n        const node = this.getSubnode(subnodeIndex);\n        return node.getNode(searchEnv);\n      } else {\n        return this;\n      }\n    }\n\n    createSubnode(index) {\n      let minx = 0.0;\n      let maxx = 0.0;\n      let miny = 0.0;\n      let maxy = 0.0;\n\n      switch (index) {\n        case 0:\n          minx = this._env.getMinX();\n          maxx = this._centrex;\n          miny = this._env.getMinY();\n          maxy = this._centrey;\n          break;\n\n        case 1:\n          minx = this._centrex;\n          maxx = this._env.getMaxX();\n          miny = this._env.getMinY();\n          maxy = this._centrey;\n          break;\n\n        case 2:\n          minx = this._env.getMinX();\n          maxx = this._centrex;\n          miny = this._centrey;\n          maxy = this._env.getMaxY();\n          break;\n\n        case 3:\n          minx = this._centrex;\n          maxx = this._env.getMaxX();\n          miny = this._centrey;\n          maxy = this._env.getMaxY();\n          break;\n      }\n\n      const sqEnv = new Envelope(minx, maxx, miny, maxy);\n      const node = new Node$1(sqEnv, this._level - 1);\n      return node;\n    }\n\n    insertNode(node) {\n      Assert.isTrue(this._env === null || this._env.contains(node._env));\n      const index = NodeBase.getSubnodeIndex(node._env, this._centrex, this._centrey);\n\n      if (node._level === this._level - 1) {\n        this._subnode[index] = node;\n      } else {\n        const childNode = this.createSubnode(index);\n        childNode.insertNode(node);\n        this._subnode[index] = childNode;\n      }\n    }\n\n  }\n\n  class IntervalSize {\n    static isZeroWidth(min, max) {\n      const width = max - min;\n      if (width === 0.0) return true;\n      const maxAbs = Math.max(Math.abs(min), Math.abs(max));\n      const scaledInterval = width / maxAbs;\n      const level = DoubleBits.exponent(scaledInterval);\n      return level <= IntervalSize.MIN_BINARY_EXPONENT;\n    }\n\n  }\n  IntervalSize.MIN_BINARY_EXPONENT = -50;\n\n  class Root extends NodeBase {\n    constructor() {\n      super();\n    }\n\n    insert(itemEnv, item) {\n      const index = NodeBase.getSubnodeIndex(itemEnv, Root.origin.x, Root.origin.y);\n\n      if (index === -1) {\n        this.add(item);\n        return null;\n      }\n\n      const node = this._subnode[index];\n\n      if (node === null || !node.getEnvelope().contains(itemEnv)) {\n        const largerNode = Node$1.createExpanded(node, itemEnv);\n        this._subnode[index] = largerNode;\n      }\n\n      this.insertContained(this._subnode[index], itemEnv, item);\n    }\n\n    isSearchMatch(searchEnv) {\n      return true;\n    }\n\n    insertContained(tree, itemEnv, item) {\n      Assert.isTrue(tree.getEnvelope().contains(itemEnv));\n      const isZeroX = IntervalSize.isZeroWidth(itemEnv.getMinX(), itemEnv.getMaxX());\n      const isZeroY = IntervalSize.isZeroWidth(itemEnv.getMinY(), itemEnv.getMaxY());\n      let node = null;\n      if (isZeroX || isZeroY) node = tree.find(itemEnv);else node = tree.getNode(itemEnv);\n      node.add(item);\n    }\n\n  }\n  Root.origin = new Coordinate(0.0, 0.0);\n\n  class SpatialIndex {\n    insert(itemEnv, item) {}\n\n    remove(itemEnv, item) {}\n\n    query() {\n    }\n\n  }\n\n  class Quadtree {\n    constructor() {\n      Quadtree.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._root = null;\n      this._minExtent = 1.0;\n      this._root = new Root();\n    }\n\n    static ensureExtent(itemEnv, minExtent) {\n      let minx = itemEnv.getMinX();\n      let maxx = itemEnv.getMaxX();\n      let miny = itemEnv.getMinY();\n      let maxy = itemEnv.getMaxY();\n      if (minx !== maxx && miny !== maxy) return itemEnv;\n\n      if (minx === maxx) {\n        minx = minx - minExtent / 2.0;\n        maxx = maxx + minExtent / 2.0;\n      }\n\n      if (miny === maxy) {\n        miny = miny - minExtent / 2.0;\n        maxy = maxy + minExtent / 2.0;\n      }\n\n      return new Envelope(minx, maxx, miny, maxy);\n    }\n\n    size() {\n      if (this._root !== null) return this._root.size();\n      return 0;\n    }\n\n    insert(itemEnv, item) {\n      this.collectStats(itemEnv);\n      const insertEnv = Quadtree.ensureExtent(itemEnv, this._minExtent);\n\n      this._root.insert(insertEnv, item);\n    }\n\n    query() {\n      if (arguments.length === 1) {\n        const searchEnv = arguments[0];\n        const visitor = new ArrayListVisitor();\n        this.query(searchEnv, visitor);\n        return visitor.getItems();\n      } else if (arguments.length === 2) {\n        const searchEnv = arguments[0],\n              visitor = arguments[1];\n\n        this._root.visit(searchEnv, visitor);\n      }\n    }\n\n    queryAll() {\n      const foundItems = new ArrayList();\n\n      this._root.addAllItems(foundItems);\n\n      return foundItems;\n    }\n\n    remove(itemEnv, item) {\n      const posEnv = Quadtree.ensureExtent(itemEnv, this._minExtent);\n      return this._root.remove(posEnv, item);\n    }\n\n    collectStats(itemEnv) {\n      const delX = itemEnv.getWidth();\n      if (delX < this._minExtent && delX > 0.0) this._minExtent = delX;\n      const delY = itemEnv.getHeight();\n      if (delY < this._minExtent && delY > 0.0) this._minExtent = delY;\n    }\n\n    depth() {\n      if (this._root !== null) return this._root.depth();\n      return 0;\n    }\n\n    isEmpty() {\n      if (this._root === null) return true;\n      return this._root.isEmpty();\n    }\n\n    get interfaces_() {\n      return [SpatialIndex, Serializable];\n    }\n\n  }\n\n  var quadtree = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Quadtree: Quadtree\n  });\n\n  class Boundable {\n    getBounds() {}\n\n  }\n\n  class ItemBoundable {\n    constructor() {\n      ItemBoundable.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._bounds = null;\n      this._item = null;\n      const bounds = arguments[0],\n            item = arguments[1];\n      this._bounds = bounds;\n      this._item = item;\n    }\n\n    getItem() {\n      return this._item;\n    }\n\n    getBounds() {\n      return this._bounds;\n    }\n\n    get interfaces_() {\n      return [Boundable, Serializable];\n    }\n\n  }\n\n  class PriorityQueue {\n    constructor() {\n      PriorityQueue.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._size = null;\n      this._items = null;\n      this._size = 0;\n      this._items = new ArrayList();\n\n      this._items.add(null);\n    }\n\n    poll() {\n      if (this.isEmpty()) return null;\n\n      const minItem = this._items.get(1);\n\n      this._items.set(1, this._items.get(this._size));\n\n      this._size -= 1;\n      this.reorder(1);\n      return minItem;\n    }\n\n    size() {\n      return this._size;\n    }\n\n    reorder(hole) {\n      let child = null;\n\n      const tmp = this._items.get(hole);\n\n      for (; hole * 2 <= this._size; hole = child) {\n        child = hole * 2;\n        if (child !== this._size && this._items.get(child + 1).compareTo(this._items.get(child)) < 0) child++;\n        if (this._items.get(child).compareTo(tmp) < 0) this._items.set(hole, this._items.get(child));else break;\n      }\n\n      this._items.set(hole, tmp);\n    }\n\n    clear() {\n      this._size = 0;\n\n      this._items.clear();\n    }\n\n    peek() {\n      if (this.isEmpty()) return null;\n\n      const minItem = this._items.get(1);\n\n      return minItem;\n    }\n\n    isEmpty() {\n      return this._size === 0;\n    }\n\n    add(x) {\n      this._items.add(null);\n\n      this._size += 1;\n      let hole = this._size;\n\n      this._items.set(0, x);\n\n      for (; x.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) this._items.set(hole, this._items.get(Math.trunc(hole / 2)));\n\n      this._items.set(hole, x);\n    }\n\n  }\n\n  class AbstractNode {\n    constructor() {\n      AbstractNode.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._childBoundables = new ArrayList();\n      this._bounds = null;\n      this._level = null;\n\n      if (arguments.length === 0) ; else if (arguments.length === 1) {\n        const level = arguments[0];\n        this._level = level;\n      }\n    }\n\n    getLevel() {\n      return this._level;\n    }\n\n    size() {\n      return this._childBoundables.size();\n    }\n\n    getChildBoundables() {\n      return this._childBoundables;\n    }\n\n    addChildBoundable(childBoundable) {\n      Assert.isTrue(this._bounds === null);\n\n      this._childBoundables.add(childBoundable);\n    }\n\n    isEmpty() {\n      return this._childBoundables.isEmpty();\n    }\n\n    getBounds() {\n      if (this._bounds === null) this._bounds = this.computeBounds();\n      return this._bounds;\n    }\n\n    get interfaces_() {\n      return [Boundable, Serializable];\n    }\n\n  }\n\n  class EnvelopeDistance {\n    static maxDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n      let dist = EnvelopeDistance.distance(ax1, ay1, bx1, by1);\n      dist = Math.max(dist, EnvelopeDistance.distance(ax1, ay1, bx2, by2));\n      dist = Math.max(dist, EnvelopeDistance.distance(ax2, ay2, bx1, by1));\n      dist = Math.max(dist, EnvelopeDistance.distance(ax2, ay2, bx2, by2));\n      return dist;\n    }\n\n    static distance(x1, y1, x2, y2) {\n      const dx = x2 - x1;\n      const dy = y2 - y1;\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    static maximumDistance(env1, env2) {\n      const minx = Math.min(env1.getMinX(), env2.getMinX());\n      const miny = Math.min(env1.getMinY(), env2.getMinY());\n      const maxx = Math.max(env1.getMaxX(), env2.getMaxX());\n      const maxy = Math.max(env1.getMaxY(), env2.getMaxY());\n      return EnvelopeDistance.distance(minx, miny, maxx, maxy);\n    }\n\n    static minMaxDistance(a, b) {\n      const aminx = a.getMinX();\n      const aminy = a.getMinY();\n      const amaxx = a.getMaxX();\n      const amaxy = a.getMaxY();\n      const bminx = b.getMinX();\n      const bminy = b.getMinY();\n      const bmaxx = b.getMaxX();\n      const bmaxy = b.getMaxY();\n      let dist = EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bminx, bminy, bminx, bmaxy);\n      dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bminx, bminy, bmaxx, bminy));\n      dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bmaxx, bmaxy, bminx, bmaxy));\n      dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bmaxx, bmaxy, bmaxx, bminy));\n      dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bminx, bminy, bminx, bmaxy));\n      dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bminx, bminy, bmaxx, bminy));\n      dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bmaxx, bmaxy, bminx, bmaxy));\n      dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bmaxx, bmaxy, bmaxx, bminy));\n      dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bminx, bminy, bminx, bmaxy));\n      dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bminx, bminy, bmaxx, bminy));\n      dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bmaxx, bmaxy, bminx, bmaxy));\n      dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bmaxx, bmaxy, bmaxx, bminy));\n      dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bminx, bminy, bminx, bmaxy));\n      dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bminx, bminy, bmaxx, bminy));\n      dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bmaxx, bmaxy, bminx, bmaxy));\n      dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bmaxx, bmaxy, bmaxx, bminy));\n      return dist;\n    }\n\n  }\n\n  class BoundablePair {\n    constructor() {\n      BoundablePair.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._boundable1 = null;\n      this._boundable2 = null;\n      this._distance = null;\n      this._itemDistance = null;\n      const boundable1 = arguments[0],\n            boundable2 = arguments[1],\n            itemDistance = arguments[2];\n      this._boundable1 = boundable1;\n      this._boundable2 = boundable2;\n      this._itemDistance = itemDistance;\n      this._distance = this.distance();\n    }\n\n    static area(b) {\n      return b.getBounds().getArea();\n    }\n\n    static isComposite(item) {\n      return item instanceof AbstractNode;\n    }\n\n    maximumDistance() {\n      return EnvelopeDistance.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds());\n    }\n\n    expandToQueue(priQ, minDistance) {\n      const isComp1 = BoundablePair.isComposite(this._boundable1);\n      const isComp2 = BoundablePair.isComposite(this._boundable2);\n\n      if (isComp1 && isComp2) {\n        if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {\n          this.expand(this._boundable1, this._boundable2, false, priQ, minDistance);\n          return null;\n        } else {\n          this.expand(this._boundable2, this._boundable1, true, priQ, minDistance);\n          return null;\n        }\n      } else if (isComp1) {\n        this.expand(this._boundable1, this._boundable2, false, priQ, minDistance);\n        return null;\n      } else if (isComp2) {\n        this.expand(this._boundable2, this._boundable1, true, priQ, minDistance);\n        return null;\n      }\n\n      throw new IllegalArgumentException('neither boundable is composite');\n    }\n\n    isLeaves() {\n      return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2));\n    }\n\n    compareTo(o) {\n      const nd = o;\n      if (this._distance < nd._distance) return -1;\n      if (this._distance > nd._distance) return 1;\n      return 0;\n    }\n\n    expand(bndComposite, bndOther, isFlipped, priQ, minDistance) {\n      const children = bndComposite.getChildBoundables();\n\n      for (let i = children.iterator(); i.hasNext();) {\n        const child = i.next();\n        let bp = null;\n        if (isFlipped) bp = new BoundablePair(bndOther, child, this._itemDistance);else bp = new BoundablePair(child, bndOther, this._itemDistance);\n        if (bp.getDistance() < minDistance) priQ.add(bp);\n      }\n    }\n\n    getBoundable(i) {\n      if (i === 0) return this._boundable1;\n      return this._boundable2;\n    }\n\n    getDistance() {\n      return this._distance;\n    }\n\n    distance() {\n      if (this.isLeaves()) return this._itemDistance.distance(this._boundable1, this._boundable2);\n      return this._boundable1.getBounds().distance(this._boundable2.getBounds());\n    }\n\n    get interfaces_() {\n      return [Comparable];\n    }\n\n  }\n\n  class AbstractSTRtree {\n    constructor() {\n      AbstractSTRtree.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._root = null;\n      this._built = false;\n      this._itemBoundables = new ArrayList();\n      this._nodeCapacity = null;\n\n      if (arguments.length === 0) {\n        AbstractSTRtree.constructor_.call(this, AbstractSTRtree.DEFAULT_NODE_CAPACITY);\n      } else if (arguments.length === 1) {\n        const nodeCapacity = arguments[0];\n        Assert.isTrue(nodeCapacity > 1, 'Node capacity must be greater than 1');\n        this._nodeCapacity = nodeCapacity;\n      }\n    }\n\n    static compareDoubles(a, b) {\n      return a > b ? 1 : a < b ? -1 : 0;\n    }\n\n    queryInternal() {\n      if (hasInterface(arguments[2], ItemVisitor) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n        const searchBounds = arguments[0],\n              node = arguments[1],\n              visitor = arguments[2];\n        const childBoundables = node.getChildBoundables();\n\n        for (let i = 0; i < childBoundables.size(); i++) {\n          const childBoundable = childBoundables.get(i);\n          if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) continue;\n          if (childBoundable instanceof AbstractNode) this.queryInternal(searchBounds, childBoundable, visitor);else if (childBoundable instanceof ItemBoundable) visitor.visitItem(childBoundable.getItem());else Assert.shouldNeverReachHere();\n        }\n      } else if (hasInterface(arguments[2], List) && arguments[0] instanceof Object && arguments[1] instanceof AbstractNode) {\n        const searchBounds = arguments[0],\n              node = arguments[1],\n              matches = arguments[2];\n        const childBoundables = node.getChildBoundables();\n\n        for (let i = 0; i < childBoundables.size(); i++) {\n          const childBoundable = childBoundables.get(i);\n          if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) continue;\n          if (childBoundable instanceof AbstractNode) this.queryInternal(searchBounds, childBoundable, matches);else if (childBoundable instanceof ItemBoundable) matches.add(childBoundable.getItem());else Assert.shouldNeverReachHere();\n        }\n      }\n    }\n\n    getNodeCapacity() {\n      return this._nodeCapacity;\n    }\n\n    lastNode(nodes) {\n      return nodes.get(nodes.size() - 1);\n    }\n\n    size() {\n      if (arguments.length === 0) {\n        if (this.isEmpty()) return 0;\n        this.build();\n        return this.size(this._root);\n      } else if (arguments.length === 1) {\n        const node = arguments[0];\n        let size = 0;\n\n        for (let i = node.getChildBoundables().iterator(); i.hasNext();) {\n          const childBoundable = i.next();\n          if (childBoundable instanceof AbstractNode) size += this.size(childBoundable);else if (childBoundable instanceof ItemBoundable) size += 1;\n        }\n\n        return size;\n      }\n    }\n\n    removeItem(node, item) {\n      let childToRemove = null;\n\n      for (let i = node.getChildBoundables().iterator(); i.hasNext();) {\n        const childBoundable = i.next();\n        if (childBoundable instanceof ItemBoundable) if (childBoundable.getItem() === item) childToRemove = childBoundable;\n      }\n\n      if (childToRemove !== null) {\n        node.getChildBoundables().remove(childToRemove);\n        return true;\n      }\n\n      return false;\n    }\n\n    itemsTree() {\n      if (arguments.length === 0) {\n        this.build();\n        const valuesTree = this.itemsTree(this._root);\n        if (valuesTree === null) return new ArrayList();\n        return valuesTree;\n      } else if (arguments.length === 1) {\n        const node = arguments[0];\n        const valuesTreeForNode = new ArrayList();\n\n        for (let i = node.getChildBoundables().iterator(); i.hasNext();) {\n          const childBoundable = i.next();\n\n          if (childBoundable instanceof AbstractNode) {\n            const valuesTreeForChild = this.itemsTree(childBoundable);\n            if (valuesTreeForChild !== null) valuesTreeForNode.add(valuesTreeForChild);\n          } else if (childBoundable instanceof ItemBoundable) {\n            valuesTreeForNode.add(childBoundable.getItem());\n          } else {\n            Assert.shouldNeverReachHere();\n          }\n        }\n\n        if (valuesTreeForNode.size() <= 0) return null;\n        return valuesTreeForNode;\n      }\n    }\n\n    insert(bounds, item) {\n      Assert.isTrue(!this._built, 'Cannot insert items into an STR packed R-tree after it has been built.');\n\n      this._itemBoundables.add(new ItemBoundable(bounds, item));\n    }\n\n    boundablesAtLevel() {\n      if (arguments.length === 1) {\n        const level = arguments[0];\n        const boundables = new ArrayList();\n        this.boundablesAtLevel(level, this._root, boundables);\n        return boundables;\n      } else if (arguments.length === 3) {\n        const level = arguments[0],\n              top = arguments[1],\n              boundables = arguments[2];\n        Assert.isTrue(level > -2);\n\n        if (top.getLevel() === level) {\n          boundables.add(top);\n          return null;\n        }\n\n        for (let i = top.getChildBoundables().iterator(); i.hasNext();) {\n          const boundable = i.next();\n\n          if (boundable instanceof AbstractNode) {\n            this.boundablesAtLevel(level, boundable, boundables);\n          } else {\n            Assert.isTrue(boundable instanceof ItemBoundable);\n            if (level === -1) boundables.add(boundable);\n          }\n        }\n\n        return null;\n      }\n    }\n\n    query() {\n      if (arguments.length === 1) {\n        const searchBounds = arguments[0];\n        this.build();\n        const matches = new ArrayList();\n        if (this.isEmpty()) return matches;\n        if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) this.queryInternal(searchBounds, this._root, matches);\n        return matches;\n      } else if (arguments.length === 2) {\n        const searchBounds = arguments[0],\n              visitor = arguments[1];\n        this.build();\n        if (this.isEmpty()) return null;\n        if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) this.queryInternal(searchBounds, this._root, visitor);\n      }\n    }\n\n    build() {\n      if (this._built) return null;\n      this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);\n      this._itemBoundables = null;\n      this._built = true;\n    }\n\n    getRoot() {\n      this.build();\n      return this._root;\n    }\n\n    remove() {\n      if (arguments.length === 2) {\n        const searchBounds = arguments[0],\n              item = arguments[1];\n        this.build();\n        if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) return this.remove(searchBounds, this._root, item);\n        return false;\n      } else if (arguments.length === 3) {\n        const searchBounds = arguments[0],\n              node = arguments[1],\n              item = arguments[2];\n        let found = this.removeItem(node, item);\n        if (found) return true;\n        let childToPrune = null;\n\n        for (let i = node.getChildBoundables().iterator(); i.hasNext();) {\n          const childBoundable = i.next();\n          if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) continue;\n\n          if (childBoundable instanceof AbstractNode) {\n            found = this.remove(searchBounds, childBoundable, item);\n\n            if (found) {\n              childToPrune = childBoundable;\n              break;\n            }\n          }\n        }\n\n        if (childToPrune !== null) if (childToPrune.getChildBoundables().isEmpty()) node.getChildBoundables().remove(childToPrune);\n        return found;\n      }\n    }\n\n    createHigherLevels(boundablesOfALevel, level) {\n      Assert.isTrue(!boundablesOfALevel.isEmpty());\n      const parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);\n      if (parentBoundables.size() === 1) return parentBoundables.get(0);\n      return this.createHigherLevels(parentBoundables, level + 1);\n    }\n\n    depth() {\n      if (arguments.length === 0) {\n        if (this.isEmpty()) return 0;\n        this.build();\n        return this.depth(this._root);\n      } else if (arguments.length === 1) {\n        const node = arguments[0];\n        let maxChildDepth = 0;\n\n        for (let i = node.getChildBoundables().iterator(); i.hasNext();) {\n          const childBoundable = i.next();\n\n          if (childBoundable instanceof AbstractNode) {\n            const childDepth = this.depth(childBoundable);\n            if (childDepth > maxChildDepth) maxChildDepth = childDepth;\n          }\n        }\n\n        return maxChildDepth + 1;\n      }\n    }\n\n    createParentBoundables(childBoundables, newLevel) {\n      Assert.isTrue(!childBoundables.isEmpty());\n      const parentBoundables = new ArrayList();\n      parentBoundables.add(this.createNode(newLevel));\n      const sortedChildBoundables = new ArrayList(childBoundables);\n      Collections.sort(sortedChildBoundables, this.getComparator());\n\n      for (let i = sortedChildBoundables.iterator(); i.hasNext();) {\n        const childBoundable = i.next();\n        if (this.lastNode(parentBoundables).getChildBoundables().size() === this.getNodeCapacity()) parentBoundables.add(this.createNode(newLevel));\n        this.lastNode(parentBoundables).addChildBoundable(childBoundable);\n      }\n\n      return parentBoundables;\n    }\n\n    isEmpty() {\n      if (!this._built) return this._itemBoundables.isEmpty();\n      return this._root.isEmpty();\n    }\n\n    get interfaces_() {\n      return [Serializable];\n    }\n\n  }\n\n  function IntersectsOp$1() {}\n\n  AbstractSTRtree.IntersectsOp = IntersectsOp$1;\n  AbstractSTRtree.DEFAULT_NODE_CAPACITY = 10;\n\n  class ItemDistance {\n    distance(item1, item2) {}\n\n  }\n\n  class STRtree extends AbstractSTRtree {\n    constructor() {\n      super();\n      STRtree.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      if (arguments.length === 0) {\n        STRtree.constructor_.call(this, STRtree.DEFAULT_NODE_CAPACITY);\n      } else if (arguments.length === 1) {\n        const nodeCapacity = arguments[0];\n        AbstractSTRtree.constructor_.call(this, nodeCapacity);\n      }\n    }\n\n    static centreX(e) {\n      return STRtree.avg(e.getMinX(), e.getMaxX());\n    }\n\n    static avg(a, b) {\n      return (a + b) / 2;\n    }\n\n    static getItems(kNearestNeighbors) {\n      const items = new Array(kNearestNeighbors.size()).fill(null);\n      let count = 0;\n\n      while (!kNearestNeighbors.isEmpty()) {\n        const bp = kNearestNeighbors.poll();\n        items[count] = bp.getBoundable(0).getItem();\n        count++;\n      }\n\n      return items;\n    }\n\n    static centreY(e) {\n      return STRtree.avg(e.getMinY(), e.getMaxY());\n    }\n\n    createParentBoundablesFromVerticalSlices(verticalSlices, newLevel) {\n      Assert.isTrue(verticalSlices.length > 0);\n      const parentBoundables = new ArrayList();\n\n      for (let i = 0; i < verticalSlices.length; i++) parentBoundables.addAll(this.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));\n\n      return parentBoundables;\n    }\n\n    nearestNeighbourK() {\n      if (arguments.length === 2) {\n        const initBndPair = arguments[0],\n              k = arguments[1];\n        return this.nearestNeighbourK(initBndPair, Double.POSITIVE_INFINITY, k);\n      } else if (arguments.length === 3) {\n        const initBndPair = arguments[0],\n              maxDistance = arguments[1],\n              k = arguments[2];\n        let distanceLowerBound = maxDistance;\n        const priQ = new PriorityQueue();\n        priQ.add(initBndPair);\n        const kNearestNeighbors = new PriorityQueue();\n\n        while (!priQ.isEmpty() && distanceLowerBound >= 0.0) {\n          const bndPair = priQ.poll();\n          const pairDistance = bndPair.getDistance();\n          if (pairDistance >= distanceLowerBound) break;\n          if (bndPair.isLeaves()) {\n            if (kNearestNeighbors.size() < k) {\n              kNearestNeighbors.add(bndPair);\n            } else {\n              const bp1 = kNearestNeighbors.peek();\n\n              if (bp1.getDistance() > pairDistance) {\n                kNearestNeighbors.poll();\n                kNearestNeighbors.add(bndPair);\n              }\n\n              const bp2 = kNearestNeighbors.peek();\n              distanceLowerBound = bp2.getDistance();\n            }\n          } else bndPair.expandToQueue(priQ, distanceLowerBound);\n        }\n\n        return STRtree.getItems(kNearestNeighbors);\n      }\n    }\n\n    createNode(level) {\n      return new STRtreeNode(level);\n    }\n\n    size() {\n      if (arguments.length === 0) return super.size.call(this);else return super.size.apply(this, arguments);\n    }\n\n    insert() {\n      if (arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof Envelope) {\n        const itemEnv = arguments[0],\n              item = arguments[1];\n        if (itemEnv.isNull()) return null;\n        super.insert.call(this, itemEnv, item);\n      } else {\n        return super.insert.apply(this, arguments);\n      }\n    }\n\n    getIntersectsOp() {\n      return STRtree.intersectsOp;\n    }\n\n    verticalSlices(childBoundables, sliceCount) {\n      const sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));\n      const slices = new Array(sliceCount).fill(null);\n      const i = childBoundables.iterator();\n\n      for (let j = 0; j < sliceCount; j++) {\n        slices[j] = new ArrayList();\n        let boundablesAddedToSlice = 0;\n\n        while (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {\n          const childBoundable = i.next();\n          slices[j].add(childBoundable);\n          boundablesAddedToSlice++;\n        }\n      }\n\n      return slices;\n    }\n\n    query() {\n      if (arguments.length === 1) {\n        const searchEnv = arguments[0];\n        return super.query.call(this, searchEnv);\n      } else if (arguments.length === 2) {\n        const searchEnv = arguments[0],\n              visitor = arguments[1];\n        super.query.call(this, searchEnv, visitor);\n      }\n    }\n\n    getComparator() {\n      return STRtree.yComparator;\n    }\n\n    createParentBoundablesFromVerticalSlice(childBoundables, newLevel) {\n      return super.createParentBoundables.call(this, childBoundables, newLevel);\n    }\n\n    remove() {\n      if (arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof Envelope) {\n        const itemEnv = arguments[0],\n              item = arguments[1];\n        return super.remove.call(this, itemEnv, item);\n      } else {\n        return super.remove.apply(this, arguments);\n      }\n    }\n\n    depth() {\n      if (arguments.length === 0) return super.depth.call(this);else return super.depth.apply(this, arguments);\n    }\n\n    createParentBoundables(childBoundables, newLevel) {\n      Assert.isTrue(!childBoundables.isEmpty());\n      const minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));\n      const sortedChildBoundables = new ArrayList(childBoundables);\n      Collections.sort(sortedChildBoundables, STRtree.xComparator);\n      const verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));\n      return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel);\n    }\n\n    nearestNeighbour() {\n      if (arguments.length === 1) {\n        if (hasInterface(arguments[0], ItemDistance)) {\n          const itemDist = arguments[0];\n          if (this.isEmpty()) return null;\n          const bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);\n          return this.nearestNeighbour(bp);\n        } else if (arguments[0] instanceof BoundablePair) {\n          const initBndPair = arguments[0];\n          let distanceLowerBound = Double.POSITIVE_INFINITY;\n          let minPair = null;\n          const priQ = new PriorityQueue();\n          priQ.add(initBndPair);\n\n          while (!priQ.isEmpty() && distanceLowerBound > 0.0) {\n            const bndPair = priQ.poll();\n            const pairDistance = bndPair.getDistance();\n            if (pairDistance >= distanceLowerBound) break;\n\n            if (bndPair.isLeaves()) {\n              distanceLowerBound = pairDistance;\n              minPair = bndPair;\n            } else {\n              bndPair.expandToQueue(priQ, distanceLowerBound);\n            }\n          }\n\n          if (minPair === null) return null;\n          return [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()];\n        }\n      } else if (arguments.length === 2) {\n        const tree = arguments[0],\n              itemDist = arguments[1];\n        if (this.isEmpty() || tree.isEmpty()) return null;\n        const bp = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist);\n        return this.nearestNeighbour(bp);\n      } else if (arguments.length === 3) {\n        const env = arguments[0],\n              item = arguments[1],\n              itemDist = arguments[2];\n        const bnd = new ItemBoundable(env, item);\n        const bp = new BoundablePair(this.getRoot(), bnd, itemDist);\n        return this.nearestNeighbour(bp)[0];\n      } else if (arguments.length === 4) {\n        const env = arguments[0],\n              item = arguments[1],\n              itemDist = arguments[2],\n              k = arguments[3];\n        const bnd = new ItemBoundable(env, item);\n        const bp = new BoundablePair(this.getRoot(), bnd, itemDist);\n        return this.nearestNeighbourK(bp, k);\n      }\n    }\n\n    isWithinDistance() {\n      if (arguments.length === 2) {\n        const initBndPair = arguments[0],\n              maxDistance = arguments[1];\n        let distanceUpperBound = Double.POSITIVE_INFINITY;\n        const priQ = new PriorityQueue();\n        priQ.add(initBndPair);\n\n        while (!priQ.isEmpty()) {\n          const bndPair = priQ.poll();\n          const pairDistance = bndPair.getDistance();\n          if (pairDistance > maxDistance) return false;\n          if (bndPair.maximumDistance() <= maxDistance) return true;\n\n          if (bndPair.isLeaves()) {\n            distanceUpperBound = pairDistance;\n            if (distanceUpperBound <= maxDistance) return true;\n          } else {\n            bndPair.expandToQueue(priQ, distanceUpperBound);\n          }\n        }\n\n        return false;\n      } else if (arguments.length === 3) {\n        const tree = arguments[0],\n              itemDist = arguments[1],\n              maxDistance = arguments[2];\n        const bp = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist);\n        return this.isWithinDistance(bp, maxDistance);\n      }\n    }\n\n    get interfaces_() {\n      return [SpatialIndex, Serializable];\n    }\n\n  }\n\n  class STRtreeNode extends AbstractNode {\n    constructor() {\n      super();\n      STRtreeNode.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      const level = arguments[0];\n      AbstractNode.constructor_.call(this, level);\n    }\n\n    computeBounds() {\n      let bounds = null;\n\n      for (let i = this.getChildBoundables().iterator(); i.hasNext();) {\n        const childBoundable = i.next();\n        if (bounds === null) bounds = new Envelope(childBoundable.getBounds());else bounds.expandToInclude(childBoundable.getBounds());\n      }\n\n      return bounds;\n    }\n\n  }\n\n  STRtree.STRtreeNode = STRtreeNode;\n  STRtree.xComparator = new class {\n    get interfaces_() {\n      return [Comparator];\n    }\n\n    compare(o1, o2) {\n      return AbstractSTRtree.compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()));\n    }\n\n  }();\n  STRtree.yComparator = new class {\n    get interfaces_() {\n      return [Comparator];\n    }\n\n    compare(o1, o2) {\n      return AbstractSTRtree.compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()));\n    }\n\n  }();\n  STRtree.intersectsOp = new class {\n    get interfaces_() {\n      return [IntersectsOp];\n    }\n\n    intersects(aBounds, bBounds) {\n      return aBounds.intersects(bBounds);\n    }\n\n  }();\n  STRtree.DEFAULT_NODE_CAPACITY = 10;\n\n  var strtree = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    STRtree: STRtree\n  });\n\n  var index = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    kdtree: kdtree,\n    quadtree: quadtree,\n    strtree: strtree\n  });\n\n  const geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];\n  /**\n   * Class for reading and writing Well-Known Text.Create a new parser for GeoJSON\n   * NOTE: Adapted from OpenLayers 2.11 implementation.\n   */\n\n  /**\n   * Create a new parser for GeoJSON\n   *\n   * @param {GeometryFactory} geometryFactory\n   * @return An instance of GeoJsonParser.\n   * @constructor\n   * @private\n   */\n\n  class GeoJSONParser {\n    constructor(geometryFactory) {\n      this.geometryFactory = geometryFactory || new GeometryFactory();\n    }\n    /**\n     * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries\n     *\n     * @param {}\n     *          A GeoJSON object.\n     * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.\n     * @private\n     */\n\n\n    read(json) {\n      let obj;\n      if (typeof json === 'string') obj = JSON.parse(json);else obj = json;\n      const type = obj.type;\n      if (!parse[type]) throw new Error('Unknown GeoJSON type: ' + obj.type);\n      if (geometryTypes.indexOf(type) !== -1) return parse[type].call(this, obj.coordinates);else if (type === 'GeometryCollection') return parse[type].call(this, obj.geometries); // feature or feature collection\n\n      return parse[type].call(this, obj);\n    }\n    /**\n     * Serialize a Geometry object into GeoJSON\n     *\n     * @param {Geometry}\n     *          geometry A Geometry or array of Geometries.\n     * @return {Object} A GeoJSON object represting the input Geometry/Geometries.\n     * @private\n     */\n\n\n    write(geometry) {\n      const type = geometry.getGeometryType();\n      if (!extract[type]) throw new Error('Geometry is not supported');\n      return extract[type].call(this, geometry);\n    }\n\n  }\n  const parse = {\n    /**\n     * Parse a GeoJSON Feature object\n     *\n     * @param {Object}\n     *          obj Object to parse.\n     *\n     * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.\n     */\n    Feature: function Feature(obj) {\n      const feature = {};\n\n      for (const key in obj) feature[key] = obj[key];\n\n      if (obj.geometry) {\n        const type = obj.geometry.type;\n        if (!parse[type]) throw new Error('Unknown GeoJSON type: ' + obj.type);\n        feature.geometry = this.read(obj.geometry);\n      }\n\n      if (obj.bbox) feature.bbox = parse.bbox.call(this, obj.bbox);\n      return feature;\n    },\n\n    /**\n     * Parse a GeoJSON FeatureCollection object\n     *\n     * @param {Object}\n     *          obj Object to parse.\n     *\n     * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.\n     */\n    FeatureCollection: function FeatureCollection(obj) {\n      const featureCollection = {};\n\n      if (obj.features) {\n        featureCollection.features = [];\n\n        for (let i = 0; i < obj.features.length; ++i) featureCollection.features.push(this.read(obj.features[i]));\n      }\n\n      if (obj.bbox) featureCollection.bbox = this.parse.bbox.call(this, obj.bbox);\n      return featureCollection;\n    },\n\n    /**\n     * Convert the ordinates in an array to an array of Coordinates\n     *\n     * @param {Array}\n     *          array Array with {Number}s.\n     *\n     * @return {Array} Array with Coordinates.\n     */\n    coordinates: function coordinates(array) {\n      const coordinates = [];\n\n      for (let i = 0; i < array.length; ++i) {\n        const sub = array[i];\n        coordinates.push(new Coordinate(sub[0], sub[1]));\n      }\n\n      return coordinates;\n    },\n\n    /**\n     * Convert the bbox to a LinearRing\n     *\n     * @param {Array}\n     *          array Array with [xMin, yMin, xMax, yMax].\n     *\n     * @return {Array} Array with Coordinates.\n     */\n    bbox: function bbox(array) {\n      return this.geometryFactory.createLinearRing([new Coordinate(array[0], array[1]), new Coordinate(array[2], array[1]), new Coordinate(array[2], array[3]), new Coordinate(array[0], array[3]), new Coordinate(array[0], array[1])]);\n    },\n\n    /**\n     * Convert an Array with ordinates to a Point\n     *\n     * @param {Array}\n     *          array Array with ordinates.\n     *\n     * @return {Point} Point.\n     */\n    Point: function Point(array) {\n      const coordinate = new Coordinate(...array);\n      return this.geometryFactory.createPoint(coordinate);\n    },\n\n    /**\n     * Convert an Array with coordinates to a MultiPoint\n     *\n     * @param {Array}\n     *          array Array with coordinates.\n     *\n     * @return {MultiPoint} MultiPoint.\n     */\n    MultiPoint: function MultiPoint(array) {\n      const points = [];\n\n      for (let i = 0; i < array.length; ++i) points.push(parse.Point.call(this, array[i]));\n\n      return this.geometryFactory.createMultiPoint(points);\n    },\n\n    /**\n     * Convert an Array with coordinates to a LineString\n     *\n     * @param {Array}\n     *          array Array with coordinates.\n     *\n     * @return {LineString} LineString.\n     */\n    LineString: function LineString(array) {\n      const coordinates = parse.coordinates.call(this, array);\n      return this.geometryFactory.createLineString(coordinates);\n    },\n\n    /**\n     * Convert an Array with coordinates to a MultiLineString\n     *\n     * @param {Array}\n     *          array Array with coordinates.\n     *\n     * @return {MultiLineString} MultiLineString.\n     */\n    MultiLineString: function MultiLineString(array) {\n      const lineStrings = [];\n\n      for (let i = 0; i < array.length; ++i) lineStrings.push(parse.LineString.call(this, array[i]));\n\n      return this.geometryFactory.createMultiLineString(lineStrings);\n    },\n\n    /**\n     * Convert an Array to a Polygon\n     *\n     * @param {Array}\n     *          array Array with shell and holes.\n     *\n     * @return {Polygon} Polygon.\n     */\n    Polygon: function Polygon(array) {\n      const shellCoordinates = parse.coordinates.call(this, array[0]);\n      const shell = this.geometryFactory.createLinearRing(shellCoordinates);\n      const holes = [];\n\n      for (let i = 1; i < array.length; ++i) {\n        const hole = array[i];\n        const coordinates = parse.coordinates.call(this, hole);\n        const linearRing = this.geometryFactory.createLinearRing(coordinates);\n        holes.push(linearRing);\n      }\n\n      return this.geometryFactory.createPolygon(shell, holes);\n    },\n\n    /**\n     * Convert an Array to a MultiPolygon\n     *\n     * @param {Array}\n     *          array Array of arrays with shell and rings.\n     *\n     * @return {MultiPolygon} MultiPolygon.\n     */\n    MultiPolygon: function MultiPolygon(array) {\n      const polygons = [];\n\n      for (let i = 0; i < array.length; ++i) {\n        const polygon = array[i];\n        polygons.push(parse.Polygon.call(this, polygon));\n      }\n\n      return this.geometryFactory.createMultiPolygon(polygons);\n    },\n\n    /**\n     * Convert an Array to a GeometryCollection\n     *\n     * @param {Array}\n     *          array Array of GeoJSON geometries.\n     *\n     * @return {GeometryCollection} GeometryCollection.\n     */\n    GeometryCollection: function GeometryCollection(array) {\n      const geometries = [];\n\n      for (let i = 0; i < array.length; ++i) {\n        const geometry = array[i];\n        geometries.push(this.read(geometry));\n      }\n\n      return this.geometryFactory.createGeometryCollection(geometries);\n    }\n  };\n  const extract = {\n    /**\n     * Convert a Coordinate to an Array\n     *\n     * @param {Coordinate}\n     *          coordinate Coordinate to convert.\n     *\n     * @return {Array} Array of ordinates.\n     */\n    coordinate: function coordinate(_coordinate) {\n      const a = [_coordinate.x, _coordinate.y];\n      if (_coordinate.z) a.push(_coordinate.z);\n      if (_coordinate.m) a.push(_coordinate.m);\n      return a;\n    },\n\n    /**\n     * Convert a Point to a GeoJSON object\n     *\n     * @param {Point}\n     *          point Point to convert.\n     *\n     * @return {Array} Array of 2 ordinates (paired to a coordinate).\n     */\n    Point: function Point(point) {\n      const array = extract.coordinate.call(this, point.getCoordinate());\n      return {\n        type: 'Point',\n        coordinates: array\n      };\n    },\n\n    /**\n     * Convert a MultiPoint to a GeoJSON object\n     *\n     * @param {MultiPoint}\n     *          multipoint MultiPoint to convert.\n     *\n     * @return {Array} Array of coordinates.\n     */\n    MultiPoint: function MultiPoint(multipoint) {\n      const array = [];\n\n      for (let i = 0; i < multipoint._geometries.length; ++i) {\n        const point = multipoint._geometries[i];\n        const geoJson = extract.Point.call(this, point);\n        array.push(geoJson.coordinates);\n      }\n\n      return {\n        type: 'MultiPoint',\n        coordinates: array\n      };\n    },\n\n    /**\n     * Convert a LineString to a GeoJSON object\n     *\n     * @param {LineString}\n     *          linestring LineString to convert.\n     *\n     * @return {Array} Array of coordinates.\n     */\n    LineString: function LineString(linestring) {\n      const array = [];\n      const coordinates = linestring.getCoordinates();\n\n      for (let i = 0; i < coordinates.length; ++i) {\n        const coordinate = coordinates[i];\n        array.push(extract.coordinate.call(this, coordinate));\n      }\n\n      return {\n        type: 'LineString',\n        coordinates: array\n      };\n    },\n\n    /**\n     * Convert a MultiLineString to a GeoJSON object\n     *\n     * @param {MultiLineString}\n     *          multilinestring MultiLineString to convert.\n     *\n     * @return {Array} Array of Array of coordinates.\n     */\n    MultiLineString: function MultiLineString(multilinestring) {\n      const array = [];\n\n      for (let i = 0; i < multilinestring._geometries.length; ++i) {\n        const linestring = multilinestring._geometries[i];\n        const geoJson = extract.LineString.call(this, linestring);\n        array.push(geoJson.coordinates);\n      }\n\n      return {\n        type: 'MultiLineString',\n        coordinates: array\n      };\n    },\n\n    /**\n     * Convert a Polygon to a GeoJSON object\n     *\n     * @param {Polygon}\n     *          polygon Polygon to convert.\n     *\n     * @return {Array} Array with shell, holes.\n     */\n    Polygon: function Polygon(polygon) {\n      const array = [];\n      const shellGeoJson = extract.LineString.call(this, polygon._shell);\n      array.push(shellGeoJson.coordinates);\n\n      for (let i = 0; i < polygon._holes.length; ++i) {\n        const hole = polygon._holes[i];\n        const holeGeoJson = extract.LineString.call(this, hole);\n        array.push(holeGeoJson.coordinates);\n      }\n\n      return {\n        type: 'Polygon',\n        coordinates: array\n      };\n    },\n\n    /**\n     * Convert a MultiPolygon to a GeoJSON object\n     *\n     * @param {MultiPolygon}\n     *          multipolygon MultiPolygon to convert.\n     *\n     * @return {Array} Array of polygons.\n     */\n    MultiPolygon: function MultiPolygon(multipolygon) {\n      const array = [];\n\n      for (let i = 0; i < multipolygon._geometries.length; ++i) {\n        const polygon = multipolygon._geometries[i];\n        const geoJson = extract.Polygon.call(this, polygon);\n        array.push(geoJson.coordinates);\n      }\n\n      return {\n        type: 'MultiPolygon',\n        coordinates: array\n      };\n    },\n\n    /**\n     * Convert a GeometryCollection to a GeoJSON object\n     *\n     * @param {GeometryCollection}\n     *          collection GeometryCollection to convert.\n     *\n     * @return {Array} Array of geometries.\n     */\n    GeometryCollection: function GeometryCollection(collection) {\n      const array = [];\n\n      for (let i = 0; i < collection._geometries.length; ++i) {\n        const geometry = collection._geometries[i];\n        const type = geometry.getGeometryType();\n        array.push(extract[type].call(this, geometry));\n      }\n\n      return {\n        type: 'GeometryCollection',\n        geometries: array\n      };\n    }\n  };\n\n  /**\n   * @module org/locationtech/jts/io/GeoJSONReader\n   */\n  /**\n   * Converts a geometry in GeoJSON to a {@link Geometry}.\n   */\n\n  class GeoJSONReader {\n    /**\n     * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,\n     * to allow it to create <code>Geometry</code> objects of the appropriate\n     * implementation. In particular, the <code>GeometryFactory</code> determines\n     * the <code>PrecisionModel</code> and <code>SRID</code> that is used.\n     *\n     * @param {GeometryFactory} geometryFactory\n     */\n    constructor(geometryFactory) {\n      this.parser = new GeoJSONParser(geometryFactory || new GeometryFactory());\n    }\n    /**\n     * Reads a GeoJSON representation of a {@link Geometry}\n     *\n     * Will also parse GeoJSON Features/FeatureCollections as custom objects.\n     *\n     * @param {Object|String} geoJson a GeoJSON Object or String.\n     * @return {Geometry|Object} a <code>Geometry or Feature/FeatureCollection representation.</code>\n     * @memberof module:org/locationtech/jts/io/GeoJSONReader#\n     */\n\n\n    read(geoJson) {\n      const geometry = this.parser.read(geoJson);\n      return geometry;\n    }\n\n  }\n\n  /**\n   * @module org/locationtech/jts/io/GeoJSONWriter\n   */\n  /**\n   * Writes the GeoJSON representation of a {@link Geometry}. The\n   * The GeoJSON format is defined <A\n   * HREF=\"http://geojson.org/geojson-spec.html\">here</A>.\n   */\n\n  class GeoJSONWriter {\n    /**\n     * The <code>GeoJSONWriter</code> outputs coordinates rounded to the precision\n     * model. Only the maximum number of decimal places necessary to represent the\n     * ordinates to the required precision will be output.\n     *\n     * @param {GeometryFactory} geometryFactory\n     * @constructor\n     */\n    constructor() {\n      this.parser = new GeoJSONParser(this.geometryFactory);\n    }\n    /**\n     * Converts a <code>Geometry</code> to its GeoJSON representation.\n     *\n     * @param {Geometry}\n     *          geometry a <code>Geometry</code> to process.\n     * @return {Object} The GeoJSON representation of the Geometry.\n     * @memberof module:org/locationtech/jts/io/GeoJSONWriter#\n     */\n\n\n    write(geometry) {\n      return this.parser.write(geometry);\n    }\n\n  }\n\n  /**\n   * @module org/locationtech/jts/io/WKTReader\n   */\n  /**\n   * Converts a geometry in Well-Known Text format to a {@link Geometry}.\n   * <p>\n   * <code>WKTReader</code> supports extracting <code>Geometry</code> objects\n   * from either {@link Reader}s or {@link String}s. This allows it to function\n   * as a parser to read <code>Geometry</code> objects from text blocks embedded\n   * in other data formats (e.g. XML).\n   */\n\n  class WKTReader {\n    /**\n     * A <code>WKTReader</code> is parameterized by a <code>GeometryFactory</code>,\n     * to allow it to create <code>Geometry</code> objects of the appropriate\n     * implementation. In particular, the <code>GeometryFactory</code> determines\n     * the <code>PrecisionModel</code> and <code>SRID</code> that is used.\n     * @param {GeometryFactory} geometryFactory\n     */\n    constructor(geometryFactory) {\n      this.parser = new WKTParser(geometryFactory || new GeometryFactory());\n    }\n    /**\n     * Reads a Well-Known Text representation of a {@link Geometry}\n     *\n     * @param {string}\n     *          wkt a <Geometry Tagged Text> string (see the OpenGIS Simple Features\n     *          Specification).\n     * @return {Geometry} a <code>Geometry</code> read from\n     *         <code>string.</code>\n     * @memberof module:org/locationtech/jts/io/WKTReader#\n     */\n\n\n    read(wkt) {\n      return this.parser.read(wkt);\n    }\n\n  }\n\n  /* eslint-disable no-undef */\n\n  function p2c(p) {\n    return [p.x, p.y];\n  }\n\n  class OL3Parser {\n    /**\n     * OpenLayers Geometry parser and writer\n     * @param {GeometryFactory} geometryFactory\n     * @param {ol} olReference\n     */\n    constructor(geometryFactory, olReference) {\n      this.geometryFactory = geometryFactory || new GeometryFactory();\n      this.ol = olReference || typeof ol !== 'undefined' && ol;\n    }\n    /**\n     * Inject OpenLayers geom classes\n     */\n\n\n    inject(Point, LineString, LinearRing, Polygon, MultiPoint, MultiLineString, MultiPolygon, GeometryCollection) {\n      this.ol = {\n        geom: {\n          Point,\n          LineString,\n          LinearRing,\n          Polygon,\n          MultiPoint,\n          MultiLineString,\n          MultiPolygon,\n          GeometryCollection\n        }\n      };\n    }\n    /**\n     * @param geometry {ol.geom.Geometry}\n     * @return {Geometry}\n     * @memberof module:org/locationtech/jts/io/OL3Parser#\n     */\n\n\n    read(geometry) {\n      const ol = this.ol;\n      if (geometry instanceof ol.geom.Point) return this.convertFromPoint(geometry);else if (geometry instanceof ol.geom.LineString) return this.convertFromLineString(geometry);else if (geometry instanceof ol.geom.LinearRing) return this.convertFromLinearRing(geometry);else if (geometry instanceof ol.geom.Polygon) return this.convertFromPolygon(geometry);else if (geometry instanceof ol.geom.MultiPoint) return this.convertFromMultiPoint(geometry);else if (geometry instanceof ol.geom.MultiLineString) return this.convertFromMultiLineString(geometry);else if (geometry instanceof ol.geom.MultiPolygon) return this.convertFromMultiPolygon(geometry);else if (geometry instanceof ol.geom.GeometryCollection) return this.convertFromCollection(geometry);\n    }\n\n    convertFromPoint(point) {\n      const coordinates = point.getCoordinates();\n      return this.geometryFactory.createPoint(new Coordinate(coordinates[0], coordinates[1]));\n    }\n\n    convertFromLineString(lineString) {\n      return this.geometryFactory.createLineString(lineString.getCoordinates().map(function (coordinates) {\n        return new Coordinate(coordinates[0], coordinates[1]);\n      }));\n    }\n\n    convertFromLinearRing(linearRing) {\n      return this.geometryFactory.createLinearRing(linearRing.getCoordinates().map(function (coordinates) {\n        return new Coordinate(coordinates[0], coordinates[1]);\n      }));\n    }\n\n    convertFromPolygon(polygon) {\n      const linearRings = polygon.getLinearRings();\n      let shell = null;\n      const holes = [];\n\n      for (let i = 0; i < linearRings.length; i++) {\n        const linearRing = this.convertFromLinearRing(linearRings[i]);\n        if (i === 0) shell = linearRing;else holes.push(linearRing);\n      }\n\n      return this.geometryFactory.createPolygon(shell, holes);\n    }\n\n    convertFromMultiPoint(multiPoint) {\n      const points = multiPoint.getPoints().map(function (point) {\n        return this.convertFromPoint(point);\n      }, this);\n      return this.geometryFactory.createMultiPoint(points);\n    }\n\n    convertFromMultiLineString(multiLineString) {\n      const lineStrings = multiLineString.getLineStrings().map(function (lineString) {\n        return this.convertFromLineString(lineString);\n      }, this);\n      return this.geometryFactory.createMultiLineString(lineStrings);\n    }\n\n    convertFromMultiPolygon(multiPolygon) {\n      const polygons = multiPolygon.getPolygons().map(function (polygon) {\n        return this.convertFromPolygon(polygon);\n      }, this);\n      return this.geometryFactory.createMultiPolygon(polygons);\n    }\n\n    convertFromCollection(collection) {\n      const geometries = collection.getGeometries().map(function (geometry) {\n        return this.read(geometry);\n      }, this);\n      return this.geometryFactory.createGeometryCollection(geometries);\n    }\n    /**\n     * @param geometry\n     *          {Geometry}\n     * @return {ol.geom.Geometry}\n     * @memberof module:org/locationtech/jts/io/OL3Parser#\n     */\n\n\n    write(geometry) {\n      if (geometry.getGeometryType() === 'Point') return this.convertToPoint(geometry.getCoordinate());else if (geometry.getGeometryType() === 'LineString') return this.convertToLineString(geometry);else if (geometry.getGeometryType() === 'LinearRing') return this.convertToLinearRing(geometry);else if (geometry.getGeometryType() === 'Polygon') return this.convertToPolygon(geometry);else if (geometry.getGeometryType() === 'MultiPoint') return this.convertToMultiPoint(geometry);else if (geometry.getGeometryType() === 'MultiLineString') return this.convertToMultiLineString(geometry);else if (geometry.getGeometryType() === 'MultiPolygon') return this.convertToMultiPolygon(geometry);else if (geometry.getGeometryType() === 'GeometryCollection') return this.convertToCollection(geometry);\n    }\n\n    convertToPoint(coordinate) {\n      return new this.ol.geom.Point([coordinate.x, coordinate.y]);\n    }\n\n    convertToLineString(lineString) {\n      const points = lineString._points._coordinates.map(p2c);\n\n      return new this.ol.geom.LineString(points);\n    }\n\n    convertToLinearRing(linearRing) {\n      const points = linearRing._points._coordinates.map(p2c);\n\n      return new this.ol.geom.LinearRing(points);\n    }\n\n    convertToPolygon(polygon) {\n      const rings = [polygon._shell._points._coordinates.map(p2c)];\n\n      for (let i = 0; i < polygon._holes.length; i++) rings.push(polygon._holes[i]._points._coordinates.map(p2c));\n\n      return new this.ol.geom.Polygon(rings);\n    }\n\n    convertToMultiPoint(multiPoint) {\n      return new this.ol.geom.MultiPoint(multiPoint.getCoordinates().map(p2c));\n    }\n\n    convertToMultiLineString(multiLineString) {\n      const lineStrings = [];\n\n      for (let i = 0; i < multiLineString._geometries.length; i++) lineStrings.push(this.convertToLineString(multiLineString._geometries[i]).getCoordinates());\n\n      return new this.ol.geom.MultiLineString(lineStrings);\n    }\n\n    convertToMultiPolygon(multiPolygon) {\n      const polygons = [];\n\n      for (let i = 0; i < multiPolygon._geometries.length; i++) polygons.push(this.convertToPolygon(multiPolygon._geometries[i]).getCoordinates());\n\n      return new this.ol.geom.MultiPolygon(polygons);\n    }\n\n    convertToCollection(geometryCollection) {\n      const geometries = [];\n\n      for (let i = 0; i < geometryCollection._geometries.length; i++) {\n        const geometry = geometryCollection._geometries[i];\n        geometries.push(this.write(geometry));\n      }\n\n      return new this.ol.geom.GeometryCollection(geometries);\n    }\n\n  }\n\n  var io = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    GeoJSONReader: GeoJSONReader,\n    GeoJSONWriter: GeoJSONWriter,\n    OL3Parser: OL3Parser,\n    WKTReader: WKTReader,\n    WKTWriter: WKTWriter\n  });\n\n  class SegmentPointComparator {\n    static relativeSign(x0, x1) {\n      if (x0 < x1) return -1;\n      if (x0 > x1) return 1;\n      return 0;\n    }\n\n    static compare(octant, p0, p1) {\n      if (p0.equals2D(p1)) return 0;\n      const xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);\n      const ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);\n\n      switch (octant) {\n        case 0:\n          return SegmentPointComparator.compareValue(xSign, ySign);\n\n        case 1:\n          return SegmentPointComparator.compareValue(ySign, xSign);\n\n        case 2:\n          return SegmentPointComparator.compareValue(ySign, -xSign);\n\n        case 3:\n          return SegmentPointComparator.compareValue(-xSign, ySign);\n\n        case 4:\n          return SegmentPointComparator.compareValue(-xSign, -ySign);\n\n        case 5:\n          return SegmentPointComparator.compareValue(-ySign, -xSign);\n\n        case 6:\n          return SegmentPointComparator.compareValue(-ySign, xSign);\n\n        case 7:\n          return SegmentPointComparator.compareValue(xSign, -ySign);\n      }\n\n      Assert.shouldNeverReachHere('invalid octant value');\n      return 0;\n    }\n\n    static compareValue(compareSign0, compareSign1) {\n      if (compareSign0 < 0) return -1;\n      if (compareSign0 > 0) return 1;\n      if (compareSign1 < 0) return -1;\n      if (compareSign1 > 0) return 1;\n      return 0;\n    }\n\n  }\n\n  class SegmentNode {\n    constructor() {\n      SegmentNode.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._segString = null;\n      this.coord = null;\n      this.segmentIndex = null;\n      this._segmentOctant = null;\n      this._isInterior = null;\n      const segString = arguments[0],\n            coord = arguments[1],\n            segmentIndex = arguments[2],\n            segmentOctant = arguments[3];\n      this._segString = segString;\n      this.coord = new Coordinate(coord);\n      this.segmentIndex = segmentIndex;\n      this._segmentOctant = segmentOctant;\n      this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));\n    }\n\n    getCoordinate() {\n      return this.coord;\n    }\n\n    print(out) {\n      out.print(this.coord);\n      out.print(' seg # = ' + this.segmentIndex);\n    }\n\n    compareTo(obj) {\n      const other = obj;\n      if (this.segmentIndex < other.segmentIndex) return -1;\n      if (this.segmentIndex > other.segmentIndex) return 1;\n      if (this.coord.equals2D(other.coord)) return 0;\n      if (!this._isInterior) return -1;\n      if (!other._isInterior) return 1;\n      return SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord);\n    }\n\n    isEndPoint(maxSegmentIndex) {\n      if (this.segmentIndex === 0 && !this._isInterior) return true;\n      if (this.segmentIndex === maxSegmentIndex) return true;\n      return false;\n    }\n\n    toString() {\n      return this.segmentIndex + ':' + this.coord.toString();\n    }\n\n    isInterior() {\n      return this._isInterior;\n    }\n\n    get interfaces_() {\n      return [Comparable];\n    }\n\n  }\n\n  class SegmentNodeList {\n    constructor() {\n      SegmentNodeList.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._nodeMap = new TreeMap();\n      this._edge = null;\n      const edge = arguments[0];\n      this._edge = edge;\n    }\n\n    getSplitCoordinates() {\n      const coordList = new CoordinateList();\n      this.addEndpoints();\n      const it = this.iterator();\n      let eiPrev = it.next();\n\n      while (it.hasNext()) {\n        const ei = it.next();\n        this.addEdgeCoordinates(eiPrev, ei, coordList);\n        eiPrev = ei;\n      }\n\n      return coordList.toCoordinateArray();\n    }\n\n    addCollapsedNodes() {\n      const collapsedVertexIndexes = new ArrayList();\n      this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);\n      this.findCollapsesFromExistingVertices(collapsedVertexIndexes);\n\n      for (let it = collapsedVertexIndexes.iterator(); it.hasNext();) {\n        const vertexIndex = it.next().intValue();\n        this.add(this._edge.getCoordinate(vertexIndex), vertexIndex);\n      }\n    }\n\n    createSplitEdgePts(ei0, ei1) {\n      let npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n      if (npts === 2) return [new Coordinate(ei0.coord), new Coordinate(ei1.coord)];\n\n      const lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);\n\n      const useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n      if (!useIntPt1) npts--;\n      const pts = new Array(npts).fill(null);\n      let ipt = 0;\n      pts[ipt++] = new Coordinate(ei0.coord);\n\n      for (let i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) pts[ipt++] = this._edge.getCoordinate(i);\n\n      if (useIntPt1) pts[ipt] = new Coordinate(ei1.coord);\n      return pts;\n    }\n\n    print(out) {\n      out.println('Intersections:');\n\n      for (let it = this.iterator(); it.hasNext();) {\n        const ei = it.next();\n        ei.print(out);\n      }\n    }\n\n    findCollapsesFromExistingVertices(collapsedVertexIndexes) {\n      for (let i = 0; i < this._edge.size() - 2; i++) {\n        const p0 = this._edge.getCoordinate(i);\n\n        const p1 = this._edge.getCoordinate(i + 1);\n\n        const p2 = this._edge.getCoordinate(i + 2);\n\n        if (p0.equals2D(p2)) collapsedVertexIndexes.add(Integer.valueOf(i + 1));\n      }\n    }\n\n    addEdgeCoordinates(ei0, ei1, coordList) {\n      const pts = this.createSplitEdgePts(ei0, ei1);\n      coordList.add(pts, false);\n    }\n\n    iterator() {\n      return this._nodeMap.values().iterator();\n    }\n\n    addSplitEdges(edgeList) {\n      this.addEndpoints();\n      this.addCollapsedNodes();\n      const it = this.iterator();\n      let eiPrev = it.next();\n\n      while (it.hasNext()) {\n        const ei = it.next();\n        const newEdge = this.createSplitEdge(eiPrev, ei);\n        edgeList.add(newEdge);\n        eiPrev = ei;\n      }\n    }\n\n    findCollapseIndex(ei0, ei1, collapsedVertexIndex) {\n      if (!ei0.coord.equals2D(ei1.coord)) return false;\n      let numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;\n      if (!ei1.isInterior()) numVerticesBetween--;\n\n      if (numVerticesBetween === 1) {\n        collapsedVertexIndex[0] = ei0.segmentIndex + 1;\n        return true;\n      }\n\n      return false;\n    }\n\n    findCollapsesFromInsertedNodes(collapsedVertexIndexes) {\n      const collapsedVertexIndex = new Array(1).fill(null);\n      const it = this.iterator();\n      let eiPrev = it.next();\n\n      while (it.hasNext()) {\n        const ei = it.next();\n        const isCollapsed = this.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);\n        if (isCollapsed) collapsedVertexIndexes.add(Integer.valueOf(collapsedVertexIndex[0]));\n        eiPrev = ei;\n      }\n    }\n\n    getEdge() {\n      return this._edge;\n    }\n\n    addEndpoints() {\n      const maxSegIndex = this._edge.size() - 1;\n      this.add(this._edge.getCoordinate(0), 0);\n      this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);\n    }\n\n    createSplitEdge(ei0, ei1) {\n      const pts = this.createSplitEdgePts(ei0, ei1);\n      return new NodedSegmentString(pts, this._edge.getData());\n    }\n\n    add(intPt, segmentIndex) {\n      const eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));\n\n      const ei = this._nodeMap.get(eiNew);\n\n      if (ei !== null) {\n        Assert.isTrue(ei.coord.equals2D(intPt), 'Found equal nodes with different coordinates');\n        return ei;\n      }\n\n      this._nodeMap.put(eiNew, eiNew);\n\n      return eiNew;\n    }\n\n    checkSplitEdgesCorrectness(splitEdges) {\n      const edgePts = this._edge.getCoordinates();\n\n      const split0 = splitEdges.get(0);\n      const pt0 = split0.getCoordinate(0);\n      if (!pt0.equals2D(edgePts[0])) throw new RuntimeException('bad split edge start point at ' + pt0);\n      const splitn = splitEdges.get(splitEdges.size() - 1);\n      const splitnPts = splitn.getCoordinates();\n      const ptn = splitnPts[splitnPts.length - 1];\n      if (!ptn.equals2D(edgePts[edgePts.length - 1])) throw new RuntimeException('bad split edge end point at ' + ptn);\n    }\n\n  }\n\n  class Octant {\n    static octant() {\n      if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n        const dx = arguments[0],\n              dy = arguments[1];\n        if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException('Cannot compute the octant for point ( ' + dx + ', ' + dy + ' )');\n        const adx = Math.abs(dx);\n        const ady = Math.abs(dy);\n        if (dx >= 0) {\n          if (dy >= 0) {\n            if (adx >= ady) return 0;else return 1;\n          } else if (adx >= ady) return 7;else return 6;\n        } else if (dy >= 0) {\n          if (adx >= ady) return 3;else return 2;\n        } else if (adx >= ady) return 4;else return 5;\n      } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n        const p0 = arguments[0],\n              p1 = arguments[1];\n        const dx = p1.x - p0.x;\n        const dy = p1.y - p0.y;\n        if (dx === 0.0 && dy === 0.0) throw new IllegalArgumentException('Cannot compute the octant for two identical points ' + p0);\n        return Octant.octant(dx, dy);\n      }\n    }\n\n  }\n\n  class SegmentString {\n    getCoordinates() {}\n\n    size() {}\n\n    getCoordinate(i) {}\n\n    isClosed() {}\n\n    setData(data) {}\n\n    getData() {}\n\n  }\n\n  class NodableSegmentString {\n    addIntersection(intPt, segmentIndex) {}\n\n    get interfaces_() {\n      return [SegmentString];\n    }\n\n  }\n\n  class NodedSegmentString {\n    constructor() {\n      NodedSegmentString.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._nodeList = new SegmentNodeList(this);\n      this._pts = null;\n      this._data = null;\n      const pts = arguments[0],\n            data = arguments[1];\n      this._pts = pts;\n      this._data = data;\n    }\n\n    static getNodedSubstrings() {\n      if (arguments.length === 1) {\n        const segStrings = arguments[0];\n        const resultEdgelist = new ArrayList();\n        NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);\n        return resultEdgelist;\n      } else if (arguments.length === 2) {\n        const segStrings = arguments[0],\n              resultEdgelist = arguments[1];\n\n        for (let i = segStrings.iterator(); i.hasNext();) {\n          const ss = i.next();\n          ss.getNodeList().addSplitEdges(resultEdgelist);\n        }\n      }\n    }\n\n    getCoordinates() {\n      return this._pts;\n    }\n\n    size() {\n      return this._pts.length;\n    }\n\n    getCoordinate(i) {\n      return this._pts[i];\n    }\n\n    isClosed() {\n      return this._pts[0].equals(this._pts[this._pts.length - 1]);\n    }\n\n    getSegmentOctant(index) {\n      if (index === this._pts.length - 1) return -1;\n      return this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1));\n    }\n\n    setData(data) {\n      this._data = data;\n    }\n\n    safeOctant(p0, p1) {\n      if (p0.equals2D(p1)) return 0;\n      return Octant.octant(p0, p1);\n    }\n\n    getData() {\n      return this._data;\n    }\n\n    addIntersection() {\n      if (arguments.length === 2) {\n        const intPt = arguments[0],\n              segmentIndex = arguments[1];\n        this.addIntersectionNode(intPt, segmentIndex);\n      } else if (arguments.length === 4) {\n        const li = arguments[0],\n              segmentIndex = arguments[1],\n              intIndex = arguments[3];\n        const intPt = new Coordinate(li.getIntersection(intIndex));\n        this.addIntersection(intPt, segmentIndex);\n      }\n    }\n\n    toString() {\n      return WKTWriter.toLineString(new CoordinateArraySequence(this._pts));\n    }\n\n    getNodeList() {\n      return this._nodeList;\n    }\n\n    addIntersectionNode(intPt, segmentIndex) {\n      let normalizedSegmentIndex = segmentIndex;\n      const nextSegIndex = normalizedSegmentIndex + 1;\n\n      if (nextSegIndex < this._pts.length) {\n        const nextPt = this._pts[nextSegIndex];\n        if (intPt.equals2D(nextPt)) normalizedSegmentIndex = nextSegIndex;\n      }\n\n      const ei = this._nodeList.add(intPt, normalizedSegmentIndex);\n\n      return ei;\n    }\n\n    addIntersections(li, segmentIndex, geomIndex) {\n      for (let i = 0; i < li.getIntersectionNum(); i++) this.addIntersection(li, segmentIndex, geomIndex, i);\n    }\n\n    get interfaces_() {\n      return [NodableSegmentString];\n    }\n\n  }\n\n  class MonotoneChainOverlapAction {\n    constructor() {\n      MonotoneChainOverlapAction.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._overlapSeg1 = new LineSegment();\n      this._overlapSeg2 = new LineSegment();\n    }\n\n    overlap() {\n      if (arguments.length === 2) ; else if (arguments.length === 4) {\n        const mc1 = arguments[0],\n              start1 = arguments[1],\n              mc2 = arguments[2],\n              start2 = arguments[3];\n        mc1.getLineSegment(start1, this._overlapSeg1);\n        mc2.getLineSegment(start2, this._overlapSeg2);\n        this.overlap(this._overlapSeg1, this._overlapSeg2);\n      }\n    }\n\n  }\n\n  class MonotoneChain$1 {\n    constructor() {\n      MonotoneChain$1.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._pts = null;\n      this._start = null;\n      this._end = null;\n      this._env = null;\n      this._context = null;\n      this._id = null;\n      const pts = arguments[0],\n            start = arguments[1],\n            end = arguments[2],\n            context = arguments[3];\n      this._pts = pts;\n      this._start = start;\n      this._end = end;\n      this._context = context;\n    }\n\n    getLineSegment(index, ls) {\n      ls.p0 = this._pts[index];\n      ls.p1 = this._pts[index + 1];\n    }\n\n    computeSelect(searchEnv, start0, end0, mcs) {\n      const p0 = this._pts[start0];\n      const p1 = this._pts[end0];\n\n      if (end0 - start0 === 1) {\n        mcs.select(this, start0);\n        return null;\n      }\n\n      if (!searchEnv.intersects(p0, p1)) return null;\n      const mid = Math.trunc((start0 + end0) / 2);\n      if (start0 < mid) this.computeSelect(searchEnv, start0, mid, mcs);\n      if (mid < end0) this.computeSelect(searchEnv, mid, end0, mcs);\n    }\n\n    getCoordinates() {\n      const coord = new Array(this._end - this._start + 1).fill(null);\n      let index = 0;\n\n      for (let i = this._start; i <= this._end; i++) coord[index++] = this._pts[i];\n\n      return coord;\n    }\n\n    computeOverlaps() {\n      if (arguments.length === 2) {\n        const mc = arguments[0],\n              mco = arguments[1];\n        this.computeOverlaps(this._start, this._end, mc, mc._start, mc._end, mco);\n      } else if (arguments.length === 6) {\n        const start0 = arguments[0],\n              end0 = arguments[1],\n              mc = arguments[2],\n              start1 = arguments[3],\n              end1 = arguments[4],\n              mco = arguments[5];\n\n        if (end0 - start0 === 1 && end1 - start1 === 1) {\n          mco.overlap(this, start0, mc, start1);\n          return null;\n        }\n\n        if (!this.overlaps(start0, end0, mc, start1, end1)) return null;\n        const mid0 = Math.trunc((start0 + end0) / 2);\n        const mid1 = Math.trunc((start1 + end1) / 2);\n\n        if (start0 < mid0) {\n          if (start1 < mid1) this.computeOverlaps(start0, mid0, mc, start1, mid1, mco);\n          if (mid1 < end1) this.computeOverlaps(start0, mid0, mc, mid1, end1, mco);\n        }\n\n        if (mid0 < end0) {\n          if (start1 < mid1) this.computeOverlaps(mid0, end0, mc, start1, mid1, mco);\n          if (mid1 < end1) this.computeOverlaps(mid0, end0, mc, mid1, end1, mco);\n        }\n      }\n    }\n\n    setId(id) {\n      this._id = id;\n    }\n\n    select(searchEnv, mcs) {\n      this.computeSelect(searchEnv, this._start, this._end, mcs);\n    }\n\n    getEnvelope() {\n      if (this._env === null) {\n        const p0 = this._pts[this._start];\n        const p1 = this._pts[this._end];\n        this._env = new Envelope(p0, p1);\n      }\n\n      return this._env;\n    }\n\n    overlaps(start0, end0, mc, start1, end1) {\n      return Envelope.intersects(this._pts[start0], this._pts[end0], mc._pts[start1], mc._pts[end1]);\n    }\n\n    getEndIndex() {\n      return this._end;\n    }\n\n    getStartIndex() {\n      return this._start;\n    }\n\n    getContext() {\n      return this._context;\n    }\n\n    getId() {\n      return this._id;\n    }\n\n  }\n\n  class MonotoneChainBuilder {\n    static findChainEnd(pts, start) {\n      let safeStart = start;\n\n      while (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) safeStart++;\n\n      if (safeStart >= pts.length - 1) return pts.length - 1;\n      const chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);\n      let last = start + 1;\n\n      while (last < pts.length) {\n        if (!pts[last - 1].equals2D(pts[last])) {\n          const quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n          if (quad !== chainQuad) break;\n        }\n\n        last++;\n      }\n\n      return last - 1;\n    }\n\n    static getChains() {\n      if (arguments.length === 1) {\n        const pts = arguments[0];\n        return MonotoneChainBuilder.getChains(pts, null);\n      } else if (arguments.length === 2) {\n        const pts = arguments[0],\n              context = arguments[1];\n        const mcList = new ArrayList();\n        let chainStart = 0;\n\n        do {\n          const chainEnd = MonotoneChainBuilder.findChainEnd(pts, chainStart);\n          const mc = new MonotoneChain$1(pts, chainStart, chainEnd, context);\n          mcList.add(mc);\n          chainStart = chainEnd;\n        } while (chainStart < pts.length - 1);\n\n        return mcList;\n      }\n    }\n\n  }\n\n  class Noder {\n    computeNodes(segStrings) {}\n\n    getNodedSubstrings() {}\n\n  }\n\n  class SinglePassNoder {\n    constructor() {\n      SinglePassNoder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._segInt = null;\n\n      if (arguments.length === 0) ; else if (arguments.length === 1) {\n        const segInt = arguments[0];\n        this.setSegmentIntersector(segInt);\n      }\n    }\n\n    setSegmentIntersector(segInt) {\n      this._segInt = segInt;\n    }\n\n    get interfaces_() {\n      return [Noder];\n    }\n\n  }\n\n  class MCIndexNoder extends SinglePassNoder {\n    constructor() {\n      super();\n      MCIndexNoder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._monoChains = new ArrayList();\n      this._index = new STRtree();\n      this._idCounter = 0;\n      this._nodedSegStrings = null;\n      this._nOverlaps = 0;\n\n      if (arguments.length === 0) ; else if (arguments.length === 1) {\n        const si = arguments[0];\n        SinglePassNoder.constructor_.call(this, si);\n      }\n    }\n\n    getMonotoneChains() {\n      return this._monoChains;\n    }\n\n    getNodedSubstrings() {\n      return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);\n    }\n\n    getIndex() {\n      return this._index;\n    }\n\n    add(segStr) {\n      const segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);\n\n      for (let i = segChains.iterator(); i.hasNext();) {\n        const mc = i.next();\n        mc.setId(this._idCounter++);\n\n        this._index.insert(mc.getEnvelope(), mc);\n\n        this._monoChains.add(mc);\n      }\n    }\n\n    computeNodes(inputSegStrings) {\n      this._nodedSegStrings = inputSegStrings;\n\n      for (let i = inputSegStrings.iterator(); i.hasNext();) this.add(i.next());\n\n      this.intersectChains();\n    }\n\n    intersectChains() {\n      const overlapAction = new SegmentOverlapAction(this._segInt);\n\n      for (let i = this._monoChains.iterator(); i.hasNext();) {\n        const queryChain = i.next();\n\n        const overlapChains = this._index.query(queryChain.getEnvelope());\n\n        for (let j = overlapChains.iterator(); j.hasNext();) {\n          const testChain = j.next();\n\n          if (testChain.getId() > queryChain.getId()) {\n            queryChain.computeOverlaps(testChain, overlapAction);\n            this._nOverlaps++;\n          }\n\n          if (this._segInt.isDone()) return null;\n        }\n      }\n    }\n\n  }\n\n  class SegmentOverlapAction extends MonotoneChainOverlapAction {\n    constructor() {\n      super();\n      SegmentOverlapAction.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._si = null;\n      const si = arguments[0];\n      this._si = si;\n    }\n\n    overlap() {\n      if (arguments.length === 4) {\n        const mc1 = arguments[0],\n              start1 = arguments[1],\n              mc2 = arguments[2],\n              start2 = arguments[3];\n        const ss1 = mc1.getContext();\n        const ss2 = mc2.getContext();\n\n        this._si.processIntersections(ss1, start1, ss2, start2);\n      } else {\n        return super.overlap.apply(this, arguments);\n      }\n    }\n\n  }\n\n  MCIndexNoder.SegmentOverlapAction = SegmentOverlapAction;\n\n  class ScaledNoder {\n    constructor() {\n      ScaledNoder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._noder = null;\n      this._scaleFactor = null;\n      this._offsetX = null;\n      this._offsetY = null;\n      this._isScaled = false;\n\n      if (arguments.length === 2) {\n        const noder = arguments[0],\n              scaleFactor = arguments[1];\n        ScaledNoder.constructor_.call(this, noder, scaleFactor, 0, 0);\n      } else if (arguments.length === 4) {\n        const noder = arguments[0],\n              scaleFactor = arguments[1];\n        this._noder = noder;\n        this._scaleFactor = scaleFactor;\n        this._isScaled = !this.isIntegerPrecision();\n      }\n    }\n\n    rescale() {\n      if (hasInterface(arguments[0], Collection)) {\n        const segStrings = arguments[0];\n\n        for (let i = segStrings.iterator(); i.hasNext();) {\n          const ss = i.next();\n          this.rescale(ss.getCoordinates());\n        }\n      } else if (arguments[0] instanceof Array) {\n        const pts = arguments[0];\n\n        for (let i = 0; i < pts.length; i++) {\n          pts[i].x = pts[i].x / this._scaleFactor + this._offsetX;\n          pts[i].y = pts[i].y / this._scaleFactor + this._offsetY;\n        }\n\n        if (pts.length === 2 && pts[0].equals2D(pts[1])) System.out.println(pts);\n      }\n    }\n\n    scale() {\n      if (hasInterface(arguments[0], Collection)) {\n        const segStrings = arguments[0];\n        const nodedSegmentStrings = new ArrayList(segStrings.size());\n\n        for (let i = segStrings.iterator(); i.hasNext();) {\n          const ss = i.next();\n          nodedSegmentStrings.add(new NodedSegmentString(this.scale(ss.getCoordinates()), ss.getData()));\n        }\n\n        return nodedSegmentStrings;\n      } else if (arguments[0] instanceof Array) {\n        const pts = arguments[0];\n        const roundPts = new Array(pts.length).fill(null);\n\n        for (let i = 0; i < pts.length; i++) roundPts[i] = new Coordinate(Math.round((pts[i].x - this._offsetX) * this._scaleFactor), Math.round((pts[i].y - this._offsetY) * this._scaleFactor), pts[i].getZ());\n\n        const roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);\n        return roundPtsNoDup;\n      }\n    }\n\n    isIntegerPrecision() {\n      return this._scaleFactor === 1.0;\n    }\n\n    getNodedSubstrings() {\n      const splitSS = this._noder.getNodedSubstrings();\n\n      if (this._isScaled) this.rescale(splitSS);\n      return splitSS;\n    }\n\n    computeNodes(inputSegStrings) {\n      let intSegStrings = inputSegStrings;\n      if (this._isScaled) intSegStrings = this.scale(inputSegStrings);\n\n      this._noder.computeNodes(intSegStrings);\n    }\n\n    get interfaces_() {\n      return [Noder];\n    }\n\n  }\n\n  var noding = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    MCIndexNoder: MCIndexNoder,\n    ScaledNoder: ScaledNoder,\n    SegmentString: SegmentString\n  });\n\n  class BoundaryOp {\n    constructor() {\n      BoundaryOp.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._geom = null;\n      this._geomFact = null;\n      this._bnRule = null;\n      this._endpointMap = null;\n\n      if (arguments.length === 1) {\n        const geom = arguments[0];\n        BoundaryOp.constructor_.call(this, geom, BoundaryNodeRule.MOD2_BOUNDARY_RULE);\n      } else if (arguments.length === 2) {\n        const geom = arguments[0],\n              bnRule = arguments[1];\n        this._geom = geom;\n        this._geomFact = geom.getFactory();\n        this._bnRule = bnRule;\n      }\n    }\n\n    static getBoundary() {\n      if (arguments.length === 1) {\n        const g = arguments[0];\n        const bop = new BoundaryOp(g);\n        return bop.getBoundary();\n      } else if (arguments.length === 2) {\n        const g = arguments[0],\n              bnRule = arguments[1];\n        const bop = new BoundaryOp(g, bnRule);\n        return bop.getBoundary();\n      }\n    }\n\n    boundaryMultiLineString(mLine) {\n      if (this._geom.isEmpty()) return this.getEmptyMultiPoint();\n      const bdyPts = this.computeBoundaryCoordinates(mLine);\n      if (bdyPts.length === 1) return this._geomFact.createPoint(bdyPts[0]);\n      return this._geomFact.createMultiPointFromCoords(bdyPts);\n    }\n\n    getBoundary() {\n      if (this._geom instanceof LineString) return this.boundaryLineString(this._geom);\n      if (this._geom instanceof MultiLineString) return this.boundaryMultiLineString(this._geom);\n      return this._geom.getBoundary();\n    }\n\n    boundaryLineString(line) {\n      if (this._geom.isEmpty()) return this.getEmptyMultiPoint();\n\n      if (line.isClosed()) {\n        const closedEndpointOnBoundary = this._bnRule.isInBoundary(2);\n\n        if (closedEndpointOnBoundary) return line.getStartPoint();else return this._geomFact.createMultiPoint();\n      }\n\n      return this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()]);\n    }\n\n    getEmptyMultiPoint() {\n      return this._geomFact.createMultiPoint();\n    }\n\n    computeBoundaryCoordinates(mLine) {\n      const bdyPts = new ArrayList();\n      this._endpointMap = new TreeMap();\n\n      for (let i = 0; i < mLine.getNumGeometries(); i++) {\n        const line = mLine.getGeometryN(i);\n        if (line.getNumPoints() === 0) continue;\n        this.addEndpoint(line.getCoordinateN(0));\n        this.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));\n      }\n\n      for (let it = this._endpointMap.entrySet().iterator(); it.hasNext();) {\n        const entry = it.next();\n        const counter = entry.getValue();\n        const valence = counter.count;\n        if (this._bnRule.isInBoundary(valence)) bdyPts.add(entry.getKey());\n      }\n\n      return CoordinateArrays.toCoordinateArray(bdyPts);\n    }\n\n    addEndpoint(pt) {\n      let counter = this._endpointMap.get(pt);\n\n      if (counter === null) {\n        counter = new Counter();\n\n        this._endpointMap.put(pt, counter);\n      }\n\n      counter.count++;\n    }\n\n  }\n\n  class Counter {\n    constructor() {\n      Counter.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.count = null;\n    }\n\n  }\n\n  class IsSimpleOp {\n    constructor() {\n      IsSimpleOp.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._inputGeom = null;\n      this._isClosedEndpointsInInterior = true;\n      this._nonSimpleLocation = null;\n\n      if (arguments.length === 1) {\n        const geom = arguments[0];\n        this._inputGeom = geom;\n      } else if (arguments.length === 2) {\n        const geom = arguments[0],\n              boundaryNodeRule = arguments[1];\n        this._inputGeom = geom;\n        this._isClosedEndpointsInInterior = !boundaryNodeRule.isInBoundary(2);\n      }\n    }\n\n    static isSimple() {\n      if (arguments.length === 1) {\n        const geom = arguments[0];\n        const op = new IsSimpleOp(geom);\n        return op.isSimple();\n      } else if (arguments.length === 2) {\n        const geom = arguments[0],\n              boundaryNodeRule = arguments[1];\n        const op = new IsSimpleOp(geom, boundaryNodeRule);\n        return op.isSimple();\n      }\n    }\n\n    isSimpleMultiPoint(mp) {\n      if (mp.isEmpty()) return true;\n      const points = new TreeSet();\n\n      for (let i = 0; i < mp.getNumGeometries(); i++) {\n        const pt = mp.getGeometryN(i);\n        const p = pt.getCoordinate();\n\n        if (points.contains(p)) {\n          this._nonSimpleLocation = p;\n          return false;\n        }\n\n        points.add(p);\n      }\n\n      return true;\n    }\n\n    isSimplePolygonal(geom) {\n      const rings = LinearComponentExtracter.getLines(geom);\n\n      for (let i = rings.iterator(); i.hasNext();) {\n        const ring = i.next();\n        if (!this.isSimpleLinearGeometry(ring)) return false;\n      }\n\n      return true;\n    }\n\n    hasClosedEndpointIntersection(graph) {\n      const endPoints = new TreeMap();\n\n      for (let i = graph.getEdgeIterator(); i.hasNext();) {\n        const e = i.next();\n        const isClosed = e.isClosed();\n        const p0 = e.getCoordinate(0);\n        this.addEndpoint(endPoints, p0, isClosed);\n        const p1 = e.getCoordinate(e.getNumPoints() - 1);\n        this.addEndpoint(endPoints, p1, isClosed);\n      }\n\n      for (let i = endPoints.values().iterator(); i.hasNext();) {\n        const eiInfo = i.next();\n\n        if (eiInfo.isClosed && eiInfo.degree !== 2) {\n          this._nonSimpleLocation = eiInfo.getCoordinate();\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    getNonSimpleLocation() {\n      return this._nonSimpleLocation;\n    }\n\n    isSimpleLinearGeometry(geom) {\n      if (geom.isEmpty()) return true;\n      const graph = new GeometryGraph(0, geom);\n      const li = new RobustLineIntersector();\n      const si = graph.computeSelfNodes(li, true);\n      if (!si.hasIntersection()) return true;\n\n      if (si.hasProperIntersection()) {\n        this._nonSimpleLocation = si.getProperIntersectionPoint();\n        return false;\n      }\n\n      if (this.hasNonEndpointIntersection(graph)) return false;\n      if (this._isClosedEndpointsInInterior) if (this.hasClosedEndpointIntersection(graph)) return false;\n      return true;\n    }\n\n    hasNonEndpointIntersection(graph) {\n      for (let i = graph.getEdgeIterator(); i.hasNext();) {\n        const e = i.next();\n        const maxSegmentIndex = e.getMaximumSegmentIndex();\n\n        for (let eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n          const ei = eiIt.next();\n\n          if (!ei.isEndPoint(maxSegmentIndex)) {\n            this._nonSimpleLocation = ei.getCoordinate();\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    addEndpoint(endPoints, p, isClosed) {\n      let eiInfo = endPoints.get(p);\n\n      if (eiInfo === null) {\n        eiInfo = new EndpointInfo(p);\n        endPoints.put(p, eiInfo);\n      }\n\n      eiInfo.addEndpoint(isClosed);\n    }\n\n    computeSimple(geom) {\n      this._nonSimpleLocation = null;\n      if (geom.isEmpty()) return true;\n      if (geom instanceof LineString) return this.isSimpleLinearGeometry(geom);\n      if (geom instanceof MultiLineString) return this.isSimpleLinearGeometry(geom);\n      if (geom instanceof MultiPoint) return this.isSimpleMultiPoint(geom);\n      if (hasInterface(geom, Polygonal)) return this.isSimplePolygonal(geom);\n      if (geom instanceof GeometryCollection) return this.isSimpleGeometryCollection(geom);\n      return true;\n    }\n\n    isSimple() {\n      this._nonSimpleLocation = null;\n      return this.computeSimple(this._inputGeom);\n    }\n\n    isSimpleGeometryCollection(geom) {\n      for (let i = 0; i < geom.getNumGeometries(); i++) {\n        const comp = geom.getGeometryN(i);\n        if (!this.computeSimple(comp)) return false;\n      }\n\n      return true;\n    }\n\n  }\n\n  class EndpointInfo {\n    constructor() {\n      EndpointInfo.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.pt = null;\n      this.isClosed = null;\n      this.degree = null;\n      const pt = arguments[0];\n      this.pt = pt;\n      this.isClosed = false;\n      this.degree = 0;\n    }\n\n    addEndpoint(isClosed) {\n      this.degree++;\n      this.isClosed |= isClosed;\n    }\n\n    getCoordinate() {\n      return this.pt;\n    }\n\n  }\n\n  IsSimpleOp.EndpointInfo = EndpointInfo;\n\n  class BufferParameters {\n    constructor() {\n      BufferParameters.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n      this._endCapStyle = BufferParameters.CAP_ROUND;\n      this._joinStyle = BufferParameters.JOIN_ROUND;\n      this._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;\n      this._isSingleSided = false;\n      this._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;\n\n      if (arguments.length === 0) ; else if (arguments.length === 1) {\n        const quadrantSegments = arguments[0];\n        this.setQuadrantSegments(quadrantSegments);\n      } else if (arguments.length === 2) {\n        const quadrantSegments = arguments[0],\n              endCapStyle = arguments[1];\n        this.setQuadrantSegments(quadrantSegments);\n        this.setEndCapStyle(endCapStyle);\n      } else if (arguments.length === 4) {\n        const quadrantSegments = arguments[0],\n              endCapStyle = arguments[1],\n              joinStyle = arguments[2],\n              mitreLimit = arguments[3];\n        this.setQuadrantSegments(quadrantSegments);\n        this.setEndCapStyle(endCapStyle);\n        this.setJoinStyle(joinStyle);\n        this.setMitreLimit(mitreLimit);\n      }\n    }\n\n    static bufferDistanceError(quadSegs) {\n      const alpha = Math.PI / 2.0 / quadSegs;\n      return 1 - Math.cos(alpha / 2.0);\n    }\n\n    getEndCapStyle() {\n      return this._endCapStyle;\n    }\n\n    isSingleSided() {\n      return this._isSingleSided;\n    }\n\n    setQuadrantSegments(quadSegs) {\n      this._quadrantSegments = quadSegs;\n      if (this._quadrantSegments === 0) this._joinStyle = BufferParameters.JOIN_BEVEL;\n\n      if (this._quadrantSegments < 0) {\n        this._joinStyle = BufferParameters.JOIN_MITRE;\n        this._mitreLimit = Math.abs(this._quadrantSegments);\n      }\n\n      if (quadSegs <= 0) this._quadrantSegments = 1;\n      if (this._joinStyle !== BufferParameters.JOIN_ROUND) this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n    }\n\n    getJoinStyle() {\n      return this._joinStyle;\n    }\n\n    setJoinStyle(joinStyle) {\n      this._joinStyle = joinStyle;\n    }\n\n    setSimplifyFactor(simplifyFactor) {\n      this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;\n    }\n\n    getSimplifyFactor() {\n      return this._simplifyFactor;\n    }\n\n    getQuadrantSegments() {\n      return this._quadrantSegments;\n    }\n\n    setEndCapStyle(endCapStyle) {\n      this._endCapStyle = endCapStyle;\n    }\n\n    getMitreLimit() {\n      return this._mitreLimit;\n    }\n\n    setMitreLimit(mitreLimit) {\n      this._mitreLimit = mitreLimit;\n    }\n\n    setSingleSided(isSingleSided) {\n      this._isSingleSided = isSingleSided;\n    }\n\n  }\n  BufferParameters.CAP_ROUND = 1;\n  BufferParameters.CAP_FLAT = 2;\n  BufferParameters.CAP_SQUARE = 3;\n  BufferParameters.JOIN_ROUND = 1;\n  BufferParameters.JOIN_MITRE = 2;\n  BufferParameters.JOIN_BEVEL = 3;\n  BufferParameters.DEFAULT_QUADRANT_SEGMENTS = 8;\n  BufferParameters.DEFAULT_MITRE_LIMIT = 5.0;\n  BufferParameters.DEFAULT_SIMPLIFY_FACTOR = 0.01;\n\n  class RightmostEdgeFinder {\n    constructor() {\n      RightmostEdgeFinder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._minIndex = -1;\n      this._minCoord = null;\n      this._minDe = null;\n      this._orientedDe = null;\n    }\n\n    getCoordinate() {\n      return this._minCoord;\n    }\n\n    getRightmostSide(de, index) {\n      let side = this.getRightmostSideOfSegment(de, index);\n      if (side < 0) side = this.getRightmostSideOfSegment(de, index - 1);\n\n      if (side < 0) {\n        this._minCoord = null;\n        this.checkForRightmostCoordinate(de);\n      }\n\n      return side;\n    }\n\n    findRightmostEdgeAtVertex() {\n      const pts = this._minDe.getEdge().getCoordinates();\n\n      Assert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, 'rightmost point expected to be interior vertex of edge');\n      const pPrev = pts[this._minIndex - 1];\n      const pNext = pts[this._minIndex + 1];\n      const orientation = Orientation.index(this._minCoord, pNext, pPrev);\n      let usePrev = false;\n      if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === Orientation.COUNTERCLOCKWISE) usePrev = true;else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === Orientation.CLOCKWISE) usePrev = true;\n      if (usePrev) this._minIndex = this._minIndex - 1;\n    }\n\n    getRightmostSideOfSegment(de, i) {\n      const e = de.getEdge();\n      const coord = e.getCoordinates();\n      if (i < 0 || i + 1 >= coord.length) return -1;\n      if (coord[i].y === coord[i + 1].y) return -1;\n      let pos = Position.LEFT;\n      if (coord[i].y < coord[i + 1].y) pos = Position.RIGHT;\n      return pos;\n    }\n\n    getEdge() {\n      return this._orientedDe;\n    }\n\n    checkForRightmostCoordinate(de) {\n      const coord = de.getEdge().getCoordinates();\n\n      for (let i = 0; i < coord.length - 1; i++) if (this._minCoord === null || coord[i].x > this._minCoord.x) {\n        this._minDe = de;\n        this._minIndex = i;\n        this._minCoord = coord[i];\n      }\n    }\n\n    findRightmostEdgeAtNode() {\n      const node = this._minDe.getNode();\n\n      const star = node.getEdges();\n      this._minDe = star.getRightmostEdge();\n\n      if (!this._minDe.isForward()) {\n        this._minDe = this._minDe.getSym();\n        this._minIndex = this._minDe.getEdge().getCoordinates().length - 1;\n      }\n    }\n\n    findEdge(dirEdgeList) {\n      for (let i = dirEdgeList.iterator(); i.hasNext();) {\n        const de = i.next();\n        if (!de.isForward()) continue;\n        this.checkForRightmostCoordinate(de);\n      }\n\n      Assert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), 'inconsistency in rightmost processing');\n      if (this._minIndex === 0) this.findRightmostEdgeAtNode();else this.findRightmostEdgeAtVertex();\n      this._orientedDe = this._minDe;\n      const rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);\n      if (rightmostSide === Position.LEFT) this._orientedDe = this._minDe.getSym();\n    }\n\n  }\n\n  class LinkedList {\n    constructor() {\n      this.array = [];\n    }\n\n    addLast(e) {\n      this.array.push(e);\n    }\n\n    removeFirst() {\n      return this.array.shift();\n    }\n\n    isEmpty() {\n      return this.array.length === 0;\n    }\n\n  }\n\n  class BufferSubgraph {\n    constructor() {\n      BufferSubgraph.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._finder = null;\n      this._dirEdgeList = new ArrayList();\n      this._nodes = new ArrayList();\n      this._rightMostCoord = null;\n      this._env = null;\n      this._finder = new RightmostEdgeFinder();\n    }\n\n    clearVisitedEdges() {\n      for (let it = this._dirEdgeList.iterator(); it.hasNext();) {\n        const de = it.next();\n        de.setVisited(false);\n      }\n    }\n\n    getRightmostCoordinate() {\n      return this._rightMostCoord;\n    }\n\n    computeNodeDepth(n) {\n      let startEdge = null;\n\n      for (let i = n.getEdges().iterator(); i.hasNext();) {\n        const de = i.next();\n\n        if (de.isVisited() || de.getSym().isVisited()) {\n          startEdge = de;\n          break;\n        }\n      }\n\n      if (startEdge === null) throw new TopologyException('unable to find edge to compute depths at ' + n.getCoordinate());\n      n.getEdges().computeDepths(startEdge);\n\n      for (let i = n.getEdges().iterator(); i.hasNext();) {\n        const de = i.next();\n        de.setVisited(true);\n        this.copySymDepths(de);\n      }\n    }\n\n    computeDepth(outsideDepth) {\n      this.clearVisitedEdges();\n\n      const de = this._finder.getEdge();\n\n      const n = de.getNode();\n      const label = de.getLabel();\n      de.setEdgeDepths(Position.RIGHT, outsideDepth);\n      this.copySymDepths(de);\n      this.computeDepths(de);\n    }\n\n    create(node) {\n      this.addReachable(node);\n\n      this._finder.findEdge(this._dirEdgeList);\n\n      this._rightMostCoord = this._finder.getCoordinate();\n    }\n\n    findResultEdges() {\n      for (let it = this._dirEdgeList.iterator(); it.hasNext();) {\n        const de = it.next();\n        if (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) de.setInResult(true);\n      }\n    }\n\n    computeDepths(startEdge) {\n      const nodesVisited = new HashSet();\n      const nodeQueue = new LinkedList();\n      const startNode = startEdge.getNode();\n      nodeQueue.addLast(startNode);\n      nodesVisited.add(startNode);\n      startEdge.setVisited(true);\n\n      while (!nodeQueue.isEmpty()) {\n        const n = nodeQueue.removeFirst();\n        nodesVisited.add(n);\n        this.computeNodeDepth(n);\n\n        for (let i = n.getEdges().iterator(); i.hasNext();) {\n          const de = i.next();\n          const sym = de.getSym();\n          if (sym.isVisited()) continue;\n          const adjNode = sym.getNode();\n\n          if (!nodesVisited.contains(adjNode)) {\n            nodeQueue.addLast(adjNode);\n            nodesVisited.add(adjNode);\n          }\n        }\n      }\n    }\n\n    compareTo(o) {\n      const graph = o;\n      if (this._rightMostCoord.x < graph._rightMostCoord.x) return -1;\n      if (this._rightMostCoord.x > graph._rightMostCoord.x) return 1;\n      return 0;\n    }\n\n    getEnvelope() {\n      if (this._env === null) {\n        const edgeEnv = new Envelope();\n\n        for (let it = this._dirEdgeList.iterator(); it.hasNext();) {\n          const dirEdge = it.next();\n          const pts = dirEdge.getEdge().getCoordinates();\n\n          for (let i = 0; i < pts.length - 1; i++) edgeEnv.expandToInclude(pts[i]);\n        }\n\n        this._env = edgeEnv;\n      }\n\n      return this._env;\n    }\n\n    addReachable(startNode) {\n      const nodeStack = new Stack();\n      nodeStack.add(startNode);\n\n      while (!nodeStack.empty()) {\n        const node = nodeStack.pop();\n        this.add(node, nodeStack);\n      }\n    }\n\n    copySymDepths(de) {\n      const sym = de.getSym();\n      sym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT));\n      sym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT));\n    }\n\n    add(node, nodeStack) {\n      node.setVisited(true);\n\n      this._nodes.add(node);\n\n      for (let i = node.getEdges().iterator(); i.hasNext();) {\n        const de = i.next();\n\n        this._dirEdgeList.add(de);\n\n        const sym = de.getSym();\n        const symNode = sym.getNode();\n        if (!symNode.isVisited()) nodeStack.push(symNode);\n      }\n    }\n\n    getNodes() {\n      return this._nodes;\n    }\n\n    getDirectedEdges() {\n      return this._dirEdgeList;\n    }\n\n    get interfaces_() {\n      return [Comparable];\n    }\n\n  }\n\n  class EdgeRing {\n    constructor() {\n      EdgeRing.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._startDe = null;\n      this._maxNodeDegree = -1;\n      this._edges = new ArrayList();\n      this._pts = new ArrayList();\n      this._label = new Label(Location.NONE);\n      this._ring = null;\n      this._isHole = null;\n      this._shell = null;\n      this._holes = new ArrayList();\n      this._geometryFactory = null;\n\n      if (arguments.length === 0) ; else if (arguments.length === 2) {\n        const start = arguments[0],\n              geometryFactory = arguments[1];\n        this._geometryFactory = geometryFactory;\n        this.computePoints(start);\n        this.computeRing();\n      }\n    }\n\n    computeRing() {\n      if (this._ring !== null) return null;\n      const coord = new Array(this._pts.size()).fill(null);\n\n      for (let i = 0; i < this._pts.size(); i++) coord[i] = this._pts.get(i);\n\n      this._ring = this._geometryFactory.createLinearRing(coord);\n      this._isHole = Orientation.isCCW(this._ring.getCoordinates());\n    }\n\n    isIsolated() {\n      return this._label.getGeometryCount() === 1;\n    }\n\n    computePoints(start) {\n      this._startDe = start;\n      let de = start;\n      let isFirstEdge = true;\n\n      do {\n        if (de === null) throw new TopologyException('Found null DirectedEdge');\n        if (de.getEdgeRing() === this) throw new TopologyException('Directed Edge visited twice during ring-building at ' + de.getCoordinate());\n\n        this._edges.add(de);\n\n        const label = de.getLabel();\n        Assert.isTrue(label.isArea());\n        this.mergeLabel(label);\n        this.addPoints(de.getEdge(), de.isForward(), isFirstEdge);\n        isFirstEdge = false;\n        this.setEdgeRing(de, this);\n        de = this.getNext(de);\n      } while (de !== this._startDe);\n    }\n\n    getLinearRing() {\n      return this._ring;\n    }\n\n    getCoordinate(i) {\n      return this._pts.get(i);\n    }\n\n    computeMaxNodeDegree() {\n      this._maxNodeDegree = 0;\n      let de = this._startDe;\n\n      do {\n        const node = de.getNode();\n        const degree = node.getEdges().getOutgoingDegree(this);\n        if (degree > this._maxNodeDegree) this._maxNodeDegree = degree;\n        de = this.getNext(de);\n      } while (de !== this._startDe);\n\n      this._maxNodeDegree *= 2;\n    }\n\n    addPoints(edge, isForward, isFirstEdge) {\n      const edgePts = edge.getCoordinates();\n\n      if (isForward) {\n        let startIndex = 1;\n        if (isFirstEdge) startIndex = 0;\n\n        for (let i = startIndex; i < edgePts.length; i++) this._pts.add(edgePts[i]);\n      } else {\n        let startIndex = edgePts.length - 2;\n        if (isFirstEdge) startIndex = edgePts.length - 1;\n\n        for (let i = startIndex; i >= 0; i--) this._pts.add(edgePts[i]);\n      }\n    }\n\n    isHole() {\n      return this._isHole;\n    }\n\n    setInResult() {\n      let de = this._startDe;\n\n      do {\n        de.getEdge().setInResult(true);\n        de = de.getNext();\n      } while (de !== this._startDe);\n    }\n\n    containsPoint(p) {\n      const shell = this.getLinearRing();\n      const env = shell.getEnvelopeInternal();\n      if (!env.contains(p)) return false;\n      if (!PointLocation.isInRing(p, shell.getCoordinates())) return false;\n\n      for (let i = this._holes.iterator(); i.hasNext();) {\n        const hole = i.next();\n        if (hole.containsPoint(p)) return false;\n      }\n\n      return true;\n    }\n\n    addHole(ring) {\n      this._holes.add(ring);\n    }\n\n    isShell() {\n      return this._shell === null;\n    }\n\n    getLabel() {\n      return this._label;\n    }\n\n    getEdges() {\n      return this._edges;\n    }\n\n    getMaxNodeDegree() {\n      if (this._maxNodeDegree < 0) this.computeMaxNodeDegree();\n      return this._maxNodeDegree;\n    }\n\n    getShell() {\n      return this._shell;\n    }\n\n    mergeLabel() {\n      if (arguments.length === 1) {\n        const deLabel = arguments[0];\n        this.mergeLabel(deLabel, 0);\n        this.mergeLabel(deLabel, 1);\n      } else if (arguments.length === 2) {\n        const deLabel = arguments[0],\n              geomIndex = arguments[1];\n        const loc = deLabel.getLocation(geomIndex, Position.RIGHT);\n        if (loc === Location.NONE) return null;\n\n        if (this._label.getLocation(geomIndex) === Location.NONE) {\n          this._label.setLocation(geomIndex, loc);\n\n          return null;\n        }\n      }\n    }\n\n    setShell(shell) {\n      this._shell = shell;\n      if (shell !== null) shell.addHole(this);\n    }\n\n    toPolygon(geometryFactory) {\n      const holeLR = new Array(this._holes.size()).fill(null);\n\n      for (let i = 0; i < this._holes.size(); i++) holeLR[i] = this._holes.get(i).getLinearRing();\n\n      const poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);\n      return poly;\n    }\n\n  }\n\n  class MinimalEdgeRing extends EdgeRing {\n    constructor() {\n      super();\n      MinimalEdgeRing.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      const start = arguments[0],\n            geometryFactory = arguments[1];\n      EdgeRing.constructor_.call(this, start, geometryFactory);\n    }\n\n    setEdgeRing(de, er) {\n      de.setMinEdgeRing(er);\n    }\n\n    getNext(de) {\n      return de.getNextMin();\n    }\n\n  }\n\n  class MaximalEdgeRing extends EdgeRing {\n    constructor() {\n      super();\n      MaximalEdgeRing.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      const start = arguments[0],\n            geometryFactory = arguments[1];\n      EdgeRing.constructor_.call(this, start, geometryFactory);\n    }\n\n    buildMinimalRings() {\n      const minEdgeRings = new ArrayList();\n      let de = this._startDe;\n\n      do {\n        if (de.getMinEdgeRing() === null) {\n          const minEr = new MinimalEdgeRing(de, this._geometryFactory);\n          minEdgeRings.add(minEr);\n        }\n\n        de = de.getNext();\n      } while (de !== this._startDe);\n\n      return minEdgeRings;\n    }\n\n    setEdgeRing(de, er) {\n      de.setEdgeRing(er);\n    }\n\n    linkDirectedEdgesForMinimalEdgeRings() {\n      let de = this._startDe;\n\n      do {\n        const node = de.getNode();\n        node.getEdges().linkMinimalDirectedEdges(this);\n        de = de.getNext();\n      } while (de !== this._startDe);\n    }\n\n    getNext(de) {\n      return de.getNext();\n    }\n\n  }\n\n  class PolygonBuilder {\n    constructor() {\n      PolygonBuilder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._geometryFactory = null;\n      this._shellList = new ArrayList();\n      const geometryFactory = arguments[0];\n      this._geometryFactory = geometryFactory;\n    }\n\n    static findEdgeRingContaining(testEr, shellList) {\n      const testRing = testEr.getLinearRing();\n      const testEnv = testRing.getEnvelopeInternal();\n      let testPt = testRing.getCoordinateN(0);\n      let minShell = null;\n      let minShellEnv = null;\n\n      for (let it = shellList.iterator(); it.hasNext();) {\n        const tryShell = it.next();\n        const tryShellRing = tryShell.getLinearRing();\n        const tryShellEnv = tryShellRing.getEnvelopeInternal();\n        if (tryShellEnv.equals(testEnv)) continue;\n        if (!tryShellEnv.contains(testEnv)) continue;\n        testPt = CoordinateArrays.ptNotInList(testRing.getCoordinates(), tryShellRing.getCoordinates());\n        let isContained = false;\n        if (PointLocation.isInRing(testPt, tryShellRing.getCoordinates())) isContained = true;\n        if (isContained) if (minShell === null || minShellEnv.contains(tryShellEnv)) {\n          minShell = tryShell;\n          minShellEnv = minShell.getLinearRing().getEnvelopeInternal();\n        }\n      }\n\n      return minShell;\n    }\n\n    sortShellsAndHoles(edgeRings, shellList, freeHoleList) {\n      for (let it = edgeRings.iterator(); it.hasNext();) {\n        const er = it.next();\n        if (er.isHole()) freeHoleList.add(er);else shellList.add(er);\n      }\n    }\n\n    computePolygons(shellList) {\n      const resultPolyList = new ArrayList();\n\n      for (let it = shellList.iterator(); it.hasNext();) {\n        const er = it.next();\n        const poly = er.toPolygon(this._geometryFactory);\n        resultPolyList.add(poly);\n      }\n\n      return resultPolyList;\n    }\n\n    placeFreeHoles(shellList, freeHoleList) {\n      for (let it = freeHoleList.iterator(); it.hasNext();) {\n        const hole = it.next();\n\n        if (hole.getShell() === null) {\n          const shell = PolygonBuilder.findEdgeRingContaining(hole, shellList);\n          if (shell === null) throw new TopologyException('unable to assign hole to a shell', hole.getCoordinate(0));\n          hole.setShell(shell);\n        }\n      }\n    }\n\n    buildMinimalEdgeRings(maxEdgeRings, shellList, freeHoleList) {\n      const edgeRings = new ArrayList();\n\n      for (let it = maxEdgeRings.iterator(); it.hasNext();) {\n        const er = it.next();\n\n        if (er.getMaxNodeDegree() > 2) {\n          er.linkDirectedEdgesForMinimalEdgeRings();\n          const minEdgeRings = er.buildMinimalRings();\n          const shell = this.findShell(minEdgeRings);\n\n          if (shell !== null) {\n            this.placePolygonHoles(shell, minEdgeRings);\n            shellList.add(shell);\n          } else {\n            freeHoleList.addAll(minEdgeRings);\n          }\n        } else {\n          edgeRings.add(er);\n        }\n      }\n\n      return edgeRings;\n    }\n\n    buildMaximalEdgeRings(dirEdges) {\n      const maxEdgeRings = new ArrayList();\n\n      for (let it = dirEdges.iterator(); it.hasNext();) {\n        const de = it.next();\n        if (de.isInResult() && de.getLabel().isArea()) if (de.getEdgeRing() === null) {\n          const er = new MaximalEdgeRing(de, this._geometryFactory);\n          maxEdgeRings.add(er);\n          er.setInResult();\n        }\n      }\n\n      return maxEdgeRings;\n    }\n\n    placePolygonHoles(shell, minEdgeRings) {\n      for (let it = minEdgeRings.iterator(); it.hasNext();) {\n        const er = it.next();\n        if (er.isHole()) er.setShell(shell);\n      }\n    }\n\n    getPolygons() {\n      const resultPolyList = this.computePolygons(this._shellList);\n      return resultPolyList;\n    }\n\n    findShell(minEdgeRings) {\n      let shellCount = 0;\n      let shell = null;\n\n      for (let it = minEdgeRings.iterator(); it.hasNext();) {\n        const er = it.next();\n\n        if (!er.isHole()) {\n          shell = er;\n          shellCount++;\n        }\n      }\n\n      Assert.isTrue(shellCount <= 1, 'found two shells in MinimalEdgeRing list');\n      return shell;\n    }\n\n    add() {\n      if (arguments.length === 1) {\n        const graph = arguments[0];\n        this.add(graph.getEdgeEnds(), graph.getNodes());\n      } else if (arguments.length === 2) {\n        const dirEdges = arguments[0],\n              nodes = arguments[1];\n        PlanarGraph.linkResultDirectedEdges(nodes);\n        const maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);\n        const freeHoleList = new ArrayList();\n        const edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);\n        this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);\n        this.placeFreeHoles(this._shellList, freeHoleList);\n      }\n    }\n\n  }\n\n  class BufferInputLineSimplifier {\n    constructor() {\n      BufferInputLineSimplifier.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._inputLine = null;\n      this._distanceTol = null;\n      this._isDeleted = null;\n      this._angleOrientation = Orientation.COUNTERCLOCKWISE;\n      const inputLine = arguments[0];\n      this._inputLine = inputLine;\n    }\n\n    static simplify(inputLine, distanceTol) {\n      const simp = new BufferInputLineSimplifier(inputLine);\n      return simp.simplify(distanceTol);\n    }\n\n    isDeletable(i0, i1, i2, distanceTol) {\n      const p0 = this._inputLine[i0];\n      const p1 = this._inputLine[i1];\n      const p2 = this._inputLine[i2];\n      if (!this.isConcave(p0, p1, p2)) return false;\n      if (!this.isShallow(p0, p1, p2, distanceTol)) return false;\n      return this.isShallowSampled(p0, p1, i0, i2, distanceTol);\n    }\n\n    deleteShallowConcavities() {\n      let index = 1;\n      let midIndex = this.findNextNonDeletedIndex(index);\n      let lastIndex = this.findNextNonDeletedIndex(midIndex);\n      let isChanged = false;\n\n      while (lastIndex < this._inputLine.length) {\n        let isMiddleVertexDeleted = false;\n\n        if (this.isDeletable(index, midIndex, lastIndex, this._distanceTol)) {\n          this._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;\n          isMiddleVertexDeleted = true;\n          isChanged = true;\n        }\n\n        if (isMiddleVertexDeleted) index = lastIndex;else index = midIndex;\n        midIndex = this.findNextNonDeletedIndex(index);\n        lastIndex = this.findNextNonDeletedIndex(midIndex);\n      }\n\n      return isChanged;\n    }\n\n    isShallowConcavity(p0, p1, p2, distanceTol) {\n      const orientation = Orientation.index(p0, p1, p2);\n      const isAngleToSimplify = orientation === this._angleOrientation;\n      if (!isAngleToSimplify) return false;\n      const dist = Distance.pointToSegment(p1, p0, p2);\n      return dist < distanceTol;\n    }\n\n    isShallowSampled(p0, p2, i0, i2, distanceTol) {\n      let inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);\n      if (inc <= 0) inc = 1;\n\n      for (let i = i0; i < i2; i += inc) if (!this.isShallow(p0, p2, this._inputLine[i], distanceTol)) return false;\n\n      return true;\n    }\n\n    isConcave(p0, p1, p2) {\n      const orientation = Orientation.index(p0, p1, p2);\n      const isConcave = orientation === this._angleOrientation;\n      return isConcave;\n    }\n\n    simplify(distanceTol) {\n      this._distanceTol = Math.abs(distanceTol);\n      if (distanceTol < 0) this._angleOrientation = Orientation.CLOCKWISE;\n      this._isDeleted = new Array(this._inputLine.length).fill(null);\n      let isChanged = false;\n\n      do isChanged = this.deleteShallowConcavities(); while (isChanged);\n\n      return this.collapseLine();\n    }\n\n    findNextNonDeletedIndex(index) {\n      let next = index + 1;\n\n      while (next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE) next++;\n\n      return next;\n    }\n\n    isShallow(p0, p1, p2, distanceTol) {\n      const dist = Distance.pointToSegment(p1, p0, p2);\n      return dist < distanceTol;\n    }\n\n    collapseLine() {\n      const coordList = new CoordinateList();\n\n      for (let i = 0; i < this._inputLine.length; i++) if (this._isDeleted[i] !== BufferInputLineSimplifier.DELETE) coordList.add(this._inputLine[i]);\n\n      return coordList.toCoordinateArray();\n    }\n\n  }\n  BufferInputLineSimplifier.INIT = 0;\n  BufferInputLineSimplifier.DELETE = 1;\n  BufferInputLineSimplifier.KEEP = 1;\n  BufferInputLineSimplifier.NUM_PTS_TO_CHECK = 10;\n\n  class OffsetSegmentString {\n    constructor() {\n      OffsetSegmentString.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._ptList = null;\n      this._precisionModel = null;\n      this._minimimVertexDistance = 0.0;\n      this._ptList = new ArrayList();\n    }\n\n    getCoordinates() {\n      const coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);\n\n      return coord;\n    }\n\n    setPrecisionModel(precisionModel) {\n      this._precisionModel = precisionModel;\n    }\n\n    addPt(pt) {\n      const bufPt = new Coordinate(pt);\n\n      this._precisionModel.makePrecise(bufPt);\n\n      if (this.isRedundant(bufPt)) return null;\n\n      this._ptList.add(bufPt);\n    }\n\n    reverse() {}\n\n    addPts(pt, isForward) {\n      if (isForward) for (let i = 0; i < pt.length; i++) this.addPt(pt[i]);else for (let i = pt.length - 1; i >= 0; i--) this.addPt(pt[i]);\n    }\n\n    isRedundant(pt) {\n      if (this._ptList.size() < 1) return false;\n\n      const lastPt = this._ptList.get(this._ptList.size() - 1);\n\n      const ptDist = pt.distance(lastPt);\n      if (ptDist < this._minimimVertexDistance) return true;\n      return false;\n    }\n\n    toString() {\n      const fact = new GeometryFactory();\n      const line = fact.createLineString(this.getCoordinates());\n      return line.toString();\n    }\n\n    closeRing() {\n      if (this._ptList.size() < 1) return null;\n      const startPt = new Coordinate(this._ptList.get(0));\n\n      const lastPt = this._ptList.get(this._ptList.size() - 1);\n\n      if (startPt.equals(lastPt)) return null;\n\n      this._ptList.add(startPt);\n    }\n\n    setMinimumVertexDistance(minimimVertexDistance) {\n      this._minimimVertexDistance = minimimVertexDistance;\n    }\n\n  }\n  OffsetSegmentString.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);\n\n  class OffsetSegmentGenerator {\n    constructor() {\n      OffsetSegmentGenerator.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._maxCurveSegmentError = 0.0;\n      this._filletAngleQuantum = null;\n      this._closingSegLengthFactor = 1;\n      this._segList = null;\n      this._distance = 0.0;\n      this._precisionModel = null;\n      this._bufParams = null;\n      this._li = null;\n      this._s0 = null;\n      this._s1 = null;\n      this._s2 = null;\n      this._seg0 = new LineSegment();\n      this._seg1 = new LineSegment();\n      this._offset0 = new LineSegment();\n      this._offset1 = new LineSegment();\n      this._side = 0;\n      this._hasNarrowConcaveAngle = false;\n      const precisionModel = arguments[0],\n            bufParams = arguments[1],\n            distance = arguments[2];\n      this._precisionModel = precisionModel;\n      this._bufParams = bufParams;\n      this._li = new RobustLineIntersector();\n      this._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();\n      if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR;\n      this.init(distance);\n    }\n\n    addNextSegment(p, addStartPoint) {\n      this._s0 = this._s1;\n      this._s1 = this._s2;\n      this._s2 = p;\n\n      this._seg0.setCoordinates(this._s0, this._s1);\n\n      this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);\n\n      this._seg1.setCoordinates(this._s1, this._s2);\n\n      this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);\n      if (this._s1.equals(this._s2)) return null;\n      const orientation = Orientation.index(this._s0, this._s1, this._s2);\n      const outsideTurn = orientation === Orientation.CLOCKWISE && this._side === Position.LEFT || orientation === Orientation.COUNTERCLOCKWISE && this._side === Position.RIGHT;\n      if (orientation === 0) this.addCollinear(addStartPoint);else if (outsideTurn) this.addOutsideTurn(orientation, addStartPoint);else this.addInsideTurn(orientation, addStartPoint);\n    }\n\n    addLineEndCap(p0, p1) {\n      const seg = new LineSegment(p0, p1);\n      const offsetL = new LineSegment();\n      this.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL);\n      const offsetR = new LineSegment();\n      this.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR);\n      const dx = p1.x - p0.x;\n      const dy = p1.y - p0.y;\n      const angle = Math.atan2(dy, dx);\n\n      switch (this._bufParams.getEndCapStyle()) {\n        case BufferParameters.CAP_ROUND:\n          this._segList.addPt(offsetL.p1);\n\n          this.addDirectedFillet(p1, angle + Math.PI / 2, angle - Math.PI / 2, Orientation.CLOCKWISE, this._distance);\n\n          this._segList.addPt(offsetR.p1);\n\n          break;\n\n        case BufferParameters.CAP_FLAT:\n          this._segList.addPt(offsetL.p1);\n\n          this._segList.addPt(offsetR.p1);\n\n          break;\n\n        case BufferParameters.CAP_SQUARE:\n          const squareCapSideOffset = new Coordinate();\n          squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);\n          squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);\n          const squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);\n          const squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);\n\n          this._segList.addPt(squareCapLOffset);\n\n          this._segList.addPt(squareCapROffset);\n\n          break;\n      }\n    }\n\n    getCoordinates() {\n      const pts = this._segList.getCoordinates();\n\n      return pts;\n    }\n\n    addMitreJoin(p, offset0, offset1, distance) {\n      const intPt = Intersection.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);\n\n      if (intPt !== null) {\n        const mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);\n\n        if (mitreRatio <= this._bufParams.getMitreLimit()) {\n          this._segList.addPt(intPt);\n\n          return null;\n        }\n      }\n\n      this.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());\n    }\n\n    addOutsideTurn(orientation, addStartPoint) {\n      if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {\n        this._segList.addPt(this._offset0.p1);\n\n        return null;\n      }\n\n      if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n        this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);\n      } else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {\n        this.addBevelJoin(this._offset0, this._offset1);\n      } else {\n        if (addStartPoint) this._segList.addPt(this._offset0.p1);\n        this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);\n\n        this._segList.addPt(this._offset1.p0);\n      }\n    }\n\n    createSquare(p) {\n      this._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance));\n\n      this._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance));\n\n      this._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance));\n\n      this._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance));\n\n      this._segList.closeRing();\n    }\n\n    addSegments(pt, isForward) {\n      this._segList.addPts(pt, isForward);\n    }\n\n    addFirstSegment() {\n      this._segList.addPt(this._offset1.p0);\n    }\n\n    addCornerFillet(p, p0, p1, direction, radius) {\n      const dx0 = p0.x - p.x;\n      const dy0 = p0.y - p.y;\n      let startAngle = Math.atan2(dy0, dx0);\n      const dx1 = p1.x - p.x;\n      const dy1 = p1.y - p.y;\n      const endAngle = Math.atan2(dy1, dx1);\n\n      if (direction === Orientation.CLOCKWISE) {\n        if (startAngle <= endAngle) startAngle += 2.0 * Math.PI;\n      } else {\n        if (startAngle >= endAngle) startAngle -= 2.0 * Math.PI;\n      }\n\n      this._segList.addPt(p0);\n\n      this.addDirectedFillet(p, startAngle, endAngle, direction, radius);\n\n      this._segList.addPt(p1);\n    }\n\n    addLastSegment() {\n      this._segList.addPt(this._offset1.p1);\n    }\n\n    initSideSegments(s1, s2, side) {\n      this._s1 = s1;\n      this._s2 = s2;\n      this._side = side;\n\n      this._seg1.setCoordinates(s1, s2);\n\n      this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);\n    }\n\n    addLimitedMitreJoin(offset0, offset1, distance, mitreLimit) {\n      const basePt = this._seg0.p1;\n      const ang0 = Angle.angle(basePt, this._seg0.p0);\n      const angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);\n      const angDiffHalf = angDiff / 2;\n      const midAng = Angle.normalize(ang0 + angDiffHalf);\n      const mitreMidAng = Angle.normalize(midAng + Math.PI);\n      const mitreDist = mitreLimit * distance;\n      const bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));\n      const bevelHalfLen = distance - bevelDelta;\n      const bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);\n      const bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);\n      const bevelMidPt = new Coordinate(bevelMidX, bevelMidY);\n      const mitreMidLine = new LineSegment(basePt, bevelMidPt);\n      const bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);\n      const bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);\n\n      if (this._side === Position.LEFT) {\n        this._segList.addPt(bevelEndLeft);\n\n        this._segList.addPt(bevelEndRight);\n      } else {\n        this._segList.addPt(bevelEndRight);\n\n        this._segList.addPt(bevelEndLeft);\n      }\n    }\n\n    addDirectedFillet(p, startAngle, endAngle, direction, radius) {\n      const directionFactor = direction === Orientation.CLOCKWISE ? -1 : 1;\n      const totalAngle = Math.abs(startAngle - endAngle);\n      const nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);\n      if (nSegs < 1) return null;\n      const angleInc = totalAngle / nSegs;\n      const pt = new Coordinate();\n\n      for (let i = 0; i < nSegs; i++) {\n        const angle = startAngle + directionFactor * i * angleInc;\n        pt.x = p.x + radius * Math.cos(angle);\n        pt.y = p.y + radius * Math.sin(angle);\n\n        this._segList.addPt(pt);\n      }\n    }\n\n    computeOffsetSegment(seg, side, distance, offset) {\n      const sideSign = side === Position.LEFT ? 1 : -1;\n      const dx = seg.p1.x - seg.p0.x;\n      const dy = seg.p1.y - seg.p0.y;\n      const len = Math.sqrt(dx * dx + dy * dy);\n      const ux = sideSign * distance * dx / len;\n      const uy = sideSign * distance * dy / len;\n      offset.p0.x = seg.p0.x - uy;\n      offset.p0.y = seg.p0.y + ux;\n      offset.p1.x = seg.p1.x - uy;\n      offset.p1.y = seg.p1.y + ux;\n    }\n\n    addInsideTurn(orientation, addStartPoint) {\n      this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);\n\n      if (this._li.hasIntersection()) {\n        this._segList.addPt(this._li.getIntersection(0));\n      } else {\n        this._hasNarrowConcaveAngle = true;\n\n        if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {\n          this._segList.addPt(this._offset0.p1);\n        } else {\n          this._segList.addPt(this._offset0.p1);\n\n          if (this._closingSegLengthFactor > 0) {\n            const mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n\n            this._segList.addPt(mid0);\n\n            const mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n\n            this._segList.addPt(mid1);\n          } else {\n            this._segList.addPt(this._s1);\n          }\n\n          this._segList.addPt(this._offset1.p0);\n        }\n      }\n    }\n\n    createCircle(p) {\n      const pt = new Coordinate(p.x + this._distance, p.y);\n\n      this._segList.addPt(pt);\n\n      this.addDirectedFillet(p, 0.0, 2.0 * Math.PI, -1, this._distance);\n\n      this._segList.closeRing();\n    }\n\n    addBevelJoin(offset0, offset1) {\n      this._segList.addPt(offset0.p1);\n\n      this._segList.addPt(offset1.p0);\n    }\n\n    init(distance) {\n      this._distance = distance;\n      this._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0));\n      this._segList = new OffsetSegmentString();\n\n      this._segList.setPrecisionModel(this._precisionModel);\n\n      this._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);\n    }\n\n    addCollinear(addStartPoint) {\n      this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);\n\n      const numInt = this._li.getIntersectionNum();\n\n      if (numInt >= 2) if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n        if (addStartPoint) this._segList.addPt(this._offset0.p1);\n\n        this._segList.addPt(this._offset1.p0);\n      } else {\n        this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, Orientation.CLOCKWISE, this._distance);\n      }\n    }\n\n    closeRing() {\n      this._segList.closeRing();\n    }\n\n    hasNarrowConcaveAngle() {\n      return this._hasNarrowConcaveAngle;\n    }\n\n  }\n  OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR = 1.0E-3;\n  OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-3;\n  OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-6;\n  OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR = 80;\n\n  class OffsetCurveBuilder {\n    constructor() {\n      OffsetCurveBuilder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._distance = 0.0;\n      this._precisionModel = null;\n      this._bufParams = null;\n      const precisionModel = arguments[0],\n            bufParams = arguments[1];\n      this._precisionModel = precisionModel;\n      this._bufParams = bufParams;\n    }\n\n    static copyCoordinates(pts) {\n      const copy = new Array(pts.length).fill(null);\n\n      for (let i = 0; i < copy.length; i++) copy[i] = new Coordinate(pts[i]);\n\n      return copy;\n    }\n\n    getOffsetCurve(inputPts, distance) {\n      this._distance = distance;\n      if (distance === 0.0) return null;\n      const isRightSide = distance < 0.0;\n      const posDistance = Math.abs(distance);\n      const segGen = this.getSegGen(posDistance);\n      if (inputPts.length <= 1) this.computePointCurve(inputPts[0], segGen);else this.computeOffsetCurve(inputPts, isRightSide, segGen);\n      const curvePts = segGen.getCoordinates();\n      if (isRightSide) CoordinateArrays.reverse(curvePts);\n      return curvePts;\n    }\n\n    computeSingleSidedBufferCurve(inputPts, isRightSide, segGen) {\n      const distTol = this.simplifyTolerance(this._distance);\n\n      if (isRightSide) {\n        segGen.addSegments(inputPts, true);\n        const simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n        const n2 = simp2.length - 1;\n        segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n        segGen.addFirstSegment();\n\n        for (let i = n2 - 2; i >= 0; i--) segGen.addNextSegment(simp2[i], true);\n      } else {\n        segGen.addSegments(inputPts, false);\n        const simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n        const n1 = simp1.length - 1;\n        segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n        segGen.addFirstSegment();\n\n        for (let i = 2; i <= n1; i++) segGen.addNextSegment(simp1[i], true);\n      }\n\n      segGen.addLastSegment();\n      segGen.closeRing();\n    }\n\n    computeRingBufferCurve(inputPts, side, segGen) {\n      let distTol = this.simplifyTolerance(this._distance);\n      if (side === Position.RIGHT) distTol = -distTol;\n      const simp = BufferInputLineSimplifier.simplify(inputPts, distTol);\n      const n = simp.length - 1;\n      segGen.initSideSegments(simp[n - 1], simp[0], side);\n\n      for (let i = 1; i <= n; i++) {\n        const addStartPoint = i !== 1;\n        segGen.addNextSegment(simp[i], addStartPoint);\n      }\n\n      segGen.closeRing();\n    }\n\n    computeLineBufferCurve(inputPts, segGen) {\n      const distTol = this.simplifyTolerance(this._distance);\n      const simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n      const n1 = simp1.length - 1;\n      segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n\n      for (let i = 2; i <= n1; i++) segGen.addNextSegment(simp1[i], true);\n\n      segGen.addLastSegment();\n      segGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);\n      const simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n      const n2 = simp2.length - 1;\n      segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n\n      for (let i = n2 - 2; i >= 0; i--) segGen.addNextSegment(simp2[i], true);\n\n      segGen.addLastSegment();\n      segGen.addLineEndCap(simp2[1], simp2[0]);\n      segGen.closeRing();\n    }\n\n    computePointCurve(pt, segGen) {\n      switch (this._bufParams.getEndCapStyle()) {\n        case BufferParameters.CAP_ROUND:\n          segGen.createCircle(pt);\n          break;\n\n        case BufferParameters.CAP_SQUARE:\n          segGen.createSquare(pt);\n          break;\n      }\n    }\n\n    getLineCurve(inputPts, distance) {\n      this._distance = distance;\n      if (this.isLineOffsetEmpty(distance)) return null;\n      const posDistance = Math.abs(distance);\n      const segGen = this.getSegGen(posDistance);\n\n      if (inputPts.length <= 1) {\n        this.computePointCurve(inputPts[0], segGen);\n      } else if (this._bufParams.isSingleSided()) {\n        const isRightSide = distance < 0.0;\n        this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);\n      } else {\n        this.computeLineBufferCurve(inputPts, segGen);\n      }\n\n      const lineCoord = segGen.getCoordinates();\n      return lineCoord;\n    }\n\n    getBufferParameters() {\n      return this._bufParams;\n    }\n\n    simplifyTolerance(bufDistance) {\n      return bufDistance * this._bufParams.getSimplifyFactor();\n    }\n\n    getRingCurve(inputPts, side, distance) {\n      this._distance = distance;\n      if (inputPts.length <= 2) return this.getLineCurve(inputPts, distance);\n      if (distance === 0.0) return OffsetCurveBuilder.copyCoordinates(inputPts);\n      const segGen = this.getSegGen(distance);\n      this.computeRingBufferCurve(inputPts, side, segGen);\n      return segGen.getCoordinates();\n    }\n\n    computeOffsetCurve(inputPts, isRightSide, segGen) {\n      const distTol = this.simplifyTolerance(this._distance);\n\n      if (isRightSide) {\n        const simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n        const n2 = simp2.length - 1;\n        segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n        segGen.addFirstSegment();\n\n        for (let i = n2 - 2; i >= 0; i--) segGen.addNextSegment(simp2[i], true);\n      } else {\n        const simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n        const n1 = simp1.length - 1;\n        segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n        segGen.addFirstSegment();\n\n        for (let i = 2; i <= n1; i++) segGen.addNextSegment(simp1[i], true);\n      }\n\n      segGen.addLastSegment();\n    }\n\n    isLineOffsetEmpty(distance) {\n      if (distance === 0.0) return true;\n      if (distance < 0.0 && !this._bufParams.isSingleSided()) return true;\n      return false;\n    }\n\n    getSegGen(distance) {\n      return new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance);\n    }\n\n  }\n\n  class SubgraphDepthLocater {\n    constructor() {\n      SubgraphDepthLocater.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._subgraphs = null;\n      this._seg = new LineSegment();\n      const subgraphs = arguments[0];\n      this._subgraphs = subgraphs;\n    }\n\n    findStabbedSegments() {\n      if (arguments.length === 1) {\n        const stabbingRayLeftPt = arguments[0];\n        const stabbedSegments = new ArrayList();\n\n        for (let i = this._subgraphs.iterator(); i.hasNext();) {\n          const bsg = i.next();\n          const env = bsg.getEnvelope();\n          if (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) continue;\n          this.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);\n        }\n\n        return stabbedSegments;\n      } else if (arguments.length === 3) {\n        if (hasInterface(arguments[2], List) && arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge) {\n          const stabbingRayLeftPt = arguments[0],\n                dirEdge = arguments[1],\n                stabbedSegments = arguments[2];\n          const pts = dirEdge.getEdge().getCoordinates();\n\n          for (let i = 0; i < pts.length - 1; i++) {\n            this._seg.p0 = pts[i];\n            this._seg.p1 = pts[i + 1];\n            if (this._seg.p0.y > this._seg.p1.y) this._seg.reverse();\n            const maxx = Math.max(this._seg.p0.x, this._seg.p1.x);\n            if (maxx < stabbingRayLeftPt.x) continue;\n            if (this._seg.isHorizontal()) continue;\n            if (stabbingRayLeftPt.y < this._seg.p0.y || stabbingRayLeftPt.y > this._seg.p1.y) continue;\n            if (Orientation.index(this._seg.p0, this._seg.p1, stabbingRayLeftPt) === Orientation.RIGHT) continue;\n            let depth = dirEdge.getDepth(Position.LEFT);\n            if (!this._seg.p0.equals(pts[i])) depth = dirEdge.getDepth(Position.RIGHT);\n            const ds = new DepthSegment(this._seg, depth);\n            stabbedSegments.add(ds);\n          }\n        } else if (hasInterface(arguments[2], List) && arguments[0] instanceof Coordinate && hasInterface(arguments[1], List)) {\n          const stabbingRayLeftPt = arguments[0],\n                dirEdges = arguments[1],\n                stabbedSegments = arguments[2];\n\n          for (let i = dirEdges.iterator(); i.hasNext();) {\n            const de = i.next();\n            if (!de.isForward()) continue;\n            this.findStabbedSegments(stabbingRayLeftPt, de, stabbedSegments);\n          }\n        }\n      }\n    }\n\n    getDepth(p) {\n      const stabbedSegments = this.findStabbedSegments(p);\n      if (stabbedSegments.size() === 0) return 0;\n      const ds = Collections.min(stabbedSegments);\n      return ds._leftDepth;\n    }\n\n  }\n\n  class DepthSegment {\n    constructor() {\n      DepthSegment.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._upwardSeg = null;\n      this._leftDepth = null;\n      const seg = arguments[0],\n            depth = arguments[1];\n      this._upwardSeg = new LineSegment(seg);\n      this._leftDepth = depth;\n    }\n\n    compareTo(obj) {\n      const other = obj;\n      if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) return 1;\n      if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) return -1;\n\n      let orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);\n\n      if (orientIndex !== 0) return orientIndex;\n      orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);\n      if (orientIndex !== 0) return orientIndex;\n      return this._upwardSeg.compareTo(other._upwardSeg);\n    }\n\n    compareX(seg0, seg1) {\n      const compare0 = seg0.p0.compareTo(seg1.p0);\n      if (compare0 !== 0) return compare0;\n      return seg0.p1.compareTo(seg1.p1);\n    }\n\n    toString() {\n      return this._upwardSeg.toString();\n    }\n\n    get interfaces_() {\n      return [Comparable];\n    }\n\n  }\n\n  SubgraphDepthLocater.DepthSegment = DepthSegment;\n\n  class OffsetCurveSetBuilder {\n    constructor() {\n      OffsetCurveSetBuilder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._inputGeom = null;\n      this._distance = null;\n      this._curveBuilder = null;\n      this._curveList = new ArrayList();\n      const inputGeom = arguments[0],\n            distance = arguments[1],\n            curveBuilder = arguments[2];\n      this._inputGeom = inputGeom;\n      this._distance = distance;\n      this._curveBuilder = curveBuilder;\n    }\n\n    addRingSide(coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {\n      if (offsetDistance === 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) return null;\n      let leftLoc = cwLeftLoc;\n      let rightLoc = cwRightLoc;\n\n      if (coord.length >= LinearRing.MINIMUM_VALID_SIZE && Orientation.isCCW(coord)) {\n        leftLoc = cwRightLoc;\n        rightLoc = cwLeftLoc;\n        side = Position.opposite(side);\n      }\n\n      const curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);\n\n      this.addCurve(curve, leftLoc, rightLoc);\n    }\n\n    addRingBothSides(coord, distance) {\n      this.addRingSide(coord, distance, Position.LEFT, Location.EXTERIOR, Location.INTERIOR);\n      this.addRingSide(coord, distance, Position.RIGHT, Location.INTERIOR, Location.EXTERIOR);\n    }\n\n    addPoint(p) {\n      if (this._distance <= 0.0) return null;\n      const coord = p.getCoordinates();\n\n      const curve = this._curveBuilder.getLineCurve(coord, this._distance);\n\n      this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n    }\n\n    addPolygon(p) {\n      let offsetDistance = this._distance;\n      let offsetSide = Position.LEFT;\n\n      if (this._distance < 0.0) {\n        offsetDistance = -this._distance;\n        offsetSide = Position.RIGHT;\n      }\n\n      const shell = p.getExteriorRing();\n      const shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());\n      if (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) return null;\n      if (this._distance <= 0.0 && shellCoord.length < 3) return null;\n      this.addRingSide(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);\n\n      for (let i = 0; i < p.getNumInteriorRing(); i++) {\n        const hole = p.getInteriorRingN(i);\n        const holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());\n        if (this._distance > 0.0 && this.isErodedCompletely(hole, -this._distance)) continue;\n        this.addRingSide(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);\n      }\n    }\n\n    isTriangleErodedCompletely(triangleCoord, bufferDistance) {\n      const tri = new Triangle(triangleCoord[0], triangleCoord[1], triangleCoord[2]);\n      const inCentre = tri.inCentre();\n      const distToCentre = Distance.pointToSegment(inCentre, tri.p0, tri.p1);\n      return distToCentre < Math.abs(bufferDistance);\n    }\n\n    addLineString(line) {\n      if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null;\n      const coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n\n      if (CoordinateArrays.isRing(coord) && !this._curveBuilder.getBufferParameters().isSingleSided()) {\n        this.addRingBothSides(coord, this._distance);\n      } else {\n        const curve = this._curveBuilder.getLineCurve(coord, this._distance);\n\n        this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n      }\n    }\n\n    addCurve(coord, leftLoc, rightLoc) {\n      if (coord === null || coord.length < 2) return null;\n      const e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc));\n\n      this._curveList.add(e);\n    }\n\n    getCurves() {\n      this.add(this._inputGeom);\n      return this._curveList;\n    }\n\n    add(g) {\n      if (g.isEmpty()) return null;\n      if (g instanceof Polygon) this.addPolygon(g);else if (g instanceof LineString) this.addLineString(g);else if (g instanceof Point) this.addPoint(g);else if (g instanceof MultiPoint) this.addCollection(g);else if (g instanceof MultiLineString) this.addCollection(g);else if (g instanceof MultiPolygon) this.addCollection(g);else if (g instanceof GeometryCollection) this.addCollection(g);else throw new UnsupportedOperationException(g.getGeometryType());\n    }\n\n    isErodedCompletely(ring, bufferDistance) {\n      const ringCoord = ring.getCoordinates();\n      if (ringCoord.length < 4) return bufferDistance < 0;\n      if (ringCoord.length === 4) return this.isTriangleErodedCompletely(ringCoord, bufferDistance);\n      const env = ring.getEnvelopeInternal();\n      const envMinDimension = Math.min(env.getHeight(), env.getWidth());\n      if (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) return true;\n      return false;\n    }\n\n    addCollection(gc) {\n      for (let i = 0; i < gc.getNumGeometries(); i++) {\n        const g = gc.getGeometryN(i);\n        this.add(g);\n      }\n    }\n\n  }\n\n  class EdgeEndStar {\n    constructor() {\n      EdgeEndStar.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._edgeMap = new TreeMap();\n      this._edgeList = null;\n      this._ptInAreaLocation = [Location.NONE, Location.NONE];\n    }\n\n    getNextCW(ee) {\n      this.getEdges();\n\n      const i = this._edgeList.indexOf(ee);\n\n      let iNextCW = i - 1;\n      if (i === 0) iNextCW = this._edgeList.size() - 1;\n      return this._edgeList.get(iNextCW);\n    }\n\n    propagateSideLabels(geomIndex) {\n      let startLoc = Location.NONE;\n\n      for (let it = this.iterator(); it.hasNext();) {\n        const e = it.next();\n        const label = e.getLabel();\n        if (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) startLoc = label.getLocation(geomIndex, Position.LEFT);\n      }\n\n      if (startLoc === Location.NONE) return null;\n      let currLoc = startLoc;\n\n      for (let it = this.iterator(); it.hasNext();) {\n        const e = it.next();\n        const label = e.getLabel();\n        if (label.getLocation(geomIndex, Position.ON) === Location.NONE) label.setLocation(geomIndex, Position.ON, currLoc);\n\n        if (label.isArea(geomIndex)) {\n          const leftLoc = label.getLocation(geomIndex, Position.LEFT);\n          const rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n\n          if (rightLoc !== Location.NONE) {\n            if (rightLoc !== currLoc) throw new TopologyException('side location conflict', e.getCoordinate());\n            if (leftLoc === Location.NONE) Assert.shouldNeverReachHere('found single null side (at ' + e.getCoordinate() + ')');\n            currLoc = leftLoc;\n          } else {\n            Assert.isTrue(label.getLocation(geomIndex, Position.LEFT) === Location.NONE, 'found single null side');\n            label.setLocation(geomIndex, Position.RIGHT, currLoc);\n            label.setLocation(geomIndex, Position.LEFT, currLoc);\n          }\n        }\n      }\n    }\n\n    getCoordinate() {\n      const it = this.iterator();\n      if (!it.hasNext()) return null;\n      const e = it.next();\n      return e.getCoordinate();\n    }\n\n    print(out) {\n      System.out.println('EdgeEndStar:   ' + this.getCoordinate());\n\n      for (let it = this.iterator(); it.hasNext();) {\n        const e = it.next();\n        e.print(out);\n      }\n    }\n\n    isAreaLabelsConsistent(geomGraph) {\n      this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());\n      return this.checkAreaLabelsConsistent(0);\n    }\n\n    checkAreaLabelsConsistent(geomIndex) {\n      const edges = this.getEdges();\n      if (edges.size() <= 0) return true;\n      const lastEdgeIndex = edges.size() - 1;\n      const startLabel = edges.get(lastEdgeIndex).getLabel();\n      const startLoc = startLabel.getLocation(geomIndex, Position.LEFT);\n      Assert.isTrue(startLoc !== Location.NONE, 'Found unlabelled area edge');\n      let currLoc = startLoc;\n\n      for (let it = this.iterator(); it.hasNext();) {\n        const e = it.next();\n        const label = e.getLabel();\n        Assert.isTrue(label.isArea(geomIndex), 'Found non-area edge');\n        const leftLoc = label.getLocation(geomIndex, Position.LEFT);\n        const rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n        if (leftLoc === rightLoc) return false;\n        if (rightLoc !== currLoc) return false;\n        currLoc = leftLoc;\n      }\n\n      return true;\n    }\n\n    findIndex(eSearch) {\n      this.iterator();\n\n      for (let i = 0; i < this._edgeList.size(); i++) {\n        const e = this._edgeList.get(i);\n\n        if (e === eSearch) return i;\n      }\n\n      return -1;\n    }\n\n    iterator() {\n      return this.getEdges().iterator();\n    }\n\n    getEdges() {\n      if (this._edgeList === null) this._edgeList = new ArrayList(this._edgeMap.values());\n      return this._edgeList;\n    }\n\n    getLocation(geomIndex, p, geom) {\n      if (this._ptInAreaLocation[geomIndex] === Location.NONE) this._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());\n      return this._ptInAreaLocation[geomIndex];\n    }\n\n    toString() {\n      const buf = new StringBuffer();\n      buf.append('EdgeEndStar:   ' + this.getCoordinate());\n      buf.append('\\n');\n\n      for (let it = this.iterator(); it.hasNext();) {\n        const e = it.next();\n        buf.append(e);\n        buf.append('\\n');\n      }\n\n      return buf.toString();\n    }\n\n    computeEdgeEndLabels(boundaryNodeRule) {\n      for (let it = this.iterator(); it.hasNext();) {\n        const ee = it.next();\n        ee.computeLabel(boundaryNodeRule);\n      }\n    }\n\n    computeLabelling(geomGraph) {\n      this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());\n      this.propagateSideLabels(0);\n      this.propagateSideLabels(1);\n      const hasDimensionalCollapseEdge = [false, false];\n\n      for (let it = this.iterator(); it.hasNext();) {\n        const e = it.next();\n        const label = e.getLabel();\n\n        for (let geomi = 0; geomi < 2; geomi++) if (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) hasDimensionalCollapseEdge[geomi] = true;\n      }\n\n      for (let it = this.iterator(); it.hasNext();) {\n        const e = it.next();\n        const label = e.getLabel();\n\n        for (let geomi = 0; geomi < 2; geomi++) if (label.isAnyNull(geomi)) {\n          let loc = Location.NONE;\n\n          if (hasDimensionalCollapseEdge[geomi]) {\n            loc = Location.EXTERIOR;\n          } else {\n            const p = e.getCoordinate();\n            loc = this.getLocation(geomi, p, geomGraph);\n          }\n\n          label.setAllLocationsIfNull(geomi, loc);\n        }\n      }\n    }\n\n    getDegree() {\n      return this._edgeMap.size();\n    }\n\n    insertEdgeEnd(e, obj) {\n      this._edgeMap.put(e, obj);\n\n      this._edgeList = null;\n    }\n\n  }\n\n  class DirectedEdgeStar extends EdgeEndStar {\n    constructor() {\n      super();\n      DirectedEdgeStar.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._resultAreaEdgeList = null;\n      this._label = null;\n      this._SCANNING_FOR_INCOMING = 1;\n      this._LINKING_TO_OUTGOING = 2;\n    }\n\n    linkResultDirectedEdges() {\n      this.getResultAreaEdges();\n      let firstOut = null;\n      let incoming = null;\n      let state = this._SCANNING_FOR_INCOMING;\n\n      for (let i = 0; i < this._resultAreaEdgeList.size(); i++) {\n        const nextOut = this._resultAreaEdgeList.get(i);\n\n        const nextIn = nextOut.getSym();\n        if (!nextOut.getLabel().isArea()) continue;\n        if (firstOut === null && nextOut.isInResult()) firstOut = nextOut;\n\n        switch (state) {\n          case this._SCANNING_FOR_INCOMING:\n            if (!nextIn.isInResult()) continue;\n            incoming = nextIn;\n            state = this._LINKING_TO_OUTGOING;\n            break;\n\n          case this._LINKING_TO_OUTGOING:\n            if (!nextOut.isInResult()) continue;\n            incoming.setNext(nextOut);\n            state = this._SCANNING_FOR_INCOMING;\n            break;\n        }\n      }\n\n      if (state === this._LINKING_TO_OUTGOING) {\n        if (firstOut === null) throw new TopologyException('no outgoing dirEdge found', this.getCoordinate());\n        Assert.isTrue(firstOut.isInResult(), 'unable to link last incoming dirEdge');\n        incoming.setNext(firstOut);\n      }\n    }\n\n    insert(ee) {\n      const de = ee;\n      this.insertEdgeEnd(de, de);\n    }\n\n    getRightmostEdge() {\n      const edges = this.getEdges();\n      const size = edges.size();\n      if (size < 1) return null;\n      const de0 = edges.get(0);\n      if (size === 1) return de0;\n      const deLast = edges.get(size - 1);\n      const quad0 = de0.getQuadrant();\n      const quad1 = deLast.getQuadrant();\n\n      if (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) {\n        return de0;\n      } else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) {\n        return deLast;\n      } else {\n        if (de0.getDy() !== 0) return de0;else if (deLast.getDy() !== 0) return deLast;\n      }\n\n      Assert.shouldNeverReachHere('found two horizontal edges incident on node');\n      return null;\n    }\n\n    print(out) {\n      System.out.println('DirectedEdgeStar: ' + this.getCoordinate());\n\n      for (let it = this.iterator(); it.hasNext();) {\n        const de = it.next();\n        out.print('out ');\n        de.print(out);\n        out.println();\n        out.print('in ');\n        de.getSym().print(out);\n        out.println();\n      }\n    }\n\n    getResultAreaEdges() {\n      if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList;\n      this._resultAreaEdgeList = new ArrayList();\n\n      for (let it = this.iterator(); it.hasNext();) {\n        const de = it.next();\n        if (de.isInResult() || de.getSym().isInResult()) this._resultAreaEdgeList.add(de);\n      }\n\n      return this._resultAreaEdgeList;\n    }\n\n    updateLabelling(nodeLabel) {\n      for (let it = this.iterator(); it.hasNext();) {\n        const de = it.next();\n        const label = de.getLabel();\n        label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));\n        label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));\n      }\n    }\n\n    linkAllDirectedEdges() {\n      this.getEdges();\n      let prevOut = null;\n      let firstIn = null;\n\n      for (let i = this._edgeList.size() - 1; i >= 0; i--) {\n        const nextOut = this._edgeList.get(i);\n\n        const nextIn = nextOut.getSym();\n        if (firstIn === null) firstIn = nextIn;\n        if (prevOut !== null) nextIn.setNext(prevOut);\n        prevOut = nextOut;\n      }\n\n      firstIn.setNext(prevOut);\n    }\n\n    computeDepths() {\n      if (arguments.length === 1) {\n        const de = arguments[0];\n        const edgeIndex = this.findIndex(de);\n        const startDepth = de.getDepth(Position.LEFT);\n        const targetLastDepth = de.getDepth(Position.RIGHT);\n        const nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);\n        const lastDepth = this.computeDepths(0, edgeIndex, nextDepth);\n        if (lastDepth !== targetLastDepth) throw new TopologyException('depth mismatch at ' + de.getCoordinate());\n      } else if (arguments.length === 3) {\n        const startIndex = arguments[0],\n              endIndex = arguments[1],\n              startDepth = arguments[2];\n        let currDepth = startDepth;\n\n        for (let i = startIndex; i < endIndex; i++) {\n          const nextDe = this._edgeList.get(i);\n\n          nextDe.setEdgeDepths(Position.RIGHT, currDepth);\n          currDepth = nextDe.getDepth(Position.LEFT);\n        }\n\n        return currDepth;\n      }\n    }\n\n    mergeSymLabels() {\n      for (let it = this.iterator(); it.hasNext();) {\n        const de = it.next();\n        const label = de.getLabel();\n        label.merge(de.getSym().getLabel());\n      }\n    }\n\n    linkMinimalDirectedEdges(er) {\n      let firstOut = null;\n      let incoming = null;\n      let state = this._SCANNING_FOR_INCOMING;\n\n      for (let i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {\n        const nextOut = this._resultAreaEdgeList.get(i);\n\n        const nextIn = nextOut.getSym();\n        if (firstOut === null && nextOut.getEdgeRing() === er) firstOut = nextOut;\n\n        switch (state) {\n          case this._SCANNING_FOR_INCOMING:\n            if (nextIn.getEdgeRing() !== er) continue;\n            incoming = nextIn;\n            state = this._LINKING_TO_OUTGOING;\n            break;\n\n          case this._LINKING_TO_OUTGOING:\n            if (nextOut.getEdgeRing() !== er) continue;\n            incoming.setNextMin(nextOut);\n            state = this._SCANNING_FOR_INCOMING;\n            break;\n        }\n      }\n\n      if (state === this._LINKING_TO_OUTGOING) {\n        Assert.isTrue(firstOut !== null, 'found null for first outgoing dirEdge');\n        Assert.isTrue(firstOut.getEdgeRing() === er, 'unable to link last incoming dirEdge');\n        incoming.setNextMin(firstOut);\n      }\n    }\n\n    getOutgoingDegree() {\n      if (arguments.length === 0) {\n        let degree = 0;\n\n        for (let it = this.iterator(); it.hasNext();) {\n          const de = it.next();\n          if (de.isInResult()) degree++;\n        }\n\n        return degree;\n      } else if (arguments.length === 1) {\n        const er = arguments[0];\n        let degree = 0;\n\n        for (let it = this.iterator(); it.hasNext();) {\n          const de = it.next();\n          if (de.getEdgeRing() === er) degree++;\n        }\n\n        return degree;\n      }\n    }\n\n    getLabel() {\n      return this._label;\n    }\n\n    findCoveredLineEdges() {\n      let startLoc = Location.NONE;\n\n      for (let it = this.iterator(); it.hasNext();) {\n        const nextOut = it.next();\n        const nextIn = nextOut.getSym();\n\n        if (!nextOut.isLineEdge()) {\n          if (nextOut.isInResult()) {\n            startLoc = Location.INTERIOR;\n            break;\n          }\n\n          if (nextIn.isInResult()) {\n            startLoc = Location.EXTERIOR;\n            break;\n          }\n        }\n      }\n\n      if (startLoc === Location.NONE) return null;\n      let currLoc = startLoc;\n\n      for (let it = this.iterator(); it.hasNext();) {\n        const nextOut = it.next();\n        const nextIn = nextOut.getSym();\n\n        if (nextOut.isLineEdge()) {\n          nextOut.getEdge().setCovered(currLoc === Location.INTERIOR);\n        } else {\n          if (nextOut.isInResult()) currLoc = Location.EXTERIOR;\n          if (nextIn.isInResult()) currLoc = Location.INTERIOR;\n        }\n      }\n    }\n\n    computeLabelling(geom) {\n      super.computeLabelling.call(this, geom);\n      this._label = new Label(Location.NONE);\n\n      for (let it = this.iterator(); it.hasNext();) {\n        const ee = it.next();\n        const e = ee.getEdge();\n        const eLabel = e.getLabel();\n\n        for (let i = 0; i < 2; i++) {\n          const eLoc = eLabel.getLocation(i);\n          if (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) this._label.setLocation(i, Location.INTERIOR);\n        }\n      }\n    }\n\n  }\n\n  class OverlayNodeFactory extends NodeFactory {\n    constructor() {\n      super();\n    }\n\n    createNode(coord) {\n      return new Node(coord, new DirectedEdgeStar());\n    }\n\n  }\n\n  class OrientedCoordinateArray {\n    constructor() {\n      OrientedCoordinateArray.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._pts = null;\n      this._orientation = null;\n      const pts = arguments[0];\n      this._pts = pts;\n      this._orientation = OrientedCoordinateArray.orientation(pts);\n    }\n\n    static orientation(pts) {\n      return CoordinateArrays.increasingDirection(pts) === 1;\n    }\n\n    static compareOriented(pts1, orientation1, pts2, orientation2) {\n      const dir1 = orientation1 ? 1 : -1;\n      const dir2 = orientation2 ? 1 : -1;\n      const limit1 = orientation1 ? pts1.length : -1;\n      const limit2 = orientation2 ? pts2.length : -1;\n      let i1 = orientation1 ? 0 : pts1.length - 1;\n      let i2 = orientation2 ? 0 : pts2.length - 1;\n\n      while (true) {\n        const compPt = pts1[i1].compareTo(pts2[i2]);\n        if (compPt !== 0) return compPt;\n        i1 += dir1;\n        i2 += dir2;\n        const done1 = i1 === limit1;\n        const done2 = i2 === limit2;\n        if (done1 && !done2) return -1;\n        if (!done1 && done2) return 1;\n        if (done1 && done2) return 0;\n      }\n    }\n\n    compareTo(o1) {\n      const oca = o1;\n      const comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);\n      return comp;\n    }\n\n    get interfaces_() {\n      return [Comparable];\n    }\n\n  }\n\n  class EdgeList {\n    constructor() {\n      EdgeList.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._edges = new ArrayList();\n      this._ocaMap = new TreeMap();\n    }\n\n    print(out) {\n      out.print('MULTILINESTRING ( ');\n\n      for (let j = 0; j < this._edges.size(); j++) {\n        const e = this._edges.get(j);\n\n        if (j > 0) out.print(',');\n        out.print('(');\n        const pts = e.getCoordinates();\n\n        for (let i = 0; i < pts.length; i++) {\n          if (i > 0) out.print(',');\n          out.print(pts[i].x + ' ' + pts[i].y);\n        }\n\n        out.println(')');\n      }\n\n      out.print(')  ');\n    }\n\n    addAll(edgeColl) {\n      for (let i = edgeColl.iterator(); i.hasNext();) this.add(i.next());\n    }\n\n    findEdgeIndex(e) {\n      for (let i = 0; i < this._edges.size(); i++) if (this._edges.get(i).equals(e)) return i;\n\n      return -1;\n    }\n\n    iterator() {\n      return this._edges.iterator();\n    }\n\n    getEdges() {\n      return this._edges;\n    }\n\n    get(i) {\n      return this._edges.get(i);\n    }\n\n    findEqualEdge(e) {\n      const oca = new OrientedCoordinateArray(e.getCoordinates());\n\n      const matchEdge = this._ocaMap.get(oca);\n\n      return matchEdge;\n    }\n\n    add(e) {\n      this._edges.add(e);\n\n      const oca = new OrientedCoordinateArray(e.getCoordinates());\n\n      this._ocaMap.put(oca, e);\n    }\n\n  }\n\n  class SegmentIntersector$1 {\n    processIntersections(e0, segIndex0, e1, segIndex1) {}\n\n    isDone() {}\n\n  }\n\n  class IntersectionAdder {\n    constructor() {\n      IntersectionAdder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._hasIntersection = false;\n      this._hasProper = false;\n      this._hasProperInterior = false;\n      this._hasInterior = false;\n      this._properIntersectionPoint = null;\n      this._li = null;\n      this._isSelfIntersection = null;\n      this.numIntersections = 0;\n      this.numInteriorIntersections = 0;\n      this.numProperIntersections = 0;\n      this.numTests = 0;\n      const li = arguments[0];\n      this._li = li;\n    }\n\n    static isAdjacentSegments(i1, i2) {\n      return Math.abs(i1 - i2) === 1;\n    }\n\n    isTrivialIntersection(e0, segIndex0, e1, segIndex1) {\n      if (e0 === e1) if (this._li.getIntersectionNum() === 1) {\n        if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) return true;\n\n        if (e0.isClosed()) {\n          const maxSegIndex = e0.size() - 1;\n          if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) return true;\n        }\n      }\n      return false;\n    }\n\n    getProperIntersectionPoint() {\n      return this._properIntersectionPoint;\n    }\n\n    hasProperInteriorIntersection() {\n      return this._hasProperInterior;\n    }\n\n    getLineIntersector() {\n      return this._li;\n    }\n\n    hasProperIntersection() {\n      return this._hasProper;\n    }\n\n    processIntersections(e0, segIndex0, e1, segIndex1) {\n      if (e0 === e1 && segIndex0 === segIndex1) return null;\n      this.numTests++;\n      const p00 = e0.getCoordinates()[segIndex0];\n      const p01 = e0.getCoordinates()[segIndex0 + 1];\n      const p10 = e1.getCoordinates()[segIndex1];\n      const p11 = e1.getCoordinates()[segIndex1 + 1];\n\n      this._li.computeIntersection(p00, p01, p10, p11);\n\n      if (this._li.hasIntersection()) {\n        this.numIntersections++;\n\n        if (this._li.isInteriorIntersection()) {\n          this.numInteriorIntersections++;\n          this._hasInterior = true;\n        }\n\n        if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n          this._hasIntersection = true;\n          e0.addIntersections(this._li, segIndex0, 0);\n          e1.addIntersections(this._li, segIndex1, 1);\n\n          if (this._li.isProper()) {\n            this.numProperIntersections++;\n            this._hasProper = true;\n            this._hasProperInterior = true;\n          }\n        }\n      }\n    }\n\n    hasIntersection() {\n      return this._hasIntersection;\n    }\n\n    isDone() {\n      return false;\n    }\n\n    hasInteriorIntersection() {\n      return this._hasInterior;\n    }\n\n    get interfaces_() {\n      return [SegmentIntersector$1];\n    }\n\n  }\n\n  class BufferBuilder {\n    constructor() {\n      BufferBuilder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._bufParams = null;\n      this._workingPrecisionModel = null;\n      this._workingNoder = null;\n      this._geomFact = null;\n      this._graph = null;\n      this._edgeList = new EdgeList();\n      const bufParams = arguments[0];\n      this._bufParams = bufParams;\n    }\n\n    static depthDelta(label) {\n      const lLoc = label.getLocation(0, Position.LEFT);\n      const rLoc = label.getLocation(0, Position.RIGHT);\n      if (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) return 1;else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) return -1;\n      return 0;\n    }\n\n    static convertSegStrings(it) {\n      const fact = new GeometryFactory();\n      const lines = new ArrayList();\n\n      while (it.hasNext()) {\n        const ss = it.next();\n        const line = fact.createLineString(ss.getCoordinates());\n        lines.add(line);\n      }\n\n      return fact.buildGeometry(lines);\n    }\n\n    setWorkingPrecisionModel(pm) {\n      this._workingPrecisionModel = pm;\n    }\n\n    insertUniqueEdge(e) {\n      const existingEdge = this._edgeList.findEqualEdge(e);\n\n      if (existingEdge !== null) {\n        const existingLabel = existingEdge.getLabel();\n        let labelToMerge = e.getLabel();\n\n        if (!existingEdge.isPointwiseEqual(e)) {\n          labelToMerge = new Label(e.getLabel());\n          labelToMerge.flip();\n        }\n\n        existingLabel.merge(labelToMerge);\n        const mergeDelta = BufferBuilder.depthDelta(labelToMerge);\n        const existingDelta = existingEdge.getDepthDelta();\n        const newDelta = existingDelta + mergeDelta;\n        existingEdge.setDepthDelta(newDelta);\n      } else {\n        this._edgeList.add(e);\n\n        e.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));\n      }\n    }\n\n    buildSubgraphs(subgraphList, polyBuilder) {\n      const processedGraphs = new ArrayList();\n\n      for (let i = subgraphList.iterator(); i.hasNext();) {\n        const subgraph = i.next();\n        const p = subgraph.getRightmostCoordinate();\n        const locater = new SubgraphDepthLocater(processedGraphs);\n        const outsideDepth = locater.getDepth(p);\n        subgraph.computeDepth(outsideDepth);\n        subgraph.findResultEdges();\n        processedGraphs.add(subgraph);\n        polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());\n      }\n    }\n\n    createSubgraphs(graph) {\n      const subgraphList = new ArrayList();\n\n      for (let i = graph.getNodes().iterator(); i.hasNext();) {\n        const node = i.next();\n\n        if (!node.isVisited()) {\n          const subgraph = new BufferSubgraph();\n          subgraph.create(node);\n          subgraphList.add(subgraph);\n        }\n      }\n\n      Collections.sort(subgraphList, Collections.reverseOrder());\n      return subgraphList;\n    }\n\n    createEmptyResultGeometry() {\n      const emptyGeom = this._geomFact.createPolygon();\n\n      return emptyGeom;\n    }\n\n    getNoder(precisionModel) {\n      if (this._workingNoder !== null) return this._workingNoder;\n      const noder = new MCIndexNoder();\n      const li = new RobustLineIntersector();\n      li.setPrecisionModel(precisionModel);\n      noder.setSegmentIntersector(new IntersectionAdder(li));\n      return noder;\n    }\n\n    buffer(g, distance) {\n      let precisionModel = this._workingPrecisionModel;\n      if (precisionModel === null) precisionModel = g.getPrecisionModel();\n      this._geomFact = g.getFactory();\n      const curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams);\n      const curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder);\n      const bufferSegStrList = curveSetBuilder.getCurves();\n      if (bufferSegStrList.size() <= 0) return this.createEmptyResultGeometry();\n      this.computeNodedEdges(bufferSegStrList, precisionModel);\n      this._graph = new PlanarGraph(new OverlayNodeFactory());\n\n      this._graph.addEdges(this._edgeList.getEdges());\n\n      const subgraphList = this.createSubgraphs(this._graph);\n      const polyBuilder = new PolygonBuilder(this._geomFact);\n      this.buildSubgraphs(subgraphList, polyBuilder);\n      const resultPolyList = polyBuilder.getPolygons();\n      if (resultPolyList.size() <= 0) return this.createEmptyResultGeometry();\n\n      const resultGeom = this._geomFact.buildGeometry(resultPolyList);\n\n      return resultGeom;\n    }\n\n    computeNodedEdges(bufferSegStrList, precisionModel) {\n      const noder = this.getNoder(precisionModel);\n      noder.computeNodes(bufferSegStrList);\n      const nodedSegStrings = noder.getNodedSubstrings();\n\n      for (let i = nodedSegStrings.iterator(); i.hasNext();) {\n        const segStr = i.next();\n        const pts = segStr.getCoordinates();\n        if (pts.length === 2 && pts[0].equals2D(pts[1])) continue;\n        const oldLabel = segStr.getData();\n        const edge = new Edge(segStr.getCoordinates(), new Label(oldLabel));\n        this.insertUniqueEdge(edge);\n      }\n    }\n\n    setNoder(noder) {\n      this._workingNoder = noder;\n    }\n\n  }\n\n  class NodingValidator {\n    constructor() {\n      NodingValidator.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._li = new RobustLineIntersector();\n      this._segStrings = null;\n      const segStrings = arguments[0];\n      this._segStrings = segStrings;\n    }\n\n    checkEndPtVertexIntersections() {\n      if (arguments.length === 0) {\n        for (let i = this._segStrings.iterator(); i.hasNext();) {\n          const ss = i.next();\n          const pts = ss.getCoordinates();\n          this.checkEndPtVertexIntersections(pts[0], this._segStrings);\n          this.checkEndPtVertexIntersections(pts[pts.length - 1], this._segStrings);\n        }\n      } else if (arguments.length === 2) {\n        const testPt = arguments[0],\n              segStrings = arguments[1];\n\n        for (let i = segStrings.iterator(); i.hasNext();) {\n          const ss = i.next();\n          const pts = ss.getCoordinates();\n\n          for (let j = 1; j < pts.length - 1; j++) if (pts[j].equals(testPt)) throw new RuntimeException('found endpt/interior pt intersection at index ' + j + ' :pt ' + testPt);\n        }\n      }\n    }\n\n    checkInteriorIntersections() {\n      if (arguments.length === 0) {\n        for (let i = this._segStrings.iterator(); i.hasNext();) {\n          const ss0 = i.next();\n\n          for (let j = this._segStrings.iterator(); j.hasNext();) {\n            const ss1 = j.next();\n            this.checkInteriorIntersections(ss0, ss1);\n          }\n        }\n      } else if (arguments.length === 2) {\n        const ss0 = arguments[0],\n              ss1 = arguments[1];\n        const pts0 = ss0.getCoordinates();\n        const pts1 = ss1.getCoordinates();\n\n        for (let i0 = 0; i0 < pts0.length - 1; i0++) for (let i1 = 0; i1 < pts1.length - 1; i1++) this.checkInteriorIntersections(ss0, i0, ss1, i1);\n      } else if (arguments.length === 4) {\n        const e0 = arguments[0],\n              segIndex0 = arguments[1],\n              e1 = arguments[2],\n              segIndex1 = arguments[3];\n        if (e0 === e1 && segIndex0 === segIndex1) return null;\n        const p00 = e0.getCoordinates()[segIndex0];\n        const p01 = e0.getCoordinates()[segIndex0 + 1];\n        const p10 = e1.getCoordinates()[segIndex1];\n        const p11 = e1.getCoordinates()[segIndex1 + 1];\n\n        this._li.computeIntersection(p00, p01, p10, p11);\n\n        if (this._li.hasIntersection()) if (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) throw new RuntimeException('found non-noded intersection at ' + p00 + '-' + p01 + ' and ' + p10 + '-' + p11);\n      }\n    }\n\n    checkValid() {\n      this.checkEndPtVertexIntersections();\n      this.checkInteriorIntersections();\n      this.checkCollapses();\n    }\n\n    checkCollapses() {\n      if (arguments.length === 0) {\n        for (let i = this._segStrings.iterator(); i.hasNext();) {\n          const ss = i.next();\n          this.checkCollapses(ss);\n        }\n      } else if (arguments.length === 1) {\n        const ss = arguments[0];\n        const pts = ss.getCoordinates();\n\n        for (let i = 0; i < pts.length - 2; i++) this.checkCollapse(pts[i], pts[i + 1], pts[i + 2]);\n      }\n    }\n\n    hasInteriorIntersection(li, p0, p1) {\n      for (let i = 0; i < li.getIntersectionNum(); i++) {\n        const intPt = li.getIntersection(i);\n        if (!(intPt.equals(p0) || intPt.equals(p1))) return true;\n      }\n\n      return false;\n    }\n\n    checkCollapse(p0, p1, p2) {\n      if (p0.equals(p2)) throw new RuntimeException('found non-noded collapse at ' + NodingValidator.fact.createLineString([p0, p1, p2]));\n    }\n\n  }\n  NodingValidator.fact = new GeometryFactory();\n\n  class HotPixel {\n    constructor() {\n      HotPixel.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._li = null;\n      this._pt = null;\n      this._originalPt = null;\n      this._ptScaled = null;\n      this._p0Scaled = null;\n      this._p1Scaled = null;\n      this._scaleFactor = null;\n      this._minx = null;\n      this._maxx = null;\n      this._miny = null;\n      this._maxy = null;\n      this._corner = new Array(4).fill(null);\n      this._safeEnv = null;\n      const pt = arguments[0],\n            scaleFactor = arguments[1],\n            li = arguments[2];\n      this._originalPt = pt;\n      this._pt = pt;\n      this._scaleFactor = scaleFactor;\n      this._li = li;\n      if (scaleFactor <= 0) throw new IllegalArgumentException('Scale factor must be non-zero');\n\n      if (scaleFactor !== 1.0) {\n        this._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));\n        this._p0Scaled = new Coordinate();\n        this._p1Scaled = new Coordinate();\n      }\n\n      this.initCorners(this._pt);\n    }\n\n    intersectsScaled(p0, p1) {\n      const segMinx = Math.min(p0.x, p1.x);\n      const segMaxx = Math.max(p0.x, p1.x);\n      const segMiny = Math.min(p0.y, p1.y);\n      const segMaxy = Math.max(p0.y, p1.y);\n      const isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;\n      if (isOutsidePixelEnv) return false;\n      const intersects = this.intersectsToleranceSquare(p0, p1);\n      Assert.isTrue(!(isOutsidePixelEnv && intersects), 'Found bad envelope test');\n      return intersects;\n    }\n\n    initCorners(pt) {\n      const tolerance = 0.5;\n      this._minx = pt.x - tolerance;\n      this._maxx = pt.x + tolerance;\n      this._miny = pt.y - tolerance;\n      this._maxy = pt.y + tolerance;\n      this._corner[0] = new Coordinate(this._maxx, this._maxy);\n      this._corner[1] = new Coordinate(this._minx, this._maxy);\n      this._corner[2] = new Coordinate(this._minx, this._miny);\n      this._corner[3] = new Coordinate(this._maxx, this._miny);\n    }\n\n    intersects(p0, p1) {\n      if (this._scaleFactor === 1.0) return this.intersectsScaled(p0, p1);\n      this.copyScaled(p0, this._p0Scaled);\n      this.copyScaled(p1, this._p1Scaled);\n      return this.intersectsScaled(this._p0Scaled, this._p1Scaled);\n    }\n\n    scale(val) {\n      return Math.round(val * this._scaleFactor);\n    }\n\n    getCoordinate() {\n      return this._originalPt;\n    }\n\n    copyScaled(p, pScaled) {\n      pScaled.x = this.scale(p.x);\n      pScaled.y = this.scale(p.y);\n    }\n\n    getSafeEnvelope() {\n      if (this._safeEnv === null) {\n        const safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;\n        this._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);\n      }\n\n      return this._safeEnv;\n    }\n\n    intersectsPixelClosure(p0, p1) {\n      this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n\n      if (this._li.hasIntersection()) return true;\n\n      this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n\n      if (this._li.hasIntersection()) return true;\n\n      this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n\n      if (this._li.hasIntersection()) return true;\n\n      this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n\n      if (this._li.hasIntersection()) return true;\n      return false;\n    }\n\n    intersectsToleranceSquare(p0, p1) {\n      let intersectsLeft = false;\n      let intersectsBottom = false;\n\n      this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n\n      if (this._li.isProper()) return true;\n\n      this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n\n      if (this._li.isProper()) return true;\n      if (this._li.hasIntersection()) intersectsLeft = true;\n\n      this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n\n      if (this._li.isProper()) return true;\n      if (this._li.hasIntersection()) intersectsBottom = true;\n\n      this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n\n      if (this._li.isProper()) return true;\n      if (intersectsLeft && intersectsBottom) return true;\n      if (p0.equals(this._pt)) return true;\n      if (p1.equals(this._pt)) return true;\n      return false;\n    }\n\n    addSnappedNode(segStr, segIndex) {\n      const p0 = segStr.getCoordinate(segIndex);\n      const p1 = segStr.getCoordinate(segIndex + 1);\n\n      if (this.intersects(p0, p1)) {\n        segStr.addIntersection(this.getCoordinate(), segIndex);\n        return true;\n      }\n\n      return false;\n    }\n\n  }\n  HotPixel.SAFE_ENV_EXPANSION_FACTOR = 0.75;\n\n  class MonotoneChainSelectAction {\n    constructor() {\n      MonotoneChainSelectAction.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.selectedSegment = new LineSegment();\n    }\n\n    select() {\n      if (arguments.length === 1) ; else if (arguments.length === 2) {\n        const mc = arguments[0],\n              startIndex = arguments[1];\n        mc.getLineSegment(startIndex, this.selectedSegment);\n        this.select(this.selectedSegment);\n      }\n    }\n\n  }\n\n  class MCIndexPointSnapper {\n    constructor() {\n      MCIndexPointSnapper.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._index = null;\n      const index = arguments[0];\n      this._index = index;\n    }\n\n    snap() {\n      if (arguments.length === 1) {\n        const hotPixel = arguments[0];\n        return this.snap(hotPixel, null, -1);\n      } else if (arguments.length === 3) {\n        const hotPixel = arguments[0],\n              parentEdge = arguments[1],\n              hotPixelVertexIndex = arguments[2];\n        const pixelEnv = hotPixel.getSafeEnvelope();\n        const hotPixelSnapAction = new HotPixelSnapAction(hotPixel, parentEdge, hotPixelVertexIndex);\n\n        this._index.query(pixelEnv, new class {\n          get interfaces_() {\n            return [ItemVisitor];\n          }\n\n          visitItem(item) {\n            const testChain = item;\n            testChain.select(pixelEnv, hotPixelSnapAction);\n          }\n\n        }());\n\n        return hotPixelSnapAction.isNodeAdded();\n      }\n    }\n\n  }\n\n  class HotPixelSnapAction extends MonotoneChainSelectAction {\n    constructor() {\n      super();\n      HotPixelSnapAction.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._hotPixel = null;\n      this._parentEdge = null;\n      this._hotPixelVertexIndex = null;\n      this._isNodeAdded = false;\n      const hotPixel = arguments[0],\n            parentEdge = arguments[1],\n            hotPixelVertexIndex = arguments[2];\n      this._hotPixel = hotPixel;\n      this._parentEdge = parentEdge;\n      this._hotPixelVertexIndex = hotPixelVertexIndex;\n    }\n\n    isNodeAdded() {\n      return this._isNodeAdded;\n    }\n\n    select() {\n      if (arguments.length === 2 && Number.isInteger(arguments[1]) && arguments[0] instanceof MonotoneChain$1) {\n        const mc = arguments[0],\n              startIndex = arguments[1];\n        const ss = mc.getContext();\n        if (this._parentEdge === ss) if (startIndex === this._hotPixelVertexIndex || startIndex + 1 === this._hotPixelVertexIndex) return null;\n        this._isNodeAdded |= this._hotPixel.addSnappedNode(ss, startIndex);\n      } else {\n        return super.select.apply(this, arguments);\n      }\n    }\n\n  }\n\n  MCIndexPointSnapper.HotPixelSnapAction = HotPixelSnapAction;\n\n  class InteriorIntersectionFinderAdder {\n    constructor() {\n      InteriorIntersectionFinderAdder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._li = null;\n      this._interiorIntersections = null;\n      const li = arguments[0];\n      this._li = li;\n      this._interiorIntersections = new ArrayList();\n    }\n\n    processIntersections(e0, segIndex0, e1, segIndex1) {\n      if (e0 === e1 && segIndex0 === segIndex1) return null;\n      const p00 = e0.getCoordinates()[segIndex0];\n      const p01 = e0.getCoordinates()[segIndex0 + 1];\n      const p10 = e1.getCoordinates()[segIndex1];\n      const p11 = e1.getCoordinates()[segIndex1 + 1];\n\n      this._li.computeIntersection(p00, p01, p10, p11);\n\n      if (this._li.hasIntersection()) if (this._li.isInteriorIntersection()) {\n        for (let intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) this._interiorIntersections.add(this._li.getIntersection(intIndex));\n\n        e0.addIntersections(this._li, segIndex0, 0);\n        e1.addIntersections(this._li, segIndex1, 1);\n      }\n    }\n\n    isDone() {\n      return false;\n    }\n\n    getInteriorIntersections() {\n      return this._interiorIntersections;\n    }\n\n    get interfaces_() {\n      return [SegmentIntersector$1];\n    }\n\n  }\n\n  class MCIndexSnapRounder {\n    constructor() {\n      MCIndexSnapRounder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._pm = null;\n      this._li = null;\n      this._scaleFactor = null;\n      this._noder = null;\n      this._pointSnapper = null;\n      this._nodedSegStrings = null;\n      const pm = arguments[0];\n      this._pm = pm;\n      this._li = new RobustLineIntersector();\n\n      this._li.setPrecisionModel(pm);\n\n      this._scaleFactor = pm.getScale();\n    }\n\n    checkCorrectness(inputSegmentStrings) {\n      const resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);\n      const nv = new NodingValidator(resultSegStrings);\n\n      try {\n        nv.checkValid();\n      } catch (ex) {\n        if (ex instanceof Exception) ex.printStackTrace();else throw ex;\n      } finally {}\n    }\n\n    getNodedSubstrings() {\n      return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings);\n    }\n\n    snapRound(segStrings, li) {\n      const intersections = this.findInteriorIntersections(segStrings, li);\n      this.computeIntersectionSnaps(intersections);\n      this.computeVertexSnaps(segStrings);\n    }\n\n    findInteriorIntersections(segStrings, li) {\n      const intFinderAdder = new InteriorIntersectionFinderAdder(li);\n\n      this._noder.setSegmentIntersector(intFinderAdder);\n\n      this._noder.computeNodes(segStrings);\n\n      return intFinderAdder.getInteriorIntersections();\n    }\n\n    computeVertexSnaps() {\n      if (hasInterface(arguments[0], Collection)) {\n        const edges = arguments[0];\n\n        for (let i0 = edges.iterator(); i0.hasNext();) {\n          const edge0 = i0.next();\n          this.computeVertexSnaps(edge0);\n        }\n      } else if (arguments[0] instanceof NodedSegmentString) {\n        const e = arguments[0];\n        const pts0 = e.getCoordinates();\n\n        for (let i = 0; i < pts0.length; i++) {\n          const hotPixel = new HotPixel(pts0[i], this._scaleFactor, this._li);\n\n          const isNodeAdded = this._pointSnapper.snap(hotPixel, e, i);\n\n          if (isNodeAdded) e.addIntersection(pts0[i], i);\n        }\n      }\n    }\n\n    computeNodes(inputSegmentStrings) {\n      this._nodedSegStrings = inputSegmentStrings;\n      this._noder = new MCIndexNoder();\n      this._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex());\n      this.snapRound(inputSegmentStrings, this._li);\n    }\n\n    computeIntersectionSnaps(snapPts) {\n      for (let it = snapPts.iterator(); it.hasNext();) {\n        const snapPt = it.next();\n        const hotPixel = new HotPixel(snapPt, this._scaleFactor, this._li);\n\n        this._pointSnapper.snap(hotPixel);\n      }\n    }\n\n    get interfaces_() {\n      return [Noder];\n    }\n\n  }\n\n  class BufferOp {\n    constructor() {\n      BufferOp.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._argGeom = null;\n      this._distance = null;\n      this._bufParams = new BufferParameters();\n      this._resultGeometry = null;\n      this._saveException = null;\n\n      if (arguments.length === 1) {\n        const g = arguments[0];\n        this._argGeom = g;\n      } else if (arguments.length === 2) {\n        const g = arguments[0],\n              bufParams = arguments[1];\n        this._argGeom = g;\n        this._bufParams = bufParams;\n      }\n    }\n\n    static bufferOp() {\n      if (arguments.length === 2) {\n        const g = arguments[0],\n              distance = arguments[1];\n        const gBuf = new BufferOp(g);\n        const geomBuf = gBuf.getResultGeometry(distance);\n        return geomBuf;\n      } else if (arguments.length === 3) {\n        if (Number.isInteger(arguments[2]) && arguments[0] instanceof Geometry && typeof arguments[1] === 'number') {\n          const g = arguments[0],\n                distance = arguments[1],\n                quadrantSegments = arguments[2];\n          const bufOp = new BufferOp(g);\n          bufOp.setQuadrantSegments(quadrantSegments);\n          const geomBuf = bufOp.getResultGeometry(distance);\n          return geomBuf;\n        } else if (arguments[2] instanceof BufferParameters && arguments[0] instanceof Geometry && typeof arguments[1] === 'number') {\n          const g = arguments[0],\n                distance = arguments[1],\n                params = arguments[2];\n          const bufOp = new BufferOp(g, params);\n          const geomBuf = bufOp.getResultGeometry(distance);\n          return geomBuf;\n        }\n      } else if (arguments.length === 4) {\n        const g = arguments[0],\n              distance = arguments[1],\n              quadrantSegments = arguments[2],\n              endCapStyle = arguments[3];\n        const bufOp = new BufferOp(g);\n        bufOp.setQuadrantSegments(quadrantSegments);\n        bufOp.setEndCapStyle(endCapStyle);\n        const geomBuf = bufOp.getResultGeometry(distance);\n        return geomBuf;\n      }\n    }\n\n    static precisionScaleFactor(g, distance, maxPrecisionDigits) {\n      const env = g.getEnvelopeInternal();\n      const envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));\n      const expandByDistance = distance > 0.0 ? distance : 0.0;\n      const bufEnvMax = envMax + 2 * expandByDistance;\n      const bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);\n      const minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;\n      const scaleFactor = Math.pow(10.0, minUnitLog10);\n      return scaleFactor;\n    }\n\n    bufferFixedPrecision(fixedPM) {\n      const noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale());\n      const bufBuilder = new BufferBuilder(this._bufParams);\n      bufBuilder.setWorkingPrecisionModel(fixedPM);\n      bufBuilder.setNoder(noder);\n      this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n    }\n\n    bufferReducedPrecision() {\n      if (arguments.length === 0) {\n        for (let precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {\n          try {\n            this.bufferReducedPrecision(precDigits);\n          } catch (ex) {\n            if (ex instanceof TopologyException) this._saveException = ex;else throw ex;\n          } finally {}\n\n          if (this._resultGeometry !== null) return null;\n        }\n\n        throw this._saveException;\n      } else if (arguments.length === 1) {\n        const precisionDigits = arguments[0];\n        const sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);\n        const fixedPM = new PrecisionModel(sizeBasedScaleFactor);\n        this.bufferFixedPrecision(fixedPM);\n      }\n    }\n\n    computeGeometry() {\n      this.bufferOriginalPrecision();\n      if (this._resultGeometry !== null) return null;\n\n      const argPM = this._argGeom.getFactory().getPrecisionModel();\n\n      if (argPM.getType() === PrecisionModel.FIXED) this.bufferFixedPrecision(argPM);else this.bufferReducedPrecision();\n    }\n\n    setQuadrantSegments(quadrantSegments) {\n      this._bufParams.setQuadrantSegments(quadrantSegments);\n    }\n\n    bufferOriginalPrecision() {\n      try {\n        const bufBuilder = new BufferBuilder(this._bufParams);\n        this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n      } catch (ex) {\n        if (ex instanceof RuntimeException) this._saveException = ex;else throw ex;\n      } finally {}\n    }\n\n    getResultGeometry(distance) {\n      this._distance = distance;\n      this.computeGeometry();\n      return this._resultGeometry;\n    }\n\n    setEndCapStyle(endCapStyle) {\n      this._bufParams.setEndCapStyle(endCapStyle);\n    }\n\n  }\n  BufferOp.CAP_ROUND = BufferParameters.CAP_ROUND;\n  BufferOp.CAP_BUTT = BufferParameters.CAP_FLAT;\n  BufferOp.CAP_FLAT = BufferParameters.CAP_FLAT;\n  BufferOp.CAP_SQUARE = BufferParameters.CAP_SQUARE;\n  BufferOp.MAX_PRECISION_DIGITS = 12;\n\n  var buffer = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    BufferOp: BufferOp,\n    BufferParameters: BufferParameters\n  });\n\n  class GeometryLocation {\n    constructor() {\n      GeometryLocation.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._component = null;\n      this._segIndex = null;\n      this._pt = null;\n\n      if (arguments.length === 2) {\n        const component = arguments[0],\n              pt = arguments[1];\n        GeometryLocation.constructor_.call(this, component, GeometryLocation.INSIDE_AREA, pt);\n      } else if (arguments.length === 3) {\n        const component = arguments[0],\n              segIndex = arguments[1],\n              pt = arguments[2];\n        this._component = component;\n        this._segIndex = segIndex;\n        this._pt = pt;\n      }\n    }\n\n    getSegmentIndex() {\n      return this._segIndex;\n    }\n\n    getCoordinate() {\n      return this._pt;\n    }\n\n    isInsideArea() {\n      return this._segIndex === GeometryLocation.INSIDE_AREA;\n    }\n\n    toString() {\n      return this._component.getGeometryType() + '[' + this._segIndex + ']' + '-' + WKTWriter.toPoint(this._pt);\n    }\n\n    getGeometryComponent() {\n      return this._component;\n    }\n\n  }\n  GeometryLocation.INSIDE_AREA = -1;\n\n  class ConnectedElementLocationFilter {\n    constructor() {\n      ConnectedElementLocationFilter.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._locations = null;\n      const locations = arguments[0];\n      this._locations = locations;\n    }\n\n    static getLocations(geom) {\n      const locations = new ArrayList();\n      geom.apply(new ConnectedElementLocationFilter(locations));\n      return locations;\n    }\n\n    filter(geom) {\n      if (geom.isEmpty()) return null;\n      if (geom instanceof Point || geom instanceof LineString || geom instanceof Polygon) this._locations.add(new GeometryLocation(geom, 0, geom.getCoordinate()));\n    }\n\n    get interfaces_() {\n      return [GeometryFilter];\n    }\n\n  }\n\n  class DistanceOp {\n    constructor() {\n      DistanceOp.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._geom = null;\n      this._terminateDistance = 0.0;\n      this._ptLocator = new PointLocator();\n      this._minDistanceLocation = null;\n      this._minDistance = Double.MAX_VALUE;\n\n      if (arguments.length === 2) {\n        const g0 = arguments[0],\n              g1 = arguments[1];\n        DistanceOp.constructor_.call(this, g0, g1, 0.0);\n      } else if (arguments.length === 3) {\n        const g0 = arguments[0],\n              g1 = arguments[1],\n              terminateDistance = arguments[2];\n        this._geom = new Array(2).fill(null);\n        this._geom[0] = g0;\n        this._geom[1] = g1;\n        this._terminateDistance = terminateDistance;\n      }\n    }\n\n    static distance(g0, g1) {\n      const distOp = new DistanceOp(g0, g1);\n      return distOp.distance();\n    }\n\n    static isWithinDistance(g0, g1, distance) {\n      const envDist = g0.getEnvelopeInternal().distance(g1.getEnvelopeInternal());\n      if (envDist > distance) return false;\n      const distOp = new DistanceOp(g0, g1, distance);\n      return distOp.distance() <= distance;\n    }\n\n    static nearestPoints(g0, g1) {\n      const distOp = new DistanceOp(g0, g1);\n      return distOp.nearestPoints();\n    }\n\n    computeContainmentDistance() {\n      if (arguments.length === 0) {\n        const locPtPoly = new Array(2).fill(null);\n        this.computeContainmentDistance(0, locPtPoly);\n        if (this._minDistance <= this._terminateDistance) return null;\n        this.computeContainmentDistance(1, locPtPoly);\n      } else if (arguments.length === 2) {\n        const polyGeomIndex = arguments[0],\n              locPtPoly = arguments[1];\n        const polyGeom = this._geom[polyGeomIndex];\n        if (polyGeom.getDimension() < 2) return null;\n        const locationsIndex = 1 - polyGeomIndex;\n        const polys = PolygonExtracter.getPolygons(polyGeom);\n\n        if (polys.size() > 0) {\n          const insideLocs = ConnectedElementLocationFilter.getLocations(this._geom[locationsIndex]);\n          this.computeContainmentDistance(insideLocs, polys, locPtPoly);\n\n          if (this._minDistance <= this._terminateDistance) {\n            this._minDistanceLocation[locationsIndex] = locPtPoly[0];\n            this._minDistanceLocation[polyGeomIndex] = locPtPoly[1];\n            return null;\n          }\n        }\n      } else if (arguments.length === 3) {\n        if (arguments[2] instanceof Array && hasInterface(arguments[0], List) && hasInterface(arguments[1], List)) {\n          const locs = arguments[0],\n                polys = arguments[1],\n                locPtPoly = arguments[2];\n\n          for (let i = 0; i < locs.size(); i++) {\n            const loc = locs.get(i);\n\n            for (let j = 0; j < polys.size(); j++) {\n              this.computeContainmentDistance(loc, polys.get(j), locPtPoly);\n              if (this._minDistance <= this._terminateDistance) return null;\n            }\n          }\n        } else if (arguments[2] instanceof Array && arguments[0] instanceof GeometryLocation && arguments[1] instanceof Polygon) {\n          const ptLoc = arguments[0],\n                poly = arguments[1],\n                locPtPoly = arguments[2];\n          const pt = ptLoc.getCoordinate();\n\n          if (Location.EXTERIOR !== this._ptLocator.locate(pt, poly)) {\n            this._minDistance = 0.0;\n            locPtPoly[0] = ptLoc;\n            locPtPoly[1] = new GeometryLocation(poly, pt);\n            return null;\n          }\n        }\n      }\n    }\n\n    computeMinDistanceLinesPoints(lines, points, locGeom) {\n      for (let i = 0; i < lines.size(); i++) {\n        const line = lines.get(i);\n\n        for (let j = 0; j < points.size(); j++) {\n          const pt = points.get(j);\n          this.computeMinDistance(line, pt, locGeom);\n          if (this._minDistance <= this._terminateDistance) return null;\n        }\n      }\n    }\n\n    computeFacetDistance() {\n      const locGeom = new Array(2).fill(null);\n      const lines0 = LinearComponentExtracter.getLines(this._geom[0]);\n      const lines1 = LinearComponentExtracter.getLines(this._geom[1]);\n      const pts0 = PointExtracter.getPoints(this._geom[0]);\n      const pts1 = PointExtracter.getPoints(this._geom[1]);\n      this.computeMinDistanceLines(lines0, lines1, locGeom);\n      this.updateMinDistance(locGeom, false);\n      if (this._minDistance <= this._terminateDistance) return null;\n      locGeom[0] = null;\n      locGeom[1] = null;\n      this.computeMinDistanceLinesPoints(lines0, pts1, locGeom);\n      this.updateMinDistance(locGeom, false);\n      if (this._minDistance <= this._terminateDistance) return null;\n      locGeom[0] = null;\n      locGeom[1] = null;\n      this.computeMinDistanceLinesPoints(lines1, pts0, locGeom);\n      this.updateMinDistance(locGeom, true);\n      if (this._minDistance <= this._terminateDistance) return null;\n      locGeom[0] = null;\n      locGeom[1] = null;\n      this.computeMinDistancePoints(pts0, pts1, locGeom);\n      this.updateMinDistance(locGeom, false);\n    }\n\n    nearestLocations() {\n      this.computeMinDistance();\n      return this._minDistanceLocation;\n    }\n\n    updateMinDistance(locGeom, flip) {\n      if (locGeom[0] === null) return null;\n\n      if (flip) {\n        this._minDistanceLocation[0] = locGeom[1];\n        this._minDistanceLocation[1] = locGeom[0];\n      } else {\n        this._minDistanceLocation[0] = locGeom[0];\n        this._minDistanceLocation[1] = locGeom[1];\n      }\n    }\n\n    nearestPoints() {\n      this.computeMinDistance();\n      const nearestPts = [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];\n      return nearestPts;\n    }\n\n    computeMinDistance() {\n      if (arguments.length === 0) {\n        if (this._minDistanceLocation !== null) return null;\n        this._minDistanceLocation = new Array(2).fill(null);\n        this.computeContainmentDistance();\n        if (this._minDistance <= this._terminateDistance) return null;\n        this.computeFacetDistance();\n      } else if (arguments.length === 3) {\n        if (arguments[2] instanceof Array && arguments[0] instanceof LineString && arguments[1] instanceof Point) {\n          const line = arguments[0],\n                pt = arguments[1],\n                locGeom = arguments[2];\n          if (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this._minDistance) return null;\n          const coord0 = line.getCoordinates();\n          const coord = pt.getCoordinate();\n\n          for (let i = 0; i < coord0.length - 1; i++) {\n            const dist = Distance.pointToSegment(coord, coord0[i], coord0[i + 1]);\n\n            if (dist < this._minDistance) {\n              this._minDistance = dist;\n              const seg = new LineSegment(coord0[i], coord0[i + 1]);\n              const segClosestPoint = seg.closestPoint(coord);\n              locGeom[0] = new GeometryLocation(line, i, segClosestPoint);\n              locGeom[1] = new GeometryLocation(pt, 0, coord);\n            }\n\n            if (this._minDistance <= this._terminateDistance) return null;\n          }\n        } else if (arguments[2] instanceof Array && arguments[0] instanceof LineString && arguments[1] instanceof LineString) {\n          const line0 = arguments[0],\n                line1 = arguments[1],\n                locGeom = arguments[2];\n          if (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this._minDistance) return null;\n          const coord0 = line0.getCoordinates();\n          const coord1 = line1.getCoordinates();\n\n          for (let i = 0; i < coord0.length - 1; i++) {\n            const segEnv0 = new Envelope(coord0[i], coord0[i + 1]);\n            if (segEnv0.distance(line1.getEnvelopeInternal()) > this._minDistance) continue;\n\n            for (let j = 0; j < coord1.length - 1; j++) {\n              const segEnv1 = new Envelope(coord1[j], coord1[j + 1]);\n              if (segEnv0.distance(segEnv1) > this._minDistance) continue;\n              const dist = Distance.segmentToSegment(coord0[i], coord0[i + 1], coord1[j], coord1[j + 1]);\n\n              if (dist < this._minDistance) {\n                this._minDistance = dist;\n                const seg0 = new LineSegment(coord0[i], coord0[i + 1]);\n                const seg1 = new LineSegment(coord1[j], coord1[j + 1]);\n                const closestPt = seg0.closestPoints(seg1);\n                locGeom[0] = new GeometryLocation(line0, i, closestPt[0]);\n                locGeom[1] = new GeometryLocation(line1, j, closestPt[1]);\n              }\n\n              if (this._minDistance <= this._terminateDistance) return null;\n            }\n          }\n        }\n      }\n    }\n\n    computeMinDistancePoints(points0, points1, locGeom) {\n      for (let i = 0; i < points0.size(); i++) {\n        const pt0 = points0.get(i);\n\n        for (let j = 0; j < points1.size(); j++) {\n          const pt1 = points1.get(j);\n          const dist = pt0.getCoordinate().distance(pt1.getCoordinate());\n\n          if (dist < this._minDistance) {\n            this._minDistance = dist;\n            locGeom[0] = new GeometryLocation(pt0, 0, pt0.getCoordinate());\n            locGeom[1] = new GeometryLocation(pt1, 0, pt1.getCoordinate());\n          }\n\n          if (this._minDistance <= this._terminateDistance) return null;\n        }\n      }\n    }\n\n    distance() {\n      if (this._geom[0] === null || this._geom[1] === null) throw new IllegalArgumentException('null geometries are not supported');\n      if (this._geom[0].isEmpty() || this._geom[1].isEmpty()) return 0.0;\n      this.computeMinDistance();\n      return this._minDistance;\n    }\n\n    computeMinDistanceLines(lines0, lines1, locGeom) {\n      for (let i = 0; i < lines0.size(); i++) {\n        const line0 = lines0.get(i);\n\n        for (let j = 0; j < lines1.size(); j++) {\n          const line1 = lines1.get(j);\n          this.computeMinDistance(line0, line1, locGeom);\n          if (this._minDistance <= this._terminateDistance) return null;\n        }\n      }\n    }\n\n  }\n\n  var distance = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    DistanceOp: DistanceOp\n  });\n\n  class EdgeString {\n    constructor() {\n      EdgeString.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._factory = null;\n      this._directedEdges = new ArrayList();\n      this._coordinates = null;\n      const factory = arguments[0];\n      this._factory = factory;\n    }\n\n    getCoordinates() {\n      if (this._coordinates === null) {\n        let forwardDirectedEdges = 0;\n        let reverseDirectedEdges = 0;\n        const coordinateList = new CoordinateList();\n\n        for (let i = this._directedEdges.iterator(); i.hasNext();) {\n          const directedEdge = i.next();\n          if (directedEdge.getEdgeDirection()) forwardDirectedEdges++;else reverseDirectedEdges++;\n          coordinateList.add(directedEdge.getEdge().getLine().getCoordinates(), false, directedEdge.getEdgeDirection());\n        }\n\n        this._coordinates = coordinateList.toCoordinateArray();\n        if (reverseDirectedEdges > forwardDirectedEdges) CoordinateArrays.reverse(this._coordinates);\n      }\n\n      return this._coordinates;\n    }\n\n    toLineString() {\n      return this._factory.createLineString(this.getCoordinates());\n    }\n\n    add(directedEdge) {\n      this._directedEdges.add(directedEdge);\n    }\n\n  }\n\n  class GraphComponent$1 {\n    constructor() {\n      GraphComponent$1.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._isMarked = false;\n      this._isVisited = false;\n      this._data = null;\n    }\n\n    static getComponentWithVisitedState(i, visitedState) {\n      while (i.hasNext()) {\n        const comp = i.next();\n        if (comp.isVisited() === visitedState) return comp;\n      }\n\n      return null;\n    }\n\n    static setVisited(i, visited) {\n      while (i.hasNext()) {\n        const comp = i.next();\n        comp.setVisited(visited);\n      }\n    }\n\n    static setMarked(i, marked) {\n      while (i.hasNext()) {\n        const comp = i.next();\n        comp.setMarked(marked);\n      }\n    }\n\n    setVisited(isVisited) {\n      this._isVisited = isVisited;\n    }\n\n    isMarked() {\n      return this._isMarked;\n    }\n\n    setData(data) {\n      this._data = data;\n    }\n\n    getData() {\n      return this._data;\n    }\n\n    setMarked(isMarked) {\n      this._isMarked = isMarked;\n    }\n\n    getContext() {\n      return this._data;\n    }\n\n    isVisited() {\n      return this._isVisited;\n    }\n\n    setContext(data) {\n      this._data = data;\n    }\n\n  }\n\n  class DirectedEdge$1 extends GraphComponent$1 {\n    constructor() {\n      super();\n      DirectedEdge$1.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._parentEdge = null;\n      this._from = null;\n      this._to = null;\n      this._p0 = null;\n      this._p1 = null;\n      this._sym = null;\n      this._edgeDirection = null;\n      this._quadrant = null;\n      this._angle = null;\n\n      if (arguments.length === 0) ; else if (arguments.length === 4) {\n        const from = arguments[0],\n              to = arguments[1],\n              directionPt = arguments[2],\n              edgeDirection = arguments[3];\n        this._from = from;\n        this._to = to;\n        this._edgeDirection = edgeDirection;\n        this._p0 = from.getCoordinate();\n        this._p1 = directionPt;\n        const dx = this._p1.x - this._p0.x;\n        const dy = this._p1.y - this._p0.y;\n        this._quadrant = Quadrant.quadrant(dx, dy);\n        this._angle = Math.atan2(dy, dx);\n      }\n    }\n\n    static toEdges(dirEdges) {\n      const edges = new ArrayList();\n\n      for (let i = dirEdges.iterator(); i.hasNext();) edges.add(i.next()._parentEdge);\n\n      return edges;\n    }\n\n    isRemoved() {\n      return this._parentEdge === null;\n    }\n\n    compareDirection(e) {\n      if (this._quadrant > e._quadrant) return 1;\n      if (this._quadrant < e._quadrant) return -1;\n      return Orientation.index(e._p0, e._p1, this._p1);\n    }\n\n    getCoordinate() {\n      return this._from.getCoordinate();\n    }\n\n    print(out) {\n      const className = this.getClass().getName();\n      const lastDotPos = className.lastIndexOf('.');\n      const name = className.substring(lastDotPos + 1);\n      out.print('  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + this._angle);\n    }\n\n    getDirectionPt() {\n      return this._p1;\n    }\n\n    getAngle() {\n      return this._angle;\n    }\n\n    compareTo(obj) {\n      const de = obj;\n      return this.compareDirection(de);\n    }\n\n    getFromNode() {\n      return this._from;\n    }\n\n    getSym() {\n      return this._sym;\n    }\n\n    setEdge(parentEdge) {\n      this._parentEdge = parentEdge;\n    }\n\n    remove() {\n      this._sym = null;\n      this._parentEdge = null;\n    }\n\n    getEdge() {\n      return this._parentEdge;\n    }\n\n    getQuadrant() {\n      return this._quadrant;\n    }\n\n    setSym(sym) {\n      this._sym = sym;\n    }\n\n    getToNode() {\n      return this._to;\n    }\n\n    getEdgeDirection() {\n      return this._edgeDirection;\n    }\n\n    get interfaces_() {\n      return [Comparable];\n    }\n\n  }\n\n  class LineMergeDirectedEdge extends DirectedEdge$1 {\n    constructor() {\n      super();\n      LineMergeDirectedEdge.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      const from = arguments[0],\n            to = arguments[1],\n            directionPt = arguments[2],\n            edgeDirection = arguments[3];\n      DirectedEdge$1.constructor_.call(this, from, to, directionPt, edgeDirection);\n    }\n\n    getNext() {\n      if (this.getToNode().getDegree() !== 2) return null;\n      if (this.getToNode().getOutEdges().getEdges().get(0) === this.getSym()) return this.getToNode().getOutEdges().getEdges().get(1);\n      Assert.isTrue(this.getToNode().getOutEdges().getEdges().get(1) === this.getSym());\n      return this.getToNode().getOutEdges().getEdges().get(0);\n    }\n\n  }\n\n  class Edge$1 extends GraphComponent$1 {\n    constructor() {\n      super();\n      Edge$1.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._dirEdge = null;\n\n      if (arguments.length === 0) ; else if (arguments.length === 2) {\n        const de0 = arguments[0],\n              de1 = arguments[1];\n        this.setDirectedEdges(de0, de1);\n      }\n    }\n\n    isRemoved() {\n      return this._dirEdge === null;\n    }\n\n    setDirectedEdges(de0, de1) {\n      this._dirEdge = [de0, de1];\n      de0.setEdge(this);\n      de1.setEdge(this);\n      de0.setSym(de1);\n      de1.setSym(de0);\n      de0.getFromNode().addOutEdge(de0);\n      de1.getFromNode().addOutEdge(de1);\n    }\n\n    getDirEdge() {\n      if (Number.isInteger(arguments[0])) {\n        const i = arguments[0];\n        return this._dirEdge[i];\n      } else if (arguments[0] instanceof Node$2) {\n        const fromNode = arguments[0];\n        if (this._dirEdge[0].getFromNode() === fromNode) return this._dirEdge[0];\n        if (this._dirEdge[1].getFromNode() === fromNode) return this._dirEdge[1];\n        return null;\n      }\n    }\n\n    remove() {\n      this._dirEdge = null;\n    }\n\n    getOppositeNode(node) {\n      if (this._dirEdge[0].getFromNode() === node) return this._dirEdge[0].getToNode();\n      if (this._dirEdge[1].getFromNode() === node) return this._dirEdge[1].getToNode();\n      return null;\n    }\n\n  }\n\n  class DirectedEdgeStar$1 {\n    constructor() {\n      DirectedEdgeStar$1.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._outEdges = new ArrayList();\n      this._sorted = false;\n    }\n\n    getNextEdge(dirEdge) {\n      const i = this.getIndex(dirEdge);\n      return this._outEdges.get(this.getIndex(i + 1));\n    }\n\n    getCoordinate() {\n      const it = this.iterator();\n      if (!it.hasNext()) return null;\n      const e = it.next();\n      return e.getCoordinate();\n    }\n\n    iterator() {\n      this.sortEdges();\n      return this._outEdges.iterator();\n    }\n\n    sortEdges() {\n      if (!this._sorted) {\n        Collections.sort(this._outEdges);\n        this._sorted = true;\n      }\n    }\n\n    remove(de) {\n      this._outEdges.remove(de);\n    }\n\n    getEdges() {\n      this.sortEdges();\n      return this._outEdges;\n    }\n\n    getNextCWEdge(dirEdge) {\n      const i = this.getIndex(dirEdge);\n      return this._outEdges.get(this.getIndex(i - 1));\n    }\n\n    getIndex() {\n      if (arguments[0] instanceof Edge$1) {\n        const edge = arguments[0];\n        this.sortEdges();\n\n        for (let i = 0; i < this._outEdges.size(); i++) {\n          const de = this._outEdges.get(i);\n\n          if (de.getEdge() === edge) return i;\n        }\n\n        return -1;\n      } else if (arguments[0] instanceof DirectedEdge$1) {\n        const dirEdge = arguments[0];\n        this.sortEdges();\n\n        for (let i = 0; i < this._outEdges.size(); i++) {\n          const de = this._outEdges.get(i);\n\n          if (de === dirEdge) return i;\n        }\n\n        return -1;\n      } else if (Number.isInteger(arguments[0])) {\n        const i = arguments[0];\n\n        let modi = i % this._outEdges.size();\n\n        if (modi < 0) modi += this._outEdges.size();\n        return modi;\n      }\n    }\n\n    add(de) {\n      this._outEdges.add(de);\n\n      this._sorted = false;\n    }\n\n    getDegree() {\n      return this._outEdges.size();\n    }\n\n  }\n\n  class Node$2 extends GraphComponent$1 {\n    constructor() {\n      super();\n      Node$2.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._pt = null;\n      this._deStar = null;\n\n      if (arguments.length === 1) {\n        const pt = arguments[0];\n        Node$2.constructor_.call(this, pt, new DirectedEdgeStar$1());\n      } else if (arguments.length === 2) {\n        const pt = arguments[0],\n              deStar = arguments[1];\n        this._pt = pt;\n        this._deStar = deStar;\n      }\n    }\n\n    static getEdgesBetween(node0, node1) {\n      const edges0 = DirectedEdge$1.toEdges(node0.getOutEdges().getEdges());\n      const commonEdges = new HashSet(edges0);\n      const edges1 = DirectedEdge$1.toEdges(node1.getOutEdges().getEdges());\n      commonEdges.retainAll(edges1);\n      return commonEdges;\n    }\n\n    isRemoved() {\n      return this._pt === null;\n    }\n\n    addOutEdge(de) {\n      this._deStar.add(de);\n    }\n\n    getCoordinate() {\n      return this._pt;\n    }\n\n    getOutEdges() {\n      return this._deStar;\n    }\n\n    remove() {\n      if (arguments.length === 0) {\n        this._pt = null;\n      } else if (arguments.length === 1) {\n        const de = arguments[0];\n\n        this._deStar.remove(de);\n      }\n    }\n\n    getIndex(edge) {\n      return this._deStar.getIndex(edge);\n    }\n\n    getDegree() {\n      return this._deStar.getDegree();\n    }\n\n  }\n\n  class LineMergeEdge extends Edge$1 {\n    constructor() {\n      super();\n      LineMergeEdge.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._line = null;\n      const line = arguments[0];\n      this._line = line;\n    }\n\n    getLine() {\n      return this._line;\n    }\n\n  }\n\n  class NodeMap$1 {\n    constructor() {\n      NodeMap$1.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._nodeMap = new TreeMap();\n    }\n\n    find(coord) {\n      return this._nodeMap.get(coord);\n    }\n\n    iterator() {\n      return this._nodeMap.values().iterator();\n    }\n\n    remove(pt) {\n      return this._nodeMap.remove(pt);\n    }\n\n    values() {\n      return this._nodeMap.values();\n    }\n\n    add(n) {\n      this._nodeMap.put(n.getCoordinate(), n);\n\n      return n;\n    }\n\n  }\n\n  class PlanarGraph$1 {\n    constructor() {\n      PlanarGraph$1.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._edges = new HashSet();\n      this._dirEdges = new HashSet();\n      this._nodeMap = new NodeMap$1();\n    }\n\n    findNodesOfDegree(degree) {\n      const nodesFound = new ArrayList();\n\n      for (let i = this.nodeIterator(); i.hasNext();) {\n        const node = i.next();\n        if (node.getDegree() === degree) nodesFound.add(node);\n      }\n\n      return nodesFound;\n    }\n\n    dirEdgeIterator() {\n      return this._dirEdges.iterator();\n    }\n\n    edgeIterator() {\n      return this._edges.iterator();\n    }\n\n    remove() {\n      if (arguments[0] instanceof Edge$1) {\n        const edge = arguments[0];\n        this.remove(edge.getDirEdge(0));\n        this.remove(edge.getDirEdge(1));\n\n        this._edges.remove(edge);\n\n        edge.remove();\n      } else if (arguments[0] instanceof DirectedEdge$1) {\n        const de = arguments[0];\n        const sym = de.getSym();\n        if (sym !== null) sym.setSym(null);\n        de.getFromNode().remove(de);\n        de.remove();\n\n        this._dirEdges.remove(de);\n      } else if (arguments[0] instanceof Node$2) {\n        const node = arguments[0];\n        const outEdges = node.getOutEdges().getEdges();\n\n        for (let i = outEdges.iterator(); i.hasNext();) {\n          const de = i.next();\n          const sym = de.getSym();\n          if (sym !== null) this.remove(sym);\n\n          this._dirEdges.remove(de);\n\n          const edge = de.getEdge();\n          if (edge !== null) this._edges.remove(edge);\n        }\n\n        this._nodeMap.remove(node.getCoordinate());\n\n        node.remove();\n      }\n    }\n\n    findNode(pt) {\n      return this._nodeMap.find(pt);\n    }\n\n    getEdges() {\n      return this._edges;\n    }\n\n    nodeIterator() {\n      return this._nodeMap.iterator();\n    }\n\n    contains() {\n      if (arguments[0] instanceof Edge$1) {\n        const e = arguments[0];\n        return this._edges.contains(e);\n      } else if (arguments[0] instanceof DirectedEdge$1) {\n        const de = arguments[0];\n        return this._dirEdges.contains(de);\n      }\n    }\n\n    add() {\n      if (arguments[0] instanceof Node$2) {\n        const node = arguments[0];\n\n        this._nodeMap.add(node);\n      } else if (arguments[0] instanceof Edge$1) {\n        const edge = arguments[0];\n\n        this._edges.add(edge);\n\n        this.add(edge.getDirEdge(0));\n        this.add(edge.getDirEdge(1));\n      } else if (arguments[0] instanceof DirectedEdge$1) {\n        const dirEdge = arguments[0];\n\n        this._dirEdges.add(dirEdge);\n      }\n    }\n\n    getNodes() {\n      return this._nodeMap.values();\n    }\n\n  }\n\n  class LineMergeGraph extends PlanarGraph$1 {\n    constructor() {\n      super();\n    }\n\n    addEdge(lineString) {\n      if (lineString.isEmpty()) return null;\n      const coordinates = CoordinateArrays.removeRepeatedPoints(lineString.getCoordinates());\n      if (coordinates.length <= 1) return null;\n      const startCoordinate = coordinates[0];\n      const endCoordinate = coordinates[coordinates.length - 1];\n      const startNode = this.getNode(startCoordinate);\n      const endNode = this.getNode(endCoordinate);\n      const directedEdge0 = new LineMergeDirectedEdge(startNode, endNode, coordinates[1], true);\n      const directedEdge1 = new LineMergeDirectedEdge(endNode, startNode, coordinates[coordinates.length - 2], false);\n      const edge = new LineMergeEdge(lineString);\n      edge.setDirectedEdges(directedEdge0, directedEdge1);\n      this.add(edge);\n    }\n\n    getNode(coordinate) {\n      let node = this.findNode(coordinate);\n\n      if (node === null) {\n        node = new Node$2(coordinate);\n        this.add(node);\n      }\n\n      return node;\n    }\n\n  }\n\n  class LineMerger {\n    constructor() {\n      LineMerger.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._graph = new LineMergeGraph();\n      this._mergedLineStrings = null;\n      this._factory = null;\n      this._edgeStrings = null;\n    }\n\n    buildEdgeStringsForUnprocessedNodes() {\n      for (let i = this._graph.getNodes().iterator(); i.hasNext();) {\n        const node = i.next();\n\n        if (!node.isMarked()) {\n          Assert.isTrue(node.getDegree() === 2);\n          this.buildEdgeStringsStartingAt(node);\n          node.setMarked(true);\n        }\n      }\n    }\n\n    buildEdgeStringsForNonDegree2Nodes() {\n      for (let i = this._graph.getNodes().iterator(); i.hasNext();) {\n        const node = i.next();\n\n        if (node.getDegree() !== 2) {\n          this.buildEdgeStringsStartingAt(node);\n          node.setMarked(true);\n        }\n      }\n    }\n\n    buildEdgeStringsForObviousStartNodes() {\n      this.buildEdgeStringsForNonDegree2Nodes();\n    }\n\n    getMergedLineStrings() {\n      this.merge();\n      return this._mergedLineStrings;\n    }\n\n    buildEdgeStringsStartingAt(node) {\n      for (let i = node.getOutEdges().iterator(); i.hasNext();) {\n        const directedEdge = i.next();\n        if (directedEdge.getEdge().isMarked()) continue;\n\n        this._edgeStrings.add(this.buildEdgeStringStartingWith(directedEdge));\n      }\n    }\n\n    merge() {\n      if (this._mergedLineStrings !== null) return null;\n      GraphComponent$1.setMarked(this._graph.nodeIterator(), false);\n      GraphComponent$1.setMarked(this._graph.edgeIterator(), false);\n      this._edgeStrings = new ArrayList();\n      this.buildEdgeStringsForObviousStartNodes();\n      this.buildEdgeStringsForIsolatedLoops();\n      this._mergedLineStrings = new ArrayList();\n\n      for (let i = this._edgeStrings.iterator(); i.hasNext();) {\n        const edgeString = i.next();\n\n        this._mergedLineStrings.add(edgeString.toLineString());\n      }\n    }\n\n    addLineString(lineString) {\n      if (this._factory === null) this._factory = lineString.getFactory();\n\n      this._graph.addEdge(lineString);\n    }\n\n    buildEdgeStringStartingWith(start) {\n      const edgeString = new EdgeString(this._factory);\n      let current = start;\n\n      do {\n        edgeString.add(current);\n        current.getEdge().setMarked(true);\n        current = current.getNext();\n      } while (current !== null && current !== start);\n\n      return edgeString;\n    }\n\n    add() {\n      if (arguments[0] instanceof Geometry) {\n        const geometry = arguments[0];\n\n        for (let i = 0; i < geometry.getNumGeometries(); i++) {\n          const component = geometry.getGeometryN(i);\n          if (component instanceof LineString) this.addLineString(component);\n        }\n      } else if (hasInterface(arguments[0], Collection)) {\n        const geometries = arguments[0];\n        this._mergedLineStrings = null;\n\n        for (let i = geometries.iterator(); i.hasNext();) {\n          const geometry = i.next();\n          this.add(geometry);\n        }\n      }\n    }\n\n    buildEdgeStringsForIsolatedLoops() {\n      this.buildEdgeStringsForUnprocessedNodes();\n    }\n\n  }\n\n  class Subgraph {\n    constructor() {\n      Subgraph.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._parentGraph = null;\n      this._edges = new HashSet();\n      this._dirEdges = new ArrayList();\n      this._nodeMap = new NodeMap$1();\n      const parentGraph = arguments[0];\n      this._parentGraph = parentGraph;\n    }\n\n    dirEdgeIterator() {\n      return this._dirEdges.iterator();\n    }\n\n    edgeIterator() {\n      return this._edges.iterator();\n    }\n\n    getParent() {\n      return this._parentGraph;\n    }\n\n    nodeIterator() {\n      return this._nodeMap.iterator();\n    }\n\n    contains(e) {\n      return this._edges.contains(e);\n    }\n\n    add(e) {\n      if (this._edges.contains(e)) return null;\n\n      this._edges.add(e);\n\n      this._dirEdges.add(e.getDirEdge(0));\n\n      this._dirEdges.add(e.getDirEdge(1));\n\n      this._nodeMap.add(e.getDirEdge(0).getFromNode());\n\n      this._nodeMap.add(e.getDirEdge(1).getFromNode());\n    }\n\n  }\n\n  class ConnectedSubgraphFinder {\n    constructor() {\n      ConnectedSubgraphFinder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._graph = null;\n      const graph = arguments[0];\n      this._graph = graph;\n    }\n\n    addReachable(startNode, subgraph) {\n      const nodeStack = new Stack();\n      nodeStack.add(startNode);\n\n      while (!nodeStack.empty()) {\n        const node = nodeStack.pop();\n        this.addEdges(node, nodeStack, subgraph);\n      }\n    }\n\n    findSubgraph(node) {\n      const subgraph = new Subgraph(this._graph);\n      this.addReachable(node, subgraph);\n      return subgraph;\n    }\n\n    getConnectedSubgraphs() {\n      const subgraphs = new ArrayList();\n      GraphComponent$1.setVisited(this._graph.nodeIterator(), false);\n\n      for (let i = this._graph.edgeIterator(); i.hasNext();) {\n        const e = i.next();\n        const node = e.getDirEdge(0).getFromNode();\n        if (!node.isVisited()) subgraphs.add(this.findSubgraph(node));\n      }\n\n      return subgraphs;\n    }\n\n    addEdges(node, nodeStack, subgraph) {\n      node.setVisited(true);\n\n      for (let i = node.getOutEdges().iterator(); i.hasNext();) {\n        const de = i.next();\n        subgraph.add(de.getEdge());\n        const toNode = de.getToNode();\n        if (!toNode.isVisited()) nodeStack.push(toNode);\n      }\n    }\n\n  }\n\n  class LineSequencer {\n    constructor() {\n      LineSequencer.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._graph = new LineMergeGraph();\n      this._factory = new GeometryFactory();\n      this._lineCount = 0;\n      this._isRun = false;\n      this._sequencedGeometry = null;\n      this._isSequenceable = false;\n    }\n\n    static findUnvisitedBestOrientedDE(node) {\n      let wellOrientedDE = null;\n      let unvisitedDE = null;\n\n      for (let i = node.getOutEdges().iterator(); i.hasNext();) {\n        const de = i.next();\n\n        if (!de.getEdge().isVisited()) {\n          unvisitedDE = de;\n          if (de.getEdgeDirection()) wellOrientedDE = de;\n        }\n      }\n\n      if (wellOrientedDE !== null) return wellOrientedDE;\n      return unvisitedDE;\n    }\n\n    static findLowestDegreeNode(graph) {\n      let minDegree = Integer.MAX_VALUE;\n      let minDegreeNode = null;\n\n      for (let i = graph.nodeIterator(); i.hasNext();) {\n        const node = i.next();\n\n        if (minDegreeNode === null || node.getDegree() < minDegree) {\n          minDegree = node.getDegree();\n          minDegreeNode = node;\n        }\n      }\n\n      return minDegreeNode;\n    }\n\n    static isSequenced(geom) {\n      if (!(geom instanceof MultiLineString)) return true;\n      const mls = geom;\n      const prevSubgraphNodes = new TreeSet();\n      let lastNode = null;\n      const currNodes = new ArrayList();\n\n      for (let i = 0; i < mls.getNumGeometries(); i++) {\n        const line = mls.getGeometryN(i);\n        const startNode = line.getCoordinateN(0);\n        const endNode = line.getCoordinateN(line.getNumPoints() - 1);\n        if (prevSubgraphNodes.contains(startNode)) return false;\n        if (prevSubgraphNodes.contains(endNode)) return false;\n        if (lastNode !== null) if (!startNode.equals(lastNode)) {\n          prevSubgraphNodes.addAll(currNodes);\n          currNodes.clear();\n        }\n        currNodes.add(startNode);\n        currNodes.add(endNode);\n        lastNode = endNode;\n      }\n\n      return true;\n    }\n\n    static reverse(line) {\n      const pts = line.getCoordinates();\n      const revPts = new Array(pts.length).fill(null);\n      const len = pts.length;\n\n      for (let i = 0; i < len; i++) revPts[len - 1 - i] = new Coordinate(pts[i]);\n\n      return line.getFactory().createLineString(revPts);\n    }\n\n    static sequence(geom) {\n      const sequencer = new LineSequencer();\n      sequencer.add(geom);\n      return sequencer.getSequencedLineStrings();\n    }\n\n    addLine(lineString) {\n      if (this._factory === null) this._factory = lineString.getFactory();\n\n      this._graph.addEdge(lineString);\n\n      this._lineCount++;\n    }\n\n    hasSequence(graph) {\n      let oddDegreeCount = 0;\n\n      for (let i = graph.nodeIterator(); i.hasNext();) {\n        const node = i.next();\n        if (node.getDegree() % 2 === 1) oddDegreeCount++;\n      }\n\n      return oddDegreeCount <= 2;\n    }\n\n    computeSequence() {\n      if (this._isRun) return null;\n      this._isRun = true;\n      const sequences = this.findSequences();\n      if (sequences === null) return null;\n      this._sequencedGeometry = this.buildSequencedGeometry(sequences);\n      this._isSequenceable = true;\n\n      const finalLineCount = this._sequencedGeometry.getNumGeometries();\n\n      Assert.isTrue(this._lineCount === finalLineCount, 'Lines were missing from result');\n      Assert.isTrue(this._sequencedGeometry instanceof LineString || this._sequencedGeometry instanceof MultiLineString, 'Result is not lineal');\n    }\n\n    findSequences() {\n      const sequences = new ArrayList();\n      const csFinder = new ConnectedSubgraphFinder(this._graph);\n      const subgraphs = csFinder.getConnectedSubgraphs();\n\n      for (let i = subgraphs.iterator(); i.hasNext();) {\n        const subgraph = i.next();\n\n        if (this.hasSequence(subgraph)) {\n          const seq = this.findSequence(subgraph);\n          sequences.add(seq);\n        } else {\n          return null;\n        }\n      }\n\n      return sequences;\n    }\n\n    addReverseSubpath(de, lit, expectedClosed) {\n      const endNode = de.getToNode();\n      let fromNode = null;\n\n      while (true) {\n        lit.add(de.getSym());\n        de.getEdge().setVisited(true);\n        fromNode = de.getFromNode();\n        const unvisitedOutDE = LineSequencer.findUnvisitedBestOrientedDE(fromNode);\n        if (unvisitedOutDE === null) break;\n        de = unvisitedOutDE.getSym();\n      }\n\n      if (expectedClosed) Assert.isTrue(fromNode === endNode, 'path not contiguous');\n    }\n\n    findSequence(graph) {\n      GraphComponent$1.setVisited(graph.edgeIterator(), false);\n      const startNode = LineSequencer.findLowestDegreeNode(graph);\n      const startDE = startNode.getOutEdges().iterator().next();\n      const startDESym = startDE.getSym();\n      const seq = new LinkedList();\n      const lit = seq.listIterator();\n      this.addReverseSubpath(startDESym, lit, false);\n\n      while (lit.hasPrevious()) {\n        const prev = lit.previous();\n        const unvisitedOutDE = LineSequencer.findUnvisitedBestOrientedDE(prev.getFromNode());\n        if (unvisitedOutDE !== null) this.addReverseSubpath(unvisitedOutDE.getSym(), lit, true);\n      }\n\n      const orientedSeq = this.orient(seq);\n      return orientedSeq;\n    }\n\n    reverse(seq) {\n      const newSeq = new LinkedList();\n\n      for (let i = seq.iterator(); i.hasNext();) {\n        const de = i.next();\n        newSeq.addFirst(de.getSym());\n      }\n\n      return newSeq;\n    }\n\n    orient(seq) {\n      const startEdge = seq.get(0);\n      const endEdge = seq.get(seq.size() - 1);\n      const startNode = startEdge.getFromNode();\n      const endNode = endEdge.getToNode();\n      let flipSeq = false;\n      const hasDegree1Node = startNode.getDegree() === 1 || endNode.getDegree() === 1;\n\n      if (hasDegree1Node) {\n        let hasObviousStartNode = false;\n\n        if (endEdge.getToNode().getDegree() === 1 && endEdge.getEdgeDirection() === false) {\n          hasObviousStartNode = true;\n          flipSeq = true;\n        }\n\n        if (startEdge.getFromNode().getDegree() === 1 && startEdge.getEdgeDirection() === true) {\n          hasObviousStartNode = true;\n          flipSeq = false;\n        }\n\n        if (!hasObviousStartNode) if (startEdge.getFromNode().getDegree() === 1) flipSeq = true;\n      }\n\n      if (flipSeq) return this.reverse(seq);\n      return seq;\n    }\n\n    buildSequencedGeometry(sequences) {\n      const lines = new ArrayList();\n\n      for (let i1 = sequences.iterator(); i1.hasNext();) {\n        const seq = i1.next();\n\n        for (let i2 = seq.iterator(); i2.hasNext();) {\n          const de = i2.next();\n          const e = de.getEdge();\n          const line = e.getLine();\n          let lineToAdd = line;\n          if (!de.getEdgeDirection() && !line.isClosed()) lineToAdd = LineSequencer.reverse(line);\n          lines.add(lineToAdd);\n        }\n      }\n\n      if (lines.size() === 0) return this._factory.createMultiLineString(new Array(0).fill(null));\n      return this._factory.buildGeometry(lines);\n    }\n\n    getSequencedLineStrings() {\n      this.computeSequence();\n      return this._sequencedGeometry;\n    }\n\n    isSequenceable() {\n      this.computeSequence();\n      return this._isSequenceable;\n    }\n\n    add() {\n      if (hasInterface(arguments[0], Collection)) {\n        const geometries = arguments[0];\n\n        for (let i = geometries.iterator(); i.hasNext();) {\n          const geometry = i.next();\n          this.add(geometry);\n        }\n      } else if (arguments[0] instanceof Geometry) {\n        const geometry = arguments[0];\n        geometry.apply(new class {\n          get interfaces_() {\n            return [GeometryComponentFilter];\n          }\n\n          filter(component) {\n            if (component instanceof LineString) this.addLine(component);\n          }\n\n        }());\n      }\n    }\n\n  }\n\n  var linemerge = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    LineMerger: LineMerger,\n    LineSequencer: LineSequencer\n  });\n\n  class LineStringSnapper {\n    constructor() {\n      LineStringSnapper.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._snapTolerance = 0.0;\n      this._srcPts = null;\n      this._seg = new LineSegment();\n      this._allowSnappingToSourceVertices = false;\n      this._isClosed = false;\n\n      if (arguments[0] instanceof LineString && typeof arguments[1] === 'number') {\n        const srcLine = arguments[0],\n              snapTolerance = arguments[1];\n        LineStringSnapper.constructor_.call(this, srcLine.getCoordinates(), snapTolerance);\n      } else if (arguments[0] instanceof Array && typeof arguments[1] === 'number') {\n        const srcPts = arguments[0],\n              snapTolerance = arguments[1];\n        this._srcPts = srcPts;\n        this._isClosed = LineStringSnapper.isClosed(srcPts);\n        this._snapTolerance = snapTolerance;\n      }\n    }\n\n    static isClosed(pts) {\n      if (pts.length <= 1) return false;\n      return pts[0].equals2D(pts[pts.length - 1]);\n    }\n\n    snapVertices(srcCoords, snapPts) {\n      const end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();\n\n      for (let i = 0; i < end; i++) {\n        const srcPt = srcCoords.get(i);\n        const snapVert = this.findSnapForVertex(srcPt, snapPts);\n\n        if (snapVert !== null) {\n          srcCoords.set(i, new Coordinate(snapVert));\n          if (i === 0 && this._isClosed) srcCoords.set(srcCoords.size() - 1, new Coordinate(snapVert));\n        }\n      }\n    }\n\n    findSnapForVertex(pt, snapPts) {\n      for (let i = 0; i < snapPts.length; i++) {\n        if (pt.equals2D(snapPts[i])) return null;\n        if (pt.distance(snapPts[i]) < this._snapTolerance) return snapPts[i];\n      }\n\n      return null;\n    }\n\n    snapTo(snapPts) {\n      const coordList = new CoordinateList(this._srcPts);\n      this.snapVertices(coordList, snapPts);\n      this.snapSegments(coordList, snapPts);\n      const newPts = coordList.toCoordinateArray();\n      return newPts;\n    }\n\n    snapSegments(srcCoords, snapPts) {\n      if (snapPts.length === 0) return null;\n      let distinctPtCount = snapPts.length;\n      if (snapPts[0].equals2D(snapPts[snapPts.length - 1])) distinctPtCount = snapPts.length - 1;\n\n      for (let i = 0; i < distinctPtCount; i++) {\n        const snapPt = snapPts[i];\n        const index = this.findSegmentIndexToSnap(snapPt, srcCoords);\n        if (index >= 0) srcCoords.add(index + 1, new Coordinate(snapPt), false);\n      }\n    }\n\n    findSegmentIndexToSnap(snapPt, srcCoords) {\n      let minDist = Double.MAX_VALUE;\n      let snapIndex = -1;\n\n      for (let i = 0; i < srcCoords.size() - 1; i++) {\n        this._seg.p0 = srcCoords.get(i);\n        this._seg.p1 = srcCoords.get(i + 1);\n        if (this._seg.p0.equals2D(snapPt) || this._seg.p1.equals2D(snapPt)) if (this._allowSnappingToSourceVertices) continue;else return -1;\n\n        const dist = this._seg.distance(snapPt);\n\n        if (dist < this._snapTolerance && dist < minDist) {\n          minDist = dist;\n          snapIndex = i;\n        }\n      }\n\n      return snapIndex;\n    }\n\n    setAllowSnappingToSourceVertices(allowSnappingToSourceVertices) {\n      this._allowSnappingToSourceVertices = allowSnappingToSourceVertices;\n    }\n\n  }\n\n  class GeometrySnapper {\n    constructor() {\n      GeometrySnapper.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._srcGeom = null;\n      const srcGeom = arguments[0];\n      this._srcGeom = srcGeom;\n    }\n\n    static snap(g0, g1, snapTolerance) {\n      const snapGeom = new Array(2).fill(null);\n      const snapper0 = new GeometrySnapper(g0);\n      snapGeom[0] = snapper0.snapTo(g1, snapTolerance);\n      const snapper1 = new GeometrySnapper(g1);\n      snapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);\n      return snapGeom;\n    }\n\n    static computeOverlaySnapTolerance() {\n      if (arguments.length === 1) {\n        const g = arguments[0];\n        let snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);\n        const pm = g.getPrecisionModel();\n\n        if (pm.getType() === PrecisionModel.FIXED) {\n          const fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;\n          if (fixedSnapTol > snapTolerance) snapTolerance = fixedSnapTol;\n        }\n\n        return snapTolerance;\n      } else if (arguments.length === 2) {\n        const g0 = arguments[0],\n              g1 = arguments[1];\n        return Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1));\n      }\n    }\n\n    static computeSizeBasedSnapTolerance(g) {\n      const env = g.getEnvelopeInternal();\n      const minDimension = Math.min(env.getHeight(), env.getWidth());\n      const snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;\n      return snapTol;\n    }\n\n    static snapToSelf(geom, snapTolerance, cleanResult) {\n      const snapper0 = new GeometrySnapper(geom);\n      return snapper0.snapToSelf(snapTolerance, cleanResult);\n    }\n\n    snapTo(snapGeom, snapTolerance) {\n      const snapPts = this.extractTargetCoordinates(snapGeom);\n      const snapTrans = new SnapTransformer(snapTolerance, snapPts);\n      return snapTrans.transform(this._srcGeom);\n    }\n\n    snapToSelf(snapTolerance, cleanResult) {\n      const snapPts = this.extractTargetCoordinates(this._srcGeom);\n      const snapTrans = new SnapTransformer(snapTolerance, snapPts, true);\n      const snappedGeom = snapTrans.transform(this._srcGeom);\n      let result = snappedGeom;\n      if (cleanResult && hasInterface(result, Polygonal)) result = snappedGeom.buffer(0);\n      return result;\n    }\n\n    computeSnapTolerance(ringPts) {\n      const minSegLen = this.computeMinimumSegmentLength(ringPts);\n      const snapTol = minSegLen / 10;\n      return snapTol;\n    }\n\n    extractTargetCoordinates(g) {\n      const ptSet = new TreeSet();\n      const pts = g.getCoordinates();\n\n      for (let i = 0; i < pts.length; i++) ptSet.add(pts[i]);\n\n      return ptSet.toArray(new Array(0).fill(null));\n    }\n\n    computeMinimumSegmentLength(pts) {\n      let minSegLen = Double.MAX_VALUE;\n\n      for (let i = 0; i < pts.length - 1; i++) {\n        const segLen = pts[i].distance(pts[i + 1]);\n        if (segLen < minSegLen) minSegLen = segLen;\n      }\n\n      return minSegLen;\n    }\n\n  }\n  GeometrySnapper.SNAP_PRECISION_FACTOR = 1e-9;\n\n  class SnapTransformer extends GeometryTransformer {\n    constructor() {\n      super();\n      SnapTransformer.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._snapTolerance = null;\n      this._snapPts = null;\n      this._isSelfSnap = false;\n\n      if (arguments.length === 2) {\n        const snapTolerance = arguments[0],\n              snapPts = arguments[1];\n        this._snapTolerance = snapTolerance;\n        this._snapPts = snapPts;\n      } else if (arguments.length === 3) {\n        const snapTolerance = arguments[0],\n              snapPts = arguments[1],\n              isSelfSnap = arguments[2];\n        this._snapTolerance = snapTolerance;\n        this._snapPts = snapPts;\n        this._isSelfSnap = isSelfSnap;\n      }\n    }\n\n    snapLine(srcPts, snapPts) {\n      const snapper = new LineStringSnapper(srcPts, this._snapTolerance);\n      snapper.setAllowSnappingToSourceVertices(this._isSelfSnap);\n      return snapper.snapTo(snapPts);\n    }\n\n    transformCoordinates(coords, parent) {\n      const srcPts = coords.toCoordinateArray();\n      const newPts = this.snapLine(srcPts, this._snapPts);\n      return this._factory.getCoordinateSequenceFactory().create(newPts);\n    }\n\n  }\n\n  var snap = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    GeometrySnapper: GeometrySnapper,\n    LineStringSnapper: LineStringSnapper\n  });\n\n  class BasicSegmentString {\n    constructor() {\n      BasicSegmentString.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._pts = null;\n      this._data = null;\n      const pts = arguments[0],\n            data = arguments[1];\n      this._pts = pts;\n      this._data = data;\n    }\n\n    getCoordinates() {\n      return this._pts;\n    }\n\n    size() {\n      return this._pts.length;\n    }\n\n    getCoordinate(i) {\n      return this._pts[i];\n    }\n\n    isClosed() {\n      return this._pts[0].equals(this._pts[this._pts.length - 1]);\n    }\n\n    getSegmentOctant(index) {\n      if (index === this._pts.length - 1) return -1;\n      return Octant.octant(this.getCoordinate(index), this.getCoordinate(index + 1));\n    }\n\n    setData(data) {\n      this._data = data;\n    }\n\n    getData() {\n      return this._data;\n    }\n\n    toString() {\n      return WKTWriter.toLineString(new CoordinateArraySequence(this._pts));\n    }\n\n    get interfaces_() {\n      return [SegmentString];\n    }\n\n  }\n\n  class NodingIntersectionFinder {\n    constructor() {\n      NodingIntersectionFinder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._findAllIntersections = false;\n      this._isCheckEndSegmentsOnly = false;\n      this._keepIntersections = true;\n      this._isInteriorIntersectionsOnly = false;\n      this._li = null;\n      this._interiorIntersection = null;\n      this._intSegments = null;\n      this._intersections = new ArrayList();\n      this._intersectionCount = 0;\n      const li = arguments[0];\n      this._li = li;\n      this._interiorIntersection = null;\n    }\n\n    static createAllIntersectionsFinder(li) {\n      const finder = new NodingIntersectionFinder(li);\n      finder.setFindAllIntersections(true);\n      return finder;\n    }\n\n    static isInteriorVertexIntersection() {\n      if (arguments.length === 4) {\n        const p0 = arguments[0],\n              p1 = arguments[1],\n              isEnd0 = arguments[2],\n              isEnd1 = arguments[3];\n        if (isEnd0 && isEnd1) return false;\n        if (p0.equals2D(p1)) return true;\n        return false;\n      } else if (arguments.length === 8) {\n        const p00 = arguments[0],\n              p01 = arguments[1],\n              p10 = arguments[2],\n              p11 = arguments[3],\n              isEnd00 = arguments[4],\n              isEnd01 = arguments[5],\n              isEnd10 = arguments[6],\n              isEnd11 = arguments[7];\n        if (NodingIntersectionFinder.isInteriorVertexIntersection(p00, p10, isEnd00, isEnd10)) return true;\n        if (NodingIntersectionFinder.isInteriorVertexIntersection(p00, p11, isEnd00, isEnd11)) return true;\n        if (NodingIntersectionFinder.isInteriorVertexIntersection(p01, p10, isEnd01, isEnd10)) return true;\n        if (NodingIntersectionFinder.isInteriorVertexIntersection(p01, p11, isEnd01, isEnd11)) return true;\n        return false;\n      }\n    }\n\n    static createInteriorIntersectionCounter(li) {\n      const finder = new NodingIntersectionFinder(li);\n      finder.setInteriorIntersectionsOnly(true);\n      finder.setFindAllIntersections(true);\n      finder.setKeepIntersections(false);\n      return finder;\n    }\n\n    static createIntersectionCounter(li) {\n      const finder = new NodingIntersectionFinder(li);\n      finder.setFindAllIntersections(true);\n      finder.setKeepIntersections(false);\n      return finder;\n    }\n\n    static isEndSegment(segStr, index) {\n      if (index === 0) return true;\n      if (index >= segStr.size() - 2) return true;\n      return false;\n    }\n\n    static createAnyIntersectionFinder(li) {\n      return new NodingIntersectionFinder(li);\n    }\n\n    static createInteriorIntersectionsFinder(li) {\n      const finder = new NodingIntersectionFinder(li);\n      finder.setFindAllIntersections(true);\n      finder.setInteriorIntersectionsOnly(true);\n      return finder;\n    }\n\n    setCheckEndSegmentsOnly(isCheckEndSegmentsOnly) {\n      this._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;\n    }\n\n    getIntersectionSegments() {\n      return this._intSegments;\n    }\n\n    count() {\n      return this._intersectionCount;\n    }\n\n    getIntersections() {\n      return this._intersections;\n    }\n\n    setFindAllIntersections(findAllIntersections) {\n      this._findAllIntersections = findAllIntersections;\n    }\n\n    setKeepIntersections(keepIntersections) {\n      this._keepIntersections = keepIntersections;\n    }\n\n    getIntersection() {\n      return this._interiorIntersection;\n    }\n\n    processIntersections(e0, segIndex0, e1, segIndex1) {\n      if (!this._findAllIntersections && this.hasIntersection()) return null;\n      const isSameSegString = e0 === e1;\n      const isSameSegment = isSameSegString && segIndex0 === segIndex1;\n      if (isSameSegment) return null;\n\n      if (this._isCheckEndSegmentsOnly) {\n        const isEndSegPresent = NodingIntersectionFinder.isEndSegment(e0, segIndex0) || NodingIntersectionFinder.isEndSegment(e1, segIndex1);\n        if (!isEndSegPresent) return null;\n      }\n\n      const p00 = e0.getCoordinate(segIndex0);\n      const p01 = e0.getCoordinate(segIndex0 + 1);\n      const p10 = e1.getCoordinate(segIndex1);\n      const p11 = e1.getCoordinate(segIndex1 + 1);\n      const isEnd00 = segIndex0 === 0;\n      const isEnd01 = segIndex0 + 2 === e0.size();\n      const isEnd10 = segIndex1 === 0;\n      const isEnd11 = segIndex1 + 2 === e1.size();\n\n      this._li.computeIntersection(p00, p01, p10, p11);\n\n      const isInteriorInt = this._li.hasIntersection() && this._li.isInteriorIntersection();\n\n      let isInteriorVertexInt = false;\n\n      if (!this._isInteriorIntersectionsOnly) {\n        const isAdjacentSegment = isSameSegString && Math.abs(segIndex1 - segIndex0) <= 1;\n        isInteriorVertexInt = !isAdjacentSegment && NodingIntersectionFinder.isInteriorVertexIntersection(p00, p01, p10, p11, isEnd00, isEnd01, isEnd10, isEnd11);\n      }\n\n      if (isInteriorInt || isInteriorVertexInt) {\n        this._intSegments = new Array(4).fill(null);\n        this._intSegments[0] = p00;\n        this._intSegments[1] = p01;\n        this._intSegments[2] = p10;\n        this._intSegments[3] = p11;\n        this._interiorIntersection = this._li.getIntersection(0);\n        if (this._keepIntersections) this._intersections.add(this._interiorIntersection);\n        this._intersectionCount++;\n      }\n    }\n\n    hasIntersection() {\n      return this._interiorIntersection !== null;\n    }\n\n    isDone() {\n      if (this._findAllIntersections) return false;\n      return this._interiorIntersection !== null;\n    }\n\n    setInteriorIntersectionsOnly(isInteriorIntersectionsOnly) {\n      this._isInteriorIntersectionsOnly = isInteriorIntersectionsOnly;\n    }\n\n    get interfaces_() {\n      return [SegmentIntersector$1];\n    }\n\n  }\n\n  class FastNodingValidator {\n    constructor() {\n      FastNodingValidator.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._li = new RobustLineIntersector();\n      this._segStrings = null;\n      this._findAllIntersections = false;\n      this._segInt = null;\n      this._isValid = true;\n      const segStrings = arguments[0];\n      this._segStrings = segStrings;\n    }\n\n    static computeIntersections(segStrings) {\n      const nv = new FastNodingValidator(segStrings);\n      nv.setFindAllIntersections(true);\n      nv.isValid();\n      return nv.getIntersections();\n    }\n\n    execute() {\n      if (this._segInt !== null) return null;\n      this.checkInteriorIntersections();\n    }\n\n    getIntersections() {\n      return this._segInt.getIntersections();\n    }\n\n    isValid() {\n      this.execute();\n      return this._isValid;\n    }\n\n    setFindAllIntersections(findAllIntersections) {\n      this._findAllIntersections = findAllIntersections;\n    }\n\n    checkInteriorIntersections() {\n      this._isValid = true;\n      this._segInt = new NodingIntersectionFinder(this._li);\n\n      this._segInt.setFindAllIntersections(this._findAllIntersections);\n\n      const noder = new MCIndexNoder();\n      noder.setSegmentIntersector(this._segInt);\n      noder.computeNodes(this._segStrings);\n\n      if (this._segInt.hasIntersection()) {\n        this._isValid = false;\n        return null;\n      }\n    }\n\n    checkValid() {\n      this.execute();\n      if (!this._isValid) throw new TopologyException(this.getErrorMessage(), this._segInt.getIntersection());\n    }\n\n    getErrorMessage() {\n      if (this._isValid) return 'no intersections found';\n\n      const intSegs = this._segInt.getIntersectionSegments();\n\n      return 'found non-noded intersection between ' + WKTWriter.toLineString(intSegs[0], intSegs[1]) + ' and ' + WKTWriter.toLineString(intSegs[2], intSegs[3]);\n    }\n\n  }\n\n  class EdgeNodingValidator {\n    constructor() {\n      EdgeNodingValidator.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._nv = null;\n      const edges = arguments[0];\n      this._nv = new FastNodingValidator(EdgeNodingValidator.toSegmentStrings(edges));\n    }\n\n    static toSegmentStrings(edges) {\n      const segStrings = new ArrayList();\n\n      for (let i = edges.iterator(); i.hasNext();) {\n        const e = i.next();\n        segStrings.add(new BasicSegmentString(e.getCoordinates(), e));\n      }\n\n      return segStrings;\n    }\n\n    static checkValid(edges) {\n      const validator = new EdgeNodingValidator(edges);\n      validator.checkValid();\n    }\n\n    checkValid() {\n      this._nv.checkValid();\n    }\n\n  }\n\n  class LineBuilder {\n    constructor() {\n      LineBuilder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._op = null;\n      this._geometryFactory = null;\n      this._ptLocator = null;\n      this._lineEdgesList = new ArrayList();\n      this._resultLineList = new ArrayList();\n      const op = arguments[0],\n            geometryFactory = arguments[1],\n            ptLocator = arguments[2];\n      this._op = op;\n      this._geometryFactory = geometryFactory;\n      this._ptLocator = ptLocator;\n    }\n\n    collectLines(opCode) {\n      for (let it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {\n        const de = it.next();\n        this.collectLineEdge(de, opCode, this._lineEdgesList);\n        this.collectBoundaryTouchEdge(de, opCode, this._lineEdgesList);\n      }\n    }\n\n    labelIsolatedLine(e, targetIndex) {\n      const loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));\n\n      e.getLabel().setLocation(targetIndex, loc);\n    }\n\n    build(opCode) {\n      this.findCoveredLineEdges();\n      this.collectLines(opCode);\n      this.buildLines(opCode);\n      return this._resultLineList;\n    }\n\n    collectLineEdge(de, opCode, edges) {\n      const label = de.getLabel();\n      const e = de.getEdge();\n      if (de.isLineEdge()) if (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e.isCovered()) {\n        edges.add(e);\n        de.setVisitedEdge(true);\n      }\n    }\n\n    findCoveredLineEdges() {\n      for (let nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {\n        const node = nodeit.next();\n        node.getEdges().findCoveredLineEdges();\n      }\n\n      for (let it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {\n        const de = it.next();\n        const e = de.getEdge();\n\n        if (de.isLineEdge() && !e.isCoveredSet()) {\n          const isCovered = this._op.isCoveredByA(de.getCoordinate());\n\n          e.setCovered(isCovered);\n        }\n      }\n    }\n\n    labelIsolatedLines(edgesList) {\n      for (let it = edgesList.iterator(); it.hasNext();) {\n        const e = it.next();\n        const label = e.getLabel();\n        if (e.isIsolated()) if (label.isNull(0)) this.labelIsolatedLine(e, 0);else this.labelIsolatedLine(e, 1);\n      }\n    }\n\n    buildLines(opCode) {\n      for (let it = this._lineEdgesList.iterator(); it.hasNext();) {\n        const e = it.next();\n\n        const line = this._geometryFactory.createLineString(e.getCoordinates());\n\n        this._resultLineList.add(line);\n\n        e.setInResult(true);\n      }\n    }\n\n    collectBoundaryTouchEdge(de, opCode, edges) {\n      const label = de.getLabel();\n      if (de.isLineEdge()) return null;\n      if (de.isVisited()) return null;\n      if (de.isInteriorAreaEdge()) return null;\n      if (de.getEdge().isInResult()) return null;\n      Assert.isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());\n\n      if (OverlayOp.isResultOfOp(label, opCode) && opCode === OverlayOp.INTERSECTION) {\n        edges.add(de.getEdge());\n        de.setVisitedEdge(true);\n      }\n    }\n\n  }\n\n  class PointBuilder {\n    constructor() {\n      PointBuilder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._op = null;\n      this._geometryFactory = null;\n      this._resultPointList = new ArrayList();\n      const op = arguments[0],\n            geometryFactory = arguments[1];\n      this._op = op;\n      this._geometryFactory = geometryFactory;\n    }\n\n    filterCoveredNodeToPoint(n) {\n      const coord = n.getCoordinate();\n\n      if (!this._op.isCoveredByLA(coord)) {\n        const pt = this._geometryFactory.createPoint(coord);\n\n        this._resultPointList.add(pt);\n      }\n    }\n\n    extractNonCoveredResultNodes(opCode) {\n      for (let nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {\n        const n = nodeit.next();\n        if (n.isInResult()) continue;\n        if (n.isIncidentEdgeInResult()) continue;\n\n        if (n.getEdges().getDegree() === 0 || opCode === OverlayOp.INTERSECTION) {\n          const label = n.getLabel();\n          if (OverlayOp.isResultOfOp(label, opCode)) this.filterCoveredNodeToPoint(n);\n        }\n      }\n    }\n\n    build(opCode) {\n      this.extractNonCoveredResultNodes(opCode);\n      return this._resultPointList;\n    }\n\n  }\n\n  class CommonBits {\n    constructor() {\n      this._isFirst = true;\n      this._commonMantissaBitsCount = 53;\n      this._commonBits = new Long();\n      this._commonSignExp = null;\n    }\n\n    getCommon() {\n      return Double.longBitsToDouble(this._commonBits);\n    }\n\n    add(num) {\n      const numBits = Double.doubleToLongBits(num);\n\n      if (this._isFirst) {\n        this._commonBits = numBits;\n        this._commonSignExp = CommonBits.signExpBits(this._commonBits);\n        this._isFirst = false;\n        return null;\n      }\n\n      const numSignExp = CommonBits.signExpBits(numBits);\n\n      if (numSignExp !== this._commonSignExp) {\n        this._commonBits.high = 0 | 0;\n        this._commonBits.low = 0 | 0;\n        return null;\n      }\n\n      this._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);\n      this._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));\n    }\n\n    toString() {\n      if (arguments.length === 1) {\n        const bits = arguments[0];\n        const x = Double.longBitsToDouble(bits);\n        const numStr = Long.toBinaryString(bits);\n        const padStr = '0000000000000000000000000000000000000000000000000000000000000000' + numStr;\n        const bitStr = padStr.substring(padStr.length - 64);\n        const str = bitStr.substring(0, 1) + '  ' + bitStr.substring(1, 12) + '(exp) ' + bitStr.substring(12) + ' [ ' + x + ' ]';\n        return str;\n      }\n    }\n\n    getClass() {\n      return CommonBits;\n    }\n\n    get interfaces_() {\n      return [];\n    }\n\n    static getBit(bits, i) {\n      const mask = 1 << i % 32;\n      if (i < 32) return (bits.low & mask) !== 0 ? 1 : 0;\n      return (bits.high & mask) !== 0 ? 1 : 0;\n    }\n\n    static signExpBits(num) {\n      return num.high >>> 20;\n    }\n\n    static zeroLowerBits(bits, nBits) {\n      let prop = 'low';\n\n      if (nBits > 32) {\n        bits.low = 0 | 0;\n        nBits %= 32;\n        prop = 'high';\n      }\n\n      if (nBits > 0) {\n        const mask = nBits < 32 ? ~((1 << nBits) - 1) : 0;\n        bits[prop] &= mask;\n      }\n\n      return bits;\n    }\n\n    static numCommonMostSigMantissaBits(num1, num2) {\n      let count = 0;\n\n      for (let i = 52; i >= 0; i--) {\n        if (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) return count;\n        count++;\n      }\n\n      return 52;\n    }\n\n  }\n\n  class CommonBitsRemover {\n    constructor() {\n      CommonBitsRemover.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._commonCoord = null;\n      this._ccFilter = new CommonCoordinateFilter();\n    }\n\n    addCommonBits(geom) {\n      const trans = new Translater(this._commonCoord);\n      geom.apply(trans);\n      geom.geometryChanged();\n    }\n\n    removeCommonBits(geom) {\n      if (this._commonCoord.x === 0.0 && this._commonCoord.y === 0.0) return geom;\n      const invCoord = new Coordinate(this._commonCoord);\n      invCoord.x = -invCoord.x;\n      invCoord.y = -invCoord.y;\n      const trans = new Translater(invCoord);\n      geom.apply(trans);\n      geom.geometryChanged();\n      return geom;\n    }\n\n    getCommonCoordinate() {\n      return this._commonCoord;\n    }\n\n    add(geom) {\n      geom.apply(this._ccFilter);\n      this._commonCoord = this._ccFilter.getCommonCoordinate();\n    }\n\n  }\n\n  class CommonCoordinateFilter {\n    constructor() {\n      CommonCoordinateFilter.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._commonBitsX = new CommonBits();\n      this._commonBitsY = new CommonBits();\n    }\n\n    filter(coord) {\n      this._commonBitsX.add(coord.x);\n\n      this._commonBitsY.add(coord.y);\n    }\n\n    getCommonCoordinate() {\n      return new Coordinate(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());\n    }\n\n    get interfaces_() {\n      return [CoordinateFilter];\n    }\n\n  }\n\n  class Translater {\n    constructor() {\n      Translater.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.trans = null;\n      const trans = arguments[0];\n      this.trans = trans;\n    }\n\n    filter(seq, i) {\n      const xp = seq.getOrdinate(i, 0) + this.trans.x;\n      const yp = seq.getOrdinate(i, 1) + this.trans.y;\n      seq.setOrdinate(i, 0, xp);\n      seq.setOrdinate(i, 1, yp);\n    }\n\n    isDone() {\n      return false;\n    }\n\n    isGeometryChanged() {\n      return true;\n    }\n\n    get interfaces_() {\n      return [CoordinateSequenceFilter];\n    }\n\n  }\n\n  CommonBitsRemover.CommonCoordinateFilter = CommonCoordinateFilter;\n  CommonBitsRemover.Translater = Translater;\n\n  class SnapOverlayOp {\n    constructor() {\n      SnapOverlayOp.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._geom = new Array(2).fill(null);\n      this._snapTolerance = null;\n      this._cbr = null;\n      const g1 = arguments[0],\n            g2 = arguments[1];\n      this._geom[0] = g1;\n      this._geom[1] = g2;\n      this.computeSnapTolerance();\n    }\n\n    static overlayOp(g0, g1, opCode) {\n      const op = new SnapOverlayOp(g0, g1);\n      return op.getResultGeometry(opCode);\n    }\n\n    static union(g0, g1) {\n      return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);\n    }\n\n    static intersection(g0, g1) {\n      return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);\n    }\n\n    static symDifference(g0, g1) {\n      return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);\n    }\n\n    static difference(g0, g1) {\n      return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);\n    }\n\n    selfSnap(geom) {\n      const snapper0 = new GeometrySnapper(geom);\n      const snapGeom = snapper0.snapTo(geom, this._snapTolerance);\n      return snapGeom;\n    }\n\n    removeCommonBits(geom) {\n      this._cbr = new CommonBitsRemover();\n\n      this._cbr.add(geom[0]);\n\n      this._cbr.add(geom[1]);\n\n      const remGeom = new Array(2).fill(null);\n      remGeom[0] = this._cbr.removeCommonBits(geom[0].copy());\n      remGeom[1] = this._cbr.removeCommonBits(geom[1].copy());\n      return remGeom;\n    }\n\n    prepareResult(geom) {\n      this._cbr.addCommonBits(geom);\n\n      return geom;\n    }\n\n    getResultGeometry(opCode) {\n      const prepGeom = this.snap(this._geom);\n      const result = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);\n      return this.prepareResult(result);\n    }\n\n    checkValid(g) {\n      if (!g.isValid()) System.out.println('Snapped geometry is invalid');\n    }\n\n    computeSnapTolerance() {\n      this._snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);\n    }\n\n    snap(geom) {\n      const remGeom = this.removeCommonBits(geom);\n      const snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1], this._snapTolerance);\n      return snapGeom;\n    }\n\n  }\n\n  class SnapIfNeededOverlayOp {\n    constructor() {\n      SnapIfNeededOverlayOp.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._geom = new Array(2).fill(null);\n      const g1 = arguments[0],\n            g2 = arguments[1];\n      this._geom[0] = g1;\n      this._geom[1] = g2;\n    }\n\n    static overlayOp(g0, g1, opCode) {\n      const op = new SnapIfNeededOverlayOp(g0, g1);\n      return op.getResultGeometry(opCode);\n    }\n\n    static union(g0, g1) {\n      return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.UNION);\n    }\n\n    static intersection(g0, g1) {\n      return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION);\n    }\n\n    static symDifference(g0, g1) {\n      return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE);\n    }\n\n    static difference(g0, g1) {\n      return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE);\n    }\n\n    getResultGeometry(opCode) {\n      let result = null;\n      let isSuccess = false;\n      let savedException = null;\n\n      try {\n        result = OverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n        const isValid = true;\n        if (isValid) isSuccess = true;\n      } catch (ex) {\n        if (ex instanceof RuntimeException) savedException = ex;else throw ex;\n      } finally {}\n\n      if (!isSuccess) try {\n        result = SnapOverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n      } catch (ex) {\n        if (ex instanceof RuntimeException) throw savedException;else throw ex;\n      } finally {}\n      return result;\n    }\n\n  }\n\n  class GeometryGraphOperation {\n    constructor() {\n      GeometryGraphOperation.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._li = new RobustLineIntersector();\n      this._resultPrecisionModel = null;\n      this._arg = null;\n\n      if (arguments.length === 1) {\n        const g0 = arguments[0];\n        this.setComputationPrecision(g0.getPrecisionModel());\n        this._arg = new Array(1).fill(null);\n        this._arg[0] = new GeometryGraph(0, g0);\n      } else if (arguments.length === 2) {\n        const g0 = arguments[0],\n              g1 = arguments[1];\n        GeometryGraphOperation.constructor_.call(this, g0, g1, BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE);\n      } else if (arguments.length === 3) {\n        const g0 = arguments[0],\n              g1 = arguments[1],\n              boundaryNodeRule = arguments[2];\n        if (g0.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) this.setComputationPrecision(g0.getPrecisionModel());else this.setComputationPrecision(g1.getPrecisionModel());\n        this._arg = new Array(2).fill(null);\n        this._arg[0] = new GeometryGraph(0, g0, boundaryNodeRule);\n        this._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);\n      }\n    }\n\n    getArgGeometry(i) {\n      return this._arg[i].getGeometry();\n    }\n\n    setComputationPrecision(pm) {\n      this._resultPrecisionModel = pm;\n\n      this._li.setPrecisionModel(this._resultPrecisionModel);\n    }\n\n  }\n\n  class OverlayOp extends GeometryGraphOperation {\n    constructor() {\n      super();\n      OverlayOp.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._ptLocator = new PointLocator();\n      this._geomFact = null;\n      this._resultGeom = null;\n      this._graph = null;\n      this._edgeList = new EdgeList();\n      this._resultPolyList = new ArrayList();\n      this._resultLineList = new ArrayList();\n      this._resultPointList = new ArrayList();\n      const g0 = arguments[0],\n            g1 = arguments[1];\n      GeometryGraphOperation.constructor_.call(this, g0, g1);\n      this._graph = new PlanarGraph(new OverlayNodeFactory());\n      this._geomFact = g0.getFactory();\n    }\n\n    static overlayOp(geom0, geom1, opCode) {\n      const gov = new OverlayOp(geom0, geom1);\n      const geomOv = gov.getResultGeometry(opCode);\n      return geomOv;\n    }\n\n    static union(geom, other) {\n      if (geom.isEmpty() || other.isEmpty()) {\n        if (geom.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.UNION, geom, other, geom.getFactory());\n        if (geom.isEmpty()) return other.copy();\n        if (other.isEmpty()) return geom.copy();\n      }\n\n      if (geom.isGeometryCollection() || other.isGeometryCollection()) throw new IllegalArgumentException('This method does not support GeometryCollection arguments');\n      return SnapIfNeededOverlayOp.overlayOp(geom, other, OverlayOp.UNION);\n    }\n\n    static intersection(geom, other) {\n      if (geom.isEmpty() || other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, geom, other, geom.getFactory());\n\n      if (geom.isGeometryCollection()) {\n        const g2 = other;\n        return GeometryCollectionMapper.map(geom, new class {\n          get interfaces_() {\n            return [MapOp];\n          }\n\n          map(g) {\n            return OverlayOp.intersection(g, g2);\n          }\n\n        }());\n      }\n\n      return SnapIfNeededOverlayOp.overlayOp(geom, other, OverlayOp.INTERSECTION);\n    }\n\n    static symDifference(geom, other) {\n      if (geom.isEmpty() || other.isEmpty()) {\n        if (geom.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, geom, other, geom.getFactory());\n        if (geom.isEmpty()) return other.copy();\n        if (other.isEmpty()) return geom.copy();\n      }\n\n      if (geom.isGeometryCollection() || other.isGeometryCollection()) throw new IllegalArgumentException('This method does not support GeometryCollection arguments');\n      return SnapIfNeededOverlayOp.overlayOp(geom, other, OverlayOp.SYMDIFFERENCE);\n    }\n\n    static resultDimension(opCode, g0, g1) {\n      const dim0 = g0.getDimension();\n      const dim1 = g1.getDimension();\n      let resultDimension = -1;\n\n      switch (opCode) {\n        case OverlayOp.INTERSECTION:\n          resultDimension = Math.min(dim0, dim1);\n          break;\n\n        case OverlayOp.UNION:\n          resultDimension = Math.max(dim0, dim1);\n          break;\n\n        case OverlayOp.DIFFERENCE:\n          resultDimension = dim0;\n          break;\n\n        case OverlayOp.SYMDIFFERENCE:\n          resultDimension = Math.max(dim0, dim1);\n          break;\n      }\n\n      return resultDimension;\n    }\n\n    static createEmptyResult(overlayOpCode, a, b, geomFact) {\n      let result = null;\n      const resultDim = OverlayOp.resultDimension(overlayOpCode, a, b);\n      return result = geomFact.createEmpty(resultDim);\n    }\n\n    static difference(geom, other) {\n      if (geom.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, geom, other, geom.getFactory());\n      if (other.isEmpty()) return geom.copy();\n      if (geom.isGeometryCollection() || other.isGeometryCollection()) throw new IllegalArgumentException('This method does not support GeometryCollection arguments');\n      return SnapIfNeededOverlayOp.overlayOp(geom, other, OverlayOp.DIFFERENCE);\n    }\n\n    static isResultOfOp() {\n      if (arguments.length === 2) {\n        const label = arguments[0],\n              opCode = arguments[1];\n        const loc0 = label.getLocation(0);\n        const loc1 = label.getLocation(1);\n        return OverlayOp.isResultOfOp(loc0, loc1, opCode);\n      } else if (arguments.length === 3) {\n        let loc0 = arguments[0],\n            loc1 = arguments[1],\n            overlayOpCode = arguments[2];\n        if (loc0 === Location.BOUNDARY) loc0 = Location.INTERIOR;\n        if (loc1 === Location.BOUNDARY) loc1 = Location.INTERIOR;\n\n        switch (overlayOpCode) {\n          case OverlayOp.INTERSECTION:\n            return loc0 === Location.INTERIOR && loc1 === Location.INTERIOR;\n\n          case OverlayOp.UNION:\n            return loc0 === Location.INTERIOR || loc1 === Location.INTERIOR;\n\n          case OverlayOp.DIFFERENCE:\n            return loc0 === Location.INTERIOR && loc1 !== Location.INTERIOR;\n\n          case OverlayOp.SYMDIFFERENCE:\n            return loc0 === Location.INTERIOR && loc1 !== Location.INTERIOR || loc0 !== Location.INTERIOR && loc1 === Location.INTERIOR;\n        }\n\n        return false;\n      }\n    }\n\n    insertUniqueEdge(e) {\n      const existingEdge = this._edgeList.findEqualEdge(e);\n\n      if (existingEdge !== null) {\n        const existingLabel = existingEdge.getLabel();\n        let labelToMerge = e.getLabel();\n\n        if (!existingEdge.isPointwiseEqual(e)) {\n          labelToMerge = new Label(e.getLabel());\n          labelToMerge.flip();\n        }\n\n        const depth = existingEdge.getDepth();\n        if (depth.isNull()) depth.add(existingLabel);\n        depth.add(labelToMerge);\n        existingLabel.merge(labelToMerge);\n      } else {\n        this._edgeList.add(e);\n      }\n    }\n\n    getGraph() {\n      return this._graph;\n    }\n\n    cancelDuplicateResultEdges() {\n      for (let it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {\n        const de = it.next();\n        const sym = de.getSym();\n\n        if (de.isInResult() && sym.isInResult()) {\n          de.setInResult(false);\n          sym.setInResult(false);\n        }\n      }\n    }\n\n    isCoveredByLA(coord) {\n      if (this.isCovered(coord, this._resultLineList)) return true;\n      if (this.isCovered(coord, this._resultPolyList)) return true;\n      return false;\n    }\n\n    computeGeometry(resultPointList, resultLineList, resultPolyList, opcode) {\n      const geomList = new ArrayList();\n      geomList.addAll(resultPointList);\n      geomList.addAll(resultLineList);\n      geomList.addAll(resultPolyList);\n      if (geomList.isEmpty()) return OverlayOp.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact);\n      return this._geomFact.buildGeometry(geomList);\n    }\n\n    mergeSymLabels() {\n      for (let nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n        const node = nodeit.next();\n        node.getEdges().mergeSymLabels();\n      }\n    }\n\n    isCovered(coord, geomList) {\n      for (let it = geomList.iterator(); it.hasNext();) {\n        const geom = it.next();\n\n        const loc = this._ptLocator.locate(coord, geom);\n\n        if (loc !== Location.EXTERIOR) return true;\n      }\n\n      return false;\n    }\n\n    replaceCollapsedEdges() {\n      const newEdges = new ArrayList();\n\n      for (let it = this._edgeList.iterator(); it.hasNext();) {\n        const e = it.next();\n\n        if (e.isCollapsed()) {\n          it.remove();\n          newEdges.add(e.getCollapsedEdge());\n        }\n      }\n\n      this._edgeList.addAll(newEdges);\n    }\n\n    updateNodeLabelling() {\n      for (let nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n        const node = nodeit.next();\n        const lbl = node.getEdges().getLabel();\n        node.getLabel().merge(lbl);\n      }\n    }\n\n    getResultGeometry(overlayOpCode) {\n      this.computeOverlay(overlayOpCode);\n      return this._resultGeom;\n    }\n\n    insertUniqueEdges(edges) {\n      for (let i = edges.iterator(); i.hasNext();) {\n        const e = i.next();\n        this.insertUniqueEdge(e);\n      }\n    }\n\n    computeOverlay(opCode) {\n      this.copyPoints(0);\n      this.copyPoints(1);\n\n      this._arg[0].computeSelfNodes(this._li, false);\n\n      this._arg[1].computeSelfNodes(this._li, false);\n\n      this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);\n\n      const baseSplitEdges = new ArrayList();\n\n      this._arg[0].computeSplitEdges(baseSplitEdges);\n\n      this._arg[1].computeSplitEdges(baseSplitEdges);\n      this.insertUniqueEdges(baseSplitEdges);\n      this.computeLabelsFromDepths();\n      this.replaceCollapsedEdges();\n      EdgeNodingValidator.checkValid(this._edgeList.getEdges());\n\n      this._graph.addEdges(this._edgeList.getEdges());\n\n      this.computeLabelling();\n      this.labelIncompleteNodes();\n      this.findResultAreaEdges(opCode);\n      this.cancelDuplicateResultEdges();\n      const polyBuilder = new PolygonBuilder(this._geomFact);\n      polyBuilder.add(this._graph);\n      this._resultPolyList = polyBuilder.getPolygons();\n      const lineBuilder = new LineBuilder(this, this._geomFact, this._ptLocator);\n      this._resultLineList = lineBuilder.build(opCode);\n      const pointBuilder = new PointBuilder(this, this._geomFact, this._ptLocator);\n      this._resultPointList = pointBuilder.build(opCode);\n      this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);\n    }\n\n    labelIncompleteNode(n, targetIndex) {\n      const loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());\n\n      n.getLabel().setLocation(targetIndex, loc);\n    }\n\n    copyPoints(argIndex) {\n      for (let i = this._arg[argIndex].getNodeIterator(); i.hasNext();) {\n        const graphNode = i.next();\n\n        const newNode = this._graph.addNode(graphNode.getCoordinate());\n\n        newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n      }\n    }\n\n    findResultAreaEdges(opCode) {\n      for (let it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {\n        const de = it.next();\n        const label = de.getLabel();\n        if (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) de.setInResult(true);\n      }\n    }\n\n    computeLabelsFromDepths() {\n      for (let it = this._edgeList.iterator(); it.hasNext();) {\n        const e = it.next();\n        const lbl = e.getLabel();\n        const depth = e.getDepth();\n\n        if (!depth.isNull()) {\n          depth.normalize();\n\n          for (let i = 0; i < 2; i++) if (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) if (depth.getDelta(i) === 0) {\n            lbl.toLine(i);\n          } else {\n            Assert.isTrue(!depth.isNull(i, Position.LEFT), 'depth of LEFT side has not been initialized');\n            lbl.setLocation(i, Position.LEFT, depth.getLocation(i, Position.LEFT));\n            Assert.isTrue(!depth.isNull(i, Position.RIGHT), 'depth of RIGHT side has not been initialized');\n            lbl.setLocation(i, Position.RIGHT, depth.getLocation(i, Position.RIGHT));\n          }\n        }\n      }\n    }\n\n    computeLabelling() {\n      for (let nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n        const node = nodeit.next();\n        node.getEdges().computeLabelling(this._arg);\n      }\n\n      this.mergeSymLabels();\n      this.updateNodeLabelling();\n    }\n\n    labelIncompleteNodes() {\n      for (let ni = this._graph.getNodes().iterator(); ni.hasNext();) {\n        const n = ni.next();\n        const label = n.getLabel();\n        if (n.isIsolated()) if (label.isNull(0)) this.labelIncompleteNode(n, 0);else this.labelIncompleteNode(n, 1);\n        n.getEdges().updateLabelling(label);\n      }\n    }\n\n    isCoveredByA(coord) {\n      if (this.isCovered(coord, this._resultPolyList)) return true;\n      return false;\n    }\n\n  }\n  OverlayOp.INTERSECTION = 1;\n  OverlayOp.UNION = 2;\n  OverlayOp.DIFFERENCE = 3;\n  OverlayOp.SYMDIFFERENCE = 4;\n\n  var overlay = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    snap: snap,\n    OverlayOp: OverlayOp\n  });\n\n  class PolygonizeDirectedEdge extends DirectedEdge$1 {\n    constructor() {\n      super();\n      PolygonizeDirectedEdge.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._edgeRing = null;\n      this._next = null;\n      this._label = -1;\n      const from = arguments[0],\n            to = arguments[1],\n            directionPt = arguments[2],\n            edgeDirection = arguments[3];\n      DirectedEdge$1.constructor_.call(this, from, to, directionPt, edgeDirection);\n    }\n\n    getNext() {\n      return this._next;\n    }\n\n    isInRing() {\n      return this._edgeRing !== null;\n    }\n\n    setRing(edgeRing) {\n      this._edgeRing = edgeRing;\n    }\n\n    setLabel(label) {\n      this._label = label;\n    }\n\n    getLabel() {\n      return this._label;\n    }\n\n    setNext(next) {\n      this._next = next;\n    }\n\n    getRing() {\n      return this._edgeRing;\n    }\n\n  }\n\n  class PolygonizeEdge extends Edge$1 {\n    constructor() {\n      super();\n      PolygonizeEdge.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._line = null;\n      const line = arguments[0];\n      this._line = line;\n    }\n\n    getLine() {\n      return this._line;\n    }\n\n  }\n\n  class ConnectedInteriorTester {\n    constructor() {\n      ConnectedInteriorTester.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._geometryFactory = new GeometryFactory();\n      this._geomGraph = null;\n      this._disconnectedRingcoord = null;\n      const geomGraph = arguments[0];\n      this._geomGraph = geomGraph;\n    }\n\n    static findDifferentPoint(coord, pt) {\n      for (let i = 0; i < coord.length; i++) if (!coord[i].equals(pt)) return coord[i];\n\n      return null;\n    }\n\n    visitInteriorRing(ring, graph) {\n      if (ring.isEmpty()) return null;\n      const pts = ring.getCoordinates();\n      const pt0 = pts[0];\n      const pt1 = ConnectedInteriorTester.findDifferentPoint(pts, pt0);\n      const e = graph.findEdgeInSameDirection(pt0, pt1);\n      const de = graph.findEdgeEnd(e);\n      let intDe = null;\n      if (de.getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) intDe = de;else if (de.getSym().getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) intDe = de.getSym();\n      Assert.isTrue(intDe !== null, 'unable to find dirEdge with Interior on RHS');\n      this.visitLinkedDirectedEdges(intDe);\n    }\n\n    visitShellInteriors(g, graph) {\n      if (g instanceof Polygon) {\n        const p = g;\n        this.visitInteriorRing(p.getExteriorRing(), graph);\n      }\n\n      if (g instanceof MultiPolygon) {\n        const mp = g;\n\n        for (let i = 0; i < mp.getNumGeometries(); i++) {\n          const p = mp.getGeometryN(i);\n          this.visitInteriorRing(p.getExteriorRing(), graph);\n        }\n      }\n    }\n\n    getCoordinate() {\n      return this._disconnectedRingcoord;\n    }\n\n    setInteriorEdgesInResult(graph) {\n      for (let it = graph.getEdgeEnds().iterator(); it.hasNext();) {\n        const de = it.next();\n        if (de.getLabel().getLocation(0, Position.RIGHT) === Location.INTERIOR) de.setInResult(true);\n      }\n    }\n\n    visitLinkedDirectedEdges(start) {\n      const startDe = start;\n      let de = start;\n\n      do {\n        Assert.isTrue(de !== null, 'found null Directed Edge');\n        de.setVisited(true);\n        de = de.getNext();\n      } while (de !== startDe);\n    }\n\n    buildEdgeRings(dirEdges) {\n      const edgeRings = new ArrayList();\n\n      for (let it = dirEdges.iterator(); it.hasNext();) {\n        const de = it.next();\n\n        if (de.isInResult() && de.getEdgeRing() === null) {\n          const er = new MaximalEdgeRing(de, this._geometryFactory);\n          er.linkDirectedEdgesForMinimalEdgeRings();\n          const minEdgeRings = er.buildMinimalRings();\n          edgeRings.addAll(minEdgeRings);\n        }\n      }\n\n      return edgeRings;\n    }\n\n    hasUnvisitedShellEdge(edgeRings) {\n      for (let i = 0; i < edgeRings.size(); i++) {\n        const er = edgeRings.get(i);\n        if (er.isHole()) continue;\n        const edges = er.getEdges();\n        let de = edges.get(0);\n        if (de.getLabel().getLocation(0, Position.RIGHT) !== Location.INTERIOR) continue;\n\n        for (let j = 0; j < edges.size(); j++) {\n          de = edges.get(j);\n\n          if (!de.isVisited()) {\n            this._disconnectedRingcoord = de.getCoordinate();\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    isInteriorsConnected() {\n      const splitEdges = new ArrayList();\n\n      this._geomGraph.computeSplitEdges(splitEdges);\n\n      const graph = new PlanarGraph(new OverlayNodeFactory());\n      graph.addEdges(splitEdges);\n      this.setInteriorEdgesInResult(graph);\n      graph.linkResultDirectedEdges();\n      const edgeRings = this.buildEdgeRings(graph.getEdgeEnds());\n      this.visitShellInteriors(this._geomGraph.getGeometry(), graph);\n      return !this.hasUnvisitedShellEdge(edgeRings);\n    }\n\n  }\n\n  class EdgeEndBuilder {\n    createEdgeEndForNext(edge, l, eiCurr, eiNext) {\n      const iNext = eiCurr.segmentIndex + 1;\n      if (iNext >= edge.getNumPoints() && eiNext === null) return null;\n      let pNext = edge.getCoordinate(iNext);\n      if (eiNext !== null && eiNext.segmentIndex === eiCurr.segmentIndex) pNext = eiNext.coord;\n      const e = new EdgeEnd(edge, eiCurr.coord, pNext, new Label(edge.getLabel()));\n      l.add(e);\n    }\n\n    createEdgeEndForPrev(edge, l, eiCurr, eiPrev) {\n      let iPrev = eiCurr.segmentIndex;\n\n      if (eiCurr.dist === 0.0) {\n        if (iPrev === 0) return null;\n        iPrev--;\n      }\n\n      let pPrev = edge.getCoordinate(iPrev);\n      if (eiPrev !== null && eiPrev.segmentIndex >= iPrev) pPrev = eiPrev.coord;\n      const label = new Label(edge.getLabel());\n      label.flip();\n      const e = new EdgeEnd(edge, eiCurr.coord, pPrev, label);\n      l.add(e);\n    }\n\n    computeEdgeEnds() {\n      if (arguments.length === 1) {\n        const edges = arguments[0];\n        const l = new ArrayList();\n\n        for (let i = edges; i.hasNext();) {\n          const e = i.next();\n          this.computeEdgeEnds(e, l);\n        }\n\n        return l;\n      } else if (arguments.length === 2) {\n        const edge = arguments[0],\n              l = arguments[1];\n        const eiList = edge.getEdgeIntersectionList();\n        eiList.addEndpoints();\n        const it = eiList.iterator();\n        let eiPrev = null;\n        let eiCurr = null;\n        if (!it.hasNext()) return null;\n        let eiNext = it.next();\n\n        do {\n          eiPrev = eiCurr;\n          eiCurr = eiNext;\n          eiNext = null;\n          if (it.hasNext()) eiNext = it.next();\n\n          if (eiCurr !== null) {\n            this.createEdgeEndForPrev(edge, l, eiCurr, eiPrev);\n            this.createEdgeEndForNext(edge, l, eiCurr, eiNext);\n          }\n        } while (eiCurr !== null);\n      }\n    }\n\n  }\n\n  class EdgeEndBundle extends EdgeEnd {\n    constructor() {\n      super();\n      EdgeEndBundle.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._edgeEnds = new ArrayList();\n\n      if (arguments.length === 1) {\n        const e = arguments[0];\n        EdgeEndBundle.constructor_.call(this, null, e);\n      } else if (arguments.length === 2) {\n        const e = arguments[1];\n        EdgeEnd.constructor_.call(this, e.getEdge(), e.getCoordinate(), e.getDirectedCoordinate(), new Label(e.getLabel()));\n        this.insert(e);\n      }\n    }\n\n    insert(e) {\n      this._edgeEnds.add(e);\n    }\n\n    print(out) {\n      out.println('EdgeEndBundle--> Label: ' + this._label);\n\n      for (let it = this.iterator(); it.hasNext();) {\n        const ee = it.next();\n        ee.print(out);\n        out.println();\n      }\n    }\n\n    iterator() {\n      return this._edgeEnds.iterator();\n    }\n\n    getEdgeEnds() {\n      return this._edgeEnds;\n    }\n\n    computeLabelOn(geomIndex, boundaryNodeRule) {\n      let boundaryCount = 0;\n      let foundInterior = false;\n\n      for (let it = this.iterator(); it.hasNext();) {\n        const e = it.next();\n        const loc = e.getLabel().getLocation(geomIndex);\n        if (loc === Location.BOUNDARY) boundaryCount++;\n        if (loc === Location.INTERIOR) foundInterior = true;\n      }\n\n      let loc = Location.NONE;\n      if (foundInterior) loc = Location.INTERIOR;\n      if (boundaryCount > 0) loc = GeometryGraph.determineBoundary(boundaryNodeRule, boundaryCount);\n\n      this._label.setLocation(geomIndex, loc);\n    }\n\n    computeLabelSide(geomIndex, side) {\n      for (let it = this.iterator(); it.hasNext();) {\n        const e = it.next();\n\n        if (e.getLabel().isArea()) {\n          const loc = e.getLabel().getLocation(geomIndex, side);\n\n          if (loc === Location.INTERIOR) {\n            this._label.setLocation(geomIndex, side, Location.INTERIOR);\n\n            return null;\n          } else if (loc === Location.EXTERIOR) {\n            this._label.setLocation(geomIndex, side, Location.EXTERIOR);\n          }\n        }\n      }\n    }\n\n    getLabel() {\n      return this._label;\n    }\n\n    computeLabelSides(geomIndex) {\n      this.computeLabelSide(geomIndex, Position.LEFT);\n      this.computeLabelSide(geomIndex, Position.RIGHT);\n    }\n\n    updateIM(im) {\n      Edge.updateIM(this._label, im);\n    }\n\n    computeLabel(boundaryNodeRule) {\n      let isArea = false;\n\n      for (let it = this.iterator(); it.hasNext();) {\n        const e = it.next();\n        if (e.getLabel().isArea()) isArea = true;\n      }\n\n      if (isArea) this._label = new Label(Location.NONE, Location.NONE, Location.NONE);else this._label = new Label(Location.NONE);\n\n      for (let i = 0; i < 2; i++) {\n        this.computeLabelOn(i, boundaryNodeRule);\n        if (isArea) this.computeLabelSides(i);\n      }\n    }\n\n  }\n\n  class EdgeEndBundleStar extends EdgeEndStar {\n    constructor() {\n      super();\n    }\n\n    updateIM(im) {\n      for (let it = this.iterator(); it.hasNext();) {\n        const esb = it.next();\n        esb.updateIM(im);\n      }\n    }\n\n    insert(e) {\n      let eb = this._edgeMap.get(e);\n\n      if (eb === null) {\n        eb = new EdgeEndBundle(e);\n        this.insertEdgeEnd(e, eb);\n      } else {\n        eb.insert(e);\n      }\n    }\n\n  }\n\n  class RelateNode extends Node {\n    constructor() {\n      super();\n      RelateNode.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      const coord = arguments[0],\n            edges = arguments[1];\n      Node.constructor_.call(this, coord, edges);\n    }\n\n    updateIMFromEdges(im) {\n      this._edges.updateIM(im);\n    }\n\n    computeIM(im) {\n      im.setAtLeastIfValid(this._label.getLocation(0), this._label.getLocation(1), 0);\n    }\n\n  }\n\n  class RelateNodeFactory extends NodeFactory {\n    constructor() {\n      super();\n    }\n\n    createNode(coord) {\n      return new RelateNode(coord, new EdgeEndBundleStar());\n    }\n\n  }\n\n  class RelateNodeGraph {\n    constructor() {\n      RelateNodeGraph.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._nodes = new NodeMap(new RelateNodeFactory());\n    }\n\n    insertEdgeEnds(ee) {\n      for (let i = ee.iterator(); i.hasNext();) {\n        const e = i.next();\n\n        this._nodes.add(e);\n      }\n    }\n\n    getNodeIterator() {\n      return this._nodes.iterator();\n    }\n\n    copyNodesAndLabels(geomGraph, argIndex) {\n      for (let nodeIt = geomGraph.getNodeIterator(); nodeIt.hasNext();) {\n        const graphNode = nodeIt.next();\n\n        const newNode = this._nodes.addNode(graphNode.getCoordinate());\n\n        newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n      }\n    }\n\n    build(geomGraph) {\n      this.computeIntersectionNodes(geomGraph, 0);\n      this.copyNodesAndLabels(geomGraph, 0);\n      const eeBuilder = new EdgeEndBuilder();\n      const eeList = eeBuilder.computeEdgeEnds(geomGraph.getEdgeIterator());\n      this.insertEdgeEnds(eeList);\n    }\n\n    computeIntersectionNodes(geomGraph, argIndex) {\n      for (let edgeIt = geomGraph.getEdgeIterator(); edgeIt.hasNext();) {\n        const e = edgeIt.next();\n        const eLoc = e.getLabel().getLocation(argIndex);\n\n        for (let eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n          const ei = eiIt.next();\n\n          const n = this._nodes.addNode(ei.coord);\n\n          if (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex);else if (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, Location.INTERIOR);\n        }\n      }\n    }\n\n  }\n\n  class ConsistentAreaTester {\n    constructor() {\n      ConsistentAreaTester.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._li = new RobustLineIntersector();\n      this._geomGraph = null;\n      this._nodeGraph = new RelateNodeGraph();\n      this._invalidPoint = null;\n      const geomGraph = arguments[0];\n      this._geomGraph = geomGraph;\n    }\n\n    isNodeEdgeAreaLabelsConsistent() {\n      for (let nodeIt = this._nodeGraph.getNodeIterator(); nodeIt.hasNext();) {\n        const node = nodeIt.next();\n\n        if (!node.getEdges().isAreaLabelsConsistent(this._geomGraph)) {\n          this._invalidPoint = node.getCoordinate().copy();\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    getInvalidPoint() {\n      return this._invalidPoint;\n    }\n\n    hasDuplicateRings() {\n      for (let nodeIt = this._nodeGraph.getNodeIterator(); nodeIt.hasNext();) {\n        const node = nodeIt.next();\n\n        for (let i = node.getEdges().iterator(); i.hasNext();) {\n          const eeb = i.next();\n\n          if (eeb.getEdgeEnds().size() > 1) {\n            this._invalidPoint = eeb.getEdge().getCoordinate(0);\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    isNodeConsistentArea() {\n      const intersector = this._geomGraph.computeSelfNodes(this._li, true, true);\n\n      if (intersector.hasProperIntersection()) {\n        this._invalidPoint = intersector.getProperIntersectionPoint();\n        return false;\n      }\n\n      this._nodeGraph.build(this._geomGraph);\n\n      return this.isNodeEdgeAreaLabelsConsistent();\n    }\n\n  }\n\n  class IndexedNestedRingTester {\n    constructor() {\n      IndexedNestedRingTester.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._graph = null;\n      this._rings = new ArrayList();\n      this._totalEnv = new Envelope();\n      this._index = null;\n      this._nestedPt = null;\n      const graph = arguments[0];\n      this._graph = graph;\n    }\n\n    buildIndex() {\n      this._index = new STRtree();\n\n      for (let i = 0; i < this._rings.size(); i++) {\n        const ring = this._rings.get(i);\n\n        const env = ring.getEnvelopeInternal();\n\n        this._index.insert(env, ring);\n      }\n    }\n\n    getNestedPoint() {\n      return this._nestedPt;\n    }\n\n    isNonNested() {\n      this.buildIndex();\n\n      for (let i = 0; i < this._rings.size(); i++) {\n        const innerRing = this._rings.get(i);\n\n        const innerRingPts = innerRing.getCoordinates();\n\n        const results = this._index.query(innerRing.getEnvelopeInternal());\n\n        for (let j = 0; j < results.size(); j++) {\n          const searchRing = results.get(j);\n          const searchRingPts = searchRing.getCoordinates();\n          if (innerRing === searchRing) continue;\n          if (!innerRing.getEnvelopeInternal().intersects(searchRing.getEnvelopeInternal())) continue;\n          const innerRingPt = IsValidOp.findPtNotNode(innerRingPts, searchRing, this._graph);\n          if (innerRingPt === null) continue;\n          const isInside = PointLocation.isInRing(innerRingPt, searchRingPts);\n\n          if (isInside) {\n            this._nestedPt = innerRingPt;\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    add(ring) {\n      this._rings.add(ring);\n\n      this._totalEnv.expandToInclude(ring.getEnvelopeInternal());\n    }\n\n  }\n\n  class TopologyValidationError {\n    constructor() {\n      TopologyValidationError.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._errorType = null;\n      this._pt = null;\n\n      if (arguments.length === 1) {\n        const errorType = arguments[0];\n        TopologyValidationError.constructor_.call(this, errorType, null);\n      } else if (arguments.length === 2) {\n        const errorType = arguments[0],\n              pt = arguments[1];\n        this._errorType = errorType;\n        if (pt !== null) this._pt = pt.copy();\n      }\n    }\n\n    getErrorType() {\n      return this._errorType;\n    }\n\n    getMessage() {\n      return TopologyValidationError.errMsg[this._errorType];\n    }\n\n    getCoordinate() {\n      return this._pt;\n    }\n\n    toString() {\n      let locStr = '';\n      if (this._pt !== null) locStr = ' at or near point ' + this._pt;\n      return this.getMessage() + locStr;\n    }\n\n  }\n  TopologyValidationError.ERROR = 0;\n  TopologyValidationError.REPEATED_POINT = 1;\n  TopologyValidationError.HOLE_OUTSIDE_SHELL = 2;\n  TopologyValidationError.NESTED_HOLES = 3;\n  TopologyValidationError.DISCONNECTED_INTERIOR = 4;\n  TopologyValidationError.SELF_INTERSECTION = 5;\n  TopologyValidationError.RING_SELF_INTERSECTION = 6;\n  TopologyValidationError.NESTED_SHELLS = 7;\n  TopologyValidationError.DUPLICATE_RINGS = 8;\n  TopologyValidationError.TOO_FEW_POINTS = 9;\n  TopologyValidationError.INVALID_COORDINATE = 10;\n  TopologyValidationError.RING_NOT_CLOSED = 11;\n  TopologyValidationError.errMsg = ['Topology Validation Error', 'Repeated Point', 'Hole lies outside shell', 'Holes are nested', 'Interior is disconnected', 'Self-intersection', 'Ring Self-intersection', 'Nested shells', 'Duplicate Rings', 'Too few distinct points in geometry component', 'Invalid Coordinate', 'Ring is not closed'];\n\n  class IsValidOp {\n    constructor() {\n      IsValidOp.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._parentGeometry = null;\n      this._isSelfTouchingRingFormingHoleValid = false;\n      this._validErr = null;\n      const parentGeometry = arguments[0];\n      this._parentGeometry = parentGeometry;\n    }\n\n    static findPtNotNode(testCoords, searchRing, graph) {\n      const searchEdge = graph.findEdge(searchRing);\n      const eiList = searchEdge.getEdgeIntersectionList();\n\n      for (let i = 0; i < testCoords.length; i++) {\n        const pt = testCoords[i];\n        if (!eiList.isIntersection(pt)) return pt;\n      }\n\n      return null;\n    }\n\n    static isValid() {\n      if (arguments[0] instanceof Geometry) {\n        const geom = arguments[0];\n        const isValidOp = new IsValidOp(geom);\n        return isValidOp.isValid();\n      } else if (arguments[0] instanceof Coordinate) {\n        const coord = arguments[0];\n        if (Double.isNaN(coord.x)) return false;\n        if (Double.isInfinite(coord.x)) return false;\n        if (Double.isNaN(coord.y)) return false;\n        if (Double.isInfinite(coord.y)) return false;\n        return true;\n      }\n    }\n\n    checkInvalidCoordinates() {\n      if (arguments[0] instanceof Array) {\n        const coords = arguments[0];\n\n        for (let i = 0; i < coords.length; i++) if (!IsValidOp.isValid(coords[i])) {\n          this._validErr = new TopologyValidationError(TopologyValidationError.INVALID_COORDINATE, coords[i]);\n          return null;\n        }\n      } else if (arguments[0] instanceof Polygon) {\n        const poly = arguments[0];\n        this.checkInvalidCoordinates(poly.getExteriorRing().getCoordinates());\n        if (this._validErr !== null) return null;\n\n        for (let i = 0; i < poly.getNumInteriorRing(); i++) {\n          this.checkInvalidCoordinates(poly.getInteriorRingN(i).getCoordinates());\n          if (this._validErr !== null) return null;\n        }\n      }\n    }\n\n    checkHolesNotNested(p, graph) {\n      if (p.getNumInteriorRing() <= 0) return null;\n      const nestedTester = new IndexedNestedRingTester(graph);\n\n      for (let i = 0; i < p.getNumInteriorRing(); i++) {\n        const innerHole = p.getInteriorRingN(i);\n        if (innerHole.isEmpty()) continue;\n        nestedTester.add(innerHole);\n      }\n\n      const isNonNested = nestedTester.isNonNested();\n      if (!isNonNested) this._validErr = new TopologyValidationError(TopologyValidationError.NESTED_HOLES, nestedTester.getNestedPoint());\n    }\n\n    checkConsistentArea(graph) {\n      const cat = new ConsistentAreaTester(graph);\n      const isValidArea = cat.isNodeConsistentArea();\n\n      if (!isValidArea) {\n        this._validErr = new TopologyValidationError(TopologyValidationError.SELF_INTERSECTION, cat.getInvalidPoint());\n        return null;\n      }\n\n      if (cat.hasDuplicateRings()) this._validErr = new TopologyValidationError(TopologyValidationError.DUPLICATE_RINGS, cat.getInvalidPoint());\n    }\n\n    isValid() {\n      this.checkValid(this._parentGeometry);\n      return this._validErr === null;\n    }\n\n    checkShellInsideHole(shell, hole, graph) {\n      const shellPts = shell.getCoordinates();\n      const holePts = hole.getCoordinates();\n      const shellPt = IsValidOp.findPtNotNode(shellPts, hole, graph);\n\n      if (shellPt !== null) {\n        const insideHole = PointLocation.isInRing(shellPt, holePts);\n        if (!insideHole) return shellPt;\n      }\n\n      const holePt = IsValidOp.findPtNotNode(holePts, shell, graph);\n\n      if (holePt !== null) {\n        const insideShell = PointLocation.isInRing(holePt, shellPts);\n        if (insideShell) return holePt;\n        return null;\n      }\n\n      Assert.shouldNeverReachHere('points in shell and hole appear to be equal');\n      return null;\n    }\n\n    checkNoSelfIntersectingRings(graph) {\n      for (let i = graph.getEdgeIterator(); i.hasNext();) {\n        const e = i.next();\n        this.checkNoSelfIntersectingRing(e.getEdgeIntersectionList());\n        if (this._validErr !== null) return null;\n      }\n    }\n\n    checkConnectedInteriors(graph) {\n      const cit = new ConnectedInteriorTester(graph);\n      if (!cit.isInteriorsConnected()) this._validErr = new TopologyValidationError(TopologyValidationError.DISCONNECTED_INTERIOR, cit.getCoordinate());\n    }\n\n    checkNoSelfIntersectingRing(eiList) {\n      const nodeSet = new TreeSet();\n      let isFirst = true;\n\n      for (let i = eiList.iterator(); i.hasNext();) {\n        const ei = i.next();\n\n        if (isFirst) {\n          isFirst = false;\n          continue;\n        }\n\n        if (nodeSet.contains(ei.coord)) {\n          this._validErr = new TopologyValidationError(TopologyValidationError.RING_SELF_INTERSECTION, ei.coord);\n          return null;\n        } else {\n          nodeSet.add(ei.coord);\n        }\n      }\n    }\n\n    checkHolesInShell(p, graph) {\n      if (p.getNumInteriorRing() <= 0) return null;\n      const shell = p.getExteriorRing();\n      const isShellEmpty = shell.isEmpty();\n      const pir = new IndexedPointInAreaLocator(shell);\n\n      for (let i = 0; i < p.getNumInteriorRing(); i++) {\n        const hole = p.getInteriorRingN(i);\n        let holePt = null;\n        if (hole.isEmpty()) continue;\n        holePt = IsValidOp.findPtNotNode(hole.getCoordinates(), shell, graph);\n        if (holePt === null) return null;\n        const outside = isShellEmpty || Location.EXTERIOR === pir.locate(holePt);\n\n        if (outside) {\n          this._validErr = new TopologyValidationError(TopologyValidationError.HOLE_OUTSIDE_SHELL, holePt);\n          return null;\n        }\n      }\n    }\n\n    checkTooFewPoints(graph) {\n      if (graph.hasTooFewPoints()) {\n        this._validErr = new TopologyValidationError(TopologyValidationError.TOO_FEW_POINTS, graph.getInvalidPoint());\n        return null;\n      }\n    }\n\n    getValidationError() {\n      this.checkValid(this._parentGeometry);\n      return this._validErr;\n    }\n\n    checkValid() {\n      if (arguments[0] instanceof Point) {\n        const g = arguments[0];\n        this.checkInvalidCoordinates(g.getCoordinates());\n      } else if (arguments[0] instanceof MultiPoint) {\n        const g = arguments[0];\n        this.checkInvalidCoordinates(g.getCoordinates());\n      } else if (arguments[0] instanceof LinearRing) {\n        const g = arguments[0];\n        this.checkInvalidCoordinates(g.getCoordinates());\n        if (this._validErr !== null) return null;\n        this.checkClosedRing(g);\n        if (this._validErr !== null) return null;\n        const graph = new GeometryGraph(0, g);\n        this.checkTooFewPoints(graph);\n        if (this._validErr !== null) return null;\n        const li = new RobustLineIntersector();\n        graph.computeSelfNodes(li, true, true);\n        this.checkNoSelfIntersectingRings(graph);\n      } else if (arguments[0] instanceof LineString) {\n        const g = arguments[0];\n        this.checkInvalidCoordinates(g.getCoordinates());\n        if (this._validErr !== null) return null;\n        const graph = new GeometryGraph(0, g);\n        this.checkTooFewPoints(graph);\n      } else if (arguments[0] instanceof Polygon) {\n        const g = arguments[0];\n        this.checkInvalidCoordinates(g);\n        if (this._validErr !== null) return null;\n        this.checkClosedRings(g);\n        if (this._validErr !== null) return null;\n        const graph = new GeometryGraph(0, g);\n        this.checkTooFewPoints(graph);\n        if (this._validErr !== null) return null;\n        this.checkConsistentArea(graph);\n        if (this._validErr !== null) return null;\n\n        if (!this._isSelfTouchingRingFormingHoleValid) {\n          this.checkNoSelfIntersectingRings(graph);\n          if (this._validErr !== null) return null;\n        }\n\n        this.checkHolesInShell(g, graph);\n        if (this._validErr !== null) return null;\n        this.checkHolesNotNested(g, graph);\n        if (this._validErr !== null) return null;\n        this.checkConnectedInteriors(graph);\n      } else if (arguments[0] instanceof MultiPolygon) {\n        const g = arguments[0];\n\n        for (let i = 0; i < g.getNumGeometries(); i++) {\n          const p = g.getGeometryN(i);\n          this.checkInvalidCoordinates(p);\n          if (this._validErr !== null) return null;\n          this.checkClosedRings(p);\n          if (this._validErr !== null) return null;\n        }\n\n        const graph = new GeometryGraph(0, g);\n        this.checkTooFewPoints(graph);\n        if (this._validErr !== null) return null;\n        this.checkConsistentArea(graph);\n        if (this._validErr !== null) return null;\n\n        if (!this._isSelfTouchingRingFormingHoleValid) {\n          this.checkNoSelfIntersectingRings(graph);\n          if (this._validErr !== null) return null;\n        }\n\n        for (let i = 0; i < g.getNumGeometries(); i++) {\n          const p = g.getGeometryN(i);\n          this.checkHolesInShell(p, graph);\n          if (this._validErr !== null) return null;\n        }\n\n        for (let i = 0; i < g.getNumGeometries(); i++) {\n          const p = g.getGeometryN(i);\n          this.checkHolesNotNested(p, graph);\n          if (this._validErr !== null) return null;\n        }\n\n        this.checkShellsNotNested(g, graph);\n        if (this._validErr !== null) return null;\n        this.checkConnectedInteriors(graph);\n      } else if (arguments[0] instanceof GeometryCollection) {\n        const gc = arguments[0];\n\n        for (let i = 0; i < gc.getNumGeometries(); i++) {\n          const g = gc.getGeometryN(i);\n          this.checkValid(g);\n          if (this._validErr !== null) return null;\n        }\n      } else if (arguments[0] instanceof Geometry) {\n        const g = arguments[0];\n        this._validErr = null;\n        if (g.isEmpty()) return null;\n        if (g instanceof Point) this.checkValid(g);else if (g instanceof MultiPoint) this.checkValid(g);else if (g instanceof LinearRing) this.checkValid(g);else if (g instanceof LineString) this.checkValid(g);else if (g instanceof Polygon) this.checkValid(g);else if (g instanceof MultiPolygon) this.checkValid(g);else if (g instanceof GeometryCollection) this.checkValid(g);else throw new UnsupportedOperationException(g.getGeometryType());\n      }\n    }\n\n    setSelfTouchingRingFormingHoleValid(isValid) {\n      this._isSelfTouchingRingFormingHoleValid = isValid;\n    }\n\n    checkShellNotNested(shell, p, graph) {\n      const shellPts = shell.getCoordinates();\n      const polyShell = p.getExteriorRing();\n      if (polyShell.isEmpty()) return null;\n      const polyPts = polyShell.getCoordinates();\n      const shellPt = IsValidOp.findPtNotNode(shellPts, polyShell, graph);\n      if (shellPt === null) return null;\n      const insidePolyShell = PointLocation.isInRing(shellPt, polyPts);\n      if (!insidePolyShell) return null;\n\n      if (p.getNumInteriorRing() <= 0) {\n        this._validErr = new TopologyValidationError(TopologyValidationError.NESTED_SHELLS, shellPt);\n        return null;\n      }\n\n      let badNestedPt = null;\n\n      for (let i = 0; i < p.getNumInteriorRing(); i++) {\n        const hole = p.getInteriorRingN(i);\n        badNestedPt = this.checkShellInsideHole(shell, hole, graph);\n        if (badNestedPt === null) return null;\n      }\n\n      this._validErr = new TopologyValidationError(TopologyValidationError.NESTED_SHELLS, badNestedPt);\n    }\n\n    checkClosedRings(poly) {\n      this.checkClosedRing(poly.getExteriorRing());\n      if (this._validErr !== null) return null;\n\n      for (let i = 0; i < poly.getNumInteriorRing(); i++) {\n        this.checkClosedRing(poly.getInteriorRingN(i));\n        if (this._validErr !== null) return null;\n      }\n    }\n\n    checkClosedRing(ring) {\n      if (ring.isEmpty()) return null;\n\n      if (!ring.isClosed()) {\n        let pt = null;\n        if (ring.getNumPoints() >= 1) pt = ring.getCoordinateN(0);\n        this._validErr = new TopologyValidationError(TopologyValidationError.RING_NOT_CLOSED, pt);\n      }\n    }\n\n    checkShellsNotNested(mp, graph) {\n      for (let i = 0; i < mp.getNumGeometries(); i++) {\n        const p = mp.getGeometryN(i);\n        const shell = p.getExteriorRing();\n\n        for (let j = 0; j < mp.getNumGeometries(); j++) {\n          if (i === j) continue;\n          const p2 = mp.getGeometryN(j);\n          this.checkShellNotNested(shell, p2, graph);\n          if (this._validErr !== null) return null;\n        }\n      }\n    }\n\n  }\n\n  class EdgeRing$1 {\n    constructor() {\n      EdgeRing$1.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._factory = null;\n      this._deList = new ArrayList();\n      this._lowestEdge = null;\n      this._ring = null;\n      this._locator = null;\n      this._ringPts = null;\n      this._holes = null;\n      this._shell = null;\n      this._isHole = null;\n      this._isProcessed = false;\n      this._isIncludedSet = false;\n      this._isIncluded = false;\n      const factory = arguments[0];\n      this._factory = factory;\n    }\n\n    static findDirEdgesInRing(startDE) {\n      let de = startDE;\n      const edges = new ArrayList();\n\n      do {\n        edges.add(de);\n        de = de.getNext();\n        Assert.isTrue(de !== null, 'found null DE in ring');\n        Assert.isTrue(de === startDE || !de.isInRing(), 'found DE already in ring');\n      } while (de !== startDE);\n\n      return edges;\n    }\n\n    static addEdge(coords, isForward, coordList) {\n      if (isForward) for (let i = 0; i < coords.length; i++) coordList.add(coords[i], false);else for (let i = coords.length - 1; i >= 0; i--) coordList.add(coords[i], false);\n    }\n\n    static findEdgeRingContaining(testEr, erList) {\n      const testRing = testEr.getRing();\n      const testEnv = testRing.getEnvelopeInternal();\n      let testPt = testRing.getCoordinateN(0);\n      let minRing = null;\n      let minRingEnv = null;\n\n      for (let it = erList.iterator(); it.hasNext();) {\n        const tryEdgeRing = it.next();\n        const tryRing = tryEdgeRing.getRing();\n        const tryShellEnv = tryRing.getEnvelopeInternal();\n        if (tryShellEnv.equals(testEnv)) continue;\n        if (!tryShellEnv.contains(testEnv)) continue;\n        testPt = CoordinateArrays.ptNotInList(testRing.getCoordinates(), tryEdgeRing.getCoordinates());\n        const isContained = tryEdgeRing.isInRing(testPt);\n        if (isContained) if (minRing === null || minRingEnv.contains(tryShellEnv)) {\n          minRing = tryEdgeRing;\n          minRingEnv = minRing.getRing().getEnvelopeInternal();\n        }\n      }\n\n      return minRing;\n    }\n\n    isIncluded() {\n      return this._isIncluded;\n    }\n\n    getCoordinates() {\n      if (this._ringPts === null) {\n        const coordList = new CoordinateList();\n\n        for (let i = this._deList.iterator(); i.hasNext();) {\n          const de = i.next();\n          const edge = de.getEdge();\n          EdgeRing$1.addEdge(edge.getLine().getCoordinates(), de.getEdgeDirection(), coordList);\n        }\n\n        this._ringPts = coordList.toCoordinateArray();\n      }\n\n      return this._ringPts;\n    }\n\n    isIncludedSet() {\n      return this._isIncludedSet;\n    }\n\n    isValid() {\n      this.getCoordinates();\n      if (this._ringPts.length <= 3) return false;\n      this.getRing();\n      return IsValidOp.isValid(this._ring);\n    }\n\n    build(startDE) {\n      let de = startDE;\n\n      do {\n        this.add(de);\n        de.setRing(this);\n        de = de.getNext();\n        Assert.isTrue(de !== null, 'found null DE in ring');\n        Assert.isTrue(de === startDE || !de.isInRing(), 'found DE already in ring');\n      } while (de !== startDE);\n    }\n\n    isInRing(pt) {\n      return Location.EXTERIOR !== this.getLocator().locate(pt);\n    }\n\n    isOuterHole() {\n      if (!this._isHole) return false;\n      return !this.hasShell();\n    }\n\n    getPolygon() {\n      let holeLR = null;\n\n      if (this._holes !== null) {\n        holeLR = new Array(this._holes.size()).fill(null);\n\n        for (let i = 0; i < this._holes.size(); i++) holeLR[i] = this._holes.get(i);\n      }\n\n      const poly = this._factory.createPolygon(this._ring, holeLR);\n\n      return poly;\n    }\n\n    isHole() {\n      return this._isHole;\n    }\n\n    isProcessed() {\n      return this._isProcessed;\n    }\n\n    addHole() {\n      if (arguments[0] instanceof LinearRing) {\n        const hole = arguments[0];\n        if (this._holes === null) this._holes = new ArrayList();\n\n        this._holes.add(hole);\n      } else if (arguments[0] instanceof EdgeRing$1) {\n        const holeER = arguments[0];\n        holeER.setShell(this);\n        const hole = holeER.getRing();\n        if (this._holes === null) this._holes = new ArrayList();\n\n        this._holes.add(hole);\n      }\n    }\n\n    setIncluded(isIncluded) {\n      this._isIncluded = isIncluded;\n      this._isIncludedSet = true;\n    }\n\n    getOuterHole() {\n      if (this.isHole()) return null;\n\n      for (let i = 0; i < this._deList.size(); i++) {\n        const de = this._deList.get(i);\n\n        const adjRing = de.getSym().getRing();\n        if (adjRing.isOuterHole()) return adjRing;\n      }\n\n      return null;\n    }\n\n    computeHole() {\n      const ring = this.getRing();\n      this._isHole = Orientation.isCCW(ring.getCoordinates());\n    }\n\n    hasShell() {\n      return this._shell !== null;\n    }\n\n    isOuterShell() {\n      return this.getOuterHole() !== null;\n    }\n\n    getLineString() {\n      this.getCoordinates();\n      return this._factory.createLineString(this._ringPts);\n    }\n\n    toString() {\n      return WKTWriter.toLineString(new CoordinateArraySequence(this.getCoordinates()));\n    }\n\n    getLocator() {\n      if (this._locator === null) this._locator = new IndexedPointInAreaLocator(this.getRing());\n      return this._locator;\n    }\n\n    getShell() {\n      if (this.isHole()) return this._shell;\n      return this;\n    }\n\n    add(de) {\n      this._deList.add(de);\n    }\n\n    getRing() {\n      if (this._ring !== null) return this._ring;\n      this.getCoordinates();\n      if (this._ringPts.length < 3) System.out.println(this._ringPts);\n\n      try {\n        this._ring = this._factory.createLinearRing(this._ringPts);\n      } catch (ex) {\n        if (ex instanceof Exception) System.out.println(this._ringPts);else throw ex;\n      } finally {}\n\n      return this._ring;\n    }\n\n    updateIncluded() {\n      if (this.isHole()) return null;\n\n      for (let i = 0; i < this._deList.size(); i++) {\n        const de = this._deList.get(i);\n\n        const adjShell = de.getSym().getRing().getShell();\n\n        if (adjShell !== null && adjShell.isIncludedSet()) {\n          this.setIncluded(!adjShell.isIncluded());\n          return null;\n        }\n      }\n    }\n\n    setShell(shell) {\n      this._shell = shell;\n    }\n\n    setProcessed(isProcessed) {\n      this._isProcessed = isProcessed;\n    }\n\n  }\n\n  class EnvelopeComparator {\n    compare(obj0, obj1) {\n      const r0 = obj0;\n      const r1 = obj1;\n      return r0.getRing().getEnvelope().compareTo(r1.getRing().getEnvelope());\n    }\n\n    get interfaces_() {\n      return [Comparator];\n    }\n\n  }\n\n  EdgeRing$1.EnvelopeComparator = EnvelopeComparator;\n\n  class PolygonizeGraph extends PlanarGraph$1 {\n    constructor() {\n      super();\n      PolygonizeGraph.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._factory = null;\n      const factory = arguments[0];\n      this._factory = factory;\n    }\n\n    static findLabeledEdgeRings(dirEdges) {\n      const edgeRingStarts = new ArrayList();\n      let currLabel = 1;\n\n      for (let i = dirEdges.iterator(); i.hasNext();) {\n        const de = i.next();\n        if (de.isMarked()) continue;\n        if (de.getLabel() >= 0) continue;\n        edgeRingStarts.add(de);\n        const edges = EdgeRing$1.findDirEdgesInRing(de);\n        PolygonizeGraph.label(edges, currLabel);\n        currLabel++;\n      }\n\n      return edgeRingStarts;\n    }\n\n    static getDegreeNonDeleted(node) {\n      const edges = node.getOutEdges().getEdges();\n      let degree = 0;\n\n      for (let i = edges.iterator(); i.hasNext();) {\n        const de = i.next();\n        if (!de.isMarked()) degree++;\n      }\n\n      return degree;\n    }\n\n    static deleteAllEdges(node) {\n      const edges = node.getOutEdges().getEdges();\n\n      for (let i = edges.iterator(); i.hasNext();) {\n        const de = i.next();\n        de.setMarked(true);\n        const sym = de.getSym();\n        if (sym !== null) sym.setMarked(true);\n      }\n    }\n\n    static label(dirEdges, label) {\n      for (let i = dirEdges.iterator(); i.hasNext();) {\n        const de = i.next();\n        de.setLabel(label);\n      }\n    }\n\n    static computeNextCWEdges(node) {\n      const deStar = node.getOutEdges();\n      let startDE = null;\n      let prevDE = null;\n\n      for (let i = deStar.getEdges().iterator(); i.hasNext();) {\n        const outDE = i.next();\n        if (outDE.isMarked()) continue;\n        if (startDE === null) startDE = outDE;\n\n        if (prevDE !== null) {\n          const sym = prevDE.getSym();\n          sym.setNext(outDE);\n        }\n\n        prevDE = outDE;\n      }\n\n      if (prevDE !== null) {\n        const sym = prevDE.getSym();\n        sym.setNext(startDE);\n      }\n    }\n\n    static computeNextCCWEdges(node, label) {\n      const deStar = node.getOutEdges();\n      let firstOutDE = null;\n      let prevInDE = null;\n      const edges = deStar.getEdges();\n\n      for (let i = edges.size() - 1; i >= 0; i--) {\n        const de = edges.get(i);\n        const sym = de.getSym();\n        let outDE = null;\n        if (de.getLabel() === label) outDE = de;\n        let inDE = null;\n        if (sym.getLabel() === label) inDE = sym;\n        if (outDE === null && inDE === null) continue;\n        if (inDE !== null) prevInDE = inDE;\n\n        if (outDE !== null) {\n          if (prevInDE !== null) {\n            prevInDE.setNext(outDE);\n            prevInDE = null;\n          }\n\n          if (firstOutDE === null) firstOutDE = outDE;\n        }\n      }\n\n      if (prevInDE !== null) {\n        Assert.isTrue(firstOutDE !== null);\n        prevInDE.setNext(firstOutDE);\n      }\n    }\n\n    static getDegree(node, label) {\n      const edges = node.getOutEdges().getEdges();\n      let degree = 0;\n\n      for (let i = edges.iterator(); i.hasNext();) {\n        const de = i.next();\n        if (de.getLabel() === label) degree++;\n      }\n\n      return degree;\n    }\n\n    static findIntersectionNodes(startDE, label) {\n      let de = startDE;\n      let intNodes = null;\n\n      do {\n        const node = de.getFromNode();\n\n        if (PolygonizeGraph.getDegree(node, label) > 1) {\n          if (intNodes === null) intNodes = new ArrayList();\n          intNodes.add(node);\n        }\n\n        de = de.getNext();\n        Assert.isTrue(de !== null, 'found null DE in ring');\n        Assert.isTrue(de === startDE || !de.isInRing(), 'found DE already in ring');\n      } while (de !== startDE);\n\n      return intNodes;\n    }\n\n    findEdgeRing(startDE) {\n      const er = new EdgeRing$1(this._factory);\n      er.build(startDE);\n      return er;\n    }\n\n    computeDepthParity() {\n      if (arguments.length === 0) {\n        while (true) {\n          return null;\n        }\n      }\n    }\n\n    computeNextCWEdges() {\n      for (let iNode = this.nodeIterator(); iNode.hasNext();) {\n        const node = iNode.next();\n        PolygonizeGraph.computeNextCWEdges(node);\n      }\n    }\n\n    addEdge(line) {\n      if (line.isEmpty()) return null;\n      const linePts = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n      if (linePts.length < 2) return null;\n      const startPt = linePts[0];\n      const endPt = linePts[linePts.length - 1];\n      const nStart = this.getNode(startPt);\n      const nEnd = this.getNode(endPt);\n      const de0 = new PolygonizeDirectedEdge(nStart, nEnd, linePts[1], true);\n      const de1 = new PolygonizeDirectedEdge(nEnd, nStart, linePts[linePts.length - 2], false);\n      const edge = new PolygonizeEdge(line);\n      edge.setDirectedEdges(de0, de1);\n      this.add(edge);\n    }\n\n    deleteCutEdges() {\n      this.computeNextCWEdges();\n      PolygonizeGraph.findLabeledEdgeRings(this._dirEdges);\n      const cutLines = new ArrayList();\n\n      for (let i = this._dirEdges.iterator(); i.hasNext();) {\n        const de = i.next();\n        if (de.isMarked()) continue;\n        const sym = de.getSym();\n\n        if (de.getLabel() === sym.getLabel()) {\n          de.setMarked(true);\n          sym.setMarked(true);\n          const e = de.getEdge();\n          cutLines.add(e.getLine());\n        }\n      }\n\n      return cutLines;\n    }\n\n    getEdgeRings() {\n      this.computeNextCWEdges();\n      PolygonizeGraph.label(this._dirEdges, -1);\n      const maximalRings = PolygonizeGraph.findLabeledEdgeRings(this._dirEdges);\n      this.convertMaximalToMinimalEdgeRings(maximalRings);\n      const edgeRingList = new ArrayList();\n\n      for (let i = this._dirEdges.iterator(); i.hasNext();) {\n        const de = i.next();\n        if (de.isMarked()) continue;\n        if (de.isInRing()) continue;\n        const er = this.findEdgeRing(de);\n        edgeRingList.add(er);\n      }\n\n      return edgeRingList;\n    }\n\n    getNode(pt) {\n      let node = this.findNode(pt);\n\n      if (node === null) {\n        node = new Node$2(pt);\n        this.add(node);\n      }\n\n      return node;\n    }\n\n    convertMaximalToMinimalEdgeRings(ringEdges) {\n      for (let i = ringEdges.iterator(); i.hasNext();) {\n        const de = i.next();\n        const label = de.getLabel();\n        const intNodes = PolygonizeGraph.findIntersectionNodes(de, label);\n        if (intNodes === null) continue;\n\n        for (let iNode = intNodes.iterator(); iNode.hasNext();) {\n          const node = iNode.next();\n          PolygonizeGraph.computeNextCCWEdges(node, label);\n        }\n      }\n    }\n\n    deleteDangles() {\n      const nodesToRemove = this.findNodesOfDegree(1);\n      const dangleLines = new HashSet();\n      const nodeStack = new Stack();\n\n      for (let i = nodesToRemove.iterator(); i.hasNext();) nodeStack.push(i.next());\n\n      while (!nodeStack.isEmpty()) {\n        const node = nodeStack.pop();\n        PolygonizeGraph.deleteAllEdges(node);\n        const nodeOutEdges = node.getOutEdges().getEdges();\n\n        for (let i = nodeOutEdges.iterator(); i.hasNext();) {\n          const de = i.next();\n          de.setMarked(true);\n          const sym = de.getSym();\n          if (sym !== null) sym.setMarked(true);\n          const e = de.getEdge();\n          dangleLines.add(e.getLine());\n          const toNode = de.getToNode();\n          if (PolygonizeGraph.getDegreeNonDeleted(toNode) === 1) nodeStack.push(toNode);\n        }\n      }\n\n      return dangleLines;\n    }\n\n  }\n\n  class HoleAssigner {\n    constructor() {\n      HoleAssigner.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._shells = null;\n      this._shellIndex = null;\n      const shells = arguments[0];\n      this._shells = shells;\n      this.buildIndex();\n    }\n\n    static assignHolesToShells(holes, shells) {\n      const assigner = new HoleAssigner(shells);\n      assigner.assignHolesToShells(holes);\n    }\n\n    assignHolesToShells(holeList) {\n      for (let i = holeList.iterator(); i.hasNext();) {\n        const holeER = i.next();\n        this.assignHoleToShell(holeER);\n      }\n    }\n\n    buildIndex() {\n      this._shellIndex = new STRtree();\n\n      for (const shell of this._shells) this._shellIndex.insert(shell.getRing().getEnvelopeInternal(), shell);\n    }\n\n    queryOverlappingShells(ringEnv) {\n      return this._shellIndex.query(ringEnv);\n    }\n\n    findShellContaining(testEr) {\n      const testEnv = testEr.getRing().getEnvelopeInternal();\n      const candidateShells = this.queryOverlappingShells(testEnv);\n      return EdgeRing$1.findEdgeRingContaining(testEr, candidateShells);\n    }\n\n    assignHoleToShell(holeER) {\n      const shell = this.findShellContaining(holeER);\n      if (shell !== null) shell.addHole(holeER);\n    }\n\n  }\n\n  class Polygonizer {\n    constructor() {\n      Polygonizer.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._lineStringAdder = new LineStringAdder(this);\n      this._graph = null;\n      this._dangles = new ArrayList();\n      this._cutEdges = new ArrayList();\n      this._invalidRingLines = new ArrayList();\n      this._holeList = null;\n      this._shellList = null;\n      this._polyList = null;\n      this._isCheckingRingsValid = true;\n      this._extractOnlyPolygonal = null;\n      this._geomFactory = null;\n\n      if (arguments.length === 0) {\n        Polygonizer.constructor_.call(this, false);\n      } else if (arguments.length === 1) {\n        const extractOnlyPolygonal = arguments[0];\n        this._extractOnlyPolygonal = extractOnlyPolygonal;\n      }\n    }\n\n    static extractPolygons(shellList, includeAll) {\n      const polyList = new ArrayList();\n\n      for (let i = shellList.iterator(); i.hasNext();) {\n        const er = i.next();\n        if (includeAll || er.isIncluded()) polyList.add(er.getPolygon());\n      }\n\n      return polyList;\n    }\n\n    static findOuterShells(shellList) {\n      for (let i = shellList.iterator(); i.hasNext();) {\n        const er = i.next();\n        const outerHoleER = er.getOuterHole();\n\n        if (outerHoleER !== null && !outerHoleER.isProcessed()) {\n          er.setIncluded(true);\n          outerHoleER.setProcessed(true);\n        }\n      }\n    }\n\n    static findDisjointShells(shellList) {\n      Polygonizer.findOuterShells(shellList);\n      let isMoreToScan = null;\n\n      do {\n        isMoreToScan = false;\n\n        for (let i = shellList.iterator(); i.hasNext();) {\n          const er = i.next();\n          if (er.isIncludedSet()) continue;\n          er.updateIncluded();\n          if (!er.isIncludedSet()) isMoreToScan = true;\n        }\n      } while (isMoreToScan);\n    }\n\n    getGeometry() {\n      if (this._geomFactory === null) this._geomFactory = new GeometryFactory();\n      this.polygonize();\n      if (this._extractOnlyPolygonal) return this._geomFactory.buildGeometry(this._polyList);\n      return this._geomFactory.createGeometryCollection(GeometryFactory.toGeometryArray(this._polyList));\n    }\n\n    getInvalidRingLines() {\n      this.polygonize();\n      return this._invalidRingLines;\n    }\n\n    findValidRings(edgeRingList, validEdgeRingList, invalidRingList) {\n      for (let i = edgeRingList.iterator(); i.hasNext();) {\n        const er = i.next();\n        if (er.isValid()) validEdgeRingList.add(er);else invalidRingList.add(er.getLineString());\n      }\n    }\n\n    polygonize() {\n      if (this._polyList !== null) return null;\n      this._polyList = new ArrayList();\n      if (this._graph === null) return null;\n      this._dangles = this._graph.deleteDangles();\n      this._cutEdges = this._graph.deleteCutEdges();\n\n      const edgeRingList = this._graph.getEdgeRings();\n\n      let validEdgeRingList = new ArrayList();\n      this._invalidRingLines = new ArrayList();\n      if (this._isCheckingRingsValid) this.findValidRings(edgeRingList, validEdgeRingList, this._invalidRingLines);else validEdgeRingList = edgeRingList;\n      this.findShellsAndHoles(validEdgeRingList);\n      HoleAssigner.assignHolesToShells(this._holeList, this._shellList);\n      Collections.sort(this._shellList, new EdgeRing$1.EnvelopeComparator());\n      let includeAll = true;\n\n      if (this._extractOnlyPolygonal) {\n        Polygonizer.findDisjointShells(this._shellList);\n        includeAll = false;\n      }\n\n      this._polyList = Polygonizer.extractPolygons(this._shellList, includeAll);\n    }\n\n    getDangles() {\n      this.polygonize();\n      return this._dangles;\n    }\n\n    getCutEdges() {\n      this.polygonize();\n      return this._cutEdges;\n    }\n\n    getPolygons() {\n      this.polygonize();\n      return this._polyList;\n    }\n\n    add() {\n      if (hasInterface(arguments[0], Collection)) {\n        const geomList = arguments[0];\n\n        for (let i = geomList.iterator(); i.hasNext();) {\n          const geometry = i.next();\n          this.add(geometry);\n        }\n      } else if (arguments[0] instanceof LineString) {\n        const line = arguments[0];\n        this._geomFactory = line.getFactory();\n        if (this._graph === null) this._graph = new PolygonizeGraph(this._geomFactory);\n\n        this._graph.addEdge(line);\n      } else if (arguments[0] instanceof Geometry) {\n        const g = arguments[0];\n        g.apply(this._lineStringAdder);\n      }\n    }\n\n    setCheckRingsValid(isCheckingRingsValid) {\n      this._isCheckingRingsValid = isCheckingRingsValid;\n    }\n\n    findShellsAndHoles(edgeRingList) {\n      this._holeList = new ArrayList();\n      this._shellList = new ArrayList();\n\n      for (let i = edgeRingList.iterator(); i.hasNext();) {\n        const er = i.next();\n        er.computeHole();\n        if (er.isHole()) this._holeList.add(er);else this._shellList.add(er);\n      }\n    }\n\n  }\n\n  class LineStringAdder {\n    constructor() {\n      LineStringAdder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.p = null;\n      const p = arguments[0];\n      this.p = p;\n    }\n\n    filter(g) {\n      if (g instanceof LineString) this.p.add(g);\n    }\n\n    get interfaces_() {\n      return [GeometryComponentFilter];\n    }\n\n  }\n\n  Polygonizer.LineStringAdder = LineStringAdder;\n\n  var polygonize = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Polygonizer: Polygonizer\n  });\n\n  class RelateComputer {\n    constructor() {\n      RelateComputer.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._li = new RobustLineIntersector();\n      this._ptLocator = new PointLocator();\n      this._arg = null;\n      this._nodes = new NodeMap(new RelateNodeFactory());\n      this._im = null;\n      this._isolatedEdges = new ArrayList();\n      this._invalidPoint = null;\n      const arg = arguments[0];\n      this._arg = arg;\n    }\n\n    insertEdgeEnds(ee) {\n      for (let i = ee.iterator(); i.hasNext();) {\n        const e = i.next();\n\n        this._nodes.add(e);\n      }\n    }\n\n    computeProperIntersectionIM(intersector, im) {\n      const dimA = this._arg[0].getGeometry().getDimension();\n\n      const dimB = this._arg[1].getGeometry().getDimension();\n\n      const hasProper = intersector.hasProperIntersection();\n      const hasProperInterior = intersector.hasProperInteriorIntersection();\n\n      if (dimA === 2 && dimB === 2) {\n        if (hasProper) im.setAtLeast('212101212');\n      } else if (dimA === 2 && dimB === 1) {\n        if (hasProper) im.setAtLeast('FFF0FFFF2');\n        if (hasProperInterior) im.setAtLeast('1FFFFF1FF');\n      } else if (dimA === 1 && dimB === 2) {\n        if (hasProper) im.setAtLeast('F0FFFFFF2');\n        if (hasProperInterior) im.setAtLeast('1F1FFFFFF');\n      } else if (dimA === 1 && dimB === 1) {\n        if (hasProperInterior) im.setAtLeast('0FFFFFFFF');\n      }\n    }\n\n    labelIsolatedEdges(thisIndex, targetIndex) {\n      for (let ei = this._arg[thisIndex].getEdgeIterator(); ei.hasNext();) {\n        const e = ei.next();\n\n        if (e.isIsolated()) {\n          this.labelIsolatedEdge(e, targetIndex, this._arg[targetIndex].getGeometry());\n\n          this._isolatedEdges.add(e);\n        }\n      }\n    }\n\n    labelIsolatedEdge(e, targetIndex, target) {\n      if (target.getDimension() > 0) {\n        const loc = this._ptLocator.locate(e.getCoordinate(), target);\n\n        e.getLabel().setAllLocations(targetIndex, loc);\n      } else {\n        e.getLabel().setAllLocations(targetIndex, Location.EXTERIOR);\n      }\n    }\n\n    computeIM() {\n      const im = new IntersectionMatrix();\n      im.set(Location.EXTERIOR, Location.EXTERIOR, 2);\n\n      if (!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal())) {\n        this.computeDisjointIM(im);\n        return im;\n      }\n\n      this._arg[0].computeSelfNodes(this._li, false);\n\n      this._arg[1].computeSelfNodes(this._li, false);\n\n      const intersector = this._arg[0].computeEdgeIntersections(this._arg[1], this._li, false);\n\n      this.computeIntersectionNodes(0);\n      this.computeIntersectionNodes(1);\n      this.copyNodesAndLabels(0);\n      this.copyNodesAndLabels(1);\n      this.labelIsolatedNodes();\n      this.computeProperIntersectionIM(intersector, im);\n      const eeBuilder = new EdgeEndBuilder();\n      const ee0 = eeBuilder.computeEdgeEnds(this._arg[0].getEdgeIterator());\n      this.insertEdgeEnds(ee0);\n      const ee1 = eeBuilder.computeEdgeEnds(this._arg[1].getEdgeIterator());\n      this.insertEdgeEnds(ee1);\n      this.labelNodeEdges();\n      this.labelIsolatedEdges(0, 1);\n      this.labelIsolatedEdges(1, 0);\n      this.updateIM(im);\n      return im;\n    }\n\n    labelNodeEdges() {\n      for (let ni = this._nodes.iterator(); ni.hasNext();) {\n        const node = ni.next();\n        node.getEdges().computeLabelling(this._arg);\n      }\n    }\n\n    copyNodesAndLabels(argIndex) {\n      for (let i = this._arg[argIndex].getNodeIterator(); i.hasNext();) {\n        const graphNode = i.next();\n\n        const newNode = this._nodes.addNode(graphNode.getCoordinate());\n\n        newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n      }\n    }\n\n    labelIntersectionNodes(argIndex) {\n      for (let i = this._arg[argIndex].getEdgeIterator(); i.hasNext();) {\n        const e = i.next();\n        const eLoc = e.getLabel().getLocation(argIndex);\n\n        for (let eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n          const ei = eiIt.next();\n\n          const n = this._nodes.find(ei.coord);\n\n          if (n.getLabel().isNull(argIndex)) if (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex);else n.setLabel(argIndex, Location.INTERIOR);\n        }\n      }\n    }\n\n    labelIsolatedNode(n, targetIndex) {\n      const loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());\n\n      n.getLabel().setAllLocations(targetIndex, loc);\n    }\n\n    computeIntersectionNodes(argIndex) {\n      for (let i = this._arg[argIndex].getEdgeIterator(); i.hasNext();) {\n        const e = i.next();\n        const eLoc = e.getLabel().getLocation(argIndex);\n\n        for (let eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();) {\n          const ei = eiIt.next();\n\n          const n = this._nodes.addNode(ei.coord);\n\n          if (eLoc === Location.BOUNDARY) n.setLabelBoundary(argIndex);else if (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, Location.INTERIOR);\n        }\n      }\n    }\n\n    labelIsolatedNodes() {\n      for (let ni = this._nodes.iterator(); ni.hasNext();) {\n        const n = ni.next();\n        const label = n.getLabel();\n        Assert.isTrue(label.getGeometryCount() > 0, 'node with empty label found');\n        if (n.isIsolated()) if (label.isNull(0)) this.labelIsolatedNode(n, 0);else this.labelIsolatedNode(n, 1);\n      }\n    }\n\n    updateIM(im) {\n      for (let ei = this._isolatedEdges.iterator(); ei.hasNext();) {\n        const e = ei.next();\n        e.updateIM(im);\n      }\n\n      for (let ni = this._nodes.iterator(); ni.hasNext();) {\n        const node = ni.next();\n        node.updateIM(im);\n        node.updateIMFromEdges(im);\n      }\n    }\n\n    computeDisjointIM(im) {\n      const ga = this._arg[0].getGeometry();\n\n      if (!ga.isEmpty()) {\n        im.set(Location.INTERIOR, Location.EXTERIOR, ga.getDimension());\n        im.set(Location.BOUNDARY, Location.EXTERIOR, ga.getBoundaryDimension());\n      }\n\n      const gb = this._arg[1].getGeometry();\n\n      if (!gb.isEmpty()) {\n        im.set(Location.EXTERIOR, Location.INTERIOR, gb.getDimension());\n        im.set(Location.EXTERIOR, Location.BOUNDARY, gb.getBoundaryDimension());\n      }\n    }\n\n  }\n\n  class RectangleContains {\n    constructor() {\n      RectangleContains.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._rectEnv = null;\n      const rectangle = arguments[0];\n      this._rectEnv = rectangle.getEnvelopeInternal();\n    }\n\n    static contains(rectangle, b) {\n      const rc = new RectangleContains(rectangle);\n      return rc.contains(b);\n    }\n\n    isContainedInBoundary(geom) {\n      if (geom instanceof Polygon) return false;\n      if (geom instanceof Point) return this.isPointContainedInBoundary(geom);\n      if (geom instanceof LineString) return this.isLineStringContainedInBoundary(geom);\n\n      for (let i = 0; i < geom.getNumGeometries(); i++) {\n        const comp = geom.getGeometryN(i);\n        if (!this.isContainedInBoundary(comp)) return false;\n      }\n\n      return true;\n    }\n\n    isLineSegmentContainedInBoundary(p0, p1) {\n      if (p0.equals(p1)) return this.isPointContainedInBoundary(p0);\n\n      if (p0.x === p1.x) {\n        if (p0.x === this._rectEnv.getMinX() || p0.x === this._rectEnv.getMaxX()) return true;\n      } else if (p0.y === p1.y) {\n        if (p0.y === this._rectEnv.getMinY() || p0.y === this._rectEnv.getMaxY()) return true;\n      }\n\n      return false;\n    }\n\n    isLineStringContainedInBoundary(line) {\n      const seq = line.getCoordinateSequence();\n      const p0 = new Coordinate();\n      const p1 = new Coordinate();\n\n      for (let i = 0; i < seq.size() - 1; i++) {\n        seq.getCoordinate(i, p0);\n        seq.getCoordinate(i + 1, p1);\n        if (!this.isLineSegmentContainedInBoundary(p0, p1)) return false;\n      }\n\n      return true;\n    }\n\n    isPointContainedInBoundary() {\n      if (arguments[0] instanceof Point) {\n        const point = arguments[0];\n        return this.isPointContainedInBoundary(point.getCoordinate());\n      } else if (arguments[0] instanceof Coordinate) {\n        const pt = arguments[0];\n        return pt.x === this._rectEnv.getMinX() || pt.x === this._rectEnv.getMaxX() || pt.y === this._rectEnv.getMinY() || pt.y === this._rectEnv.getMaxY();\n      }\n    }\n\n    contains(geom) {\n      if (!this._rectEnv.contains(geom.getEnvelopeInternal())) return false;\n      if (this.isContainedInBoundary(geom)) return false;\n      return true;\n    }\n\n  }\n\n  class RectangleLineIntersector {\n    constructor() {\n      RectangleLineIntersector.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._li = new RobustLineIntersector();\n      this._rectEnv = null;\n      this._diagUp0 = null;\n      this._diagUp1 = null;\n      this._diagDown0 = null;\n      this._diagDown1 = null;\n      const rectEnv = arguments[0];\n      this._rectEnv = rectEnv;\n      this._diagUp0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMinY());\n      this._diagUp1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMaxY());\n      this._diagDown0 = new Coordinate(rectEnv.getMinX(), rectEnv.getMaxY());\n      this._diagDown1 = new Coordinate(rectEnv.getMaxX(), rectEnv.getMinY());\n    }\n\n    intersects(p0, p1) {\n      const segEnv = new Envelope(p0, p1);\n      if (!this._rectEnv.intersects(segEnv)) return false;\n      if (this._rectEnv.intersects(p0)) return true;\n      if (this._rectEnv.intersects(p1)) return true;\n\n      if (p0.compareTo(p1) > 0) {\n        const tmp = p0;\n        p0 = p1;\n        p1 = tmp;\n      }\n\n      let isSegUpwards = false;\n      if (p1.y > p0.y) isSegUpwards = true;\n      if (isSegUpwards) this._li.computeIntersection(p0, p1, this._diagDown0, this._diagDown1);else this._li.computeIntersection(p0, p1, this._diagUp0, this._diagUp1);\n      if (this._li.hasIntersection()) return true;\n      return false;\n    }\n\n  }\n\n  class RectangleIntersects {\n    constructor() {\n      RectangleIntersects.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._rectangle = null;\n      this._rectEnv = null;\n      const rectangle = arguments[0];\n      this._rectangle = rectangle;\n      this._rectEnv = rectangle.getEnvelopeInternal();\n    }\n\n    static intersects(rectangle, b) {\n      const rp = new RectangleIntersects(rectangle);\n      return rp.intersects(b);\n    }\n\n    intersects(geom) {\n      if (!this._rectEnv.intersects(geom.getEnvelopeInternal())) return false;\n      const visitor = new EnvelopeIntersectsVisitor(this._rectEnv);\n      visitor.applyTo(geom);\n      if (visitor.intersects()) return true;\n      const ecpVisitor = new GeometryContainsPointVisitor(this._rectangle);\n      ecpVisitor.applyTo(geom);\n      if (ecpVisitor.containsPoint()) return true;\n      const riVisitor = new RectangleIntersectsSegmentVisitor(this._rectangle);\n      riVisitor.applyTo(geom);\n      if (riVisitor.intersects()) return true;\n      return false;\n    }\n\n  }\n\n  class EnvelopeIntersectsVisitor extends ShortCircuitedGeometryVisitor {\n    constructor() {\n      super();\n      EnvelopeIntersectsVisitor.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._rectEnv = null;\n      this._intersects = false;\n      const rectEnv = arguments[0];\n      this._rectEnv = rectEnv;\n    }\n\n    isDone() {\n      return this._intersects === true;\n    }\n\n    visit(element) {\n      const elementEnv = element.getEnvelopeInternal();\n      if (!this._rectEnv.intersects(elementEnv)) return null;\n\n      if (this._rectEnv.contains(elementEnv)) {\n        this._intersects = true;\n        return null;\n      }\n\n      if (elementEnv.getMinX() >= this._rectEnv.getMinX() && elementEnv.getMaxX() <= this._rectEnv.getMaxX()) {\n        this._intersects = true;\n        return null;\n      }\n\n      if (elementEnv.getMinY() >= this._rectEnv.getMinY() && elementEnv.getMaxY() <= this._rectEnv.getMaxY()) {\n        this._intersects = true;\n        return null;\n      }\n    }\n\n    intersects() {\n      return this._intersects;\n    }\n\n  }\n\n  class GeometryContainsPointVisitor extends ShortCircuitedGeometryVisitor {\n    constructor() {\n      super();\n      GeometryContainsPointVisitor.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._rectSeq = null;\n      this._rectEnv = null;\n      this._containsPoint = false;\n      const rectangle = arguments[0];\n      this._rectSeq = rectangle.getExteriorRing().getCoordinateSequence();\n      this._rectEnv = rectangle.getEnvelopeInternal();\n    }\n\n    isDone() {\n      return this._containsPoint === true;\n    }\n\n    visit(geom) {\n      if (!(geom instanceof Polygon)) return null;\n      const elementEnv = geom.getEnvelopeInternal();\n      if (!this._rectEnv.intersects(elementEnv)) return null;\n      const rectPt = new Coordinate();\n\n      for (let i = 0; i < 4; i++) {\n        this._rectSeq.getCoordinate(i, rectPt);\n\n        if (!elementEnv.contains(rectPt)) continue;\n\n        if (SimplePointInAreaLocator.containsPointInPolygon(rectPt, geom)) {\n          this._containsPoint = true;\n          return null;\n        }\n      }\n    }\n\n    containsPoint() {\n      return this._containsPoint;\n    }\n\n  }\n\n  class RectangleIntersectsSegmentVisitor extends ShortCircuitedGeometryVisitor {\n    constructor() {\n      super();\n      RectangleIntersectsSegmentVisitor.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._rectEnv = null;\n      this._rectIntersector = null;\n      this._hasIntersection = false;\n      this._p0 = new Coordinate();\n      this._p1 = new Coordinate();\n      const rectangle = arguments[0];\n      this._rectEnv = rectangle.getEnvelopeInternal();\n      this._rectIntersector = new RectangleLineIntersector(this._rectEnv);\n    }\n\n    intersects() {\n      return this._hasIntersection;\n    }\n\n    isDone() {\n      return this._hasIntersection === true;\n    }\n\n    visit(geom) {\n      const elementEnv = geom.getEnvelopeInternal();\n      if (!this._rectEnv.intersects(elementEnv)) return null;\n      const lines = LinearComponentExtracter.getLines(geom);\n      this.checkIntersectionWithLineStrings(lines);\n    }\n\n    checkIntersectionWithLineStrings(lines) {\n      for (let i = lines.iterator(); i.hasNext();) {\n        const testLine = i.next();\n        this.checkIntersectionWithSegments(testLine);\n        if (this._hasIntersection) return null;\n      }\n    }\n\n    checkIntersectionWithSegments(testLine) {\n      const seq1 = testLine.getCoordinateSequence();\n\n      for (let j = 1; j < seq1.size(); j++) {\n        seq1.getCoordinate(j - 1, this._p0);\n        seq1.getCoordinate(j, this._p1);\n\n        if (this._rectIntersector.intersects(this._p0, this._p1)) {\n          this._hasIntersection = true;\n          return null;\n        }\n      }\n    }\n\n  }\n\n  class RelateOp extends GeometryGraphOperation {\n    constructor() {\n      super();\n      RelateOp.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._relate = null;\n\n      if (arguments.length === 2) {\n        const g0 = arguments[0],\n              g1 = arguments[1];\n        GeometryGraphOperation.constructor_.call(this, g0, g1);\n        this._relate = new RelateComputer(this._arg);\n      } else if (arguments.length === 3) {\n        const g0 = arguments[0],\n              g1 = arguments[1],\n              boundaryNodeRule = arguments[2];\n        GeometryGraphOperation.constructor_.call(this, g0, g1, boundaryNodeRule);\n        this._relate = new RelateComputer(this._arg);\n      }\n    }\n\n    static covers(g1, g2) {\n      if (g2.getDimension() === 2 && g1.getDimension() < 2) return false;\n      if (g2.getDimension() === 1 && g1.getDimension() < 1 && g2.getLength() > 0.0) return false;\n      if (!g1.getEnvelopeInternal().covers(g2.getEnvelopeInternal())) return false;\n      if (g1.isRectangle()) return true;\n      return new RelateOp(g1, g2).getIntersectionMatrix().isCovers();\n    }\n\n    static intersects(g1, g2) {\n      if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n      if (g1.isRectangle()) return RectangleIntersects.intersects(g1, g2);\n      if (g2.isRectangle()) return RectangleIntersects.intersects(g2, g1);\n\n      if (g1.isGeometryCollection() || g2.isGeometryCollection()) {\n\n        for (let i = 0; i < g1.getNumGeometries(); i++) for (let j = 0; j < g2.getNumGeometries(); j++) if (g1.getGeometryN(i).intersects(g2.getGeometryN(j))) return true;\n\n        return false;\n      }\n\n      return new RelateOp(g1, g2).getIntersectionMatrix().isIntersects();\n    }\n\n    static touches(g1, g2) {\n      if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n      return new RelateOp(g1, g2).getIntersectionMatrix().isTouches(g1.getDimension(), g2.getDimension());\n    }\n\n    static equalsTopo(g1, g2) {\n      if (!g1.getEnvelopeInternal().equals(g2.getEnvelopeInternal())) return false;\n      return RelateOp.relate(g1, g2).isEquals(g1.getDimension(), g2.getDimension());\n    }\n\n    static relate() {\n      if (arguments.length === 2) {\n        const a = arguments[0],\n              b = arguments[1];\n        const relOp = new RelateOp(a, b);\n        const im = relOp.getIntersectionMatrix();\n        return im;\n      } else if (arguments.length === 3) {\n        const a = arguments[0],\n              b = arguments[1],\n              boundaryNodeRule = arguments[2];\n        const relOp = new RelateOp(a, b, boundaryNodeRule);\n        const im = relOp.getIntersectionMatrix();\n        return im;\n      }\n    }\n\n    static overlaps(g1, g2) {\n      if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n      return new RelateOp(g1, g2).getIntersectionMatrix().isOverlaps(g1.getDimension(), g2.getDimension());\n    }\n\n    static crosses(g1, g2) {\n      if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;\n      return new RelateOp(g1, g2).getIntersectionMatrix().isCrosses(g1.getDimension(), g2.getDimension());\n    }\n\n    static contains(g1, g2) {\n      if (g2.getDimension() === 2 && g1.getDimension() < 2) return false;\n      if (g2.getDimension() === 1 && g1.getDimension() < 1 && g2.getLength() > 0.0) return false;\n      if (!g1.getEnvelopeInternal().contains(g2.getEnvelopeInternal())) return false;\n      if (g1.isRectangle()) return RectangleContains.contains(g1, g2);\n      return new RelateOp(g1, g2).getIntersectionMatrix().isContains();\n    }\n\n    getIntersectionMatrix() {\n      return this._relate.computeIM();\n    }\n\n  }\n\n  var relate = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    RelateOp: RelateOp\n  });\n\n  class PointGeometryUnion {\n    constructor() {\n      PointGeometryUnion.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._pointGeom = null;\n      this._otherGeom = null;\n      this._geomFact = null;\n      const pointGeom = arguments[0],\n            otherGeom = arguments[1];\n      this._pointGeom = pointGeom;\n      this._otherGeom = otherGeom;\n      this._geomFact = otherGeom.getFactory();\n    }\n\n    static union(pointGeom, otherGeom) {\n      const unioner = new PointGeometryUnion(pointGeom, otherGeom);\n      return unioner.union();\n    }\n\n    union() {\n      const locater = new PointLocator();\n      const exteriorCoords = new TreeSet();\n\n      for (let i = 0; i < this._pointGeom.getNumGeometries(); i++) {\n        const point = this._pointGeom.getGeometryN(i);\n\n        const coord = point.getCoordinate();\n        const loc = locater.locate(coord, this._otherGeom);\n        if (loc === Location.EXTERIOR) exteriorCoords.add(coord);\n      }\n\n      if (exteriorCoords.size() === 0) return this._otherGeom;\n      let ptComp = null;\n      const coords = CoordinateArrays.toCoordinateArray(exteriorCoords);\n      if (coords.length === 1) ptComp = this._geomFact.createPoint(coords[0]);else ptComp = this._geomFact.createMultiPointFromCoords(coords);\n      return GeometryCombiner.combine(ptComp, this._otherGeom);\n    }\n\n  }\n\n  class InputExtracter {\n    constructor() {\n      InputExtracter.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._geomFactory = null;\n      this._polygons = new ArrayList();\n      this._lines = new ArrayList();\n      this._points = new ArrayList();\n      this._dimension = Dimension.FALSE;\n    }\n\n    static extract() {\n      if (hasInterface(arguments[0], Collection)) {\n        const geoms = arguments[0];\n        const extracter = new InputExtracter();\n        extracter.add(geoms);\n        return extracter;\n      } else if (arguments[0] instanceof Geometry) {\n        const geom = arguments[0];\n        const extracter = new InputExtracter();\n        extracter.add(geom);\n        return extracter;\n      }\n    }\n\n    getFactory() {\n      return this._geomFactory;\n    }\n\n    recordDimension(dim) {\n      if (dim > this._dimension) this._dimension = dim;\n    }\n\n    getDimension() {\n      return this._dimension;\n    }\n\n    filter(geom) {\n      this.recordDimension(geom.getDimension());\n      if (geom instanceof GeometryCollection) return null;\n      if (geom.isEmpty()) return null;\n\n      if (geom instanceof Polygon) {\n        this._polygons.add(geom);\n\n        return null;\n      } else if (geom instanceof LineString) {\n        this._lines.add(geom);\n\n        return null;\n      } else if (geom instanceof Point) {\n        this._points.add(geom);\n\n        return null;\n      }\n\n      Assert.shouldNeverReachHere('Unhandled geometry type: ' + geom.getGeometryType());\n    }\n\n    getExtract(dim) {\n      switch (dim) {\n        case 0:\n          return this._points;\n\n        case 1:\n          return this._lines;\n\n        case 2:\n          return this._polygons;\n      }\n\n      Assert.shouldNeverReachHere('Invalid dimension: ' + dim);\n      return null;\n    }\n\n    isEmpty() {\n      return this._polygons.isEmpty() && this._lines.isEmpty() && this._points.isEmpty();\n    }\n\n    add() {\n      if (hasInterface(arguments[0], Collection)) {\n        const geoms = arguments[0];\n\n        for (const geom of geoms) this.add(geom);\n      } else if (arguments[0] instanceof Geometry) {\n        const geom = arguments[0];\n        if (this._geomFactory === null) this._geomFactory = geom.getFactory();\n        geom.apply(this);\n      }\n    }\n\n    get interfaces_() {\n      return [GeometryFilter];\n    }\n\n  }\n\n  class OverlapUnion {\n    constructor() {\n      OverlapUnion.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._geomFactory = null;\n      this._g0 = null;\n      this._g1 = null;\n      this._isUnionSafe = null;\n      const g0 = arguments[0],\n            g1 = arguments[1];\n      this._g0 = g0;\n      this._g1 = g1;\n      this._geomFactory = g0.getFactory();\n    }\n\n    static containsProperly() {\n      if (arguments.length === 2) {\n        const env = arguments[0],\n              p = arguments[1];\n        if (env.isNull()) return false;\n        return p.getX() > env.getMinX() && p.getX() < env.getMaxX() && p.getY() > env.getMinY() && p.getY() < env.getMaxY();\n      } else if (arguments.length === 3) {\n        const env = arguments[0],\n              p0 = arguments[1],\n              p1 = arguments[2];\n        return OverlapUnion.containsProperly(env, p0) && OverlapUnion.containsProperly(env, p1);\n      }\n    }\n\n    static union(g0, g1) {\n      const union = new OverlapUnion(g0, g1);\n      return union.union();\n    }\n\n    static intersects(env, p0, p1) {\n      return env.intersects(p0) || env.intersects(p1);\n    }\n\n    static overlapEnvelope(g0, g1) {\n      const g0Env = g0.getEnvelopeInternal();\n      const g1Env = g1.getEnvelopeInternal();\n      const overlapEnv = g0Env.intersection(g1Env);\n      return overlapEnv;\n    }\n\n    static extractBorderSegments(geom, env, segs) {\n      geom.apply(new class {\n        get interfaces_() {\n          return [CoordinateSequenceFilter];\n        }\n\n        filter(seq, i) {\n          if (i <= 0) return null;\n          const p0 = seq.getCoordinate(i - 1);\n          const p1 = seq.getCoordinate(i);\n          const isBorder = OverlapUnion.intersects(env, p0, p1) && !OverlapUnion.containsProperly(env, p0, p1);\n\n          if (isBorder) {\n            const seg = new LineSegment(p0, p1);\n            segs.add(seg);\n          }\n        }\n\n        isDone() {\n          return false;\n        }\n\n        isGeometryChanged() {\n          return false;\n        }\n\n      }());\n    }\n\n    static unionBuffer(g0, g1) {\n      const factory = g0.getFactory();\n      const gColl = factory.createGeometryCollection([g0, g1]);\n      const union = gColl.buffer(0.0);\n      return union;\n    }\n\n    isBorderSegmentsSame(result, env) {\n      const segsBefore = this.extractBorderSegments(this._g0, this._g1, env);\n      const segsAfter = new ArrayList();\n      OverlapUnion.extractBorderSegments(result, env, segsAfter);\n      return this.isEqual(segsBefore, segsAfter);\n    }\n\n    extractByEnvelope(env, geom, disjointGeoms) {\n      const intersectingGeoms = new ArrayList();\n\n      for (let i = 0; i < geom.getNumGeometries(); i++) {\n        const elem = geom.getGeometryN(i);\n\n        if (elem.getEnvelopeInternal().intersects(env)) {\n          intersectingGeoms.add(elem);\n        } else {\n          const copy = elem.copy();\n          disjointGeoms.add(copy);\n        }\n      }\n\n      return this._geomFactory.buildGeometry(intersectingGeoms);\n    }\n\n    isEqual(segs0, segs1) {\n      if (segs0.size() !== segs1.size()) return false;\n      const segIndex = new HashSet(segs0);\n\n      for (const seg of segs1) if (!segIndex.contains(seg)) return false;\n\n      return true;\n    }\n\n    union() {\n      const overlapEnv = OverlapUnion.overlapEnvelope(this._g0, this._g1);\n\n      if (overlapEnv.isNull()) {\n        const g0Copy = this._g0.copy();\n\n        const g1Copy = this._g1.copy();\n\n        return GeometryCombiner.combine(g0Copy, g1Copy);\n      }\n\n      const disjointPolys = new ArrayList();\n      const g0Overlap = this.extractByEnvelope(overlapEnv, this._g0, disjointPolys);\n      const g1Overlap = this.extractByEnvelope(overlapEnv, this._g1, disjointPolys);\n      const unionGeom = this.unionFull(g0Overlap, g1Overlap);\n      let result = null;\n      this._isUnionSafe = this.isBorderSegmentsSame(unionGeom, overlapEnv);\n      if (!this._isUnionSafe) result = this.unionFull(this._g0, this._g1);else result = this.combine(unionGeom, disjointPolys);\n      return result;\n    }\n\n    combine(unionGeom, disjointPolys) {\n      if (disjointPolys.size() <= 0) return unionGeom;\n      disjointPolys.add(unionGeom);\n      const result = GeometryCombiner.combine(disjointPolys);\n      return result;\n    }\n\n    unionFull(geom0, geom1) {\n      try {\n        return geom0.union(geom1);\n      } catch (ex) {\n        if (ex instanceof TopologyException) return OverlapUnion.unionBuffer(geom0, geom1);else throw ex;\n      } finally {}\n    }\n\n    extractBorderSegments(geom0, geom1, env) {\n      const segs = new ArrayList();\n      OverlapUnion.extractBorderSegments(geom0, env, segs);\n      if (geom1 !== null) OverlapUnion.extractBorderSegments(geom1, env, segs);\n      return segs;\n    }\n\n    isUnionOptimized() {\n      return this._isUnionSafe;\n    }\n\n  }\n\n  class CascadedPolygonUnion {\n    constructor() {\n      CascadedPolygonUnion.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._inputPolys = null;\n      this._geomFactory = null;\n      const polys = arguments[0];\n      this._inputPolys = polys;\n      if (this._inputPolys === null) this._inputPolys = new ArrayList();\n    }\n\n    static restrictToPolygons(g) {\n      if (hasInterface(g, Polygonal)) return g;\n      const polygons = PolygonExtracter.getPolygons(g);\n      if (polygons.size() === 1) return polygons.get(0);\n      return g.getFactory().createMultiPolygon(GeometryFactory.toPolygonArray(polygons));\n    }\n\n    static getGeometry(list, index) {\n      if (index >= list.size()) return null;\n      return list.get(index);\n    }\n\n    static union(polys) {\n      const op = new CascadedPolygonUnion(polys);\n      return op.union();\n    }\n\n    reduceToGeometries(geomTree) {\n      const geoms = new ArrayList();\n\n      for (let i = geomTree.iterator(); i.hasNext();) {\n        const o = i.next();\n        let geom = null;\n        if (hasInterface(o, List)) geom = this.unionTree(o);else if (o instanceof Geometry) geom = o;\n        geoms.add(geom);\n      }\n\n      return geoms;\n    }\n\n    union() {\n      if (this._inputPolys === null) throw new IllegalStateException('union() method cannot be called twice');\n      if (this._inputPolys.isEmpty()) return null;\n      this._geomFactory = this._inputPolys.iterator().next().getFactory();\n      const index = new STRtree(CascadedPolygonUnion.STRTREE_NODE_CAPACITY);\n\n      for (let i = this._inputPolys.iterator(); i.hasNext();) {\n        const item = i.next();\n        index.insert(item.getEnvelopeInternal(), item);\n      }\n\n      this._inputPolys = null;\n      const itemTree = index.itemsTree();\n      const unionAll = this.unionTree(itemTree);\n      return unionAll;\n    }\n\n    binaryUnion() {\n      if (arguments.length === 1) {\n        const geoms = arguments[0];\n        return this.binaryUnion(geoms, 0, geoms.size());\n      } else if (arguments.length === 3) {\n        const geoms = arguments[0],\n              start = arguments[1],\n              end = arguments[2];\n\n        if (end - start <= 1) {\n          const g0 = CascadedPolygonUnion.getGeometry(geoms, start);\n          return this.unionSafe(g0, null);\n        } else if (end - start === 2) {\n          return this.unionSafe(CascadedPolygonUnion.getGeometry(geoms, start), CascadedPolygonUnion.getGeometry(geoms, start + 1));\n        } else {\n          const mid = Math.trunc((end + start) / 2);\n          const g0 = this.binaryUnion(geoms, start, mid);\n          const g1 = this.binaryUnion(geoms, mid, end);\n          return this.unionSafe(g0, g1);\n        }\n      }\n    }\n\n    repeatedUnion(geoms) {\n      let union = null;\n\n      for (let i = geoms.iterator(); i.hasNext();) {\n        const g = i.next();\n        if (union === null) union = g.copy();else union = union.union(g);\n      }\n\n      return union;\n    }\n\n    unionSafe(g0, g1) {\n      if (g0 === null && g1 === null) return null;\n      if (g0 === null) return g1.copy();\n      if (g1 === null) return g0.copy();\n      return this.unionActual(g0, g1);\n    }\n\n    unionActual(g0, g1) {\n      const union = OverlapUnion.union(g0, g1);\n      return CascadedPolygonUnion.restrictToPolygons(union);\n    }\n\n    unionTree(geomTree) {\n      const geoms = this.reduceToGeometries(geomTree);\n      const union = this.binaryUnion(geoms);\n      return union;\n    }\n\n    bufferUnion() {\n      if (arguments.length === 1) {\n        const geoms = arguments[0];\n        const factory = geoms.get(0).getFactory();\n        const gColl = factory.buildGeometry(geoms);\n        const unionAll = gColl.buffer(0.0);\n        return unionAll;\n      } else if (arguments.length === 2) {\n        const g0 = arguments[0],\n              g1 = arguments[1];\n        const factory = g0.getFactory();\n        const gColl = factory.createGeometryCollection([g0, g1]);\n        const unionAll = gColl.buffer(0.0);\n        return unionAll;\n      }\n    }\n\n  }\n  CascadedPolygonUnion.STRTREE_NODE_CAPACITY = 4;\n\n  class UnaryUnionOp {\n    constructor() {\n      UnaryUnionOp.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._geomFact = null;\n      this._extracter = null;\n\n      if (arguments.length === 1) {\n        if (hasInterface(arguments[0], Collection)) {\n          const geoms = arguments[0];\n          this.extract(geoms);\n        } else if (arguments[0] instanceof Geometry) {\n          const geom = arguments[0];\n          this.extract(geom);\n        }\n      } else if (arguments.length === 2) {\n        const geoms = arguments[0],\n              geomFact = arguments[1];\n        this._geomFact = geomFact;\n        this.extract(geoms);\n      }\n    }\n\n    static union() {\n      if (arguments.length === 1) {\n        if (hasInterface(arguments[0], Collection)) {\n          const geoms = arguments[0];\n          const op = new UnaryUnionOp(geoms);\n          return op.union();\n        } else if (arguments[0] instanceof Geometry) {\n          const geom = arguments[0];\n          const op = new UnaryUnionOp(geom);\n          return op.union();\n        }\n      } else if (arguments.length === 2) {\n        const geoms = arguments[0],\n              geomFact = arguments[1];\n        const op = new UnaryUnionOp(geoms, geomFact);\n        return op.union();\n      }\n    }\n\n    unionNoOpt(g0) {\n      const empty = this._geomFact.createPoint();\n\n      return SnapIfNeededOverlayOp.overlayOp(g0, empty, OverlayOp.UNION);\n    }\n\n    unionWithNull(g0, g1) {\n      if (g0 === null && g1 === null) return null;\n      if (g1 === null) return g0;\n      if (g0 === null) return g1;\n      return g0.union(g1);\n    }\n\n    extract() {\n      if (hasInterface(arguments[0], Collection)) {\n        const geoms = arguments[0];\n        this._extracter = InputExtracter.extract(geoms);\n      } else if (arguments[0] instanceof Geometry) {\n        const geom = arguments[0];\n        this._extracter = InputExtracter.extract(geom);\n      }\n    }\n\n    union() {\n      if (this._geomFact === null) this._geomFact = this._extracter.getFactory();\n      if (this._geomFact === null) return null;\n      if (this._extracter.isEmpty()) return this._geomFact.createEmpty(this._extracter.getDimension());\n\n      const points = this._extracter.getExtract(0);\n\n      const lines = this._extracter.getExtract(1);\n\n      const polygons = this._extracter.getExtract(2);\n\n      let unionPoints = null;\n\n      if (points.size() > 0) {\n        const ptGeom = this._geomFact.buildGeometry(points);\n\n        unionPoints = this.unionNoOpt(ptGeom);\n      }\n\n      let unionLines = null;\n\n      if (lines.size() > 0) {\n        const lineGeom = this._geomFact.buildGeometry(lines);\n\n        unionLines = this.unionNoOpt(lineGeom);\n      }\n\n      let unionPolygons = null;\n      if (polygons.size() > 0) unionPolygons = CascadedPolygonUnion.union(polygons);\n      const unionLA = this.unionWithNull(unionLines, unionPolygons);\n      let union = null;\n      if (unionPoints === null) union = unionLA;else if (unionLA === null) union = unionPoints;else union = PointGeometryUnion.union(unionPoints, unionLA);\n      if (union === null) return this._geomFact.createGeometryCollection();\n      return union;\n    }\n\n  }\n\n  var union = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    UnaryUnionOp: UnaryUnionOp\n  });\n\n  var valid = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    IsValidOp: IsValidOp,\n    ConsistentAreaTester: ConsistentAreaTester\n  });\n\n  var operation = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    BoundaryOp: BoundaryOp,\n    IsSimpleOp: IsSimpleOp,\n    buffer: buffer,\n    distance: distance,\n    linemerge: linemerge,\n    overlay: overlay,\n    polygonize: polygonize,\n    relate: relate,\n    union: union,\n    valid: valid\n  });\n\n  class PrecisionReducerCoordinateOperation extends GeometryEditor.CoordinateOperation {\n    constructor() {\n      super();\n      PrecisionReducerCoordinateOperation.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._targetPM = null;\n      this._removeCollapsed = true;\n      const targetPM = arguments[0],\n            removeCollapsed = arguments[1];\n      this._targetPM = targetPM;\n      this._removeCollapsed = removeCollapsed;\n    }\n\n    edit() {\n      if (arguments.length === 2 && arguments[1] instanceof Geometry && arguments[0] instanceof Array) {\n        const coordinates = arguments[0],\n              geom = arguments[1];\n        if (coordinates.length === 0) return null;\n        const reducedCoords = new Array(coordinates.length).fill(null);\n\n        for (let i = 0; i < coordinates.length; i++) {\n          const coord = new Coordinate(coordinates[i]);\n\n          this._targetPM.makePrecise(coord);\n\n          reducedCoords[i] = coord;\n        }\n\n        const noRepeatedCoordList = new CoordinateList(reducedCoords, false);\n        const noRepeatedCoords = noRepeatedCoordList.toCoordinateArray();\n        let minLength = 0;\n        if (geom instanceof LineString) minLength = 2;\n        if (geom instanceof LinearRing) minLength = 4;\n        let collapsedCoords = reducedCoords;\n        if (this._removeCollapsed) collapsedCoords = null;\n        if (noRepeatedCoords.length < minLength) return collapsedCoords;\n        return noRepeatedCoords;\n      } else {\n        return super.edit.apply(this, arguments);\n      }\n    }\n\n  }\n\n  class GeometryPrecisionReducer {\n    constructor() {\n      GeometryPrecisionReducer.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._targetPM = null;\n      this._removeCollapsed = true;\n      this._changePrecisionModel = false;\n      this._isPointwise = false;\n      const pm = arguments[0];\n      this._targetPM = pm;\n    }\n\n    static reduce(g, precModel) {\n      const reducer = new GeometryPrecisionReducer(precModel);\n      return reducer.reduce(g);\n    }\n\n    static reducePointwise(g, precModel) {\n      const reducer = new GeometryPrecisionReducer(precModel);\n      reducer.setPointwise(true);\n      return reducer.reduce(g);\n    }\n\n    fixPolygonalTopology(geom) {\n      let geomToBuffer = geom;\n      if (!this._changePrecisionModel) geomToBuffer = this.changePM(geom, this._targetPM);\n      const bufGeom = BufferOp.bufferOp(geomToBuffer, 0);\n      return bufGeom;\n    }\n\n    reducePointwise(geom) {\n      let geomEdit = null;\n\n      if (this._changePrecisionModel) {\n        const newFactory = this.createFactory(geom.getFactory(), this._targetPM);\n        geomEdit = new GeometryEditor(newFactory);\n      } else {\n        geomEdit = new GeometryEditor();\n      }\n\n      let finalRemoveCollapsed = this._removeCollapsed;\n      if (geom.getDimension() >= 2) finalRemoveCollapsed = true;\n      const reduceGeom = geomEdit.edit(geom, new PrecisionReducerCoordinateOperation(this._targetPM, finalRemoveCollapsed));\n      return reduceGeom;\n    }\n\n    changePM(geom, newPM) {\n      const geomEditor = this.createEditor(geom.getFactory(), newPM);\n      return geomEditor.edit(geom, new GeometryEditor.NoOpGeometryOperation());\n    }\n\n    setRemoveCollapsedComponents(removeCollapsed) {\n      this._removeCollapsed = removeCollapsed;\n    }\n\n    createFactory(inputFactory, pm) {\n      const newFactory = new GeometryFactory(pm, inputFactory.getSRID(), inputFactory.getCoordinateSequenceFactory());\n      return newFactory;\n    }\n\n    setChangePrecisionModel(changePrecisionModel) {\n      this._changePrecisionModel = changePrecisionModel;\n    }\n\n    reduce(geom) {\n      const reducePW = this.reducePointwise(geom);\n      if (this._isPointwise) return reducePW;\n      if (!hasInterface(reducePW, Polygonal)) return reducePW;\n      if (IsValidOp.isValid(reducePW)) return reducePW;\n      return this.fixPolygonalTopology(reducePW);\n    }\n\n    setPointwise(isPointwise) {\n      this._isPointwise = isPointwise;\n    }\n\n    createEditor(geomFactory, newPM) {\n      if (geomFactory.getPrecisionModel() === newPM) return new GeometryEditor();\n      const newFactory = this.createFactory(geomFactory, newPM);\n      const geomEdit = new GeometryEditor(newFactory);\n      return geomEdit;\n    }\n\n  }\n\n  var precision = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    GeometryPrecisionReducer: GeometryPrecisionReducer\n  });\n\n  class DouglasPeuckerLineSimplifier {\n    constructor() {\n      DouglasPeuckerLineSimplifier.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._pts = null;\n      this._usePt = null;\n      this._distanceTolerance = null;\n      this._seg = new LineSegment();\n      const pts = arguments[0];\n      this._pts = pts;\n    }\n\n    static simplify(pts, distanceTolerance) {\n      const simp = new DouglasPeuckerLineSimplifier(pts);\n      simp.setDistanceTolerance(distanceTolerance);\n      return simp.simplify();\n    }\n\n    simplifySection(i, j) {\n      if (i + 1 === j) return null;\n      this._seg.p0 = this._pts[i];\n      this._seg.p1 = this._pts[j];\n      let maxDistance = -1.0;\n      let maxIndex = i;\n\n      for (let k = i + 1; k < j; k++) {\n        const distance = this._seg.distance(this._pts[k]);\n\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          maxIndex = k;\n        }\n      }\n\n      if (maxDistance <= this._distanceTolerance) {\n        for (let k = i + 1; k < j; k++) this._usePt[k] = false;\n      } else {\n        this.simplifySection(i, maxIndex);\n        this.simplifySection(maxIndex, j);\n      }\n    }\n\n    setDistanceTolerance(distanceTolerance) {\n      this._distanceTolerance = distanceTolerance;\n    }\n\n    simplify() {\n      this._usePt = new Array(this._pts.length).fill(null);\n\n      for (let i = 0; i < this._pts.length; i++) this._usePt[i] = true;\n\n      this.simplifySection(0, this._pts.length - 1);\n      const coordList = new CoordinateList();\n\n      for (let i = 0; i < this._pts.length; i++) if (this._usePt[i]) coordList.add(new Coordinate(this._pts[i]));\n\n      return coordList.toCoordinateArray();\n    }\n\n  }\n\n  class DouglasPeuckerSimplifier {\n    constructor() {\n      DouglasPeuckerSimplifier.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._inputGeom = null;\n      this._distanceTolerance = null;\n      this._isEnsureValidTopology = true;\n      const inputGeom = arguments[0];\n      this._inputGeom = inputGeom;\n    }\n\n    static simplify(geom, distanceTolerance) {\n      const tss = new DouglasPeuckerSimplifier(geom);\n      tss.setDistanceTolerance(distanceTolerance);\n      return tss.getResultGeometry();\n    }\n\n    setEnsureValid(isEnsureValidTopology) {\n      this._isEnsureValidTopology = isEnsureValidTopology;\n    }\n\n    getResultGeometry() {\n      if (this._inputGeom.isEmpty()) return this._inputGeom.copy();\n      return new DPTransformer(this._isEnsureValidTopology, this._distanceTolerance).transform(this._inputGeom);\n    }\n\n    setDistanceTolerance(distanceTolerance) {\n      if (distanceTolerance < 0.0) throw new IllegalArgumentException('Tolerance must be non-negative');\n      this._distanceTolerance = distanceTolerance;\n    }\n\n  }\n\n  class DPTransformer extends GeometryTransformer {\n    constructor() {\n      super();\n      DPTransformer.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._isEnsureValidTopology = true;\n      this._distanceTolerance = null;\n      const isEnsureValidTopology = arguments[0],\n            distanceTolerance = arguments[1];\n      this._isEnsureValidTopology = isEnsureValidTopology;\n      this._distanceTolerance = distanceTolerance;\n    }\n\n    transformPolygon(geom, parent) {\n      if (geom.isEmpty()) return null;\n      const rawGeom = super.transformPolygon.call(this, geom, parent);\n      if (parent instanceof MultiPolygon) return rawGeom;\n      return this.createValidArea(rawGeom);\n    }\n\n    createValidArea(rawAreaGeom) {\n      if (this._isEnsureValidTopology) return rawAreaGeom.buffer(0.0);\n      return rawAreaGeom;\n    }\n\n    transformCoordinates(coords, parent) {\n      const inputPts = coords.toCoordinateArray();\n      let newPts = null;\n      if (inputPts.length === 0) newPts = new Array(0).fill(null);else newPts = DouglasPeuckerLineSimplifier.simplify(inputPts, this._distanceTolerance);\n      return this._factory.getCoordinateSequenceFactory().create(newPts);\n    }\n\n    transformMultiPolygon(geom, parent) {\n      const rawGeom = super.transformMultiPolygon.call(this, geom, parent);\n      return this.createValidArea(rawGeom);\n    }\n\n    transformLinearRing(geom, parent) {\n      const removeDegenerateRings = parent instanceof Polygon;\n      const simpResult = super.transformLinearRing.call(this, geom, parent);\n      if (removeDegenerateRings && !(simpResult instanceof LinearRing)) return null;\n      return simpResult;\n    }\n\n  }\n\n  DouglasPeuckerSimplifier.DPTransformer = DPTransformer;\n\n  class TaggedLineSegment extends LineSegment {\n    constructor() {\n      super();\n      TaggedLineSegment.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._parent = null;\n      this._index = null;\n\n      if (arguments.length === 2) {\n        const p0 = arguments[0],\n              p1 = arguments[1];\n        TaggedLineSegment.constructor_.call(this, p0, p1, null, -1);\n      } else if (arguments.length === 4) {\n        const p0 = arguments[0],\n              p1 = arguments[1],\n              parent = arguments[2],\n              index = arguments[3];\n        LineSegment.constructor_.call(this, p0, p1);\n        this._parent = parent;\n        this._index = index;\n      }\n    }\n\n    getIndex() {\n      return this._index;\n    }\n\n    getParent() {\n      return this._parent;\n    }\n\n  }\n\n  class TaggedLineString {\n    constructor() {\n      TaggedLineString.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._parentLine = null;\n      this._segs = null;\n      this._resultSegs = new ArrayList();\n      this._minimumSize = null;\n\n      if (arguments.length === 1) {\n        const parentLine = arguments[0];\n        TaggedLineString.constructor_.call(this, parentLine, 2);\n      } else if (arguments.length === 2) {\n        const parentLine = arguments[0],\n              minimumSize = arguments[1];\n        this._parentLine = parentLine;\n        this._minimumSize = minimumSize;\n        this.init();\n      }\n    }\n\n    static extractCoordinates(segs) {\n      const pts = new Array(segs.size() + 1).fill(null);\n      let seg = null;\n\n      for (let i = 0; i < segs.size(); i++) {\n        seg = segs.get(i);\n        pts[i] = seg.p0;\n      }\n\n      pts[pts.length - 1] = seg.p1;\n      return pts;\n    }\n\n    addToResult(seg) {\n      this._resultSegs.add(seg);\n    }\n\n    asLineString() {\n      return this._parentLine.getFactory().createLineString(TaggedLineString.extractCoordinates(this._resultSegs));\n    }\n\n    getResultSize() {\n      const resultSegsSize = this._resultSegs.size();\n\n      return resultSegsSize === 0 ? 0 : resultSegsSize + 1;\n    }\n\n    getParent() {\n      return this._parentLine;\n    }\n\n    getSegment(i) {\n      return this._segs[i];\n    }\n\n    getParentCoordinates() {\n      return this._parentLine.getCoordinates();\n    }\n\n    getMinimumSize() {\n      return this._minimumSize;\n    }\n\n    asLinearRing() {\n      return this._parentLine.getFactory().createLinearRing(TaggedLineString.extractCoordinates(this._resultSegs));\n    }\n\n    getSegments() {\n      return this._segs;\n    }\n\n    init() {\n      const pts = this._parentLine.getCoordinates();\n\n      this._segs = new Array(pts.length - 1).fill(null);\n\n      for (let i = 0; i < pts.length - 1; i++) {\n        const seg = new TaggedLineSegment(pts[i], pts[i + 1], this._parentLine, i);\n        this._segs[i] = seg;\n      }\n    }\n\n    getResultCoordinates() {\n      return TaggedLineString.extractCoordinates(this._resultSegs);\n    }\n\n  }\n\n  class LineSegmentIndex {\n    constructor() {\n      LineSegmentIndex.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._index = new Quadtree();\n    }\n\n    remove(seg) {\n      this._index.remove(new Envelope(seg.p0, seg.p1), seg);\n    }\n\n    add() {\n      if (arguments[0] instanceof TaggedLineString) {\n        const line = arguments[0];\n        const segs = line.getSegments();\n\n        for (let i = 0; i < segs.length; i++) {\n          const seg = segs[i];\n          this.add(seg);\n        }\n      } else if (arguments[0] instanceof LineSegment) {\n        const seg = arguments[0];\n\n        this._index.insert(new Envelope(seg.p0, seg.p1), seg);\n      }\n    }\n\n    query(querySeg) {\n      const env = new Envelope(querySeg.p0, querySeg.p1);\n      const visitor = new LineSegmentVisitor(querySeg);\n\n      this._index.query(env, visitor);\n\n      const itemsFound = visitor.getItems();\n      return itemsFound;\n    }\n\n  }\n\n  class LineSegmentVisitor {\n    constructor() {\n      LineSegmentVisitor.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._querySeg = null;\n      this._items = new ArrayList();\n      const querySeg = arguments[0];\n      this._querySeg = querySeg;\n    }\n\n    visitItem(item) {\n      const seg = item;\n      if (Envelope.intersects(seg.p0, seg.p1, this._querySeg.p0, this._querySeg.p1)) this._items.add(item);\n    }\n\n    getItems() {\n      return this._items;\n    }\n\n    get interfaces_() {\n      return [ItemVisitor];\n    }\n\n  }\n\n  class TaggedLineStringSimplifier {\n    constructor() {\n      TaggedLineStringSimplifier.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._li = new RobustLineIntersector();\n      this._inputIndex = new LineSegmentIndex();\n      this._outputIndex = new LineSegmentIndex();\n      this._line = null;\n      this._linePts = null;\n      this._distanceTolerance = 0.0;\n      const inputIndex = arguments[0],\n            outputIndex = arguments[1];\n      this._inputIndex = inputIndex;\n      this._outputIndex = outputIndex;\n    }\n\n    static isInLineSection(line, sectionIndex, seg) {\n      if (seg.getParent() !== line.getParent()) return false;\n      const segIndex = seg.getIndex();\n      if (segIndex >= sectionIndex[0] && segIndex < sectionIndex[1]) return true;\n      return false;\n    }\n\n    flatten(start, end) {\n      const p0 = this._linePts[start];\n      const p1 = this._linePts[end];\n      const newSeg = new LineSegment(p0, p1);\n      this.remove(this._line, start, end);\n\n      this._outputIndex.add(newSeg);\n\n      return newSeg;\n    }\n\n    hasBadIntersection(parentLine, sectionIndex, candidateSeg) {\n      if (this.hasBadOutputIntersection(candidateSeg)) return true;\n      if (this.hasBadInputIntersection(parentLine, sectionIndex, candidateSeg)) return true;\n      return false;\n    }\n\n    setDistanceTolerance(distanceTolerance) {\n      this._distanceTolerance = distanceTolerance;\n    }\n\n    simplifySection(i, j, depth) {\n      depth += 1;\n      const sectionIndex = new Array(2).fill(null);\n\n      if (i + 1 === j) {\n        const newSeg = this._line.getSegment(i);\n\n        this._line.addToResult(newSeg);\n\n        return null;\n      }\n\n      let isValidToSimplify = true;\n\n      if (this._line.getResultSize() < this._line.getMinimumSize()) {\n        const worstCaseSize = depth + 1;\n        if (worstCaseSize < this._line.getMinimumSize()) isValidToSimplify = false;\n      }\n\n      const distance = new Array(1).fill(null);\n      const furthestPtIndex = this.findFurthestPoint(this._linePts, i, j, distance);\n      if (distance[0] > this._distanceTolerance) isValidToSimplify = false;\n      const candidateSeg = new LineSegment();\n      candidateSeg.p0 = this._linePts[i];\n      candidateSeg.p1 = this._linePts[j];\n      sectionIndex[0] = i;\n      sectionIndex[1] = j;\n      if (this.hasBadIntersection(this._line, sectionIndex, candidateSeg)) isValidToSimplify = false;\n\n      if (isValidToSimplify) {\n        const newSeg = this.flatten(i, j);\n\n        this._line.addToResult(newSeg);\n\n        return null;\n      }\n\n      this.simplifySection(i, furthestPtIndex, depth);\n      this.simplifySection(furthestPtIndex, j, depth);\n    }\n\n    hasBadOutputIntersection(candidateSeg) {\n      const querySegs = this._outputIndex.query(candidateSeg);\n\n      for (let i = querySegs.iterator(); i.hasNext();) {\n        const querySeg = i.next();\n        if (this.hasInteriorIntersection(querySeg, candidateSeg)) return true;\n      }\n\n      return false;\n    }\n\n    findFurthestPoint(pts, i, j, maxDistance) {\n      const seg = new LineSegment();\n      seg.p0 = pts[i];\n      seg.p1 = pts[j];\n      let maxDist = -1.0;\n      let maxIndex = i;\n\n      for (let k = i + 1; k < j; k++) {\n        const midPt = pts[k];\n        const distance = seg.distance(midPt);\n\n        if (distance > maxDist) {\n          maxDist = distance;\n          maxIndex = k;\n        }\n      }\n\n      maxDistance[0] = maxDist;\n      return maxIndex;\n    }\n\n    simplify(line) {\n      this._line = line;\n      this._linePts = line.getParentCoordinates();\n      this.simplifySection(0, this._linePts.length - 1, 0);\n    }\n\n    remove(line, start, end) {\n      for (let i = start; i < end; i++) {\n        const seg = line.getSegment(i);\n\n        this._inputIndex.remove(seg);\n      }\n    }\n\n    hasInteriorIntersection(seg0, seg1) {\n      this._li.computeIntersection(seg0.p0, seg0.p1, seg1.p0, seg1.p1);\n\n      return this._li.isInteriorIntersection();\n    }\n\n    hasBadInputIntersection(parentLine, sectionIndex, candidateSeg) {\n      const querySegs = this._inputIndex.query(candidateSeg);\n\n      for (let i = querySegs.iterator(); i.hasNext();) {\n        const querySeg = i.next();\n\n        if (this.hasInteriorIntersection(querySeg, candidateSeg)) {\n          if (TaggedLineStringSimplifier.isInLineSection(parentLine, sectionIndex, querySeg)) continue;\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n  }\n\n  class TaggedLinesSimplifier {\n    constructor() {\n      TaggedLinesSimplifier.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._inputIndex = new LineSegmentIndex();\n      this._outputIndex = new LineSegmentIndex();\n      this._distanceTolerance = 0.0;\n    }\n\n    setDistanceTolerance(distanceTolerance) {\n      this._distanceTolerance = distanceTolerance;\n    }\n\n    simplify(taggedLines) {\n      for (let i = taggedLines.iterator(); i.hasNext();) this._inputIndex.add(i.next());\n\n      for (let i = taggedLines.iterator(); i.hasNext();) {\n        const tlss = new TaggedLineStringSimplifier(this._inputIndex, this._outputIndex);\n        tlss.setDistanceTolerance(this._distanceTolerance);\n        tlss.simplify(i.next());\n      }\n    }\n\n  }\n\n  class TopologyPreservingSimplifier {\n    constructor() {\n      TopologyPreservingSimplifier.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._inputGeom = null;\n      this._lineSimplifier = new TaggedLinesSimplifier();\n      this._linestringMap = null;\n      const inputGeom = arguments[0];\n      this._inputGeom = inputGeom;\n    }\n\n    static simplify(geom, distanceTolerance) {\n      const tss = new TopologyPreservingSimplifier(geom);\n      tss.setDistanceTolerance(distanceTolerance);\n      return tss.getResultGeometry();\n    }\n\n    getResultGeometry() {\n      if (this._inputGeom.isEmpty()) return this._inputGeom.copy();\n      this._linestringMap = new HashMap();\n\n      this._inputGeom.apply(new LineStringMapBuilderFilter(this));\n\n      this._lineSimplifier.simplify(this._linestringMap.values());\n\n      const result = new LineStringTransformer(this._linestringMap).transform(this._inputGeom);\n      return result;\n    }\n\n    setDistanceTolerance(distanceTolerance) {\n      if (distanceTolerance < 0.0) throw new IllegalArgumentException('Tolerance must be non-negative');\n\n      this._lineSimplifier.setDistanceTolerance(distanceTolerance);\n    }\n\n  }\n\n  class LineStringTransformer extends GeometryTransformer {\n    constructor() {\n      super();\n      LineStringTransformer.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._linestringMap = null;\n      const linestringMap = arguments[0];\n      this._linestringMap = linestringMap;\n    }\n\n    transformCoordinates(coords, parent) {\n      if (coords.size() === 0) return null;\n\n      if (parent instanceof LineString) {\n        const taggedLine = this._linestringMap.get(parent);\n\n        return this.createCoordinateSequence(taggedLine.getResultCoordinates());\n      }\n\n      return super.transformCoordinates.call(this, coords, parent);\n    }\n\n  }\n\n  class LineStringMapBuilderFilter {\n    constructor() {\n      LineStringMapBuilderFilter.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.tps = null;\n      const tps = arguments[0];\n      this.tps = tps;\n    }\n\n    filter(geom) {\n      if (geom instanceof LineString) {\n        const line = geom;\n        if (line.isEmpty()) return null;\n        const minSize = line.isClosed() ? 4 : 2;\n        const taggedLine = new TaggedLineString(line, minSize);\n\n        this.tps._linestringMap.put(line, taggedLine);\n      }\n    }\n\n    get interfaces_() {\n      return [GeometryComponentFilter];\n    }\n\n  }\n\n  TopologyPreservingSimplifier.LineStringTransformer = LineStringTransformer;\n  TopologyPreservingSimplifier.LineStringMapBuilderFilter = LineStringMapBuilderFilter;\n\n  class VWLineSimplifier {\n    constructor() {\n      VWLineSimplifier.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._pts = null;\n      this._tolerance = null;\n      const pts = arguments[0],\n            distanceTolerance = arguments[1];\n      this._pts = pts;\n      this._tolerance = distanceTolerance * distanceTolerance;\n    }\n\n    static simplify(pts, distanceTolerance) {\n      const simp = new VWLineSimplifier(pts, distanceTolerance);\n      return simp.simplify();\n    }\n\n    simplifyVertex(vwLine) {\n      let curr = vwLine;\n      let minArea = curr.getArea();\n      let minVertex = null;\n\n      while (curr !== null) {\n        const area = curr.getArea();\n\n        if (area < minArea) {\n          minArea = area;\n          minVertex = curr;\n        }\n\n        curr = curr._next;\n      }\n\n      if (minVertex !== null && minArea < this._tolerance) minVertex.remove();\n      if (!vwLine.isLive()) return -1;\n      return minArea;\n    }\n\n    simplify() {\n      const vwLine = VWVertex.buildLine(this._pts);\n      let minArea = this._tolerance;\n\n      do minArea = this.simplifyVertex(vwLine); while (minArea < this._tolerance);\n\n      const simp = vwLine.getCoordinates();\n      if (simp.length < 2) return [simp[0], new Coordinate(simp[0])];\n      return simp;\n    }\n\n  }\n\n  class VWVertex {\n    constructor() {\n      VWVertex.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._pt = null;\n      this._prev = null;\n      this._next = null;\n      this._area = VWVertex.MAX_AREA;\n      this._isLive = true;\n      const pt = arguments[0];\n      this._pt = pt;\n    }\n\n    static buildLine(pts) {\n      let first = null;\n      let prev = null;\n\n      for (let i = 0; i < pts.length; i++) {\n        const v = new VWVertex(pts[i]);\n        if (first === null) first = v;\n        v.setPrev(prev);\n\n        if (prev !== null) {\n          prev.setNext(v);\n          prev.updateArea();\n        }\n\n        prev = v;\n      }\n\n      return first;\n    }\n\n    getCoordinates() {\n      const coords = new CoordinateList();\n      let curr = this;\n\n      do {\n        coords.add(curr._pt, false);\n        curr = curr._next;\n      } while (curr !== null);\n\n      return coords.toCoordinateArray();\n    }\n\n    getArea() {\n      return this._area;\n    }\n\n    updateArea() {\n      if (this._prev === null || this._next === null) {\n        this._area = VWVertex.MAX_AREA;\n        return null;\n      }\n\n      this._area = Math.abs(Triangle.area(this._prev._pt, this._pt, this._next._pt));\n    }\n\n    remove() {\n      const tmpPrev = this._prev;\n      const tmpNext = this._next;\n      let result = null;\n\n      if (this._prev !== null) {\n        this._prev.setNext(tmpNext);\n\n        this._prev.updateArea();\n\n        result = this._prev;\n      }\n\n      if (this._next !== null) {\n        this._next.setPrev(tmpPrev);\n\n        this._next.updateArea();\n\n        if (result === null) result = this._next;\n      }\n\n      this._isLive = false;\n      return result;\n    }\n\n    isLive() {\n      return this._isLive;\n    }\n\n    setPrev(prev) {\n      this._prev = prev;\n    }\n\n    setNext(next) {\n      this._next = next;\n    }\n\n  }\n\n  VWVertex.MAX_AREA = Double.MAX_VALUE;\n  VWLineSimplifier.VWVertex = VWVertex;\n\n  class VWSimplifier {\n    constructor() {\n      VWSimplifier.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._inputGeom = null;\n      this._distanceTolerance = null;\n      this._isEnsureValidTopology = true;\n      const inputGeom = arguments[0];\n      this._inputGeom = inputGeom;\n    }\n\n    static simplify(geom, distanceTolerance) {\n      const simp = new VWSimplifier(geom);\n      simp.setDistanceTolerance(distanceTolerance);\n      return simp.getResultGeometry();\n    }\n\n    setEnsureValid(isEnsureValidTopology) {\n      this._isEnsureValidTopology = isEnsureValidTopology;\n    }\n\n    getResultGeometry() {\n      if (this._inputGeom.isEmpty()) return this._inputGeom.copy();\n      return new VWTransformer(this._isEnsureValidTopology, this._distanceTolerance).transform(this._inputGeom);\n    }\n\n    setDistanceTolerance(distanceTolerance) {\n      if (distanceTolerance < 0.0) throw new IllegalArgumentException('Tolerance must be non-negative');\n      this._distanceTolerance = distanceTolerance;\n    }\n\n  }\n\n  class VWTransformer extends GeometryTransformer {\n    constructor() {\n      super();\n      VWTransformer.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._isEnsureValidTopology = true;\n      this._distanceTolerance = null;\n      const isEnsureValidTopology = arguments[0],\n            distanceTolerance = arguments[1];\n      this._isEnsureValidTopology = isEnsureValidTopology;\n      this._distanceTolerance = distanceTolerance;\n    }\n\n    transformPolygon(geom, parent) {\n      if (geom.isEmpty()) return null;\n      const rawGeom = super.transformPolygon.call(this, geom, parent);\n      if (parent instanceof MultiPolygon) return rawGeom;\n      return this.createValidArea(rawGeom);\n    }\n\n    createValidArea(rawAreaGeom) {\n      if (this._isEnsureValidTopology) return rawAreaGeom.buffer(0.0);\n      return rawAreaGeom;\n    }\n\n    transformCoordinates(coords, parent) {\n      const inputPts = coords.toCoordinateArray();\n      let newPts = null;\n      if (inputPts.length === 0) newPts = new Array(0).fill(null);else newPts = VWLineSimplifier.simplify(inputPts, this._distanceTolerance);\n      return this._factory.getCoordinateSequenceFactory().create(newPts);\n    }\n\n    transformMultiPolygon(geom, parent) {\n      const rawGeom = super.transformMultiPolygon.call(this, geom, parent);\n      return this.createValidArea(rawGeom);\n    }\n\n    transformLinearRing(geom, parent) {\n      const removeDegenerateRings = parent instanceof Polygon;\n      const simpResult = super.transformLinearRing.call(this, geom, parent);\n      if (removeDegenerateRings && !(simpResult instanceof LinearRing)) return null;\n      return simpResult;\n    }\n\n  }\n\n  VWSimplifier.VWTransformer = VWTransformer;\n\n  var simplify = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    DouglasPeuckerSimplifier: DouglasPeuckerSimplifier,\n    TopologyPreservingSimplifier: TopologyPreservingSimplifier,\n    VWSimplifier: VWSimplifier\n  });\n\n  class SplitSegment {\n    constructor() {\n      SplitSegment.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._seg = null;\n      this._segLen = null;\n      this._splitPt = null;\n      this._minimumLen = 0.0;\n      const seg = arguments[0];\n      this._seg = seg;\n      this._segLen = seg.getLength();\n    }\n\n    static pointAlongReverse(seg, segmentLengthFraction) {\n      const coord = new Coordinate();\n      coord.x = seg.p1.x - segmentLengthFraction * (seg.p1.x - seg.p0.x);\n      coord.y = seg.p1.y - segmentLengthFraction * (seg.p1.y - seg.p0.y);\n      return coord;\n    }\n\n    splitAt() {\n      if (arguments.length === 1) {\n        const pt = arguments[0];\n        const minFrac = this._minimumLen / this._segLen;\n\n        if (pt.distance(this._seg.p0) < this._minimumLen) {\n          this._splitPt = this._seg.pointAlong(minFrac);\n          return null;\n        }\n\n        if (pt.distance(this._seg.p1) < this._minimumLen) {\n          this._splitPt = SplitSegment.pointAlongReverse(this._seg, minFrac);\n          return null;\n        }\n\n        this._splitPt = pt;\n      } else if (arguments.length === 2) {\n        const length = arguments[0],\n              endPt = arguments[1];\n        const actualLen = this.getConstrainedLength(length);\n        const frac = actualLen / this._segLen;\n        if (endPt.equals2D(this._seg.p0)) this._splitPt = this._seg.pointAlong(frac);else this._splitPt = SplitSegment.pointAlongReverse(this._seg, frac);\n      }\n    }\n\n    setMinimumLength(minLen) {\n      this._minimumLen = minLen;\n    }\n\n    getConstrainedLength(len) {\n      if (len < this._minimumLen) return this._minimumLen;\n      return len;\n    }\n\n    getSplitPoint() {\n      return this._splitPt;\n    }\n\n  }\n\n  class ConstraintSplitPointFinder {\n    findSplitPoint(seg, encroachPt) {}\n\n  }\n\n  class NonEncroachingSplitPointFinder {\n    static projectedSplitPoint(seg, encroachPt) {\n      const lineSeg = seg.getLineSegment();\n      const projPt = lineSeg.project(encroachPt);\n      return projPt;\n    }\n\n    findSplitPoint(seg, encroachPt) {\n      const lineSeg = seg.getLineSegment();\n      const segLen = lineSeg.getLength();\n      const midPtLen = segLen / 2;\n      const splitSeg = new SplitSegment(lineSeg);\n      const projPt = NonEncroachingSplitPointFinder.projectedSplitPoint(seg, encroachPt);\n      const nonEncroachDiam = projPt.distance(encroachPt) * 2 * 0.8;\n      let maxSplitLen = nonEncroachDiam;\n      if (maxSplitLen > midPtLen) maxSplitLen = midPtLen;\n      splitSeg.setMinimumLength(maxSplitLen);\n      splitSeg.splitAt(projPt);\n      return splitSeg.getSplitPoint();\n    }\n\n    get interfaces_() {\n      return [ConstraintSplitPointFinder];\n    }\n\n  }\n\n  class TrianglePredicate {\n    static triArea(a, b, c) {\n      return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    }\n\n    static isInCircleDDNormalized(a, b, c, p) {\n      const adx = DD.valueOf(a.x).selfSubtract(p.x);\n      const ady = DD.valueOf(a.y).selfSubtract(p.y);\n      const bdx = DD.valueOf(b.x).selfSubtract(p.x);\n      const bdy = DD.valueOf(b.y).selfSubtract(p.y);\n      const cdx = DD.valueOf(c.x).selfSubtract(p.x);\n      const cdy = DD.valueOf(c.y).selfSubtract(p.y);\n      const abdet = adx.multiply(bdy).selfSubtract(bdx.multiply(ady));\n      const bcdet = bdx.multiply(cdy).selfSubtract(cdx.multiply(bdy));\n      const cadet = cdx.multiply(ady).selfSubtract(adx.multiply(cdy));\n      const alift = adx.multiply(adx).selfAdd(ady.multiply(ady));\n      const blift = bdx.multiply(bdx).selfAdd(bdy.multiply(bdy));\n      const clift = cdx.multiply(cdx).selfAdd(cdy.multiply(cdy));\n      const sum = alift.selfMultiply(bcdet).selfAdd(blift.selfMultiply(cadet)).selfAdd(clift.selfMultiply(abdet));\n      const isInCircle = sum.doubleValue() > 0;\n      return isInCircle;\n    }\n\n    static checkRobustInCircle(a, b, c, p) {\n      const nonRobustInCircle = TrianglePredicate.isInCircleNonRobust(a, b, c, p);\n      const isInCircleDD = TrianglePredicate.isInCircleDDSlow(a, b, c, p);\n      const isInCircleCC = TrianglePredicate.isInCircleCC(a, b, c, p);\n      const circumCentre = Triangle.circumcentre(a, b, c);\n      System.out.println('p radius diff a = ' + Math.abs(p.distance(circumCentre) - a.distance(circumCentre)) / a.distance(circumCentre));\n\n      if (nonRobustInCircle !== isInCircleDD || nonRobustInCircle !== isInCircleCC) {\n        System.out.println('inCircle robustness failure (double result = ' + nonRobustInCircle + ', DD result = ' + isInCircleDD + ', CC result = ' + isInCircleCC + ')');\n        System.out.println(WKTWriter.toLineString(new CoordinateArraySequence([a, b, c, p])));\n        System.out.println('Circumcentre = ' + WKTWriter.toPoint(circumCentre) + ' radius = ' + a.distance(circumCentre));\n        System.out.println('p radius diff a = ' + Math.abs(p.distance(circumCentre) / a.distance(circumCentre) - 1));\n        System.out.println('p radius diff b = ' + Math.abs(p.distance(circumCentre) / b.distance(circumCentre) - 1));\n        System.out.println('p radius diff c = ' + Math.abs(p.distance(circumCentre) / c.distance(circumCentre) - 1));\n        System.out.println();\n      }\n    }\n\n    static isInCircleDDFast(a, b, c, p) {\n      const aTerm = DD.sqr(a.x).selfAdd(DD.sqr(a.y)).selfMultiply(TrianglePredicate.triAreaDDFast(b, c, p));\n      const bTerm = DD.sqr(b.x).selfAdd(DD.sqr(b.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, c, p));\n      const cTerm = DD.sqr(c.x).selfAdd(DD.sqr(c.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, b, p));\n      const pTerm = DD.sqr(p.x).selfAdd(DD.sqr(p.y)).selfMultiply(TrianglePredicate.triAreaDDFast(a, b, c));\n      const sum = aTerm.selfSubtract(bTerm).selfAdd(cTerm).selfSubtract(pTerm);\n      const isInCircle = sum.doubleValue() > 0;\n      return isInCircle;\n    }\n\n    static isInCircleCC(a, b, c, p) {\n      const cc = Triangle.circumcentre(a, b, c);\n      const ccRadius = a.distance(cc);\n      const pRadiusDiff = p.distance(cc) - ccRadius;\n      return pRadiusDiff <= 0;\n    }\n\n    static isInCircleNormalized(a, b, c, p) {\n      const adx = a.x - p.x;\n      const ady = a.y - p.y;\n      const bdx = b.x - p.x;\n      const bdy = b.y - p.y;\n      const cdx = c.x - p.x;\n      const cdy = c.y - p.y;\n      const abdet = adx * bdy - bdx * ady;\n      const bcdet = bdx * cdy - cdx * bdy;\n      const cadet = cdx * ady - adx * cdy;\n      const alift = adx * adx + ady * ady;\n      const blift = bdx * bdx + bdy * bdy;\n      const clift = cdx * cdx + cdy * cdy;\n      const disc = alift * bcdet + blift * cadet + clift * abdet;\n      return disc > 0;\n    }\n\n    static isInCircleDDSlow(a, b, c, p) {\n      const px = DD.valueOf(p.x);\n      const py = DD.valueOf(p.y);\n      const ax = DD.valueOf(a.x);\n      const ay = DD.valueOf(a.y);\n      const bx = DD.valueOf(b.x);\n      const by = DD.valueOf(b.y);\n      const cx = DD.valueOf(c.x);\n      const cy = DD.valueOf(c.y);\n      const aTerm = ax.multiply(ax).add(ay.multiply(ay)).multiply(TrianglePredicate.triAreaDDSlow(bx, by, cx, cy, px, py));\n      const bTerm = bx.multiply(bx).add(by.multiply(by)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, cx, cy, px, py));\n      const cTerm = cx.multiply(cx).add(cy.multiply(cy)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, bx, by, px, py));\n      const pTerm = px.multiply(px).add(py.multiply(py)).multiply(TrianglePredicate.triAreaDDSlow(ax, ay, bx, by, cx, cy));\n      const sum = aTerm.subtract(bTerm).add(cTerm).subtract(pTerm);\n      const isInCircle = sum.doubleValue() > 0;\n      return isInCircle;\n    }\n\n    static isInCircleNonRobust(a, b, c, p) {\n      const isInCircle = (a.x * a.x + a.y * a.y) * TrianglePredicate.triArea(b, c, p) - (b.x * b.x + b.y * b.y) * TrianglePredicate.triArea(a, c, p) + (c.x * c.x + c.y * c.y) * TrianglePredicate.triArea(a, b, p) - (p.x * p.x + p.y * p.y) * TrianglePredicate.triArea(a, b, c) > 0;\n      return isInCircle;\n    }\n\n    static isInCircleRobust(a, b, c, p) {\n      return TrianglePredicate.isInCircleNormalized(a, b, c, p);\n    }\n\n    static triAreaDDSlow(ax, ay, bx, by, cx, cy) {\n      return bx.subtract(ax).multiply(cy.subtract(ay)).subtract(by.subtract(ay).multiply(cx.subtract(ax)));\n    }\n\n    static triAreaDDFast(a, b, c) {\n      const t1 = DD.valueOf(b.x).selfSubtract(a.x).selfMultiply(DD.valueOf(c.y).selfSubtract(a.y));\n      const t2 = DD.valueOf(b.y).selfSubtract(a.y).selfMultiply(DD.valueOf(c.x).selfSubtract(a.x));\n      return t1.selfSubtract(t2);\n    }\n\n  }\n\n  class Vertex {\n    constructor() {\n      Vertex.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._p = null;\n\n      if (arguments.length === 1) {\n        const _p = arguments[0];\n        this._p = new Coordinate(_p);\n      } else if (arguments.length === 2) {\n        const _x = arguments[0],\n              _y = arguments[1];\n        this._p = new Coordinate(_x, _y);\n      } else if (arguments.length === 3) {\n        const _x = arguments[0],\n              _y = arguments[1],\n              _z = arguments[2];\n        this._p = new Coordinate(_x, _y, _z);\n      }\n    }\n\n    static interpolateZ() {\n      if (arguments.length === 3) {\n        const p = arguments[0],\n              p0 = arguments[1],\n              p1 = arguments[2];\n        const segLen = p0.distance(p1);\n        const ptLen = p.distance(p0);\n        const dz = p1.getZ() - p0.getZ();\n        const pz = p0.getZ() + dz * (ptLen / segLen);\n        return pz;\n      } else if (arguments.length === 4) {\n        const p = arguments[0],\n              v0 = arguments[1],\n              v1 = arguments[2],\n              v2 = arguments[3];\n        const x0 = v0.x;\n        const y0 = v0.y;\n        const a = v1.x - x0;\n        const b = v2.x - x0;\n        const c = v1.y - y0;\n        const d = v2.y - y0;\n        const det = a * d - b * c;\n        const dx = p.x - x0;\n        const dy = p.y - y0;\n        const t = (d * dx - b * dy) / det;\n        const u = (-c * dx + a * dy) / det;\n        const z = v0.getZ() + t * (v1.getZ() - v0.getZ()) + u * (v2.getZ() - v0.getZ());\n        return z;\n      }\n    }\n\n    circleCenter(b, c) {\n      const a = new Vertex(this.getX(), this.getY());\n      const cab = this.bisector(a, b);\n      const cbc = this.bisector(b, c);\n      const hcc = new HCoordinate(cab, cbc);\n      let cc = null;\n\n      try {\n        cc = new Vertex(hcc.getX(), hcc.getY());\n      } catch (nre) {\n        if (nre instanceof NotRepresentableException) {\n          System.err.println('a: ' + a + '  b: ' + b + '  c: ' + c);\n          System.err.println(nre);\n        } else {\n          throw nre;\n        }\n      } finally {}\n\n      return cc;\n    }\n\n    dot(v) {\n      return this._p.x * v.getX() + this._p.y * v.getY();\n    }\n\n    magn() {\n      return Math.sqrt(this._p.x * this._p.x + this._p.y * this._p.y);\n    }\n\n    getZ() {\n      return this._p.getZ();\n    }\n\n    bisector(a, b) {\n      const dx = b.getX() - a.getX();\n      const dy = b.getY() - a.getY();\n      const l1 = new HCoordinate(a.getX() + dx / 2.0, a.getY() + dy / 2.0, 1.0);\n      const l2 = new HCoordinate(a.getX() - dy + dx / 2.0, a.getY() + dx + dy / 2.0, 1.0);\n      return new HCoordinate(l1, l2);\n    }\n\n    equals() {\n      if (arguments.length === 1) {\n        const _x = arguments[0];\n        if (this._p.x === _x.getX() && this._p.y === _x.getY()) return true;else return false;\n      } else if (arguments.length === 2) {\n        const _x = arguments[0],\n              tolerance = arguments[1];\n        if (this._p.distance(_x.getCoordinate()) < tolerance) return true;else return false;\n      }\n    }\n\n    getCoordinate() {\n      return this._p;\n    }\n\n    isInCircle(a, b, c) {\n      return TrianglePredicate.isInCircleRobust(a._p, b._p, c._p, this._p);\n    }\n\n    interpolateZValue(v0, v1, v2) {\n      const x0 = v0.getX();\n      const y0 = v0.getY();\n      const a = v1.getX() - x0;\n      const b = v2.getX() - x0;\n      const c = v1.getY() - y0;\n      const d = v2.getY() - y0;\n      const det = a * d - b * c;\n      const dx = this.getX() - x0;\n      const dy = this.getY() - y0;\n      const t = (d * dx - b * dy) / det;\n      const u = (-c * dx + a * dy) / det;\n      const z = v0.getZ() + t * (v1.getZ() - v0.getZ()) + u * (v2.getZ() - v0.getZ());\n      return z;\n    }\n\n    midPoint(a) {\n      const xm = (this._p.x + a.getX()) / 2.0;\n      const ym = (this._p.y + a.getY()) / 2.0;\n      const zm = (this._p.getZ() + a.getZ()) / 2.0;\n      return new Vertex(xm, ym, zm);\n    }\n\n    rightOf(e) {\n      return this.isCCW(e.dest(), e.orig());\n    }\n\n    isCCW(b, c) {\n      return (b._p.x - this._p.x) * (c._p.y - this._p.y) - (b._p.y - this._p.y) * (c._p.x - this._p.x) > 0;\n    }\n\n    getX() {\n      return this._p.x;\n    }\n\n    crossProduct(v) {\n      return this._p.x * v.getY() - this._p.y * v.getX();\n    }\n\n    setZ(_z) {\n      this._p.setZ(_z);\n    }\n\n    times(c) {\n      return new Vertex(c * this._p.x, c * this._p.y);\n    }\n\n    cross() {\n      return new Vertex(this._p.y, -this._p.x);\n    }\n\n    leftOf(e) {\n      return this.isCCW(e.orig(), e.dest());\n    }\n\n    toString() {\n      return 'POINT (' + this._p.x + ' ' + this._p.y + ')';\n    }\n\n    sub(v) {\n      return new Vertex(this._p.x - v.getX(), this._p.y - v.getY());\n    }\n\n    getY() {\n      return this._p.y;\n    }\n\n    classify(p0, p1) {\n      const p2 = this;\n      const a = p1.sub(p0);\n      const b = p2.sub(p0);\n      const sa = a.crossProduct(b);\n      if (sa > 0.0) return Vertex.LEFT;\n      if (sa < 0.0) return Vertex.RIGHT;\n      if (a.getX() * b.getX() < 0.0 || a.getY() * b.getY() < 0.0) return Vertex.BEHIND;\n      if (a.magn() < b.magn()) return Vertex.BEYOND;\n      if (p0.equals(p2)) return Vertex.ORIGIN;\n      if (p1.equals(p2)) return Vertex.DESTINATION;\n      return Vertex.BETWEEN;\n    }\n\n    sum(v) {\n      return new Vertex(this._p.x + v.getX(), this._p.y + v.getY());\n    }\n\n    distance(v1, v2) {\n      return Math.sqrt(Math.pow(v2.getX() - v1.getX(), 2.0) + Math.pow(v2.getY() - v1.getY(), 2.0));\n    }\n\n    circumRadiusRatio(b, c) {\n      const x = this.circleCenter(b, c);\n      const radius = this.distance(x, b);\n      let edgeLength = this.distance(this, b);\n      let el = this.distance(b, c);\n      if (el < edgeLength) edgeLength = el;\n      el = this.distance(c, this);\n      if (el < edgeLength) edgeLength = el;\n      return radius / edgeLength;\n    }\n\n  }\n  Vertex.LEFT = 0;\n  Vertex.RIGHT = 1;\n  Vertex.BEYOND = 2;\n  Vertex.BEHIND = 3;\n  Vertex.BETWEEN = 4;\n  Vertex.ORIGIN = 5;\n  Vertex.DESTINATION = 6;\n\n  class ConstraintVertex extends Vertex {\n    constructor() {\n      super();\n      ConstraintVertex.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._isOnConstraint = null;\n      this._constraint = null;\n      const p = arguments[0];\n      Vertex.constructor_.call(this, p);\n    }\n\n    getConstraint() {\n      return this._constraint;\n    }\n\n    setOnConstraint(isOnConstraint) {\n      this._isOnConstraint = isOnConstraint;\n    }\n\n    merge(other) {\n      if (other._isOnConstraint) {\n        this._isOnConstraint = true;\n        this._constraint = other._constraint;\n      }\n    }\n\n    isOnConstraint() {\n      return this._isOnConstraint;\n    }\n\n    setConstraint(constraint) {\n      this._isOnConstraint = true;\n      this._constraint = constraint;\n    }\n\n  }\n\n  class QuadEdge {\n    constructor() {\n      QuadEdge.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._rot = null;\n      this._vertex = null;\n      this._next = null;\n      this._data = null;\n    }\n\n    static makeEdge(o, d) {\n      const q0 = new QuadEdge();\n      const q1 = new QuadEdge();\n      const q2 = new QuadEdge();\n      const q3 = new QuadEdge();\n      q0._rot = q1;\n      q1._rot = q2;\n      q2._rot = q3;\n      q3._rot = q0;\n      q0.setNext(q0);\n      q1.setNext(q3);\n      q2.setNext(q2);\n      q3.setNext(q1);\n      const base = q0;\n      base.setOrig(o);\n      base.setDest(d);\n      return base;\n    }\n\n    static swap(e) {\n      const a = e.oPrev();\n      const b = e.sym().oPrev();\n      QuadEdge.splice(e, a);\n      QuadEdge.splice(e.sym(), b);\n      QuadEdge.splice(e, a.lNext());\n      QuadEdge.splice(e.sym(), b.lNext());\n      e.setOrig(a.dest());\n      e.setDest(b.dest());\n    }\n\n    static splice(a, b) {\n      const alpha = a.oNext().rot();\n      const beta = b.oNext().rot();\n      const t1 = b.oNext();\n      const t2 = a.oNext();\n      const t3 = beta.oNext();\n      const t4 = alpha.oNext();\n      a.setNext(t1);\n      b.setNext(t2);\n      alpha.setNext(t3);\n      beta.setNext(t4);\n    }\n\n    static connect(a, b) {\n      const e = QuadEdge.makeEdge(a.dest(), b.orig());\n      QuadEdge.splice(e, a.lNext());\n      QuadEdge.splice(e.sym(), b);\n      return e;\n    }\n\n    equalsNonOriented(qe) {\n      if (this.equalsOriented(qe)) return true;\n      if (this.equalsOriented(qe.sym())) return true;\n      return false;\n    }\n\n    toLineSegment() {\n      return new LineSegment(this._vertex.getCoordinate(), this.dest().getCoordinate());\n    }\n\n    dest() {\n      return this.sym().orig();\n    }\n\n    oNext() {\n      return this._next;\n    }\n\n    equalsOriented(qe) {\n      if (this.orig().getCoordinate().equals2D(qe.orig().getCoordinate()) && this.dest().getCoordinate().equals2D(qe.dest().getCoordinate())) return true;\n      return false;\n    }\n\n    dNext() {\n      return this.sym().oNext().sym();\n    }\n\n    lPrev() {\n      return this._next.sym();\n    }\n\n    rPrev() {\n      return this.sym().oNext();\n    }\n\n    rot() {\n      return this._rot;\n    }\n\n    oPrev() {\n      return this._rot._next._rot;\n    }\n\n    sym() {\n      return this._rot._rot;\n    }\n\n    setOrig(o) {\n      this._vertex = o;\n    }\n\n    lNext() {\n      return this.invRot().oNext().rot();\n    }\n\n    getLength() {\n      return this.orig().getCoordinate().distance(this.dest().getCoordinate());\n    }\n\n    invRot() {\n      return this._rot.sym();\n    }\n\n    setDest(d) {\n      this.sym().setOrig(d);\n    }\n\n    setData(data) {\n      this._data = data;\n    }\n\n    getData() {\n      return this._data;\n    }\n\n    delete() {\n      this._rot = null;\n    }\n\n    orig() {\n      return this._vertex;\n    }\n\n    rNext() {\n      return this._rot._next.invRot();\n    }\n\n    toString() {\n      const p0 = this._vertex.getCoordinate();\n\n      const p1 = this.dest().getCoordinate();\n      return WKTWriter.toLineString(p0, p1);\n    }\n\n    isLive() {\n      return this._rot !== null;\n    }\n\n    getPrimary() {\n      if (this.orig().getCoordinate().compareTo(this.dest().getCoordinate()) <= 0) return this;else return this.sym();\n    }\n\n    dPrev() {\n      return this.invRot().oNext().invRot();\n    }\n\n    setNext(next) {\n      this._next = next;\n    }\n\n  }\n\n  class IncrementalDelaunayTriangulator {\n    constructor() {\n      IncrementalDelaunayTriangulator.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._subdiv = null;\n      this._isUsingTolerance = false;\n      const subdiv = arguments[0];\n      this._subdiv = subdiv;\n      this._isUsingTolerance = subdiv.getTolerance() > 0.0;\n    }\n\n    insertSite(v) {\n      let e = this._subdiv.locate(v);\n\n      if (this._subdiv.isVertexOfEdge(e, v)) {\n        return e;\n      } else if (this._subdiv.isOnEdge(e, v.getCoordinate())) {\n        e = e.oPrev();\n\n        this._subdiv.delete(e.oNext());\n      }\n\n      let base = this._subdiv.makeEdge(e.orig(), v);\n\n      QuadEdge.splice(base, e);\n      const startEdge = base;\n\n      do {\n        base = this._subdiv.connect(e, base.sym());\n        e = base.oPrev();\n      } while (e.lNext() !== startEdge);\n\n      do {\n        const t = e.oPrev();\n\n        if (t.dest().rightOf(e) && v.isInCircle(e.orig(), t.dest(), e.dest())) {\n          QuadEdge.swap(e);\n          e = e.oPrev();\n        } else if (e.oNext() === startEdge) {\n          return base;\n        } else {\n          e = e.oNext().lPrev();\n        }\n      } while (true);\n    }\n\n    insertSites(vertices) {\n      for (let i = vertices.iterator(); i.hasNext();) {\n        const v = i.next();\n        this.insertSite(v);\n      }\n    }\n\n  }\n\n  class QuadEdgeLocator {\n    locate(v) {}\n\n  }\n\n  class LastFoundQuadEdgeLocator {\n    constructor() {\n      LastFoundQuadEdgeLocator.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._subdiv = null;\n      this._lastEdge = null;\n      const subdiv = arguments[0];\n      this._subdiv = subdiv;\n      this.init();\n    }\n\n    init() {\n      this._lastEdge = this.findEdge();\n    }\n\n    locate(v) {\n      if (!this._lastEdge.isLive()) this.init();\n\n      const e = this._subdiv.locateFromEdge(v, this._lastEdge);\n\n      this._lastEdge = e;\n      return e;\n    }\n\n    findEdge() {\n      const edges = this._subdiv.getEdges();\n\n      return edges.iterator().next();\n    }\n\n    get interfaces_() {\n      return [QuadEdgeLocator];\n    }\n\n  }\n\n  class LocateFailureException extends RuntimeException {\n    constructor() {\n      super();\n      LocateFailureException.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._seg = null;\n\n      if (arguments.length === 1) {\n        if (typeof arguments[0] === 'string') {\n          const msg = arguments[0];\n          RuntimeException.constructor_.call(this, msg);\n        } else if (arguments[0] instanceof LineSegment) {\n          const seg = arguments[0];\n          RuntimeException.constructor_.call(this, 'Locate failed to converge (at edge: ' + seg + ').  Possible causes include invalid Subdivision topology or very close sites');\n          this._seg = new LineSegment(seg);\n        }\n      } else if (arguments.length === 2) {\n        const msg = arguments[0],\n              seg = arguments[1];\n        RuntimeException.constructor_.call(this, LocateFailureException.msgWithSpatial(msg, seg));\n        this._seg = new LineSegment(seg);\n      }\n    }\n\n    static msgWithSpatial(msg, seg) {\n      if (seg !== null) return msg + ' [ ' + seg + ' ]';\n      return msg;\n    }\n\n    getSegment() {\n      return this._seg;\n    }\n\n  }\n\n  class TriangleVisitor {\n    visit(triEdges) {}\n\n  }\n\n  class QuadEdgeSubdivision {\n    constructor() {\n      QuadEdgeSubdivision.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._visitedKey = 0;\n      this._quadEdges = new ArrayList();\n      this._startingEdge = null;\n      this._tolerance = null;\n      this._edgeCoincidenceTolerance = null;\n      this._frameVertex = new Array(3).fill(null);\n      this._frameEnv = null;\n      this._locator = null;\n      this._seg = new LineSegment();\n      this._triEdges = new Array(3).fill(null);\n      const env = arguments[0],\n            tolerance = arguments[1];\n      this._tolerance = tolerance;\n      this._edgeCoincidenceTolerance = tolerance / QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR;\n      this.createFrame(env);\n      this._startingEdge = this.initSubdiv();\n      this._locator = new LastFoundQuadEdgeLocator(this);\n    }\n\n    static getTriangleEdges(startQE, triEdge) {\n      triEdge[0] = startQE;\n      triEdge[1] = triEdge[0].lNext();\n      triEdge[2] = triEdge[1].lNext();\n      if (triEdge[2].lNext() !== triEdge[0]) throw new IllegalArgumentException('Edges do not form a triangle');\n    }\n\n    getTriangleVertices(includeFrame) {\n      const visitor = new TriangleVertexListVisitor();\n      this.visitTriangles(visitor, includeFrame);\n      return visitor.getTriangleVertices();\n    }\n\n    isFrameVertex(v) {\n      if (v.equals(this._frameVertex[0])) return true;\n      if (v.equals(this._frameVertex[1])) return true;\n      if (v.equals(this._frameVertex[2])) return true;\n      return false;\n    }\n\n    isVertexOfEdge(e, v) {\n      if (v.equals(e.orig(), this._tolerance) || v.equals(e.dest(), this._tolerance)) return true;\n      return false;\n    }\n\n    connect(a, b) {\n      const q = QuadEdge.connect(a, b);\n\n      this._quadEdges.add(q);\n\n      return q;\n    }\n\n    getVoronoiCellPolygon(qe, geomFact) {\n      const cellPts = new ArrayList();\n      const startQE = qe;\n\n      do {\n        const cc = qe.rot().orig().getCoordinate();\n        cellPts.add(cc);\n        qe = qe.oPrev();\n      } while (qe !== startQE);\n\n      const coordList = new CoordinateList();\n      coordList.addAll(cellPts, false);\n      coordList.closeRing();\n\n      if (coordList.size() < 4) {\n        System.out.println(coordList);\n        coordList.add(coordList.get(coordList.size() - 1), true);\n      }\n\n      const pts = coordList.toCoordinateArray();\n      const cellPoly = geomFact.createPolygon(geomFact.createLinearRing(pts));\n      const v = startQE.orig();\n      cellPoly.setUserData(v.getCoordinate());\n      return cellPoly;\n    }\n\n    setLocator(locator) {\n      this._locator = locator;\n    }\n\n    initSubdiv() {\n      const ea = this.makeEdge(this._frameVertex[0], this._frameVertex[1]);\n      const eb = this.makeEdge(this._frameVertex[1], this._frameVertex[2]);\n      QuadEdge.splice(ea.sym(), eb);\n      const ec = this.makeEdge(this._frameVertex[2], this._frameVertex[0]);\n      QuadEdge.splice(eb.sym(), ec);\n      QuadEdge.splice(ec.sym(), ea);\n      return ea;\n    }\n\n    isFrameBorderEdge(e) {\n      const leftTri = new Array(3).fill(null);\n      QuadEdgeSubdivision.getTriangleEdges(e, leftTri);\n      const rightTri = new Array(3).fill(null);\n      QuadEdgeSubdivision.getTriangleEdges(e.sym(), rightTri);\n      const vLeftTriOther = e.lNext().dest();\n      if (this.isFrameVertex(vLeftTriOther)) return true;\n      const vRightTriOther = e.sym().lNext().dest();\n      if (this.isFrameVertex(vRightTriOther)) return true;\n      return false;\n    }\n\n    makeEdge(o, d) {\n      const q = QuadEdge.makeEdge(o, d);\n\n      this._quadEdges.add(q);\n\n      return q;\n    }\n\n    visitTriangles(triVisitor, includeFrame) {\n      this._visitedKey++;\n      const edgeStack = new Stack();\n      edgeStack.push(this._startingEdge);\n      const visitedEdges = new HashSet();\n\n      while (!edgeStack.empty()) {\n        const edge = edgeStack.pop();\n\n        if (!visitedEdges.contains(edge)) {\n          const triEdges = this.fetchTriangleToVisit(edge, edgeStack, includeFrame, visitedEdges);\n          if (triEdges !== null) triVisitor.visit(triEdges);\n        }\n      }\n    }\n\n    isFrameEdge(e) {\n      if (this.isFrameVertex(e.orig()) || this.isFrameVertex(e.dest())) return true;\n      return false;\n    }\n\n    isOnEdge(e, p) {\n      this._seg.setCoordinates(e.orig().getCoordinate(), e.dest().getCoordinate());\n\n      const dist = this._seg.distance(p);\n\n      return dist < this._edgeCoincidenceTolerance;\n    }\n\n    getEnvelope() {\n      return new Envelope(this._frameEnv);\n    }\n\n    createFrame(env) {\n      const deltaX = env.getWidth();\n      const deltaY = env.getHeight();\n      let offset = 0.0;\n      if (deltaX > deltaY) offset = deltaX * 10.0;else offset = deltaY * 10.0;\n      this._frameVertex[0] = new Vertex((env.getMaxX() + env.getMinX()) / 2.0, env.getMaxY() + offset);\n      this._frameVertex[1] = new Vertex(env.getMinX() - offset, env.getMinY() - offset);\n      this._frameVertex[2] = new Vertex(env.getMaxX() + offset, env.getMinY() - offset);\n      this._frameEnv = new Envelope(this._frameVertex[0].getCoordinate(), this._frameVertex[1].getCoordinate());\n\n      this._frameEnv.expandToInclude(this._frameVertex[2].getCoordinate());\n    }\n\n    getTriangleCoordinates(includeFrame) {\n      const visitor = new TriangleCoordinatesVisitor();\n      this.visitTriangles(visitor, includeFrame);\n      return visitor.getTriangles();\n    }\n\n    getVertices(includeFrame) {\n      const vertices = new HashSet();\n\n      for (let i = this._quadEdges.iterator(); i.hasNext();) {\n        const qe = i.next();\n        const v = qe.orig();\n        if (includeFrame || !this.isFrameVertex(v)) vertices.add(v);\n        const vd = qe.dest();\n        if (includeFrame || !this.isFrameVertex(vd)) vertices.add(vd);\n      }\n\n      return vertices;\n    }\n\n    fetchTriangleToVisit(edge, edgeStack, includeFrame, visitedEdges) {\n      let curr = edge;\n      let edgeCount = 0;\n      let isFrame = false;\n\n      do {\n        this._triEdges[edgeCount] = curr;\n        if (this.isFrameEdge(curr)) isFrame = true;\n        const sym = curr.sym();\n        if (!visitedEdges.contains(sym)) edgeStack.push(sym);\n        visitedEdges.add(curr);\n        edgeCount++;\n        curr = curr.lNext();\n      } while (curr !== edge);\n\n      if (isFrame && !includeFrame) return null;\n      return this._triEdges;\n    }\n\n    getEdges() {\n      if (arguments.length === 0) {\n        return this._quadEdges;\n      } else if (arguments.length === 1) {\n        const geomFact = arguments[0];\n        const quadEdges = this.getPrimaryEdges(false);\n        const edges = new Array(quadEdges.size()).fill(null);\n        let i = 0;\n\n        for (let it = quadEdges.iterator(); it.hasNext();) {\n          const qe = it.next();\n          edges[i++] = geomFact.createLineString([qe.orig().getCoordinate(), qe.dest().getCoordinate()]);\n        }\n\n        return geomFact.createMultiLineString(edges);\n      }\n    }\n\n    getVertexUniqueEdges(includeFrame) {\n      const edges = new ArrayList();\n      const visitedVertices = new HashSet();\n\n      for (let i = this._quadEdges.iterator(); i.hasNext();) {\n        const qe = i.next();\n        const v = qe.orig();\n\n        if (!visitedVertices.contains(v)) {\n          visitedVertices.add(v);\n          if (includeFrame || !this.isFrameVertex(v)) edges.add(qe);\n        }\n\n        const qd = qe.sym();\n        const vd = qd.orig();\n\n        if (!visitedVertices.contains(vd)) {\n          visitedVertices.add(vd);\n          if (includeFrame || !this.isFrameVertex(vd)) edges.add(qd);\n        }\n      }\n\n      return edges;\n    }\n\n    getTriangleEdges(includeFrame) {\n      const visitor = new TriangleEdgesListVisitor();\n      this.visitTriangles(visitor, includeFrame);\n      return visitor.getTriangleEdges();\n    }\n\n    getPrimaryEdges(includeFrame) {\n      this._visitedKey++;\n      const edges = new ArrayList();\n      const edgeStack = new Stack();\n      edgeStack.push(this._startingEdge);\n      const visitedEdges = new HashSet();\n\n      while (!edgeStack.empty()) {\n        const edge = edgeStack.pop();\n\n        if (!visitedEdges.contains(edge)) {\n          const priQE = edge.getPrimary();\n          if (includeFrame || !this.isFrameEdge(priQE)) edges.add(priQE);\n          edgeStack.push(edge.oNext());\n          edgeStack.push(edge.sym().oNext());\n          visitedEdges.add(edge);\n          visitedEdges.add(edge.sym());\n        }\n      }\n\n      return edges;\n    }\n\n    delete(e) {\n      QuadEdge.splice(e, e.oPrev());\n      QuadEdge.splice(e.sym(), e.sym().oPrev());\n      const eSym = e.sym();\n      const eRot = e.rot();\n      const eRotSym = e.rot().sym();\n\n      this._quadEdges.remove(e);\n\n      this._quadEdges.remove(eSym);\n\n      this._quadEdges.remove(eRot);\n\n      this._quadEdges.remove(eRotSym);\n\n      e.delete();\n      eSym.delete();\n      eRot.delete();\n      eRotSym.delete();\n    }\n\n    locateFromEdge(v, startEdge) {\n      let iter = 0;\n\n      const maxIter = this._quadEdges.size();\n\n      let e = startEdge;\n\n      while (true) {\n        iter++;\n        if (iter > maxIter) throw new LocateFailureException(e.toLineSegment());\n        if (v.equals(e.orig()) || v.equals(e.dest())) break;else if (v.rightOf(e)) e = e.sym();else if (!v.rightOf(e.oNext())) e = e.oNext();else if (!v.rightOf(e.dPrev())) e = e.dPrev();else break;\n      }\n\n      return e;\n    }\n\n    getTolerance() {\n      return this._tolerance;\n    }\n\n    getVoronoiCellPolygons(geomFact) {\n      this.visitTriangles(new TriangleCircumcentreVisitor(), true);\n      const cells = new ArrayList();\n      const edges = this.getVertexUniqueEdges(false);\n\n      for (let i = edges.iterator(); i.hasNext();) {\n        const qe = i.next();\n        cells.add(this.getVoronoiCellPolygon(qe, geomFact));\n      }\n\n      return cells;\n    }\n\n    getVoronoiDiagram(geomFact) {\n      const vorCells = this.getVoronoiCellPolygons(geomFact);\n      return geomFact.createGeometryCollection(GeometryFactory.toGeometryArray(vorCells));\n    }\n\n    getTriangles(geomFact) {\n      const triPtsList = this.getTriangleCoordinates(false);\n      const tris = new Array(triPtsList.size()).fill(null);\n      let i = 0;\n\n      for (let it = triPtsList.iterator(); it.hasNext();) {\n        const triPt = it.next();\n        tris[i++] = geomFact.createPolygon(geomFact.createLinearRing(triPt));\n      }\n\n      return geomFact.createGeometryCollection(tris);\n    }\n\n    insertSite(v) {\n      let e = this.locate(v);\n      if (v.equals(e.orig(), this._tolerance) || v.equals(e.dest(), this._tolerance)) return e;\n      let base = this.makeEdge(e.orig(), v);\n      QuadEdge.splice(base, e);\n      const startEdge = base;\n\n      do {\n        base = this.connect(e, base.sym());\n        e = base.oPrev();\n      } while (e.lNext() !== startEdge);\n\n      return startEdge;\n    }\n\n    locate() {\n      if (arguments.length === 1) {\n        if (arguments[0] instanceof Vertex) {\n          const v = arguments[0];\n          return this._locator.locate(v);\n        } else if (arguments[0] instanceof Coordinate) {\n          const p = arguments[0];\n          return this._locator.locate(new Vertex(p));\n        }\n      } else if (arguments.length === 2) {\n        const p0 = arguments[0],\n              p1 = arguments[1];\n\n        const e = this._locator.locate(new Vertex(p0));\n\n        if (e === null) return null;\n        let base = e;\n        if (e.dest().getCoordinate().equals2D(p0)) base = e.sym();\n        let locEdge = base;\n\n        do {\n          if (locEdge.dest().getCoordinate().equals2D(p1)) return locEdge;\n          locEdge = locEdge.oNext();\n        } while (locEdge !== base);\n\n        return null;\n      }\n    }\n\n  }\n\n  class TriangleCircumcentreVisitor {\n    visit(triEdges) {\n      const a = triEdges[0].orig().getCoordinate();\n      const b = triEdges[1].orig().getCoordinate();\n      const c = triEdges[2].orig().getCoordinate();\n      const cc = Triangle.circumcentreDD(a, b, c);\n      const ccVertex = new Vertex(cc);\n\n      for (let i = 0; i < 3; i++) triEdges[i].rot().setOrig(ccVertex);\n    }\n\n    get interfaces_() {\n      return [TriangleVisitor];\n    }\n\n  }\n\n  class TriangleEdgesListVisitor {\n    constructor() {\n      TriangleEdgesListVisitor.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._triList = new ArrayList();\n    }\n\n    getTriangleEdges() {\n      return this._triList;\n    }\n\n    visit(triEdges) {\n      this._triList.add(triEdges);\n    }\n\n    get interfaces_() {\n      return [TriangleVisitor];\n    }\n\n  }\n\n  class TriangleVertexListVisitor {\n    constructor() {\n      TriangleVertexListVisitor.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._triList = new ArrayList();\n    }\n\n    visit(triEdges) {\n      this._triList.add([triEdges[0].orig(), triEdges[1].orig(), triEdges[2].orig()]);\n    }\n\n    getTriangleVertices() {\n      return this._triList;\n    }\n\n    get interfaces_() {\n      return [TriangleVisitor];\n    }\n\n  }\n\n  class TriangleCoordinatesVisitor {\n    constructor() {\n      TriangleCoordinatesVisitor.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._coordList = new CoordinateList();\n      this._triCoords = new ArrayList();\n    }\n\n    checkTriangleSize(pts) {\n      let loc = '';\n      if (pts.length >= 2) loc = WKTWriter.toLineString(pts[0], pts[1]);else if (pts.length >= 1) loc = WKTWriter.toPoint(pts[0]);\n    }\n\n    visit(triEdges) {\n      this._coordList.clear();\n\n      for (let i = 0; i < 3; i++) {\n        const v = triEdges[i].orig();\n\n        this._coordList.add(v.getCoordinate());\n      }\n\n      if (this._coordList.size() > 0) {\n        this._coordList.closeRing();\n\n        const pts = this._coordList.toCoordinateArray();\n\n        if (pts.length !== 4) return null;\n\n        this._triCoords.add(pts);\n      }\n    }\n\n    getTriangles() {\n      return this._triCoords;\n    }\n\n    get interfaces_() {\n      return [TriangleVisitor];\n    }\n\n  }\n\n  QuadEdgeSubdivision.TriangleCircumcentreVisitor = TriangleCircumcentreVisitor;\n  QuadEdgeSubdivision.TriangleEdgesListVisitor = TriangleEdgesListVisitor;\n  QuadEdgeSubdivision.TriangleVertexListVisitor = TriangleVertexListVisitor;\n  QuadEdgeSubdivision.TriangleCoordinatesVisitor = TriangleCoordinatesVisitor;\n  QuadEdgeSubdivision.EDGE_COINCIDENCE_TOL_FACTOR = 1000;\n\n  class Segment {\n    constructor() {\n      Segment.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._ls = null;\n      this._data = null;\n\n      if (arguments.length === 2) {\n        const p0 = arguments[0],\n              p1 = arguments[1];\n        this._ls = new LineSegment(p0, p1);\n      } else if (arguments.length === 3) {\n        const p0 = arguments[0],\n              p1 = arguments[1],\n              data = arguments[2];\n        this._ls = new LineSegment(p0, p1);\n        this._data = data;\n      } else if (arguments.length === 6) {\n        const x1 = arguments[0],\n              y1 = arguments[1],\n              z1 = arguments[2],\n              x2 = arguments[3],\n              y2 = arguments[4],\n              z2 = arguments[5];\n        Segment.constructor_.call(this, new Coordinate(x1, y1, z1), new Coordinate(x2, y2, z2));\n      } else if (arguments.length === 7) {\n        const x1 = arguments[0],\n              y1 = arguments[1],\n              z1 = arguments[2],\n              x2 = arguments[3],\n              y2 = arguments[4],\n              z2 = arguments[5],\n              data = arguments[6];\n        Segment.constructor_.call(this, new Coordinate(x1, y1, z1), new Coordinate(x2, y2, z2), data);\n      }\n    }\n\n    getLineSegment() {\n      return this._ls;\n    }\n\n    getEndZ() {\n      const p = this._ls.getCoordinate(1);\n\n      return p.getZ();\n    }\n\n    getStartZ() {\n      const p = this._ls.getCoordinate(0);\n\n      return p.getZ();\n    }\n\n    intersection(s) {\n      return this._ls.intersection(s.getLineSegment());\n    }\n\n    getStart() {\n      return this._ls.getCoordinate(0);\n    }\n\n    getEnd() {\n      return this._ls.getCoordinate(1);\n    }\n\n    getEndY() {\n      const p = this._ls.getCoordinate(1);\n\n      return p.y;\n    }\n\n    getStartX() {\n      const p = this._ls.getCoordinate(0);\n\n      return p.x;\n    }\n\n    equalsTopo(s) {\n      return this._ls.equalsTopo(s.getLineSegment());\n    }\n\n    getStartY() {\n      const p = this._ls.getCoordinate(0);\n\n      return p.y;\n    }\n\n    setData(data) {\n      this._data = data;\n    }\n\n    getData() {\n      return this._data;\n    }\n\n    getEndX() {\n      const p = this._ls.getCoordinate(1);\n\n      return p.x;\n    }\n\n    toString() {\n      return this._ls.toString();\n    }\n\n  }\n\n  class ConstraintEnforcementException extends RuntimeException {\n    constructor() {\n      super();\n      ConstraintEnforcementException.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._pt = null;\n\n      if (arguments.length === 1) {\n        const msg = arguments[0];\n        RuntimeException.constructor_.call(this, msg);\n      } else if (arguments.length === 2) {\n        const msg = arguments[0],\n              pt = arguments[1];\n        RuntimeException.constructor_.call(this, ConstraintEnforcementException.msgWithCoord(msg, pt));\n        this._pt = new Coordinate(pt);\n      }\n    }\n\n    static msgWithCoord(msg, pt) {\n      if (pt !== null) return msg + ' [ ' + WKTWriter.toPoint(pt) + ' ]';\n      return msg;\n    }\n\n    getCoordinate() {\n      return this._pt;\n    }\n\n  }\n\n  class ConformingDelaunayTriangulator {\n    constructor() {\n      ConformingDelaunayTriangulator.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._initialVertices = null;\n      this._segVertices = null;\n      this._segments = new ArrayList();\n      this._subdiv = null;\n      this._incDel = null;\n      this._convexHull = null;\n      this._splitFinder = new NonEncroachingSplitPointFinder();\n      this._kdt = null;\n      this._vertexFactory = null;\n      this._computeAreaEnv = null;\n      this._splitPt = null;\n      this._tolerance = null;\n      const initialVertices = arguments[0],\n            tolerance = arguments[1];\n      this._initialVertices = new ArrayList(initialVertices);\n      this._tolerance = tolerance;\n      this._kdt = new KdTree(tolerance);\n    }\n\n    static computeVertexEnvelope(vertices) {\n      const env = new Envelope();\n\n      for (let i = vertices.iterator(); i.hasNext();) {\n        const v = i.next();\n        env.expandToInclude(v.getCoordinate());\n      }\n\n      return env;\n    }\n\n    getInitialVertices() {\n      return this._initialVertices;\n    }\n\n    getKDT() {\n      return this._kdt;\n    }\n\n    enforceConstraints() {\n      this.addConstraintVertices();\n      let count = 0;\n      let splits = 0;\n\n      do {\n        splits = this.enforceGabriel(this._segments);\n        count++;\n      } while (splits > 0 && count < ConformingDelaunayTriangulator.MAX_SPLIT_ITER);\n\n      if (count === ConformingDelaunayTriangulator.MAX_SPLIT_ITER) throw new ConstraintEnforcementException('Too many splitting iterations while enforcing constraints.  Last split point was at: ', this._splitPt);\n    }\n\n    insertSites(vertices) {\n      for (let i = vertices.iterator(); i.hasNext();) {\n        const v = i.next();\n        this.insertSite(v);\n      }\n    }\n\n    getVertexFactory() {\n      return this._vertexFactory;\n    }\n\n    getPointArray() {\n      const pts = new Array(this._initialVertices.size() + this._segVertices.size()).fill(null);\n      let index = 0;\n\n      for (let i = this._initialVertices.iterator(); i.hasNext();) {\n        const v = i.next();\n        pts[index++] = v.getCoordinate();\n      }\n\n      for (let i2 = this._segVertices.iterator(); i2.hasNext();) {\n        const v = i2.next();\n        pts[index++] = v.getCoordinate();\n      }\n\n      return pts;\n    }\n\n    setConstraints(segments, segVertices) {\n      this._segments = segments;\n      this._segVertices = segVertices;\n    }\n\n    computeConvexHull() {\n      const fact = new GeometryFactory();\n      const coords = this.getPointArray();\n      const hull = new ConvexHull(coords, fact);\n      this._convexHull = hull.getConvexHull();\n    }\n\n    addConstraintVertices() {\n      this.computeConvexHull();\n      this.insertSites(this._segVertices);\n    }\n\n    findNonGabrielPoint(seg) {\n      const p = seg.getStart();\n      const q = seg.getEnd();\n      const midPt = new Coordinate((p.x + q.x) / 2.0, (p.y + q.y) / 2.0);\n      const segRadius = p.distance(midPt);\n      const env = new Envelope(midPt);\n      env.expandBy(segRadius);\n\n      const result = this._kdt.query(env);\n\n      let closestNonGabriel = null;\n      let minDist = Double.MAX_VALUE;\n\n      for (let i = result.iterator(); i.hasNext();) {\n        const nextNode = i.next();\n        const testPt = nextNode.getCoordinate();\n        if (testPt.equals2D(p) || testPt.equals2D(q)) continue;\n        const testRadius = midPt.distance(testPt);\n\n        if (testRadius < segRadius) {\n          const testDist = testRadius;\n\n          if (closestNonGabriel === null || testDist < minDist) {\n            closestNonGabriel = testPt;\n            minDist = testDist;\n          }\n        }\n      }\n\n      return closestNonGabriel;\n    }\n\n    getConstraintSegments() {\n      return this._segments;\n    }\n\n    setSplitPointFinder(splitFinder) {\n      this._splitFinder = splitFinder;\n    }\n\n    getConvexHull() {\n      return this._convexHull;\n    }\n\n    getTolerance() {\n      return this._tolerance;\n    }\n\n    enforceGabriel(segsToInsert) {\n      const newSegments = new ArrayList();\n      let splits = 0;\n      const segsToRemove = new ArrayList();\n\n      for (let i = segsToInsert.iterator(); i.hasNext();) {\n        const seg = i.next();\n        const encroachPt = this.findNonGabrielPoint(seg);\n        if (encroachPt === null) continue;\n        this._splitPt = this._splitFinder.findSplitPoint(seg, encroachPt);\n        const splitVertex = this.createVertex(this._splitPt, seg);\n        const insertedVertex = this.insertSite(splitVertex);\n\n        if (!insertedVertex.getCoordinate().equals2D(this._splitPt)) ;\n\n        const s1 = new Segment(seg.getStartX(), seg.getStartY(), seg.getStartZ(), splitVertex.getX(), splitVertex.getY(), splitVertex.getZ(), seg.getData());\n        const s2 = new Segment(splitVertex.getX(), splitVertex.getY(), splitVertex.getZ(), seg.getEndX(), seg.getEndY(), seg.getEndZ(), seg.getData());\n        newSegments.add(s1);\n        newSegments.add(s2);\n        segsToRemove.add(seg);\n        splits = splits + 1;\n      }\n\n      segsToInsert.removeAll(segsToRemove);\n      segsToInsert.addAll(newSegments);\n      return splits;\n    }\n\n    createVertex() {\n      if (arguments.length === 1) {\n        const p = arguments[0];\n        let v = null;\n        if (this._vertexFactory !== null) v = this._vertexFactory.createVertex(p, null);else v = new ConstraintVertex(p);\n        return v;\n      } else if (arguments.length === 2) {\n        const p = arguments[0],\n              seg = arguments[1];\n        let v = null;\n        if (this._vertexFactory !== null) v = this._vertexFactory.createVertex(p, seg);else v = new ConstraintVertex(p);\n        v.setOnConstraint(true);\n        return v;\n      }\n    }\n\n    getSubdivision() {\n      return this._subdiv;\n    }\n\n    computeBoundingBox() {\n      const vertexEnv = ConformingDelaunayTriangulator.computeVertexEnvelope(this._initialVertices);\n      const segEnv = ConformingDelaunayTriangulator.computeVertexEnvelope(this._segVertices);\n      const allPointsEnv = new Envelope(vertexEnv);\n      allPointsEnv.expandToInclude(segEnv);\n      const deltaX = allPointsEnv.getWidth() * 0.2;\n      const deltaY = allPointsEnv.getHeight() * 0.2;\n      const delta = Math.max(deltaX, deltaY);\n      this._computeAreaEnv = new Envelope(allPointsEnv);\n\n      this._computeAreaEnv.expandBy(delta);\n    }\n\n    setVertexFactory(vertexFactory) {\n      this._vertexFactory = vertexFactory;\n    }\n\n    formInitialDelaunay() {\n      this.computeBoundingBox();\n      this._subdiv = new QuadEdgeSubdivision(this._computeAreaEnv, this._tolerance);\n\n      this._subdiv.setLocator(new LastFoundQuadEdgeLocator(this._subdiv));\n\n      this._incDel = new IncrementalDelaunayTriangulator(this._subdiv);\n      this.insertSites(this._initialVertices);\n    }\n\n    insertSite() {\n      if (arguments[0] instanceof ConstraintVertex) {\n        const v = arguments[0];\n\n        const kdnode = this._kdt.insert(v.getCoordinate(), v);\n\n        if (!kdnode.isRepeated()) {\n          this._incDel.insertSite(v);\n        } else {\n          const snappedV = kdnode.getData();\n          snappedV.merge(v);\n          return snappedV;\n        }\n\n        return v;\n      } else if (arguments[0] instanceof Coordinate) {\n        const p = arguments[0];\n        this.insertSite(this.createVertex(p));\n      }\n    }\n\n  }\n  ConformingDelaunayTriangulator.MAX_SPLIT_ITER = 99;\n\n  class DelaunayTriangulationBuilder {\n    constructor() {\n      DelaunayTriangulationBuilder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._siteCoords = null;\n      this._tolerance = 0.0;\n      this._subdiv = null;\n    }\n\n    static extractUniqueCoordinates(geom) {\n      if (geom === null) return new CoordinateList();\n      const coords = geom.getCoordinates();\n      return DelaunayTriangulationBuilder.unique(coords);\n    }\n\n    static envelope(coords) {\n      const env = new Envelope();\n\n      for (let i = coords.iterator(); i.hasNext();) {\n        const coord = i.next();\n        env.expandToInclude(coord);\n      }\n\n      return env;\n    }\n\n    static unique(coords) {\n      const coordsCopy = CoordinateArrays.copyDeep(coords);\n      Arrays.sort(coordsCopy);\n      const coordList = new CoordinateList(coordsCopy, false);\n      return coordList;\n    }\n\n    static toVertices(coords) {\n      const verts = new ArrayList();\n\n      for (let i = coords.iterator(); i.hasNext();) {\n        const coord = i.next();\n        verts.add(new Vertex(coord));\n      }\n\n      return verts;\n    }\n\n    create() {\n      if (this._subdiv !== null) return null;\n      const siteEnv = DelaunayTriangulationBuilder.envelope(this._siteCoords);\n      const vertices = DelaunayTriangulationBuilder.toVertices(this._siteCoords);\n      this._subdiv = new QuadEdgeSubdivision(siteEnv, this._tolerance);\n      const triangulator = new IncrementalDelaunayTriangulator(this._subdiv);\n      triangulator.insertSites(vertices);\n    }\n\n    setTolerance(tolerance) {\n      this._tolerance = tolerance;\n    }\n\n    setSites() {\n      if (arguments[0] instanceof Geometry) {\n        const geom = arguments[0];\n        this._siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);\n      } else if (hasInterface(arguments[0], Collection)) {\n        const coords = arguments[0];\n        this._siteCoords = DelaunayTriangulationBuilder.unique(CoordinateArrays.toCoordinateArray(coords));\n      }\n    }\n\n    getEdges(geomFact) {\n      this.create();\n      return this._subdiv.getEdges(geomFact);\n    }\n\n    getSubdivision() {\n      this.create();\n      return this._subdiv;\n    }\n\n    getTriangles(geomFact) {\n      this.create();\n      return this._subdiv.getTriangles(geomFact);\n    }\n\n  }\n\n  class ConformingDelaunayTriangulationBuilder {\n    constructor() {\n      ConformingDelaunayTriangulationBuilder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._siteCoords = null;\n      this._constraintLines = null;\n      this._tolerance = 0.0;\n      this._subdiv = null;\n      this._constraintVertexMap = new TreeMap();\n    }\n\n    static createConstraintSegments() {\n      if (arguments.length === 1) {\n        const geom = arguments[0];\n        const lines = LinearComponentExtracter.getLines(geom);\n        const constraintSegs = new ArrayList();\n\n        for (let i = lines.iterator(); i.hasNext();) {\n          const line = i.next();\n          ConformingDelaunayTriangulationBuilder.createConstraintSegments(line, constraintSegs);\n        }\n\n        return constraintSegs;\n      } else if (arguments.length === 2) {\n        const line = arguments[0],\n              constraintSegs = arguments[1];\n        const coords = line.getCoordinates();\n\n        for (let i = 1; i < coords.length; i++) constraintSegs.add(new Segment(coords[i - 1], coords[i]));\n      }\n    }\n\n    createSiteVertices(coords) {\n      const verts = new ArrayList();\n\n      for (let i = coords.iterator(); i.hasNext();) {\n        const coord = i.next();\n        if (this._constraintVertexMap.containsKey(coord)) continue;\n        verts.add(new ConstraintVertex(coord));\n      }\n\n      return verts;\n    }\n\n    create() {\n      if (this._subdiv !== null) return null;\n      const siteEnv = DelaunayTriangulationBuilder.envelope(this._siteCoords);\n      let segments = new ArrayList();\n\n      if (this._constraintLines !== null) {\n        siteEnv.expandToInclude(this._constraintLines.getEnvelopeInternal());\n        this.createVertices(this._constraintLines);\n        segments = ConformingDelaunayTriangulationBuilder.createConstraintSegments(this._constraintLines);\n      }\n\n      const sites = this.createSiteVertices(this._siteCoords);\n      const cdt = new ConformingDelaunayTriangulator(sites, this._tolerance);\n      cdt.setConstraints(segments, new ArrayList(this._constraintVertexMap.values()));\n      cdt.formInitialDelaunay();\n      cdt.enforceConstraints();\n      this._subdiv = cdt.getSubdivision();\n    }\n\n    setTolerance(tolerance) {\n      this._tolerance = tolerance;\n    }\n\n    setConstraints(constraintLines) {\n      this._constraintLines = constraintLines;\n    }\n\n    setSites(geom) {\n      this._siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);\n    }\n\n    getEdges(geomFact) {\n      this.create();\n      return this._subdiv.getEdges(geomFact);\n    }\n\n    getSubdivision() {\n      this.create();\n      return this._subdiv;\n    }\n\n    getTriangles(geomFact) {\n      this.create();\n      return this._subdiv.getTriangles(geomFact);\n    }\n\n    createVertices(geom) {\n      const coords = geom.getCoordinates();\n\n      for (let i = 0; i < coords.length; i++) {\n        const v = new ConstraintVertex(coords[i]);\n\n        this._constraintVertexMap.put(coords[i], v);\n      }\n    }\n\n  }\n\n  class VoronoiDiagramBuilder {\n    constructor() {\n      VoronoiDiagramBuilder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._siteCoords = null;\n      this._tolerance = 0.0;\n      this._subdiv = null;\n      this._clipEnv = null;\n      this._diagramEnv = null;\n    }\n\n    static clipGeometryCollection(geom, clipEnv) {\n      const clipPoly = geom.getFactory().toGeometry(clipEnv);\n      const clipped = new ArrayList();\n\n      for (let i = 0; i < geom.getNumGeometries(); i++) {\n        const g = geom.getGeometryN(i);\n        let result = null;\n\n        if (clipEnv.contains(g.getEnvelopeInternal())) {\n          result = g;\n        } else if (clipEnv.intersects(g.getEnvelopeInternal())) {\n          result = OverlayOp.intersection(clipPoly, g);\n          result.setUserData(g.getUserData());\n        }\n\n        if (result !== null && !result.isEmpty()) clipped.add(result);\n      }\n\n      return geom.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(clipped));\n    }\n\n    create() {\n      if (this._subdiv !== null) return null;\n      const siteEnv = DelaunayTriangulationBuilder.envelope(this._siteCoords);\n      this._diagramEnv = this._clipEnv;\n\n      if (this._diagramEnv === null) {\n        this._diagramEnv = siteEnv;\n\n        const expandBy = this._diagramEnv.getDiameter();\n\n        this._diagramEnv.expandBy(expandBy);\n      }\n\n      const vertices = DelaunayTriangulationBuilder.toVertices(this._siteCoords);\n      this._subdiv = new QuadEdgeSubdivision(siteEnv, this._tolerance);\n      const triangulator = new IncrementalDelaunayTriangulator(this._subdiv);\n      triangulator.insertSites(vertices);\n    }\n\n    getDiagram(geomFact) {\n      this.create();\n\n      const polys = this._subdiv.getVoronoiDiagram(geomFact);\n\n      return VoronoiDiagramBuilder.clipGeometryCollection(polys, this._diagramEnv);\n    }\n\n    setTolerance(tolerance) {\n      this._tolerance = tolerance;\n    }\n\n    setSites() {\n      if (arguments[0] instanceof Geometry) {\n        const geom = arguments[0];\n        this._siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(geom);\n      } else if (hasInterface(arguments[0], Collection)) {\n        const coords = arguments[0];\n        this._siteCoords = DelaunayTriangulationBuilder.unique(CoordinateArrays.toCoordinateArray(coords));\n      }\n    }\n\n    setClipEnvelope(clipEnv) {\n      this._clipEnv = clipEnv;\n    }\n\n    getSubdivision() {\n      this.create();\n      return this._subdiv;\n    }\n\n  }\n\n  var quadedge = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Vertex: Vertex\n  });\n\n  var triangulate = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ConformingDelaunayTriangulationBuilder: ConformingDelaunayTriangulationBuilder,\n    DelaunayTriangulationBuilder: DelaunayTriangulationBuilder,\n    VoronoiDiagramBuilder: VoronoiDiagramBuilder,\n    quadedge: quadedge\n  });\n\n  class LinearIterator {\n    constructor() {\n      LinearIterator.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._linearGeom = null;\n      this._numLines = null;\n      this._currentLine = null;\n      this._componentIndex = 0;\n      this._vertexIndex = 0;\n\n      if (arguments.length === 1) {\n        const linear = arguments[0];\n        LinearIterator.constructor_.call(this, linear, 0, 0);\n      } else if (arguments.length === 2) {\n        const linear = arguments[0],\n              start = arguments[1];\n        LinearIterator.constructor_.call(this, linear, start.getComponentIndex(), LinearIterator.segmentEndVertexIndex(start));\n      } else if (arguments.length === 3) {\n        const linearGeom = arguments[0],\n              componentIndex = arguments[1],\n              vertexIndex = arguments[2];\n        if (!hasInterface(linearGeom, Lineal)) throw new IllegalArgumentException('Lineal geometry is required');\n        this._linearGeom = linearGeom;\n        this._numLines = linearGeom.getNumGeometries();\n        this._componentIndex = componentIndex;\n        this._vertexIndex = vertexIndex;\n        this.loadCurrentLine();\n      }\n    }\n\n    static segmentEndVertexIndex(loc) {\n      if (loc.getSegmentFraction() > 0.0) return loc.getSegmentIndex() + 1;\n      return loc.getSegmentIndex();\n    }\n\n    getComponentIndex() {\n      return this._componentIndex;\n    }\n\n    getLine() {\n      return this._currentLine;\n    }\n\n    getVertexIndex() {\n      return this._vertexIndex;\n    }\n\n    getSegmentEnd() {\n      if (this._vertexIndex < this.getLine().getNumPoints() - 1) return this._currentLine.getCoordinateN(this._vertexIndex + 1);\n      return null;\n    }\n\n    next() {\n      if (!this.hasNext()) return null;\n      this._vertexIndex++;\n\n      if (this._vertexIndex >= this._currentLine.getNumPoints()) {\n        this._componentIndex++;\n        this.loadCurrentLine();\n        this._vertexIndex = 0;\n      }\n    }\n\n    loadCurrentLine() {\n      if (this._componentIndex >= this._numLines) {\n        this._currentLine = null;\n        return null;\n      }\n\n      this._currentLine = this._linearGeom.getGeometryN(this._componentIndex);\n    }\n\n    getSegmentStart() {\n      return this._currentLine.getCoordinateN(this._vertexIndex);\n    }\n\n    isEndOfLine() {\n      if (this._componentIndex >= this._numLines) return false;\n      if (this._vertexIndex < this._currentLine.getNumPoints() - 1) return false;\n      return true;\n    }\n\n    hasNext() {\n      if (this._componentIndex >= this._numLines) return false;\n      if (this._componentIndex === this._numLines - 1 && this._vertexIndex >= this._currentLine.getNumPoints()) return false;\n      return true;\n    }\n\n  }\n\n  class LengthIndexOfPoint {\n    constructor() {\n      LengthIndexOfPoint.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._linearGeom = null;\n      const linearGeom = arguments[0];\n      this._linearGeom = linearGeom;\n    }\n\n    static indexOf(linearGeom, inputPt) {\n      const locater = new LengthIndexOfPoint(linearGeom);\n      return locater.indexOf(inputPt);\n    }\n\n    static indexOfAfter(linearGeom, inputPt, minIndex) {\n      const locater = new LengthIndexOfPoint(linearGeom);\n      return locater.indexOfAfter(inputPt, minIndex);\n    }\n\n    indexOf(inputPt) {\n      return this.indexOfFromStart(inputPt, -1.0);\n    }\n\n    indexOfFromStart(inputPt, minIndex) {\n      let minDistance = Double.MAX_VALUE;\n      let ptMeasure = minIndex;\n      let segmentStartMeasure = 0.0;\n      const seg = new LineSegment();\n      const it = new LinearIterator(this._linearGeom);\n\n      while (it.hasNext()) {\n        if (!it.isEndOfLine()) {\n          seg.p0 = it.getSegmentStart();\n          seg.p1 = it.getSegmentEnd();\n          const segDistance = seg.distance(inputPt);\n          const segMeasureToPt = this.segmentNearestMeasure(seg, inputPt, segmentStartMeasure);\n\n          if (segDistance < minDistance && segMeasureToPt > minIndex) {\n            ptMeasure = segMeasureToPt;\n            minDistance = segDistance;\n          }\n\n          segmentStartMeasure += seg.getLength();\n        }\n\n        it.next();\n      }\n\n      return ptMeasure;\n    }\n\n    indexOfAfter(inputPt, minIndex) {\n      if (minIndex < 0.0) return this.indexOf(inputPt);\n\n      const endIndex = this._linearGeom.getLength();\n\n      if (endIndex < minIndex) return endIndex;\n      const closestAfter = this.indexOfFromStart(inputPt, minIndex);\n      Assert.isTrue(closestAfter >= minIndex, 'computed index is before specified minimum index');\n      return closestAfter;\n    }\n\n    segmentNearestMeasure(seg, inputPt, segmentStartMeasure) {\n      const projFactor = seg.projectionFactor(inputPt);\n      if (projFactor <= 0.0) return segmentStartMeasure;\n      if (projFactor <= 1.0) return segmentStartMeasure + projFactor * seg.getLength();\n      return segmentStartMeasure + seg.getLength();\n    }\n\n  }\n\n  class LinearLocation {\n    constructor() {\n      LinearLocation.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._componentIndex = 0;\n      this._segmentIndex = 0;\n      this._segmentFraction = 0.0;\n\n      if (arguments.length === 0) ; else if (arguments.length === 1) {\n        const loc = arguments[0];\n        this._componentIndex = loc._componentIndex;\n        this._segmentIndex = loc._segmentIndex;\n        this._segmentFraction = loc._segmentFraction;\n      } else if (arguments.length === 2) {\n        const segmentIndex = arguments[0],\n              segmentFraction = arguments[1];\n        LinearLocation.constructor_.call(this, 0, segmentIndex, segmentFraction);\n      } else if (arguments.length === 3) {\n        const componentIndex = arguments[0],\n              segmentIndex = arguments[1],\n              segmentFraction = arguments[2];\n        this._componentIndex = componentIndex;\n        this._segmentIndex = segmentIndex;\n        this._segmentFraction = segmentFraction;\n        this.normalize();\n      } else if (arguments.length === 4) {\n        const componentIndex = arguments[0],\n              segmentIndex = arguments[1],\n              segmentFraction = arguments[2],\n              doNormalize = arguments[3];\n        this._componentIndex = componentIndex;\n        this._segmentIndex = segmentIndex;\n        this._segmentFraction = segmentFraction;\n        if (doNormalize) this.normalize();\n      }\n    }\n\n    static getEndLocation(linear) {\n      const loc = new LinearLocation();\n      loc.setToEnd(linear);\n      return loc;\n    }\n\n    static pointAlongSegmentByFraction(p0, p1, frac) {\n      if (frac <= 0.0) return p0;\n      if (frac >= 1.0) return p1;\n      const x = (p1.x - p0.x) * frac + p0.x;\n      const y = (p1.y - p0.y) * frac + p0.y;\n      const z = (p1.getZ() - p0.getZ()) * frac + p0.getZ();\n      return new Coordinate(x, y, z);\n    }\n\n    static compareLocationValues(componentIndex0, segmentIndex0, segmentFraction0, componentIndex1, segmentIndex1, segmentFraction1) {\n      if (componentIndex0 < componentIndex1) return -1;\n      if (componentIndex0 > componentIndex1) return 1;\n      if (segmentIndex0 < segmentIndex1) return -1;\n      if (segmentIndex0 > segmentIndex1) return 1;\n      if (segmentFraction0 < segmentFraction1) return -1;\n      if (segmentFraction0 > segmentFraction1) return 1;\n      return 0;\n    }\n\n    static numSegments(line) {\n      const npts = line.getNumPoints();\n      if (npts <= 1) return 0;\n      return npts - 1;\n    }\n\n    getSegmentIndex() {\n      return this._segmentIndex;\n    }\n\n    getComponentIndex() {\n      return this._componentIndex;\n    }\n\n    isEndpoint(linearGeom) {\n      const lineComp = linearGeom.getGeometryN(this._componentIndex);\n      const nseg = LinearLocation.numSegments(lineComp);\n      return this._segmentIndex >= nseg || this._segmentIndex === nseg - 1 && this._segmentFraction >= 1.0;\n    }\n\n    isValid(linearGeom) {\n      if (this._componentIndex < 0 || this._componentIndex >= linearGeom.getNumGeometries()) return false;\n      const lineComp = linearGeom.getGeometryN(this._componentIndex);\n      if (this._segmentIndex < 0 || this._segmentIndex > lineComp.getNumPoints()) return false;\n      if (this._segmentIndex === lineComp.getNumPoints() && this._segmentFraction !== 0.0) return false;\n      if (this._segmentFraction < 0.0 || this._segmentFraction > 1.0) return false;\n      return true;\n    }\n\n    normalize() {\n      if (this._segmentFraction < 0.0) this._segmentFraction = 0.0;\n      if (this._segmentFraction > 1.0) this._segmentFraction = 1.0;\n\n      if (this._componentIndex < 0) {\n        this._componentIndex = 0;\n        this._segmentIndex = 0;\n        this._segmentFraction = 0.0;\n      }\n\n      if (this._segmentIndex < 0) {\n        this._segmentIndex = 0;\n        this._segmentFraction = 0.0;\n      }\n\n      if (this._segmentFraction === 1.0) {\n        this._segmentFraction = 0.0;\n        this._segmentIndex += 1;\n      }\n    }\n\n    toLowest(linearGeom) {\n      const lineComp = linearGeom.getGeometryN(this._componentIndex);\n      const nseg = LinearLocation.numSegments(lineComp);\n      if (this._segmentIndex < nseg) return this;\n      return new LinearLocation(this._componentIndex, nseg - 1, 1.0, false);\n    }\n\n    getCoordinate(linearGeom) {\n      const lineComp = linearGeom.getGeometryN(this._componentIndex);\n      const p0 = lineComp.getCoordinateN(this._segmentIndex);\n      if (this._segmentIndex >= LinearLocation.numSegments(lineComp)) return p0;\n      const p1 = lineComp.getCoordinateN(this._segmentIndex + 1);\n      return LinearLocation.pointAlongSegmentByFraction(p0, p1, this._segmentFraction);\n    }\n\n    getSegmentFraction() {\n      return this._segmentFraction;\n    }\n\n    getSegment(linearGeom) {\n      const lineComp = linearGeom.getGeometryN(this._componentIndex);\n      const p0 = lineComp.getCoordinateN(this._segmentIndex);\n\n      if (this._segmentIndex >= LinearLocation.numSegments(lineComp)) {\n        const prev = lineComp.getCoordinateN(lineComp.getNumPoints() - 2);\n        return new LineSegment(prev, p0);\n      }\n\n      const p1 = lineComp.getCoordinateN(this._segmentIndex + 1);\n      return new LineSegment(p0, p1);\n    }\n\n    clamp(linear) {\n      if (this._componentIndex >= linear.getNumGeometries()) {\n        this.setToEnd(linear);\n        return null;\n      }\n\n      if (this._segmentIndex >= linear.getNumPoints()) {\n        const line = linear.getGeometryN(this._componentIndex);\n        this._segmentIndex = LinearLocation.numSegments(line);\n        this._segmentFraction = 1.0;\n      }\n    }\n\n    setToEnd(linear) {\n      this._componentIndex = linear.getNumGeometries() - 1;\n      const lastLine = linear.getGeometryN(this._componentIndex);\n      this._segmentIndex = LinearLocation.numSegments(lastLine);\n      this._segmentFraction = 0.0;\n    }\n\n    compareTo(o) {\n      const other = o;\n      if (this._componentIndex < other._componentIndex) return -1;\n      if (this._componentIndex > other._componentIndex) return 1;\n      if (this._segmentIndex < other._segmentIndex) return -1;\n      if (this._segmentIndex > other._segmentIndex) return 1;\n      if (this._segmentFraction < other._segmentFraction) return -1;\n      if (this._segmentFraction > other._segmentFraction) return 1;\n      return 0;\n    }\n\n    copy() {\n      return new LinearLocation(this._componentIndex, this._segmentIndex, this._segmentFraction);\n    }\n\n    toString() {\n      return 'LinearLoc[' + this._componentIndex + ', ' + this._segmentIndex + ', ' + this._segmentFraction + ']';\n    }\n\n    isOnSameSegment(loc) {\n      if (this._componentIndex !== loc._componentIndex) return false;\n      if (this._segmentIndex === loc._segmentIndex) return true;\n      if (loc._segmentIndex - this._segmentIndex === 1 && loc._segmentFraction === 0.0) return true;\n      if (this._segmentIndex - loc._segmentIndex === 1 && this._segmentFraction === 0.0) return true;\n      return false;\n    }\n\n    snapToVertex(linearGeom, minDistance) {\n      if (this._segmentFraction <= 0.0 || this._segmentFraction >= 1.0) return null;\n      const segLen = this.getSegmentLength(linearGeom);\n      const lenToStart = this._segmentFraction * segLen;\n      const lenToEnd = segLen - lenToStart;\n      if (lenToStart <= lenToEnd && lenToStart < minDistance) this._segmentFraction = 0.0;else if (lenToEnd <= lenToStart && lenToEnd < minDistance) this._segmentFraction = 1.0;\n    }\n\n    compareLocationValues(componentIndex1, segmentIndex1, segmentFraction1) {\n      if (this._componentIndex < componentIndex1) return -1;\n      if (this._componentIndex > componentIndex1) return 1;\n      if (this._segmentIndex < segmentIndex1) return -1;\n      if (this._segmentIndex > segmentIndex1) return 1;\n      if (this._segmentFraction < segmentFraction1) return -1;\n      if (this._segmentFraction > segmentFraction1) return 1;\n      return 0;\n    }\n\n    getSegmentLength(linearGeom) {\n      const lineComp = linearGeom.getGeometryN(this._componentIndex);\n      let segIndex = this._segmentIndex;\n      if (this._segmentIndex >= LinearLocation.numSegments(lineComp)) segIndex = lineComp.getNumPoints() - 2;\n      const p0 = lineComp.getCoordinateN(segIndex);\n      const p1 = lineComp.getCoordinateN(segIndex + 1);\n      return p0.distance(p1);\n    }\n\n    isVertex() {\n      return this._segmentFraction <= 0.0 || this._segmentFraction >= 1.0;\n    }\n\n    get interfaces_() {\n      return [Comparable];\n    }\n\n  }\n\n  class LocationIndexOfPoint {\n    constructor() {\n      LocationIndexOfPoint.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._linearGeom = null;\n      const linearGeom = arguments[0];\n      this._linearGeom = linearGeom;\n    }\n\n    static indexOf(linearGeom, inputPt) {\n      const locater = new LocationIndexOfPoint(linearGeom);\n      return locater.indexOf(inputPt);\n    }\n\n    static indexOfAfter(linearGeom, inputPt, minIndex) {\n      const locater = new LocationIndexOfPoint(linearGeom);\n      return locater.indexOfAfter(inputPt, minIndex);\n    }\n\n    indexOf(inputPt) {\n      return this.indexOfFromStart(inputPt, null);\n    }\n\n    indexOfFromStart(inputPt, minIndex) {\n      let minDistance = Double.MAX_VALUE;\n      let minComponentIndex = 0;\n      let minSegmentIndex = 0;\n      let minFrac = -1.0;\n      const seg = new LineSegment();\n\n      for (let it = new LinearIterator(this._linearGeom); it.hasNext(); it.next()) if (!it.isEndOfLine()) {\n        seg.p0 = it.getSegmentStart();\n        seg.p1 = it.getSegmentEnd();\n        const segDistance = seg.distance(inputPt);\n        const segFrac = seg.segmentFraction(inputPt);\n        const candidateComponentIndex = it.getComponentIndex();\n        const candidateSegmentIndex = it.getVertexIndex();\n        if (segDistance < minDistance) if (minIndex === null || minIndex.compareLocationValues(candidateComponentIndex, candidateSegmentIndex, segFrac) < 0) {\n          minComponentIndex = candidateComponentIndex;\n          minSegmentIndex = candidateSegmentIndex;\n          minFrac = segFrac;\n          minDistance = segDistance;\n        }\n      }\n\n      if (minDistance === Double.MAX_VALUE) return new LinearLocation(minIndex);\n      const loc = new LinearLocation(minComponentIndex, minSegmentIndex, minFrac);\n      return loc;\n    }\n\n    indexOfAfter(inputPt, minIndex) {\n      if (minIndex === null) return this.indexOf(inputPt);\n      const endLoc = LinearLocation.getEndLocation(this._linearGeom);\n      if (endLoc.compareTo(minIndex) <= 0) return endLoc;\n      const closestAfter = this.indexOfFromStart(inputPt, minIndex);\n      Assert.isTrue(closestAfter.compareTo(minIndex) >= 0, 'computed location is before specified minimum location');\n      return closestAfter;\n    }\n\n  }\n\n  class LocationIndexOfLine {\n    constructor() {\n      LocationIndexOfLine.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._linearGeom = null;\n      const linearGeom = arguments[0];\n      this._linearGeom = linearGeom;\n    }\n\n    static indicesOf(linearGeom, subLine) {\n      const locater = new LocationIndexOfLine(linearGeom);\n      return locater.indicesOf(subLine);\n    }\n\n    indicesOf(subLine) {\n      const startPt = subLine.getGeometryN(0).getCoordinateN(0);\n      const lastLine = subLine.getGeometryN(subLine.getNumGeometries() - 1);\n      const endPt = lastLine.getCoordinateN(lastLine.getNumPoints() - 1);\n      const locPt = new LocationIndexOfPoint(this._linearGeom);\n      const subLineLoc = new Array(2).fill(null);\n      subLineLoc[0] = locPt.indexOf(startPt);\n      if (subLine.getLength() === 0.0) subLineLoc[1] = subLineLoc[0].copy();else subLineLoc[1] = locPt.indexOfAfter(endPt, subLineLoc[0]);\n      return subLineLoc;\n    }\n\n  }\n\n  class LengthLocationMap {\n    constructor() {\n      LengthLocationMap.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._linearGeom = null;\n      const linearGeom = arguments[0];\n      this._linearGeom = linearGeom;\n    }\n\n    static getLength(linearGeom, loc) {\n      const locater = new LengthLocationMap(linearGeom);\n      return locater.getLength(loc);\n    }\n\n    static getLocation() {\n      if (arguments.length === 2) {\n        const linearGeom = arguments[0],\n              length = arguments[1];\n        const locater = new LengthLocationMap(linearGeom);\n        return locater.getLocation(length);\n      } else if (arguments.length === 3) {\n        const linearGeom = arguments[0],\n              length = arguments[1],\n              resolveLower = arguments[2];\n        const locater = new LengthLocationMap(linearGeom);\n        return locater.getLocation(length, resolveLower);\n      }\n    }\n\n    getLength(loc) {\n      let totalLength = 0.0;\n      const it = new LinearIterator(this._linearGeom);\n\n      while (it.hasNext()) {\n        if (!it.isEndOfLine()) {\n          const p0 = it.getSegmentStart();\n          const p1 = it.getSegmentEnd();\n          const segLen = p1.distance(p0);\n          if (loc.getComponentIndex() === it.getComponentIndex() && loc.getSegmentIndex() === it.getVertexIndex()) return totalLength + segLen * loc.getSegmentFraction();\n          totalLength += segLen;\n        }\n\n        it.next();\n      }\n\n      return totalLength;\n    }\n\n    resolveHigher(loc) {\n      if (!loc.isEndpoint(this._linearGeom)) return loc;\n      let compIndex = loc.getComponentIndex();\n      if (compIndex >= this._linearGeom.getNumGeometries() - 1) return loc;\n\n      do compIndex++; while (compIndex < this._linearGeom.getNumGeometries() - 1 && this._linearGeom.getGeometryN(compIndex).getLength() === 0);\n\n      return new LinearLocation(compIndex, 0, 0.0);\n    }\n\n    getLocation() {\n      if (arguments.length === 1) {\n        const length = arguments[0];\n        return this.getLocation(length, true);\n      } else if (arguments.length === 2) {\n        const length = arguments[0],\n              resolveLower = arguments[1];\n        let forwardLength = length;\n\n        if (length < 0.0) {\n          const lineLen = this._linearGeom.getLength();\n\n          forwardLength = lineLen + length;\n        }\n\n        const loc = this.getLocationForward(forwardLength);\n        if (resolveLower) return loc;\n        return this.resolveHigher(loc);\n      }\n    }\n\n    getLocationForward(length) {\n      if (length <= 0.0) return new LinearLocation();\n      let totalLength = 0.0;\n      const it = new LinearIterator(this._linearGeom);\n\n      while (it.hasNext()) {\n        if (it.isEndOfLine()) {\n          if (totalLength === length) {\n            const compIndex = it.getComponentIndex();\n            const segIndex = it.getVertexIndex();\n            return new LinearLocation(compIndex, segIndex, 0.0);\n          }\n        } else {\n          const p0 = it.getSegmentStart();\n          const p1 = it.getSegmentEnd();\n          const segLen = p1.distance(p0);\n\n          if (totalLength + segLen > length) {\n            const frac = (length - totalLength) / segLen;\n            const compIndex = it.getComponentIndex();\n            const segIndex = it.getVertexIndex();\n            return new LinearLocation(compIndex, segIndex, frac);\n          }\n\n          totalLength += segLen;\n        }\n\n        it.next();\n      }\n\n      return LinearLocation.getEndLocation(this._linearGeom);\n    }\n\n  }\n\n  class LinearGeometryBuilder {\n    constructor() {\n      LinearGeometryBuilder.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._geomFact = null;\n      this._lines = new ArrayList();\n      this._coordList = null;\n      this._ignoreInvalidLines = false;\n      this._fixInvalidLines = false;\n      this._lastPt = null;\n      const geomFact = arguments[0];\n      this._geomFact = geomFact;\n    }\n\n    getGeometry() {\n      this.endLine();\n      return this._geomFact.buildGeometry(this._lines);\n    }\n\n    getLastCoordinate() {\n      return this._lastPt;\n    }\n\n    endLine() {\n      if (this._coordList === null) return null;\n\n      if (this._ignoreInvalidLines && this._coordList.size() < 2) {\n        this._coordList = null;\n        return null;\n      }\n\n      const rawPts = this._coordList.toCoordinateArray();\n\n      let pts = rawPts;\n      if (this._fixInvalidLines) pts = this.validCoordinateSequence(rawPts);\n      this._coordList = null;\n      let line = null;\n\n      try {\n        line = this._geomFact.createLineString(pts);\n      } catch (ex) {\n        if (ex instanceof IllegalArgumentException) {\n          if (!this._ignoreInvalidLines) throw ex;\n        } else {\n          throw ex;\n        }\n      } finally {}\n\n      if (line !== null) this._lines.add(line);\n    }\n\n    setFixInvalidLines(fixInvalidLines) {\n      this._fixInvalidLines = fixInvalidLines;\n    }\n\n    add() {\n      if (arguments.length === 1) {\n        const pt = arguments[0];\n        this.add(pt, true);\n      } else if (arguments.length === 2) {\n        const pt = arguments[0],\n              allowRepeatedPoints = arguments[1];\n        if (this._coordList === null) this._coordList = new CoordinateList();\n\n        this._coordList.add(pt, allowRepeatedPoints);\n\n        this._lastPt = pt;\n      }\n    }\n\n    setIgnoreInvalidLines(ignoreInvalidLines) {\n      this._ignoreInvalidLines = ignoreInvalidLines;\n    }\n\n    validCoordinateSequence(pts) {\n      if (pts.length >= 2) return pts;\n      const validPts = [pts[0], pts[0]];\n      return validPts;\n    }\n\n  }\n\n  class ExtractLineByLocation {\n    constructor() {\n      ExtractLineByLocation.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._line = null;\n      const line = arguments[0];\n      this._line = line;\n    }\n\n    static extract(line, start, end) {\n      const ls = new ExtractLineByLocation(line);\n      return ls.extract(start, end);\n    }\n\n    computeLinear(start, end) {\n      const builder = new LinearGeometryBuilder(this._line.getFactory());\n      builder.setFixInvalidLines(true);\n      if (!start.isVertex()) builder.add(start.getCoordinate(this._line));\n\n      for (let it = new LinearIterator(this._line, start); it.hasNext(); it.next()) {\n        if (end.compareLocationValues(it.getComponentIndex(), it.getVertexIndex(), 0.0) < 0) break;\n        const pt = it.getSegmentStart();\n        builder.add(pt);\n        if (it.isEndOfLine()) builder.endLine();\n      }\n\n      if (!end.isVertex()) builder.add(end.getCoordinate(this._line));\n      return builder.getGeometry();\n    }\n\n    computeLine(start, end) {\n      const coordinates = this._line.getCoordinates();\n\n      const newCoordinates = new CoordinateList();\n      let startSegmentIndex = start.getSegmentIndex();\n      if (start.getSegmentFraction() > 0.0) startSegmentIndex += 1;\n      let lastSegmentIndex = end.getSegmentIndex();\n      if (end.getSegmentFraction() === 1.0) lastSegmentIndex += 1;\n      if (lastSegmentIndex >= coordinates.length) lastSegmentIndex = coordinates.length - 1;\n      if (!start.isVertex()) newCoordinates.add(start.getCoordinate(this._line));\n\n      for (let i = startSegmentIndex; i <= lastSegmentIndex; i++) newCoordinates.add(coordinates[i]);\n\n      if (!end.isVertex()) newCoordinates.add(end.getCoordinate(this._line));\n      if (newCoordinates.size() <= 0) newCoordinates.add(start.getCoordinate(this._line));\n      let newCoordinateArray = newCoordinates.toCoordinateArray();\n      if (newCoordinateArray.length <= 1) newCoordinateArray = [newCoordinateArray[0], newCoordinateArray[0]];\n      return this._line.getFactory().createLineString(newCoordinateArray);\n    }\n\n    extract(start, end) {\n      if (end.compareTo(start) < 0) return this.reverse(this.computeLinear(end, start));\n      return this.computeLinear(start, end);\n    }\n\n    reverse(linear) {\n      if (hasInterface(linear, Lineal)) return linear.reverse();\n      Assert.shouldNeverReachHere('non-linear geometry encountered');\n      return null;\n    }\n\n  }\n\n  class LengthIndexedLine {\n    constructor() {\n      LengthIndexedLine.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._linearGeom = null;\n      const linearGeom = arguments[0];\n      this._linearGeom = linearGeom;\n    }\n\n    clampIndex(index) {\n      const posIndex = this.positiveIndex(index);\n      const startIndex = this.getStartIndex();\n      if (posIndex < startIndex) return startIndex;\n      const endIndex = this.getEndIndex();\n      if (posIndex > endIndex) return endIndex;\n      return posIndex;\n    }\n\n    locationOf() {\n      if (arguments.length === 1) {\n        const index = arguments[0];\n        return LengthLocationMap.getLocation(this._linearGeom, index);\n      } else if (arguments.length === 2) {\n        const index = arguments[0],\n              resolveLower = arguments[1];\n        return LengthLocationMap.getLocation(this._linearGeom, index, resolveLower);\n      }\n    }\n\n    project(pt) {\n      return LengthIndexOfPoint.indexOf(this._linearGeom, pt);\n    }\n\n    positiveIndex(index) {\n      if (index >= 0.0) return index;\n      return this._linearGeom.getLength() + index;\n    }\n\n    extractPoint() {\n      if (arguments.length === 1) {\n        const index = arguments[0];\n        const loc = LengthLocationMap.getLocation(this._linearGeom, index);\n        return loc.getCoordinate(this._linearGeom);\n      } else if (arguments.length === 2) {\n        const index = arguments[0],\n              offsetDistance = arguments[1];\n        const loc = LengthLocationMap.getLocation(this._linearGeom, index);\n        const locLow = loc.toLowest(this._linearGeom);\n        return locLow.getSegment(this._linearGeom).pointAlongOffset(locLow.getSegmentFraction(), offsetDistance);\n      }\n    }\n\n    isValidIndex(index) {\n      return index >= this.getStartIndex() && index <= this.getEndIndex();\n    }\n\n    getEndIndex() {\n      return this._linearGeom.getLength();\n    }\n\n    getStartIndex() {\n      return 0.0;\n    }\n\n    indexOfAfter(pt, minIndex) {\n      return LengthIndexOfPoint.indexOfAfter(this._linearGeom, pt, minIndex);\n    }\n\n    extractLine(startIndex, endIndex) {\n      const startIndex2 = this.clampIndex(startIndex);\n      const endIndex2 = this.clampIndex(endIndex);\n      const resolveStartLower = startIndex2 === endIndex2;\n      const startLoc = this.locationOf(startIndex2, resolveStartLower);\n      const endLoc = this.locationOf(endIndex2);\n      return ExtractLineByLocation.extract(this._linearGeom, startLoc, endLoc);\n    }\n\n    indexOf(pt) {\n      return LengthIndexOfPoint.indexOf(this._linearGeom, pt);\n    }\n\n    indicesOf(subLine) {\n      const locIndex = LocationIndexOfLine.indicesOf(this._linearGeom, subLine);\n      const index = [LengthLocationMap.getLength(this._linearGeom, locIndex[0]), LengthLocationMap.getLength(this._linearGeom, locIndex[1])];\n      return index;\n    }\n\n  }\n\n  class LocationIndexedLine {\n    constructor() {\n      LocationIndexedLine.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._linearGeom = null;\n      const linearGeom = arguments[0];\n      this._linearGeom = linearGeom;\n      this.checkGeometryType();\n    }\n\n    clampIndex(index) {\n      const loc = index.copy();\n      loc.clamp(this._linearGeom);\n      return loc;\n    }\n\n    project(pt) {\n      return LocationIndexOfPoint.indexOf(this._linearGeom, pt);\n    }\n\n    checkGeometryType() {\n      if (!(this._linearGeom instanceof LineString || this._linearGeom instanceof MultiLineString)) throw new IllegalArgumentException('Input geometry must be linear');\n    }\n\n    extractPoint() {\n      if (arguments.length === 1) {\n        const index = arguments[0];\n        return index.getCoordinate(this._linearGeom);\n      } else if (arguments.length === 2) {\n        const index = arguments[0],\n              offsetDistance = arguments[1];\n        const indexLow = index.toLowest(this._linearGeom);\n        return indexLow.getSegment(this._linearGeom).pointAlongOffset(indexLow.getSegmentFraction(), offsetDistance);\n      }\n    }\n\n    isValidIndex(index) {\n      return index.isValid(this._linearGeom);\n    }\n\n    getEndIndex() {\n      return LinearLocation.getEndLocation(this._linearGeom);\n    }\n\n    getStartIndex() {\n      return new LinearLocation();\n    }\n\n    indexOfAfter(pt, minIndex) {\n      return LocationIndexOfPoint.indexOfAfter(this._linearGeom, pt, minIndex);\n    }\n\n    extractLine(startIndex, endIndex) {\n      return ExtractLineByLocation.extract(this._linearGeom, startIndex, endIndex);\n    }\n\n    indexOf(pt) {\n      return LocationIndexOfPoint.indexOf(this._linearGeom, pt);\n    }\n\n    indicesOf(subLine) {\n      return LocationIndexOfLine.indicesOf(this._linearGeom, subLine);\n    }\n\n  }\n\n  var linearref = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    LengthIndexedLine: LengthIndexedLine,\n    LengthLocationMap: LengthLocationMap,\n    LinearGeometryBuilder: LinearGeometryBuilder,\n    LinearIterator: LinearIterator,\n    LinearLocation: LinearLocation,\n    LocationIndexedLine: LocationIndexedLine\n  });\n\n  class CollectionUtil {\n    static transform(coll, func) {\n      const result = new ArrayList();\n\n      for (let i = coll.iterator(); i.hasNext();) result.add(func.execute(i.next()));\n\n      return result;\n    }\n\n    static select(collection, func) {\n      const result = new ArrayList();\n\n      for (let i = collection.iterator(); i.hasNext();) {\n        const item = i.next();\n        if (Boolean.TRUE.equals(func.execute(item))) result.add(item);\n      }\n\n      return result;\n    }\n\n    static apply(coll, func) {\n      for (let i = coll.iterator(); i.hasNext();) func.execute(i.next());\n    }\n\n  }\n\n  function Function() {}\n\n  CollectionUtil.Function = Function;\n\n  class CoordinateArrayFilter {\n    constructor() {\n      CoordinateArrayFilter.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.pts = null;\n      this.n = 0;\n      const size = arguments[0];\n      this.pts = new Array(size).fill(null);\n    }\n\n    filter(coord) {\n      this.pts[this.n++] = coord;\n    }\n\n    getCoordinates() {\n      return this.pts;\n    }\n\n    get interfaces_() {\n      return [CoordinateFilter];\n    }\n\n  }\n\n  class CoordinateCountFilter {\n    constructor() {\n      CoordinateCountFilter.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._n = 0;\n    }\n\n    filter(coord) {\n      this._n++;\n    }\n\n    getCount() {\n      return this._n;\n    }\n\n    get interfaces_() {\n      return [CoordinateFilter];\n    }\n\n  }\n\n  class ObjectCounter {\n    constructor() {\n      ObjectCounter.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this._counts = new HashMap();\n    }\n\n    count(o) {\n      const counter = this._counts.get(o);\n\n      if (counter === null) return 0;else return counter.count();\n    }\n\n    add(o) {\n      const counter = this._counts.get(o);\n\n      if (counter === null) this._counts.put(o, new Counter$1(1));else counter.increment();\n    }\n\n  }\n\n  class Counter$1 {\n    constructor() {\n      Counter$1.constructor_.apply(this, arguments);\n    }\n\n    static constructor_() {\n      this.count = 0;\n\n      if (arguments.length === 0) ; else if (arguments.length === 1) {\n        const count = arguments[0];\n        this.count = count;\n      }\n    }\n\n    count() {\n      return this.count;\n    }\n\n    increment() {\n      this.count++;\n    }\n\n  }\n\n  ObjectCounter.Counter = Counter$1;\n\n  function PrintStream() {}\n\n  function StringReader() {}\n\n  function ByteArrayOutputStream() {}\n\n  class IOException extends Exception {}\n\n  function LineNumberReader() {}\n\n  class StringUtil {\n    static chars(c, n) {\n      const ch = new Array(n).fill(null);\n\n      for (let i = 0; i < n; i++) ch[i] = c;\n\n      return new String(ch);\n    }\n\n    static getStackTrace() {\n      if (arguments.length === 1) {\n        const t = arguments[0];\n        const os = new ByteArrayOutputStream();\n        const ps = new PrintStream(os);\n        t.printStackTrace(ps);\n        return os.toString();\n      } else if (arguments.length === 2) {\n        const t = arguments[0],\n              depth = arguments[1];\n        let stackTrace = '';\n        const stringReader = new StringReader(StringUtil.getStackTrace(t));\n        const lineNumberReader = new LineNumberReader(stringReader);\n\n        for (let i = 0; i < depth; i++) try {\n          stackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;\n        } catch (e) {\n          if (e instanceof IOException) Assert.shouldNeverReachHere();else throw e;\n        } finally {}\n\n        return stackTrace;\n      }\n    }\n\n    static spaces(n) {\n      return StringUtil.chars(' ', n);\n    }\n\n    static split(s, separator) {\n      const separatorlen = separator.length;\n      const tokenList = new ArrayList();\n      let tmpString = '' + s;\n      let pos = tmpString.indexOf(separator);\n\n      while (pos >= 0) {\n        const token = tmpString.substring(0, pos);\n        tokenList.add(token);\n        tmpString = tmpString.substring(pos + separatorlen);\n        pos = tmpString.indexOf(separator);\n      }\n\n      if (tmpString.length > 0) tokenList.add(tmpString);\n      const res = new Array(tokenList.size()).fill(null);\n\n      for (let i = 0; i < res.length; i++) res[i] = tokenList.get(i);\n\n      return res;\n    }\n\n  }\n  StringUtil.NEWLINE = System.getProperty('line.separator');\n\n  var util$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    CollectionUtil: CollectionUtil,\n    CoordinateArrayFilter: CoordinateArrayFilter,\n    CoordinateCountFilter: CoordinateCountFilter,\n    GeometricShapeFactory: GeometricShapeFactory,\n    NumberUtil: NumberUtil,\n    ObjectCounter: ObjectCounter,\n    PriorityQueue: PriorityQueue,\n    StringUtil: StringUtil,\n    UniqueCoordinateArrayFilter: UniqueCoordinateArrayFilter\n  });\n\n  class UnionOp {\n    get interfaces_() {\n      return [];\n    }\n\n    getClass() {\n      return UnionOp;\n    }\n\n    static union(g, other) {\n      if (g.isEmpty() || other.isEmpty()) {\n        if (g.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.UNION, g, other, g.getFactory());\n        if (g.isEmpty()) return other.copy();\n        if (other.isEmpty()) return g.copy();\n      }\n\n      g.checkNotGeometryCollection(g);\n      g.checkNotGeometryCollection(other);\n      return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.UNION);\n    }\n\n  }\n\n  LineString.prototype.getBoundary = function () {\n    return BoundaryOp.getBoundary(this);\n  };\n\n  MultiLineString.prototype.getBoundary = function () {\n    return BoundaryOp.getBoundary(this);\n  };\n\n  Geometry.prototype.equalsTopo = function (g) {\n    return RelateOp.equalsTopo(this, g);\n  };\n\n  Geometry.prototype.equals = function (g) {\n    if (g === null) return false;\n    return RelateOp.equalsTopo(this, g);\n  };\n\n  Geometry.prototype.union = function () {\n    if (arguments.length === 0) {\n      return UnaryUnionOp.union(this);\n    } else if (arguments.length === 1) {\n      const other = arguments[0];\n      return UnionOp.union(this, other);\n    }\n  };\n\n  Geometry.prototype.isValid = function () {\n    return IsValidOp.isValid(this);\n  };\n\n  Geometry.prototype.intersection = function (other) {\n    return OverlayOp.intersection(this, other);\n  };\n\n  Geometry.prototype.covers = function (g) {\n    return RelateOp.covers(this, g);\n  };\n\n  Geometry.prototype.coveredBy = function (g) {\n    return RelateOp.covers(g, this);\n  };\n\n  Geometry.prototype.touches = function (g) {\n    return RelateOp.touches(this, g);\n  };\n\n  Geometry.prototype.intersects = function (g) {\n    return RelateOp.intersects(this, g);\n  };\n\n  Geometry.prototype.within = function (g) {\n    return RelateOp.contains(g, this);\n  };\n\n  Geometry.prototype.overlaps = function (g) {\n    return RelateOp.overlaps(this, g);\n  };\n\n  Geometry.prototype.disjoint = function (g) {\n    return RelateOp.disjoint(this, g);\n  };\n\n  Geometry.prototype.crosses = function (g) {\n    return RelateOp.crosses(this, g);\n  };\n\n  Geometry.prototype.buffer = function () {\n    if (arguments.length === 1) {\n      const distance = arguments[0];\n      return BufferOp.bufferOp(this, distance);\n    } else if (arguments.length === 2) {\n      const distance = arguments[0];\n      const quadrantSegments = arguments[1];\n      return BufferOp.bufferOp(this, distance, quadrantSegments);\n    } else if (arguments.length === 3) {\n      const distance = arguments[0];\n      const quadrantSegments = arguments[1];\n      const endCapStyle = arguments[2];\n      return BufferOp.bufferOp(this, distance, quadrantSegments, endCapStyle);\n    }\n  };\n\n  Geometry.prototype.convexHull = function () {\n    return new ConvexHull(this).getConvexHull();\n  };\n\n  Geometry.prototype.relate = function () {\n    if (arguments.length === 1) {\n      const geometry = arguments[0];\n      return RelateOp.relate(this, geometry);\n    } else if (arguments.length === 2) {\n      const geometry = arguments[0];\n      const intersectionPattern = arguments[1];\n      return RelateOp.relate(this, geometry).matches(intersectionPattern);\n    }\n  };\n\n  Geometry.prototype.getCentroid = function () {\n    if (this.isEmpty()) return this._factory.createPoint();\n    const centPt = Centroid.getCentroid(this);\n    return this.createPointFromInternalCoord(centPt, this);\n  };\n\n  Geometry.prototype.getInteriorPoint = function () {\n    if (this.isEmpty()) return this._factory.createPoint();\n    let intPt = null;\n    const dim = this.getDimension();\n    if (dim === 0) intPt = new InteriorPointPoint(this);else if (dim === 1) intPt = new InteriorPointLine(this);else intPt = new InteriorPointArea(this);\n    const interiorPt = intPt.getInteriorPoint();\n    return this.createPointFromInternalCoord(interiorPt, this);\n  };\n\n  Geometry.prototype.symDifference = function (other) {\n    return OverlayOp.symDifference(this, other);\n  };\n\n  Geometry.prototype.createPointFromInternalCoord = function (coord, exemplar) {\n    exemplar.getPrecisionModel().makePrecise(coord);\n    return exemplar.getFactory().createPoint(coord);\n  };\n\n  Geometry.prototype.toText = function () {\n    const writer = new WKTWriter();\n    return writer.write(this);\n  };\n\n  Geometry.prototype.toString = function () {\n    this.toText();\n  };\n\n  Geometry.prototype.contains = function (g) {\n    return RelateOp.contains(this, g);\n  };\n\n  Geometry.prototype.difference = function (other) {\n    return OverlayOp.difference(this, other);\n  };\n\n  Geometry.prototype.isSimple = function () {\n    const op = new IsSimpleOp(this);\n    return op.isSimple();\n  };\n\n  Geometry.prototype.isWithinDistance = function (geom, distance) {\n    const envDist = this.getEnvelopeInternal().distance(geom.getEnvelopeInternal());\n    if (envDist > distance) return false;\n    return DistanceOp.isWithinDistance(this, geom, distance);\n  };\n\n  Geometry.prototype.distance = function (g) {\n    return DistanceOp.distance(this, g);\n  };\n\n  const version = '2.5.0 (ba89299)';\n\n  exports.algorithm = algorithm;\n  exports.densify = densify;\n  exports.dissolve = dissolve;\n  exports.geom = geom;\n  exports.geomgraph = geomgraph;\n  exports.index = index;\n  exports.io = io;\n  exports.linearref = linearref;\n  exports.noding = noding;\n  exports.operation = operation;\n  exports.precision = precision;\n  exports.simplify = simplify;\n  exports.triangulate = triangulate;\n  exports.util = util$1;\n  exports.version = version;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=jsts.js.map\n","'use strict';\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Helpers\n\n// Merge objects\n//\nfunction assign(obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n\n  sources.forEach(function (source) {\n    if (!source) { return; }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key];\n    });\n  });\n\n  return obj;\n}\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\nfunction isString(obj) { return _class(obj) === '[object String]'; }\nfunction isObject(obj) { return _class(obj) === '[object Object]'; }\nfunction isRegExp(obj) { return _class(obj) === '[object RegExp]'; }\nfunction isFunction(obj) { return _class(obj) === '[object Function]'; }\n\n\nfunction escapeRE(str) { return str.replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&'); }\n\n////////////////////////////////////////////////////////////////////////////////\n\n\nvar defaultOptions = {\n  fuzzyLink: true,\n  fuzzyEmail: true,\n  fuzzyIP: false\n};\n\n\nfunction isOptionsObj(obj) {\n  return Object.keys(obj || {}).reduce(function (acc, k) {\n    return acc || defaultOptions.hasOwnProperty(k);\n  }, false);\n}\n\n\nvar defaultSchemas = {\n  'http:': {\n    validate: function (text, pos, self) {\n      var tail = text.slice(pos);\n\n      if (!self.re.http) {\n        // compile lazily, because \"host\"-containing variables can change on tlds update.\n        self.re.http =  new RegExp(\n          '^\\\\/\\\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i'\n        );\n      }\n      if (self.re.http.test(tail)) {\n        return tail.match(self.re.http)[0].length;\n      }\n      return 0;\n    }\n  },\n  'https:':  'http:',\n  'ftp:':    'http:',\n  '//':      {\n    validate: function (text, pos, self) {\n      var tail = text.slice(pos);\n\n      if (!self.re.no_http) {\n      // compile lazily, because \"host\"-containing variables can change on tlds update.\n        self.re.no_http =  new RegExp(\n          '^' +\n          self.re.src_auth +\n          // Don't allow single-level domains, because of false positives like '//test'\n          // with code comments\n          '(?:localhost|(?:(?:' + self.re.src_domain + ')\\\\.)+' + self.re.src_domain_root + ')' +\n          self.re.src_port +\n          self.re.src_host_terminator +\n          self.re.src_path,\n\n          'i'\n        );\n      }\n\n      if (self.re.no_http.test(tail)) {\n        // should not be `://` & `///`, that protects from errors in protocol name\n        if (pos >= 3 && text[pos - 3] === ':') { return 0; }\n        if (pos >= 3 && text[pos - 3] === '/') { return 0; }\n        return tail.match(self.re.no_http)[0].length;\n      }\n      return 0;\n    }\n  },\n  'mailto:': {\n    validate: function (text, pos, self) {\n      var tail = text.slice(pos);\n\n      if (!self.re.mailto) {\n        self.re.mailto =  new RegExp(\n          '^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i'\n        );\n      }\n      if (self.re.mailto.test(tail)) {\n        return tail.match(self.re.mailto)[0].length;\n      }\n      return 0;\n    }\n  }\n};\n\n/*eslint-disable max-len*/\n\n// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)\nvar tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';\n\n// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead\nvar tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');\n\n/*eslint-enable max-len*/\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction resetScanCache(self) {\n  self.__index__ = -1;\n  self.__text_cache__   = '';\n}\n\nfunction createValidator(re) {\n  return function (text, pos) {\n    var tail = text.slice(pos);\n\n    if (re.test(tail)) {\n      return tail.match(re)[0].length;\n    }\n    return 0;\n  };\n}\n\nfunction createNormalizer() {\n  return function (match, self) {\n    self.normalize(match);\n  };\n}\n\n// Schemas compiler. Build regexps.\n//\nfunction compile(self) {\n\n  // Load & clone RE patterns.\n  var re = self.re = require('./lib/re')(self.__opts__);\n\n  // Define dynamic patterns\n  var tlds = self.__tlds__.slice();\n\n  self.onCompile();\n\n  if (!self.__tlds_replaced__) {\n    tlds.push(tlds_2ch_src_re);\n  }\n  tlds.push(re.src_xn);\n\n  re.src_tlds = tlds.join('|');\n\n  function untpl(tpl) { return tpl.replace('%TLDS%', re.src_tlds); }\n\n  re.email_fuzzy      = RegExp(untpl(re.tpl_email_fuzzy), 'i');\n  re.link_fuzzy       = RegExp(untpl(re.tpl_link_fuzzy), 'i');\n  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');\n  re.host_fuzzy_test  = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');\n\n  //\n  // Compile each schema\n  //\n\n  var aliases = [];\n\n  self.__compiled__ = {}; // Reset compiled data\n\n  function schemaError(name, val) {\n    throw new Error('(LinkifyIt) Invalid schema \"' + name + '\": ' + val);\n  }\n\n  Object.keys(self.__schemas__).forEach(function (name) {\n    var val = self.__schemas__[name];\n\n    // skip disabled methods\n    if (val === null) { return; }\n\n    var compiled = { validate: null, link: null };\n\n    self.__compiled__[name] = compiled;\n\n    if (isObject(val)) {\n      if (isRegExp(val.validate)) {\n        compiled.validate = createValidator(val.validate);\n      } else if (isFunction(val.validate)) {\n        compiled.validate = val.validate;\n      } else {\n        schemaError(name, val);\n      }\n\n      if (isFunction(val.normalize)) {\n        compiled.normalize = val.normalize;\n      } else if (!val.normalize) {\n        compiled.normalize = createNormalizer();\n      } else {\n        schemaError(name, val);\n      }\n\n      return;\n    }\n\n    if (isString(val)) {\n      aliases.push(name);\n      return;\n    }\n\n    schemaError(name, val);\n  });\n\n  //\n  // Compile postponed aliases\n  //\n\n  aliases.forEach(function (alias) {\n    if (!self.__compiled__[self.__schemas__[alias]]) {\n      // Silently fail on missed schemas to avoid errons on disable.\n      // schemaError(alias, self.__schemas__[alias]);\n      return;\n    }\n\n    self.__compiled__[alias].validate =\n      self.__compiled__[self.__schemas__[alias]].validate;\n    self.__compiled__[alias].normalize =\n      self.__compiled__[self.__schemas__[alias]].normalize;\n  });\n\n  //\n  // Fake record for guessed links\n  //\n  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };\n\n  //\n  // Build schema condition\n  //\n  var slist = Object.keys(self.__compiled__)\n                      .filter(function (name) {\n                        // Filter disabled & fake schemas\n                        return name.length > 0 && self.__compiled__[name];\n                      })\n                      .map(escapeRE)\n                      .join('|');\n  // (?!_) cause 1.5x slowdown\n  self.re.schema_test   = RegExp('(^|(?!_)(?:[><\\uff5c]|' + re.src_ZPCc + '))(' + slist + ')', 'i');\n  self.re.schema_search = RegExp('(^|(?!_)(?:[><\\uff5c]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');\n\n  self.re.pretest = RegExp(\n    '(' + self.re.schema_test.source + ')|(' + self.re.host_fuzzy_test.source + ')|@',\n    'i'\n  );\n\n  //\n  // Cleanup\n  //\n\n  resetScanCache(self);\n}\n\n/**\n * class Match\n *\n * Match result. Single element of array, returned by [[LinkifyIt#match]]\n **/\nfunction Match(self, shift) {\n  var start = self.__index__,\n      end   = self.__last_index__,\n      text  = self.__text_cache__.slice(start, end);\n\n  /**\n   * Match#schema -> String\n   *\n   * Prefix (protocol) for matched string.\n   **/\n  this.schema    = self.__schema__.toLowerCase();\n  /**\n   * Match#index -> Number\n   *\n   * First position of matched string.\n   **/\n  this.index     = start + shift;\n  /**\n   * Match#lastIndex -> Number\n   *\n   * Next position after matched string.\n   **/\n  this.lastIndex = end + shift;\n  /**\n   * Match#raw -> String\n   *\n   * Matched string.\n   **/\n  this.raw       = text;\n  /**\n   * Match#text -> String\n   *\n   * Notmalized text of matched string.\n   **/\n  this.text      = text;\n  /**\n   * Match#url -> String\n   *\n   * Normalized url of matched string.\n   **/\n  this.url       = text;\n}\n\nfunction createMatch(self, shift) {\n  var match = new Match(self, shift);\n\n  self.__compiled__[match.schema].normalize(match, self);\n\n  return match;\n}\n\n\n/**\n * class LinkifyIt\n **/\n\n/**\n * new LinkifyIt(schemas, options)\n * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)\n * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }\n *\n * Creates new linkifier instance with optional additional schemas.\n * Can be called without `new` keyword for convenience.\n *\n * By default understands:\n *\n * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links\n * - \"fuzzy\" links and emails (example.com, foo@bar.com).\n *\n * `schemas` is an object, where each key/value describes protocol/rule:\n *\n * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`\n *   for example). `linkify-it` makes shure that prefix is not preceeded with\n *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.\n * - __value__ - rule to check tail after link prefix\n *   - _String_ - just alias to existing rule\n *   - _Object_\n *     - _validate_ - validator function (should return matched length on success),\n *       or `RegExp`.\n *     - _normalize_ - optional function to normalize text & url of matched result\n *       (for example, for @twitter mentions).\n *\n * `options`:\n *\n * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.\n * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts\n *   like version numbers. Default `false`.\n * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.\n *\n **/\nfunction LinkifyIt(schemas, options) {\n  if (!(this instanceof LinkifyIt)) {\n    return new LinkifyIt(schemas, options);\n  }\n\n  if (!options) {\n    if (isOptionsObj(schemas)) {\n      options = schemas;\n      schemas = {};\n    }\n  }\n\n  this.__opts__           = assign({}, defaultOptions, options);\n\n  // Cache last tested result. Used to skip repeating steps on next `match` call.\n  this.__index__          = -1;\n  this.__last_index__     = -1; // Next scan position\n  this.__schema__         = '';\n  this.__text_cache__     = '';\n\n  this.__schemas__        = assign({}, defaultSchemas, schemas);\n  this.__compiled__       = {};\n\n  this.__tlds__           = tlds_default;\n  this.__tlds_replaced__  = false;\n\n  this.re = {};\n\n  compile(this);\n}\n\n\n/** chainable\n * LinkifyIt#add(schema, definition)\n * - schema (String): rule name (fixed pattern prefix)\n * - definition (String|RegExp|Object): schema definition\n *\n * Add new rule definition. See constructor description for details.\n **/\nLinkifyIt.prototype.add = function add(schema, definition) {\n  this.__schemas__[schema] = definition;\n  compile(this);\n  return this;\n};\n\n\n/** chainable\n * LinkifyIt#set(options)\n * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }\n *\n * Set recognition options for links without schema.\n **/\nLinkifyIt.prototype.set = function set(options) {\n  this.__opts__ = assign(this.__opts__, options);\n  return this;\n};\n\n\n/**\n * LinkifyIt#test(text) -> Boolean\n *\n * Searches linkifiable pattern and returns `true` on success or `false` on fail.\n **/\nLinkifyIt.prototype.test = function test(text) {\n  // Reset scan cache\n  this.__text_cache__ = text;\n  this.__index__      = -1;\n\n  if (!text.length) { return false; }\n\n  var m, ml, me, len, shift, next, re, tld_pos, at_pos;\n\n  // try to scan for link with schema - that's the most simple rule\n  if (this.re.schema_test.test(text)) {\n    re = this.re.schema_search;\n    re.lastIndex = 0;\n    while ((m = re.exec(text)) !== null) {\n      len = this.testSchemaAt(text, m[2], re.lastIndex);\n      if (len) {\n        this.__schema__     = m[2];\n        this.__index__      = m.index + m[1].length;\n        this.__last_index__ = m.index + m[0].length + len;\n        break;\n      }\n    }\n  }\n\n  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {\n    // guess schemaless links\n    tld_pos = text.search(this.re.host_fuzzy_test);\n    if (tld_pos >= 0) {\n      // if tld is located after found link - no need to check fuzzy pattern\n      if (this.__index__ < 0 || tld_pos < this.__index__) {\n        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {\n\n          shift = ml.index + ml[1].length;\n\n          if (this.__index__ < 0 || shift < this.__index__) {\n            this.__schema__     = '';\n            this.__index__      = shift;\n            this.__last_index__ = ml.index + ml[0].length;\n          }\n        }\n      }\n    }\n  }\n\n  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {\n    // guess schemaless emails\n    at_pos = text.indexOf('@');\n    if (at_pos >= 0) {\n      // We can't skip this check, because this cases are possible:\n      // 192.168.1.1@gmail.com, my.in@example.com\n      if ((me = text.match(this.re.email_fuzzy)) !== null) {\n\n        shift = me.index + me[1].length;\n        next  = me.index + me[0].length;\n\n        if (this.__index__ < 0 || shift < this.__index__ ||\n            (shift === this.__index__ && next > this.__last_index__)) {\n          this.__schema__     = 'mailto:';\n          this.__index__      = shift;\n          this.__last_index__ = next;\n        }\n      }\n    }\n  }\n\n  return this.__index__ >= 0;\n};\n\n\n/**\n * LinkifyIt#pretest(text) -> Boolean\n *\n * Very quick check, that can give false positives. Returns true if link MAY BE\n * can exists. Can be used for speed optimization, when you need to check that\n * link NOT exists.\n **/\nLinkifyIt.prototype.pretest = function pretest(text) {\n  return this.re.pretest.test(text);\n};\n\n\n/**\n * LinkifyIt#testSchemaAt(text, name, position) -> Number\n * - text (String): text to scan\n * - name (String): rule (schema) name\n * - position (Number): text offset to check from\n *\n * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly\n * at given position. Returns length of found pattern (0 on fail).\n **/\nLinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {\n  // If not supported schema check requested - terminate\n  if (!this.__compiled__[schema.toLowerCase()]) {\n    return 0;\n  }\n  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);\n};\n\n\n/**\n * LinkifyIt#match(text) -> Array|null\n *\n * Returns array of found link descriptions or `null` on fail. We strongly\n * recommend to use [[LinkifyIt#test]] first, for best speed.\n *\n * ##### Result match description\n *\n * - __schema__ - link schema, can be empty for fuzzy links, or `//` for\n *   protocol-neutral  links.\n * - __index__ - offset of matched text\n * - __lastIndex__ - index of next char after mathch end\n * - __raw__ - matched text\n * - __text__ - normalized text\n * - __url__ - link, generated from matched text\n **/\nLinkifyIt.prototype.match = function match(text) {\n  var shift = 0, result = [];\n\n  // Try to take previous element from cache, if .test() called before\n  if (this.__index__ >= 0 && this.__text_cache__ === text) {\n    result.push(createMatch(this, shift));\n    shift = this.__last_index__;\n  }\n\n  // Cut head if cache was used\n  var tail = shift ? text.slice(shift) : text;\n\n  // Scan string until end reached\n  while (this.test(tail)) {\n    result.push(createMatch(this, shift));\n\n    tail = tail.slice(this.__last_index__);\n    shift += this.__last_index__;\n  }\n\n  if (result.length) {\n    return result;\n  }\n\n  return null;\n};\n\n\n/** chainable\n * LinkifyIt#tlds(list [, keepOld]) -> this\n * - list (Array): list of tlds\n * - keepOld (Boolean): merge with current list if `true` (`false` by default)\n *\n * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)\n * to avoid false positives. By default this algorythm used:\n *\n * - hostname with any 2-letter root zones are ok.\n * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф\n *   are ok.\n * - encoded (`xn--...`) root zones are ok.\n *\n * If list is replaced, then exact match for 2-chars root zones will be checked.\n **/\nLinkifyIt.prototype.tlds = function tlds(list, keepOld) {\n  list = Array.isArray(list) ? list : [ list ];\n\n  if (!keepOld) {\n    this.__tlds__ = list.slice();\n    this.__tlds_replaced__ = true;\n    compile(this);\n    return this;\n  }\n\n  this.__tlds__ = this.__tlds__.concat(list)\n                                  .sort()\n                                  .filter(function (el, idx, arr) {\n                                    return el !== arr[idx - 1];\n                                  })\n                                  .reverse();\n\n  compile(this);\n  return this;\n};\n\n/**\n * LinkifyIt#normalize(match)\n *\n * Default normalizer (if schema does not define it's own).\n **/\nLinkifyIt.prototype.normalize = function normalize(match) {\n\n  // Do minimal possible changes by default. Need to collect feedback prior\n  // to move forward https://github.com/markdown-it/linkify-it/issues/1\n\n  if (!match.schema) { match.url = 'http://' + match.url; }\n\n  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {\n    match.url = 'mailto:' + match.url;\n  }\n};\n\n\n/**\n * LinkifyIt#onCompile()\n *\n * Override to modify basic RegExp-s.\n **/\nLinkifyIt.prototype.onCompile = function onCompile() {\n};\n\n\nmodule.exports = LinkifyIt;\n","'use strict';\n\n\nmodule.exports = function (opts) {\n  var re = {};\n\n  // Use direct extract instead of `regenerate` to reduse browserified size\n  re.src_Any = require('uc.micro/properties/Any/regex').source;\n  re.src_Cc  = require('uc.micro/categories/Cc/regex').source;\n  re.src_Z   = require('uc.micro/categories/Z/regex').source;\n  re.src_P   = require('uc.micro/categories/P/regex').source;\n\n  // \\p{\\Z\\P\\Cc\\CF} (white spaces + control + format + punctuation)\n  re.src_ZPCc = [ re.src_Z, re.src_P, re.src_Cc ].join('|');\n\n  // \\p{\\Z\\Cc} (white spaces + control)\n  re.src_ZCc = [ re.src_Z, re.src_Cc ].join('|');\n\n  // Experimental. List of chars, completely prohibited in links\n  // because can separate it from other part of text\n  var text_separators = '[><\\uff5c]';\n\n  // All possible word characters (everything without punctuation, spaces & controls)\n  // Defined via punctuation & spaces to save space\n  // Should be something like \\p{\\L\\N\\S\\M} (\\w but without `_`)\n  re.src_pseudo_letter       = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';\n  // The same as abothe but without [0-9]\n  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';\n\n  ////////////////////////////////////////////////////////////////////////////////\n\n  re.src_ip4 =\n\n    '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';\n\n  // Prohibit any of \"@/[]()\" in user/pass to avoid wrong domain fetch.\n  re.src_auth    = '(?:(?:(?!' + re.src_ZCc + '|[@/\\\\[\\\\]()]).)+@)?';\n\n  re.src_port =\n\n    '(?::(?:6(?:[0-4]\\\\d{3}|5(?:[0-4]\\\\d{2}|5(?:[0-2]\\\\d|3[0-5])))|[1-5]?\\\\d{1,4}))?';\n\n  re.src_host_terminator =\n\n    '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\\\d|\\\\.-|\\\\.(?!$|' + re.src_ZPCc + '))';\n\n  re.src_path =\n\n    '(?:' +\n      '[/?#]' +\n        '(?:' +\n          '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\\\]{}.,\"\\'?!\\\\-]).|' +\n          '\\\\[(?:(?!' + re.src_ZCc + '|\\\\]).)*\\\\]|' +\n          '\\\\((?:(?!' + re.src_ZCc + '|[)]).)*\\\\)|' +\n          '\\\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\\\}|' +\n          '\\\\\"(?:(?!' + re.src_ZCc + '|[\"]).)+\\\\\"|' +\n          \"\\\\'(?:(?!\" + re.src_ZCc + \"|[']).)+\\\\'|\" +\n          \"\\\\'(?=\" + re.src_pseudo_letter + '|[-]).|' +  // allow `I'm_king` if no pair found\n          '\\\\.{2,}[a-zA-Z0-9%/&]|' + // google has many dots in \"google search\" links (#66, #81).\n                                     // github has ... in commit range links,\n                                     // Restrict to\n                                     // - english\n                                     // - percent-encoded\n                                     // - parts of file path\n                                     // - params separator\n                                     // until more examples found.\n          '\\\\.(?!' + re.src_ZCc + '|[.]).|' +\n          (opts && opts['---'] ?\n            '\\\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate\n            :\n            '\\\\-+|'\n          ) +\n          '\\\\,(?!' + re.src_ZCc + ').|' +       // allow `,,,` in paths\n          '\\\\!+(?!' + re.src_ZCc + '|[!]).|' +  // allow `!!!` in paths, but not at the end\n          '\\\\?(?!' + re.src_ZCc + '|[?]).' +\n        ')+' +\n      '|\\\\/' +\n    ')?';\n\n  // Allow anything in markdown spec, forbid quote (\") at the first position\n  // because emails enclosed in quotes are far more common\n  re.src_email_name =\n\n    '[\\\\-;:&=\\\\+\\\\$,\\\\.a-zA-Z0-9_][\\\\-;:&=\\\\+\\\\$,\\\\\"\\\\.a-zA-Z0-9_]*';\n\n  re.src_xn =\n\n    'xn--[a-z0-9\\\\-]{1,59}';\n\n  // More to read about domain names\n  // http://serverfault.com/questions/638260/\n\n  re.src_domain_root =\n\n    // Allow letters & digits (http://test1)\n    '(?:' +\n      re.src_xn +\n      '|' +\n      re.src_pseudo_letter + '{1,63}' +\n    ')';\n\n  re.src_domain =\n\n    '(?:' +\n      re.src_xn +\n      '|' +\n      '(?:' + re.src_pseudo_letter + ')' +\n      '|' +\n      '(?:' + re.src_pseudo_letter + '(?:-|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' +\n    ')';\n\n  re.src_host =\n\n    '(?:' +\n    // Don't need IP check, because digits are already allowed in normal domain names\n    //   src_ip4 +\n    // '|' +\n      '(?:(?:(?:' + re.src_domain + ')\\\\.)*' + re.src_domain/*_root*/ + ')' +\n    ')';\n\n  re.tpl_host_fuzzy =\n\n    '(?:' +\n      re.src_ip4 +\n    '|' +\n      '(?:(?:(?:' + re.src_domain + ')\\\\.)+(?:%TLDS%))' +\n    ')';\n\n  re.tpl_host_no_ip_fuzzy =\n\n    '(?:(?:(?:' + re.src_domain + ')\\\\.)+(?:%TLDS%))';\n\n  re.src_host_strict =\n\n    re.src_host + re.src_host_terminator;\n\n  re.tpl_host_fuzzy_strict =\n\n    re.tpl_host_fuzzy + re.src_host_terminator;\n\n  re.src_host_port_strict =\n\n    re.src_host + re.src_port + re.src_host_terminator;\n\n  re.tpl_host_port_fuzzy_strict =\n\n    re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;\n\n  re.tpl_host_port_no_ip_fuzzy_strict =\n\n    re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;\n\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Main rules\n\n  // Rude test fuzzy links by host, for quick deny\n  re.tpl_host_fuzzy_test =\n\n    'localhost|www\\\\.|\\\\.\\\\d{1,3}\\\\.|(?:\\\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';\n\n  re.tpl_email_fuzzy =\n\n      '(^|' + text_separators + '|\"|\\\\(|' + re.src_ZCc + ')' +\n      '(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';\n\n  re.tpl_link_fuzzy =\n      // Fuzzy link can't be prepended with .:/\\- and non punctuation.\n      // but can start with > (markdown blockquote)\n      '(^|(?![.:/\\\\-_@])(?:[$+<=>^`|\\uff5c]|' + re.src_ZPCc + '))' +\n      '((?![$+<=>^`|\\uff5c])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';\n\n  re.tpl_link_no_ip_fuzzy =\n      // Fuzzy link can't be prepended with .:/\\- and non punctuation.\n      // but can start with > (markdown blockquote)\n      '(^|(?![.:/\\\\-_@])(?:[$+<=>^`|\\uff5c]|' + re.src_ZPCc + '))' +\n      '((?![$+<=>^`|\\uff5c])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';\n\n  return re;\n};\n","'use strict';\n\n\nmodule.exports = require('./lib/');\n","// HTML5 entities map: { name -> utf16string }\n//\n'use strict';\n\n/*eslint quotes:0*/\nmodule.exports = require('entities/lib/maps/entities.json');\n","// List of valid html blocks names, accorting to commonmark spec\n// http://jgm.github.io/CommonMark/spec.html#html-blocks\n\n'use strict';\n\n\nmodule.exports = [\n  'address',\n  'article',\n  'aside',\n  'base',\n  'basefont',\n  'blockquote',\n  'body',\n  'caption',\n  'center',\n  'col',\n  'colgroup',\n  'dd',\n  'details',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'frame',\n  'frameset',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hr',\n  'html',\n  'iframe',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'menu',\n  'menuitem',\n  'meta',\n  'nav',\n  'noframes',\n  'ol',\n  'optgroup',\n  'option',\n  'p',\n  'param',\n  'section',\n  'source',\n  'summary',\n  'table',\n  'tbody',\n  'td',\n  'tfoot',\n  'th',\n  'thead',\n  'title',\n  'tr',\n  'track',\n  'ul'\n];\n","// Regexps to match html elements\n\n'use strict';\n\nvar attr_name     = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\n\nvar unquoted      = '[^\"\\'=<>`\\\\x00-\\\\x20]+';\nvar single_quoted = \"'[^']*'\";\nvar double_quoted = '\"[^\"]*\"';\n\nvar attr_value  = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';\n\nvar attribute   = '(?:\\\\s+' + attr_name + '(?:\\\\s*=\\\\s*' + attr_value + ')?)';\n\nvar open_tag    = '<[A-Za-z][A-Za-z0-9\\\\-]*' + attribute + '*\\\\s*\\\\/?>';\n\nvar close_tag   = '<\\\\/[A-Za-z][A-Za-z0-9\\\\-]*\\\\s*>';\nvar comment     = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';\nvar processing  = '<[?].*?[?]>';\nvar declaration = '<![A-Z]+\\\\s+[^>]*>';\nvar cdata       = '<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>';\n\nvar HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment +\n                        '|' + processing + '|' + declaration + '|' + cdata + ')');\nvar HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');\n\nmodule.exports.HTML_TAG_RE = HTML_TAG_RE;\nmodule.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;\n","// Utilities\n//\n'use strict';\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction isString(obj) { return _class(obj) === '[object String]'; }\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction has(object, key) {\n  return _hasOwnProperty.call(object, key);\n}\n\n// Merge objects\n//\nfunction assign(obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n\n  sources.forEach(function (source) {\n    if (!source) { return; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be object');\n    }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key];\n    });\n  });\n\n  return obj;\n}\n\n// Remove element from array and put another array at those position.\n// Useful for some operations with tokens\nfunction arrayReplaceAt(src, pos, newElements) {\n  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction isValidEntityCode(c) {\n  /*eslint no-bitwise:0*/\n  // broken sequence\n  if (c >= 0xD800 && c <= 0xDFFF) { return false; }\n  // never used\n  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }\n  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }\n  // control codes\n  if (c >= 0x00 && c <= 0x08) { return false; }\n  if (c === 0x0B) { return false; }\n  if (c >= 0x0E && c <= 0x1F) { return false; }\n  if (c >= 0x7F && c <= 0x9F) { return false; }\n  // out of range\n  if (c > 0x10FFFF) { return false; }\n  return true;\n}\n\nfunction fromCodePoint(c) {\n  /*eslint no-bitwise:0*/\n  if (c > 0xffff) {\n    c -= 0x10000;\n    var surrogate1 = 0xd800 + (c >> 10),\n        surrogate2 = 0xdc00 + (c & 0x3ff);\n\n    return String.fromCharCode(surrogate1, surrogate2);\n  }\n  return String.fromCharCode(c);\n}\n\n\nvar UNESCAPE_MD_RE  = /\\\\([!\"#$%&'()*+,\\-.\\/:;<=>?@[\\\\\\]^_`{|}~])/g;\nvar ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi;\nvar UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');\n\nvar DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;\n\nvar entities = require('./entities');\n\nfunction replaceEntityPattern(match, name) {\n  var code = 0;\n\n  if (has(entities, name)) {\n    return entities[name];\n  }\n\n  if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {\n    code = name[1].toLowerCase() === 'x' ?\n      parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);\n\n    if (isValidEntityCode(code)) {\n      return fromCodePoint(code);\n    }\n  }\n\n  return match;\n}\n\n/*function replaceEntities(str) {\n  if (str.indexOf('&') < 0) { return str; }\n\n  return str.replace(ENTITY_RE, replaceEntityPattern);\n}*/\n\nfunction unescapeMd(str) {\n  if (str.indexOf('\\\\') < 0) { return str; }\n  return str.replace(UNESCAPE_MD_RE, '$1');\n}\n\nfunction unescapeAll(str) {\n  if (str.indexOf('\\\\') < 0 && str.indexOf('&') < 0) { return str; }\n\n  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {\n    if (escaped) { return escaped; }\n    return replaceEntityPattern(match, entity);\n  });\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar HTML_ESCAPE_TEST_RE = /[&<>\"]/;\nvar HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\nvar HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n};\n\nfunction replaceUnsafeChar(ch) {\n  return HTML_REPLACEMENTS[ch];\n}\n\nfunction escapeHtml(str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n  }\n  return str;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar REGEXP_ESCAPE_RE = /[.?*+^$[\\]\\\\(){}|-]/g;\n\nfunction escapeRE(str) {\n  return str.replace(REGEXP_ESCAPE_RE, '\\\\$&');\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction isSpace(code) {\n  switch (code) {\n    case 0x09:\n    case 0x20:\n      return true;\n  }\n  return false;\n}\n\n// Zs (unicode class) || [\\t\\f\\v\\r\\n]\nfunction isWhiteSpace(code) {\n  if (code >= 0x2000 && code <= 0x200A) { return true; }\n  switch (code) {\n    case 0x09: // \\t\n    case 0x0A: // \\n\n    case 0x0B: // \\v\n    case 0x0C: // \\f\n    case 0x0D: // \\r\n    case 0x20:\n    case 0xA0:\n    case 0x1680:\n    case 0x202F:\n    case 0x205F:\n    case 0x3000:\n      return true;\n  }\n  return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/*eslint-disable max-len*/\nvar UNICODE_PUNCT_RE = require('uc.micro/categories/P/regex');\n\n// Currently without astral characters support.\nfunction isPunctChar(ch) {\n  return UNICODE_PUNCT_RE.test(ch);\n}\n\n\n// Markdown ASCII punctuation characters.\n//\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\n//\n// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.\n//\nfunction isMdAsciiPunct(ch) {\n  switch (ch) {\n    case 0x21/* ! */:\n    case 0x22/* \" */:\n    case 0x23/* # */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x26/* & */:\n    case 0x27/* ' */:\n    case 0x28/* ( */:\n    case 0x29/* ) */:\n    case 0x2A/* * */:\n    case 0x2B/* + */:\n    case 0x2C/* , */:\n    case 0x2D/* - */:\n    case 0x2E/* . */:\n    case 0x2F/* / */:\n    case 0x3A/* : */:\n    case 0x3B/* ; */:\n    case 0x3C/* < */:\n    case 0x3D/* = */:\n    case 0x3E/* > */:\n    case 0x3F/* ? */:\n    case 0x40/* @ */:\n    case 0x5B/* [ */:\n    case 0x5C/* \\ */:\n    case 0x5D/* ] */:\n    case 0x5E/* ^ */:\n    case 0x5F/* _ */:\n    case 0x60/* ` */:\n    case 0x7B/* { */:\n    case 0x7C/* | */:\n    case 0x7D/* } */:\n    case 0x7E/* ~ */:\n      return true;\n    default:\n      return false;\n  }\n}\n\n// Hepler to unify [reference labels].\n//\nfunction normalizeReference(str) {\n  // Trim and collapse whitespace\n  //\n  str = str.trim().replace(/\\s+/g, ' ');\n\n  // In node v10 'ẞ'.toLowerCase() === 'Ṿ', which is presumed to be a bug\n  // fixed in v12 (couldn't find any details).\n  //\n  // So treat this one as a special case\n  // (remove this when node v10 is no longer supported).\n  //\n  if ('ẞ'.toLowerCase() === 'Ṿ') {\n    str = str.replace(/ẞ/g, 'ß');\n  }\n\n  // .toLowerCase().toUpperCase() should get rid of all differences\n  // between letter variants.\n  //\n  // Simple .toLowerCase() doesn't normalize 125 code points correctly,\n  // and .toUpperCase doesn't normalize 6 of them (list of exceptions:\n  // İ, ϴ, ẞ, Ω, K, Å - those are already uppercased, but have differently\n  // uppercased versions).\n  //\n  // Here's an example showing how it happens. Lets take greek letter omega:\n  // uppercase U+0398 (Θ), U+03f4 (ϴ) and lowercase U+03b8 (θ), U+03d1 (ϑ)\n  //\n  // Unicode entries:\n  // 0398;GREEK CAPITAL LETTER THETA;Lu;0;L;;;;;N;;;;03B8;\n  // 03B8;GREEK SMALL LETTER THETA;Ll;0;L;;;;;N;;;0398;;0398\n  // 03D1;GREEK THETA SYMBOL;Ll;0;L;<compat> 03B8;;;;N;GREEK SMALL LETTER SCRIPT THETA;;0398;;0398\n  // 03F4;GREEK CAPITAL THETA SYMBOL;Lu;0;L;<compat> 0398;;;;N;;;;03B8;\n  //\n  // Case-insensitive comparison should treat all of them as equivalent.\n  //\n  // But .toLowerCase() doesn't change ϑ (it's already lowercase),\n  // and .toUpperCase() doesn't change ϴ (already uppercase).\n  //\n  // Applying first lower then upper case normalizes any character:\n  // '\\u0398\\u03f4\\u03b8\\u03d1'.toLowerCase().toUpperCase() === '\\u0398\\u0398\\u0398\\u0398'\n  //\n  // Note: this is equivalent to unicode case folding; unicode normalization\n  // is a different step that is not required here.\n  //\n  // Final result should be uppercased, because it's later stored in an object\n  // (this avoid a conflict with Object.prototype members,\n  // most notably, `__proto__`)\n  //\n  return str.toLowerCase().toUpperCase();\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Re-export libraries commonly used in both markdown-it and its plugins,\n// so plugins won't have to depend on them explicitly, which reduces their\n// bundled size (e.g. a browser build).\n//\nexports.lib                 = {};\nexports.lib.mdurl           = require('mdurl');\nexports.lib.ucmicro         = require('uc.micro');\n\nexports.assign              = assign;\nexports.isString            = isString;\nexports.has                 = has;\nexports.unescapeMd          = unescapeMd;\nexports.unescapeAll         = unescapeAll;\nexports.isValidEntityCode   = isValidEntityCode;\nexports.fromCodePoint       = fromCodePoint;\n// exports.replaceEntities     = replaceEntities;\nexports.escapeHtml          = escapeHtml;\nexports.arrayReplaceAt      = arrayReplaceAt;\nexports.isSpace             = isSpace;\nexports.isWhiteSpace        = isWhiteSpace;\nexports.isMdAsciiPunct      = isMdAsciiPunct;\nexports.isPunctChar         = isPunctChar;\nexports.escapeRE            = escapeRE;\nexports.normalizeReference  = normalizeReference;\n","// Just a shortcut for bulk export\n'use strict';\n\n\nexports.parseLinkLabel       = require('./parse_link_label');\nexports.parseLinkDestination = require('./parse_link_destination');\nexports.parseLinkTitle       = require('./parse_link_title');\n","// Parse link destination\n//\n'use strict';\n\n\nvar unescapeAll = require('../common/utils').unescapeAll;\n\n\nmodule.exports = function parseLinkDestination(str, pos, max) {\n  var code, level,\n      lines = 0,\n      start = pos,\n      result = {\n        ok: false,\n        pos: 0,\n        lines: 0,\n        str: ''\n      };\n\n  if (str.charCodeAt(pos) === 0x3C /* < */) {\n    pos++;\n    while (pos < max) {\n      code = str.charCodeAt(pos);\n      if (code === 0x0A /* \\n */) { return result; }\n      if (code === 0x3E /* > */) {\n        result.pos = pos + 1;\n        result.str = unescapeAll(str.slice(start + 1, pos));\n        result.ok = true;\n        return result;\n      }\n      if (code === 0x5C /* \\ */ && pos + 1 < max) {\n        pos += 2;\n        continue;\n      }\n\n      pos++;\n    }\n\n    // no closing '>'\n    return result;\n  }\n\n  // this should be ... } else { ... branch\n\n  level = 0;\n  while (pos < max) {\n    code = str.charCodeAt(pos);\n\n    if (code === 0x20) { break; }\n\n    // ascii control characters\n    if (code < 0x20 || code === 0x7F) { break; }\n\n    if (code === 0x5C /* \\ */ && pos + 1 < max) {\n      pos += 2;\n      continue;\n    }\n\n    if (code === 0x28 /* ( */) {\n      level++;\n    }\n\n    if (code === 0x29 /* ) */) {\n      if (level === 0) { break; }\n      level--;\n    }\n\n    pos++;\n  }\n\n  if (start === pos) { return result; }\n  if (level !== 0) { return result; }\n\n  result.str = unescapeAll(str.slice(start, pos));\n  result.lines = lines;\n  result.pos = pos;\n  result.ok = true;\n  return result;\n};\n","// Parse link label\n//\n// this function assumes that first character (\"[\") already matches;\n// returns the end of the label\n//\n'use strict';\n\nmodule.exports = function parseLinkLabel(state, start, disableNested) {\n  var level, found, marker, prevPos,\n      labelEnd = -1,\n      max = state.posMax,\n      oldPos = state.pos;\n\n  state.pos = start + 1;\n  level = 1;\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos);\n    if (marker === 0x5D /* ] */) {\n      level--;\n      if (level === 0) {\n        found = true;\n        break;\n      }\n    }\n\n    prevPos = state.pos;\n    state.md.inline.skipToken(state);\n    if (marker === 0x5B /* [ */) {\n      if (prevPos === state.pos - 1) {\n        // increase level if we find text `[`, which is not a part of any token\n        level++;\n      } else if (disableNested) {\n        state.pos = oldPos;\n        return -1;\n      }\n    }\n  }\n\n  if (found) {\n    labelEnd = state.pos;\n  }\n\n  // restore old state\n  state.pos = oldPos;\n\n  return labelEnd;\n};\n","// Parse link title\n//\n'use strict';\n\n\nvar unescapeAll = require('../common/utils').unescapeAll;\n\n\nmodule.exports = function parseLinkTitle(str, pos, max) {\n  var code,\n      marker,\n      lines = 0,\n      start = pos,\n      result = {\n        ok: false,\n        pos: 0,\n        lines: 0,\n        str: ''\n      };\n\n  if (pos >= max) { return result; }\n\n  marker = str.charCodeAt(pos);\n\n  if (marker !== 0x22 /* \" */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return result; }\n\n  pos++;\n\n  // if opening marker is \"(\", switch it to closing marker \")\"\n  if (marker === 0x28) { marker = 0x29; }\n\n  while (pos < max) {\n    code = str.charCodeAt(pos);\n    if (code === marker) {\n      result.pos = pos + 1;\n      result.lines = lines;\n      result.str = unescapeAll(str.slice(start + 1, pos));\n      result.ok = true;\n      return result;\n    } else if (code === 0x0A) {\n      lines++;\n    } else if (code === 0x5C /* \\ */ && pos + 1 < max) {\n      pos++;\n      if (str.charCodeAt(pos) === 0x0A) {\n        lines++;\n      }\n    }\n\n    pos++;\n  }\n\n  return result;\n};\n","// Main parser class\n\n'use strict';\n\n\nvar utils        = require('./common/utils');\nvar helpers      = require('./helpers');\nvar Renderer     = require('./renderer');\nvar ParserCore   = require('./parser_core');\nvar ParserBlock  = require('./parser_block');\nvar ParserInline = require('./parser_inline');\nvar LinkifyIt    = require('linkify-it');\nvar mdurl        = require('mdurl');\nvar punycode     = require('punycode');\n\n\nvar config = {\n  default: require('./presets/default'),\n  zero: require('./presets/zero'),\n  commonmark: require('./presets/commonmark')\n};\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// This validator can prohibit more than really needed to prevent XSS. It's a\n// tradeoff to keep code simple and to be secure by default.\n//\n// If you need different setup - override validator method as you wish. Or\n// replace it with dummy function and use external sanitizer.\n//\n\nvar BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;\nvar GOOD_DATA_RE = /^data:image\\/(gif|png|jpeg|webp);/;\n\nfunction validateLink(url) {\n  // url should be normalized at this point, and existing entities are decoded\n  var str = url.trim().toLowerCase();\n\n  return BAD_PROTO_RE.test(str) ? (GOOD_DATA_RE.test(str) ? true : false) : true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n\nvar RECODE_HOSTNAME_FOR = [ 'http:', 'https:', 'mailto:' ];\n\nfunction normalizeLink(url) {\n  var parsed = mdurl.parse(url, true);\n\n  if (parsed.hostname) {\n    // Encode hostnames in urls like:\n    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\n    //\n    // We don't encode unknown schemas, because it's likely that we encode\n    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\n    //\n    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n      try {\n        parsed.hostname = punycode.toASCII(parsed.hostname);\n      } catch (er) { /**/ }\n    }\n  }\n\n  return mdurl.encode(mdurl.format(parsed));\n}\n\nfunction normalizeLinkText(url) {\n  var parsed = mdurl.parse(url, true);\n\n  if (parsed.hostname) {\n    // Encode hostnames in urls like:\n    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\n    //\n    // We don't encode unknown schemas, because it's likely that we encode\n    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\n    //\n    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n      try {\n        parsed.hostname = punycode.toUnicode(parsed.hostname);\n      } catch (er) { /**/ }\n    }\n  }\n\n  // add '%' to exclude list because of https://github.com/markdown-it/markdown-it/issues/720\n  return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + '%');\n}\n\n\n/**\n * class MarkdownIt\n *\n * Main parser/renderer class.\n *\n * ##### Usage\n *\n * ```javascript\n * // node.js, \"classic\" way:\n * var MarkdownIt = require('markdown-it'),\n *     md = new MarkdownIt();\n * var result = md.render('# markdown-it rulezz!');\n *\n * // node.js, the same, but with sugar:\n * var md = require('markdown-it')();\n * var result = md.render('# markdown-it rulezz!');\n *\n * // browser without AMD, added to \"window\" on script load\n * // Note, there are no dash.\n * var md = window.markdownit();\n * var result = md.render('# markdown-it rulezz!');\n * ```\n *\n * Single line rendering, without paragraph wrap:\n *\n * ```javascript\n * var md = require('markdown-it')();\n * var result = md.renderInline('__markdown-it__ rulezz!');\n * ```\n **/\n\n/**\n * new MarkdownIt([presetName, options])\n * - presetName (String): optional, `commonmark` / `zero`\n * - options (Object)\n *\n * Creates parser instanse with given config. Can be called without `new`.\n *\n * ##### presetName\n *\n * MarkdownIt provides named presets as a convenience to quickly\n * enable/disable active syntax rules and options for common use cases.\n *\n * - [\"commonmark\"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -\n *   configures parser to strict [CommonMark](http://commonmark.org/) mode.\n * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -\n *   similar to GFM, used when no preset name given. Enables all available rules,\n *   but still without html, typographer & autolinker.\n * - [\"zero\"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -\n *   all rules disabled. Useful to quickly setup your config via `.enable()`.\n *   For example, when you need only `bold` and `italic` markup and nothing else.\n *\n * ##### options:\n *\n * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!\n *   That's not safe! You may need external sanitizer to protect output from XSS.\n *   It's better to extend features via plugins, instead of enabling HTML.\n * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags\n *   (`<br />`). This is needed only for full CommonMark compatibility. In real\n *   world you will need HTML output.\n * - __breaks__ - `false`. Set `true` to convert `\\n` in paragraphs into `<br>`.\n * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.\n *   Can be useful for external highlighters.\n * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.\n * - __typographer__  - `false`. Set `true` to enable [some language-neutral\n *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +\n *   quotes beautification (smartquotes).\n * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement\n *   pairs, when typographer enabled and smartquotes on. For example, you can\n *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and\n *   `['«\\xA0', '\\xA0»', '‹\\xA0', '\\xA0›']` for French (including nbsp).\n * - __highlight__ - `null`. Highlighter function for fenced code blocks.\n *   Highlighter `function (str, lang)` should return escaped HTML. It can also\n *   return empty string if the source was not changed and should be escaped\n *   externaly. If result starts with <pre... internal wrapper is skipped.\n *\n * ##### Example\n *\n * ```javascript\n * // commonmark mode\n * var md = require('markdown-it')('commonmark');\n *\n * // default mode\n * var md = require('markdown-it')();\n *\n * // enable everything\n * var md = require('markdown-it')({\n *   html: true,\n *   linkify: true,\n *   typographer: true\n * });\n * ```\n *\n * ##### Syntax highlighting\n *\n * ```js\n * var hljs = require('highlight.js') // https://highlightjs.org/\n *\n * var md = require('markdown-it')({\n *   highlight: function (str, lang) {\n *     if (lang && hljs.getLanguage(lang)) {\n *       try {\n *         return hljs.highlight(lang, str, true).value;\n *       } catch (__) {}\n *     }\n *\n *     return ''; // use external default escaping\n *   }\n * });\n * ```\n *\n * Or with full wrapper override (if you need assign class to `<pre>`):\n *\n * ```javascript\n * var hljs = require('highlight.js') // https://highlightjs.org/\n *\n * // Actual default values\n * var md = require('markdown-it')({\n *   highlight: function (str, lang) {\n *     if (lang && hljs.getLanguage(lang)) {\n *       try {\n *         return '<pre class=\"hljs\"><code>' +\n *                hljs.highlight(lang, str, true).value +\n *                '</code></pre>';\n *       } catch (__) {}\n *     }\n *\n *     return '<pre class=\"hljs\"><code>' + md.utils.escapeHtml(str) + '</code></pre>';\n *   }\n * });\n * ```\n *\n **/\nfunction MarkdownIt(presetName, options) {\n  if (!(this instanceof MarkdownIt)) {\n    return new MarkdownIt(presetName, options);\n  }\n\n  if (!options) {\n    if (!utils.isString(presetName)) {\n      options = presetName || {};\n      presetName = 'default';\n    }\n  }\n\n  /**\n   * MarkdownIt#inline -> ParserInline\n   *\n   * Instance of [[ParserInline]]. You may need it to add new rules when\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n   * [[MarkdownIt.enable]].\n   **/\n  this.inline = new ParserInline();\n\n  /**\n   * MarkdownIt#block -> ParserBlock\n   *\n   * Instance of [[ParserBlock]]. You may need it to add new rules when\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n   * [[MarkdownIt.enable]].\n   **/\n  this.block = new ParserBlock();\n\n  /**\n   * MarkdownIt#core -> Core\n   *\n   * Instance of [[Core]] chain executor. You may need it to add new rules when\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n   * [[MarkdownIt.enable]].\n   **/\n  this.core = new ParserCore();\n\n  /**\n   * MarkdownIt#renderer -> Renderer\n   *\n   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering\n   * rules for new token types, generated by plugins.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * function myToken(tokens, idx, options, env, self) {\n   *   //...\n   *   return result;\n   * };\n   *\n   * md.renderer.rules['my_token'] = myToken\n   * ```\n   *\n   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).\n   **/\n  this.renderer = new Renderer();\n\n  /**\n   * MarkdownIt#linkify -> LinkifyIt\n   *\n   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.\n   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)\n   * rule.\n   **/\n  this.linkify = new LinkifyIt();\n\n  /**\n   * MarkdownIt#validateLink(url) -> Boolean\n   *\n   * Link validation function. CommonMark allows too much in links. By default\n   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas\n   * except some embedded image types.\n   *\n   * You can change this behaviour:\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   * // enable everything\n   * md.validateLink = function () { return true; }\n   * ```\n   **/\n  this.validateLink = validateLink;\n\n  /**\n   * MarkdownIt#normalizeLink(url) -> String\n   *\n   * Function used to encode link url to a machine-readable format,\n   * which includes url-encoding, punycode, etc.\n   **/\n  this.normalizeLink = normalizeLink;\n\n  /**\n   * MarkdownIt#normalizeLinkText(url) -> String\n   *\n   * Function used to decode link url to a human-readable format`\n   **/\n  this.normalizeLinkText = normalizeLinkText;\n\n\n  // Expose utils & helpers for easy acces from plugins\n\n  /**\n   * MarkdownIt#utils -> utils\n   *\n   * Assorted utility functions, useful to write plugins. See details\n   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).\n   **/\n  this.utils = utils;\n\n  /**\n   * MarkdownIt#helpers -> helpers\n   *\n   * Link components parser functions, useful to write plugins. See details\n   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).\n   **/\n  this.helpers = utils.assign({}, helpers);\n\n\n  this.options = {};\n  this.configure(presetName);\n\n  if (options) { this.set(options); }\n}\n\n\n/** chainable\n * MarkdownIt.set(options)\n *\n * Set parser options (in the same format as in constructor). Probably, you\n * will never need it, but you can change options after constructor call.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')()\n *             .set({ html: true, breaks: true })\n *             .set({ typographer, true });\n * ```\n *\n * __Note:__ To achieve the best possible performance, don't modify a\n * `markdown-it` instance options on the fly. If you need multiple configurations\n * it's best to create multiple instances and initialize each with separate\n * config.\n **/\nMarkdownIt.prototype.set = function (options) {\n  utils.assign(this.options, options);\n  return this;\n};\n\n\n/** chainable, internal\n * MarkdownIt.configure(presets)\n *\n * Batch load of all options and compenent settings. This is internal method,\n * and you probably will not need it. But if you will - see available presets\n * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)\n *\n * We strongly recommend to use presets instead of direct config loads. That\n * will give better compatibility with next versions.\n **/\nMarkdownIt.prototype.configure = function (presets) {\n  var self = this, presetName;\n\n  if (utils.isString(presets)) {\n    presetName = presets;\n    presets = config[presetName];\n    if (!presets) { throw new Error('Wrong `markdown-it` preset \"' + presetName + '\", check name'); }\n  }\n\n  if (!presets) { throw new Error('Wrong `markdown-it` preset, can\\'t be empty'); }\n\n  if (presets.options) { self.set(presets.options); }\n\n  if (presets.components) {\n    Object.keys(presets.components).forEach(function (name) {\n      if (presets.components[name].rules) {\n        self[name].ruler.enableOnly(presets.components[name].rules);\n      }\n      if (presets.components[name].rules2) {\n        self[name].ruler2.enableOnly(presets.components[name].rules2);\n      }\n    });\n  }\n  return this;\n};\n\n\n/** chainable\n * MarkdownIt.enable(list, ignoreInvalid)\n * - list (String|Array): rule name or list of rule names to enable\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable list or rules. It will automatically find appropriate components,\n * containing rules with given names. If rule not found, and `ignoreInvalid`\n * not set - throws exception.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')()\n *             .enable(['sub', 'sup'])\n *             .disable('smartquotes');\n * ```\n **/\nMarkdownIt.prototype.enable = function (list, ignoreInvalid) {\n  var result = [];\n\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  [ 'core', 'block', 'inline' ].forEach(function (chain) {\n    result = result.concat(this[chain].ruler.enable(list, true));\n  }, this);\n\n  result = result.concat(this.inline.ruler2.enable(list, true));\n\n  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });\n\n  if (missed.length && !ignoreInvalid) {\n    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);\n  }\n\n  return this;\n};\n\n\n/** chainable\n * MarkdownIt.disable(list, ignoreInvalid)\n * - list (String|Array): rule name or list of rule names to disable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * The same as [[MarkdownIt.enable]], but turn specified rules off.\n **/\nMarkdownIt.prototype.disable = function (list, ignoreInvalid) {\n  var result = [];\n\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  [ 'core', 'block', 'inline' ].forEach(function (chain) {\n    result = result.concat(this[chain].ruler.disable(list, true));\n  }, this);\n\n  result = result.concat(this.inline.ruler2.disable(list, true));\n\n  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });\n\n  if (missed.length && !ignoreInvalid) {\n    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);\n  }\n  return this;\n};\n\n\n/** chainable\n * MarkdownIt.use(plugin, params)\n *\n * Load specified plugin with given params into current parser instance.\n * It's just a sugar to call `plugin(md, params)` with curring.\n *\n * ##### Example\n *\n * ```javascript\n * var iterator = require('markdown-it-for-inline');\n * var md = require('markdown-it')()\n *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {\n *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');\n *             });\n * ```\n **/\nMarkdownIt.prototype.use = function (plugin /*, params, ... */) {\n  var args = [ this ].concat(Array.prototype.slice.call(arguments, 1));\n  plugin.apply(plugin, args);\n  return this;\n};\n\n\n/** internal\n * MarkdownIt.parse(src, env) -> Array\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * Parse input string and return list of block tokens (special token type\n * \"inline\" will contain list of inline tokens). You should not call this\n * method directly, until you write custom renderer (for example, to produce\n * AST).\n *\n * `env` is used to pass data between \"distributed\" rules and return additional\n * metadata like reference info, needed for the renderer. It also can be used to\n * inject data in specific cases. Usually, you will be ok to pass `{}`,\n * and then pass updated object to renderer.\n **/\nMarkdownIt.prototype.parse = function (src, env) {\n  if (typeof src !== 'string') {\n    throw new Error('Input data should be a String');\n  }\n\n  var state = new this.core.State(src, this, env);\n\n  this.core.process(state);\n\n  return state.tokens;\n};\n\n\n/**\n * MarkdownIt.render(src [, env]) -> String\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * Render markdown string into html. It does all magic for you :).\n *\n * `env` can be used to inject additional metadata (`{}` by default).\n * But you will not need it with high probability. See also comment\n * in [[MarkdownIt.parse]].\n **/\nMarkdownIt.prototype.render = function (src, env) {\n  env = env || {};\n\n  return this.renderer.render(this.parse(src, env), this.options, env);\n};\n\n\n/** internal\n * MarkdownIt.parseInline(src, env) -> Array\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the\n * block tokens list with the single `inline` element, containing parsed inline\n * tokens in `children` property. Also updates `env` object.\n **/\nMarkdownIt.prototype.parseInline = function (src, env) {\n  var state = new this.core.State(src, this, env);\n\n  state.inlineMode = true;\n  this.core.process(state);\n\n  return state.tokens;\n};\n\n\n/**\n * MarkdownIt.renderInline(src [, env]) -> String\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * Similar to [[MarkdownIt.render]] but for single paragraph content. Result\n * will NOT be wrapped into `<p>` tags.\n **/\nMarkdownIt.prototype.renderInline = function (src, env) {\n  env = env || {};\n\n  return this.renderer.render(this.parseInline(src, env), this.options, env);\n};\n\n\nmodule.exports = MarkdownIt;\n","/** internal\n * class ParserBlock\n *\n * Block-level tokenizer.\n **/\n'use strict';\n\n\nvar Ruler           = require('./ruler');\n\n\nvar _rules = [\n  // First 2 params - rule name & source. Secondary array - list of rules,\n  // which can be terminated by this one.\n  [ 'table',      require('./rules_block/table'),      [ 'paragraph', 'reference' ] ],\n  [ 'code',       require('./rules_block/code') ],\n  [ 'fence',      require('./rules_block/fence'),      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'blockquote', require('./rules_block/blockquote'), [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'hr',         require('./rules_block/hr'),         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'list',       require('./rules_block/list'),       [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'reference',  require('./rules_block/reference') ],\n  [ 'heading',    require('./rules_block/heading'),    [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'lheading',   require('./rules_block/lheading') ],\n  [ 'html_block', require('./rules_block/html_block'), [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'paragraph',  require('./rules_block/paragraph') ]\n];\n\n\n/**\n * new ParserBlock()\n **/\nfunction ParserBlock() {\n  /**\n   * ParserBlock#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of block rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });\n  }\n}\n\n\n// Generate tokens for input range\n//\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var ok, i,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      line = startLine,\n      hasEmptyLines = false,\n      maxNesting = state.md.options.maxNesting;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n    if (line >= endLine) { break; }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.sCount[line] < state.blkIndent) { break; }\n\n    // If nesting level exceeded - skip tail to the end. That's not ordinary\n    // situation and we should not care about content.\n    if (state.level >= maxNesting) {\n      state.line = endLine;\n      break;\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n      if (ok) { break; }\n    }\n\n    // set state.tight if we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines;\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n      state.line = line;\n    }\n  }\n};\n\n\n/**\n * ParserBlock.parse(str, md, env, outTokens)\n *\n * Process input string and push block tokens into `outTokens`\n **/\nParserBlock.prototype.parse = function (src, md, env, outTokens) {\n  var state;\n\n  if (!src) { return; }\n\n  state = new this.State(src, md, env, outTokens);\n\n  this.tokenize(state, state.line, state.lineMax);\n};\n\n\nParserBlock.prototype.State = require('./rules_block/state_block');\n\n\nmodule.exports = ParserBlock;\n","/** internal\n * class Core\n *\n * Top-level rules executor. Glues block/inline parsers and does intermediate\n * transformations.\n **/\n'use strict';\n\n\nvar Ruler  = require('./ruler');\n\n\nvar _rules = [\n  [ 'normalize',      require('./rules_core/normalize')      ],\n  [ 'block',          require('./rules_core/block')          ],\n  [ 'inline',         require('./rules_core/inline')         ],\n  [ 'linkify',        require('./rules_core/linkify')        ],\n  [ 'replacements',   require('./rules_core/replacements')   ],\n  [ 'smartquotes',    require('./rules_core/smartquotes')    ]\n];\n\n\n/**\n * new Core()\n **/\nfunction Core() {\n  /**\n   * Core#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of core rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n}\n\n\n/**\n * Core.process(state)\n *\n * Executes core chain rules.\n **/\nCore.prototype.process = function (state) {\n  var i, l, rules;\n\n  rules = this.ruler.getRules('');\n\n  for (i = 0, l = rules.length; i < l; i++) {\n    rules[i](state);\n  }\n};\n\nCore.prototype.State = require('./rules_core/state_core');\n\n\nmodule.exports = Core;\n","/** internal\n * class ParserInline\n *\n * Tokenizes paragraph content.\n **/\n'use strict';\n\n\nvar Ruler           = require('./ruler');\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Parser rules\n\nvar _rules = [\n  [ 'text',            require('./rules_inline/text') ],\n  [ 'newline',         require('./rules_inline/newline') ],\n  [ 'escape',          require('./rules_inline/escape') ],\n  [ 'backticks',       require('./rules_inline/backticks') ],\n  [ 'strikethrough',   require('./rules_inline/strikethrough').tokenize ],\n  [ 'emphasis',        require('./rules_inline/emphasis').tokenize ],\n  [ 'link',            require('./rules_inline/link') ],\n  [ 'image',           require('./rules_inline/image') ],\n  [ 'autolink',        require('./rules_inline/autolink') ],\n  [ 'html_inline',     require('./rules_inline/html_inline') ],\n  [ 'entity',          require('./rules_inline/entity') ]\n];\n\nvar _rules2 = [\n  [ 'balance_pairs',   require('./rules_inline/balance_pairs') ],\n  [ 'strikethrough',   require('./rules_inline/strikethrough').postProcess ],\n  [ 'emphasis',        require('./rules_inline/emphasis').postProcess ],\n  [ 'text_collapse',   require('./rules_inline/text_collapse') ]\n];\n\n\n/**\n * new ParserInline()\n **/\nfunction ParserInline() {\n  var i;\n\n  /**\n   * ParserInline#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of inline rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n\n  /**\n   * ParserInline#ruler2 -> Ruler\n   *\n   * [[Ruler]] instance. Second ruler used for post-processing\n   * (e.g. in emphasis-like rules).\n   **/\n  this.ruler2 = new Ruler();\n\n  for (i = 0; i < _rules2.length; i++) {\n    this.ruler2.push(_rules2[i][0], _rules2[i][1]);\n  }\n}\n\n\n// Skip single token by running all rules in validation mode;\n// returns `true` if any rule reported success\n//\nParserInline.prototype.skipToken = function (state) {\n  var ok, i, pos = state.pos,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      maxNesting = state.md.options.maxNesting,\n      cache = state.cache;\n\n\n  if (typeof cache[pos] !== 'undefined') {\n    state.pos = cache[pos];\n    return;\n  }\n\n  if (state.level < maxNesting) {\n    for (i = 0; i < len; i++) {\n      // Increment state.level and decrement it later to limit recursion.\n      // It's harmless to do here, because no tokens are created. But ideally,\n      // we'd need a separate private state variable for this purpose.\n      //\n      state.level++;\n      ok = rules[i](state, true);\n      state.level--;\n\n      if (ok) { break; }\n    }\n  } else {\n    // Too much nesting, just skip until the end of the paragraph.\n    //\n    // NOTE: this will cause links to behave incorrectly in the following case,\n    //       when an amount of `[` is exactly equal to `maxNesting + 1`:\n    //\n    //       [[[[[[[[[[[[[[[[[[[[[foo]()\n    //\n    // TODO: remove this workaround when CM standard will allow nested links\n    //       (we can replace it by preventing links from being parsed in\n    //       validation mode)\n    //\n    state.pos = state.posMax;\n  }\n\n  if (!ok) { state.pos++; }\n  cache[pos] = state.pos;\n};\n\n\n// Generate tokens for input range\n//\nParserInline.prototype.tokenize = function (state) {\n  var ok, i,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      end = state.posMax,\n      maxNesting = state.md.options.maxNesting;\n\n  while (state.pos < end) {\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.pos`\n    // - update `state.tokens`\n    // - return true\n\n    if (state.level < maxNesting) {\n      for (i = 0; i < len; i++) {\n        ok = rules[i](state, false);\n        if (ok) { break; }\n      }\n    }\n\n    if (ok) {\n      if (state.pos >= end) { break; }\n      continue;\n    }\n\n    state.pending += state.src[state.pos++];\n  }\n\n  if (state.pending) {\n    state.pushPending();\n  }\n};\n\n\n/**\n * ParserInline.parse(str, md, env, outTokens)\n *\n * Process input string and push inline tokens into `outTokens`\n **/\nParserInline.prototype.parse = function (str, md, env, outTokens) {\n  var i, rules, len;\n  var state = new this.State(str, md, env, outTokens);\n\n  this.tokenize(state);\n\n  rules = this.ruler2.getRules('');\n  len = rules.length;\n\n  for (i = 0; i < len; i++) {\n    rules[i](state);\n  }\n};\n\n\nParserInline.prototype.State = require('./rules_inline/state_inline');\n\n\nmodule.exports = ParserInline;\n","// Commonmark default options\n\n'use strict';\n\n\nmodule.exports = {\n  options: {\n    html:         true,         // Enable HTML tags in source\n    xhtmlOut:     true,         // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkify:      false,        // autoconvert URL-like texts to links\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Could be either a String or an Array.\n    //\n    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,\n    // and ['«\\xA0', '\\xA0»', '‹\\xA0', '\\xA0›'] for French (including nbsp).\n    quotes: '\\u201c\\u201d\\u2018\\u2019', /* “”‘’ */\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if the source string is not changed and should be escaped externaly.\n    // If result starts with <pre... internal wrapper is skipped.\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    maxNesting:   20            // Internal protection, recursion limit\n  },\n\n  components: {\n\n    core: {\n      rules: [\n        'normalize',\n        'block',\n        'inline'\n      ]\n    },\n\n    block: {\n      rules: [\n        'blockquote',\n        'code',\n        'fence',\n        'heading',\n        'hr',\n        'html_block',\n        'lheading',\n        'list',\n        'reference',\n        'paragraph'\n      ]\n    },\n\n    inline: {\n      rules: [\n        'autolink',\n        'backticks',\n        'emphasis',\n        'entity',\n        'escape',\n        'html_inline',\n        'image',\n        'link',\n        'newline',\n        'text'\n      ],\n      rules2: [\n        'balance_pairs',\n        'emphasis',\n        'text_collapse'\n      ]\n    }\n  }\n};\n","// markdown-it default options\n\n'use strict';\n\n\nmodule.exports = {\n  options: {\n    html:         false,        // Enable HTML tags in source\n    xhtmlOut:     false,        // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkify:      false,        // autoconvert URL-like texts to links\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Could be either a String or an Array.\n    //\n    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,\n    // and ['«\\xA0', '\\xA0»', '‹\\xA0', '\\xA0›'] for French (including nbsp).\n    quotes: '\\u201c\\u201d\\u2018\\u2019', /* “”‘’ */\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if the source string is not changed and should be escaped externaly.\n    // If result starts with <pre... internal wrapper is skipped.\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    maxNesting:   100            // Internal protection, recursion limit\n  },\n\n  components: {\n\n    core: {},\n    block: {},\n    inline: {}\n  }\n};\n","// \"Zero\" preset, with nothing enabled. Useful for manual configuring of simple\n// modes. For example, to parse bold/italic only.\n\n'use strict';\n\n\nmodule.exports = {\n  options: {\n    html:         false,        // Enable HTML tags in source\n    xhtmlOut:     false,        // Use '/' to close single tags (<br />)\n    breaks:       false,        // Convert '\\n' in paragraphs into <br>\n    langPrefix:   'language-',  // CSS language prefix for fenced blocks\n    linkify:      false,        // autoconvert URL-like texts to links\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer:  false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Could be either a String or an Array.\n    //\n    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,\n    // and ['«\\xA0', '\\xA0»', '‹\\xA0', '\\xA0›'] for French (including nbsp).\n    quotes: '\\u201c\\u201d\\u2018\\u2019', /* “”‘’ */\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if the source string is not changed and should be escaped externaly.\n    // If result starts with <pre... internal wrapper is skipped.\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    maxNesting:   20            // Internal protection, recursion limit\n  },\n\n  components: {\n\n    core: {\n      rules: [\n        'normalize',\n        'block',\n        'inline'\n      ]\n    },\n\n    block: {\n      rules: [\n        'paragraph'\n      ]\n    },\n\n    inline: {\n      rules: [\n        'text'\n      ],\n      rules2: [\n        'balance_pairs',\n        'text_collapse'\n      ]\n    }\n  }\n};\n","/**\n * class Renderer\n *\n * Generates HTML from parsed token stream. Each instance has independent\n * copy of rules. Those can be rewritten with ease. Also, you can add new\n * rules if you create plugin and adds new token types.\n **/\n'use strict';\n\n\nvar assign          = require('./common/utils').assign;\nvar unescapeAll     = require('./common/utils').unescapeAll;\nvar escapeHtml      = require('./common/utils').escapeHtml;\n\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar default_rules = {};\n\n\ndefault_rules.code_inline = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx];\n\n  return  '<code' + slf.renderAttrs(token) + '>' +\n          escapeHtml(tokens[idx].content) +\n          '</code>';\n};\n\n\ndefault_rules.code_block = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx];\n\n  return  '<pre' + slf.renderAttrs(token) + '><code>' +\n          escapeHtml(tokens[idx].content) +\n          '</code></pre>\\n';\n};\n\n\ndefault_rules.fence = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx],\n      info = token.info ? unescapeAll(token.info).trim() : '',\n      langName = '',\n      langAttrs = '',\n      highlighted, i, arr, tmpAttrs, tmpToken;\n\n  if (info) {\n    arr = info.split(/(\\s+)/g);\n    langName = arr[0];\n    langAttrs = arr.slice(2).join('');\n  }\n\n  if (options.highlight) {\n    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);\n  } else {\n    highlighted = escapeHtml(token.content);\n  }\n\n  if (highlighted.indexOf('<pre') === 0) {\n    return highlighted + '\\n';\n  }\n\n  // If language exists, inject class gently, without modifying original token.\n  // May be, one day we will add .clone() for token and simplify this part, but\n  // now we prefer to keep things local.\n  if (info) {\n    i        = token.attrIndex('class');\n    tmpAttrs = token.attrs ? token.attrs.slice() : [];\n\n    if (i < 0) {\n      tmpAttrs.push([ 'class', options.langPrefix + langName ]);\n    } else {\n      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;\n    }\n\n    // Fake token just to render attributes\n    tmpToken = {\n      attrs: tmpAttrs\n    };\n\n    return  '<pre><code' + slf.renderAttrs(tmpToken) + '>'\n          + highlighted\n          + '</code></pre>\\n';\n  }\n\n\n  return  '<pre><code' + slf.renderAttrs(token) + '>'\n        + highlighted\n        + '</code></pre>\\n';\n};\n\n\ndefault_rules.image = function (tokens, idx, options, env, slf) {\n  var token = tokens[idx];\n\n  // \"alt\" attr MUST be set, even if empty. Because it's mandatory and\n  // should be placed on proper position for tests.\n  //\n  // Replace content with actual value\n\n  token.attrs[token.attrIndex('alt')][1] =\n    slf.renderInlineAsText(token.children, options, env);\n\n  return slf.renderToken(tokens, idx, options);\n};\n\n\ndefault_rules.hardbreak = function (tokens, idx, options /*, env */) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\n};\ndefault_rules.softbreak = function (tokens, idx, options /*, env */) {\n  return options.breaks ? (options.xhtmlOut ? '<br />\\n' : '<br>\\n') : '\\n';\n};\n\n\ndefault_rules.text = function (tokens, idx /*, options, env */) {\n  return escapeHtml(tokens[idx].content);\n};\n\n\ndefault_rules.html_block = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\ndefault_rules.html_inline = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\n\n\n/**\n * new Renderer()\n *\n * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.\n **/\nfunction Renderer() {\n\n  /**\n   * Renderer#rules -> Object\n   *\n   * Contains render rules for tokens. Can be updated and extended.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * md.renderer.rules.strong_open  = function () { return '<b>'; };\n   * md.renderer.rules.strong_close = function () { return '</b>'; };\n   *\n   * var result = md.renderInline(...);\n   * ```\n   *\n   * Each rule is called as independent static function with fixed signature:\n   *\n   * ```javascript\n   * function my_token_render(tokens, idx, options, env, renderer) {\n   *   // ...\n   *   return renderedHTML;\n   * }\n   * ```\n   *\n   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)\n   * for more details and examples.\n   **/\n  this.rules = assign({}, default_rules);\n}\n\n\n/**\n * Renderer.renderAttrs(token) -> String\n *\n * Render token attributes to string.\n **/\nRenderer.prototype.renderAttrs = function renderAttrs(token) {\n  var i, l, result;\n\n  if (!token.attrs) { return ''; }\n\n  result = '';\n\n  for (i = 0, l = token.attrs.length; i < l; i++) {\n    result += ' ' + escapeHtml(token.attrs[i][0]) + '=\"' + escapeHtml(token.attrs[i][1]) + '\"';\n  }\n\n  return result;\n};\n\n\n/**\n * Renderer.renderToken(tokens, idx, options) -> String\n * - tokens (Array): list of tokens\n * - idx (Numbed): token index to render\n * - options (Object): params of parser instance\n *\n * Default token renderer. Can be overriden by custom function\n * in [[Renderer#rules]].\n **/\nRenderer.prototype.renderToken = function renderToken(tokens, idx, options) {\n  var nextToken,\n      result = '',\n      needLf = false,\n      token = tokens[idx];\n\n  // Tight list paragraphs\n  if (token.hidden) {\n    return '';\n  }\n\n  // Insert a newline between hidden paragraph and subsequent opening\n  // block-level tag.\n  //\n  // For example, here we should insert a newline before blockquote:\n  //  - a\n  //    >\n  //\n  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n    result += '\\n';\n  }\n\n  // Add token name, e.g. `<img`\n  result += (token.nesting === -1 ? '</' : '<') + token.tag;\n\n  // Encode attributes, e.g. `<img src=\"foo\"`\n  result += this.renderAttrs(token);\n\n  // Add a slash for self-closing tags, e.g. `<img src=\"foo\" /`\n  if (token.nesting === 0 && options.xhtmlOut) {\n    result += ' /';\n  }\n\n  // Check if we need to add a newline after this tag\n  if (token.block) {\n    needLf = true;\n\n    if (token.nesting === 1) {\n      if (idx + 1 < tokens.length) {\n        nextToken = tokens[idx + 1];\n\n        if (nextToken.type === 'inline' || nextToken.hidden) {\n          // Block-level tag containing an inline tag.\n          //\n          needLf = false;\n\n        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {\n          // Opening tag + closing tag of the same type. E.g. `<li></li>`.\n          //\n          needLf = false;\n        }\n      }\n    }\n  }\n\n  result += needLf ? '>\\n' : '>';\n\n  return result;\n};\n\n\n/**\n * Renderer.renderInline(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * The same as [[Renderer.render]], but for single token of `inline` type.\n **/\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  var type,\n      result = '',\n      rules = this.rules;\n\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n\n    if (typeof rules[type] !== 'undefined') {\n      result += rules[type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options);\n    }\n  }\n\n  return result;\n};\n\n\n/** internal\n * Renderer.renderInlineAsText(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Special kludge for image `alt` attributes to conform CommonMark spec.\n * Don't try to use it! Spec requires to show `alt` content with stripped markup,\n * instead of simple escaping.\n **/\nRenderer.prototype.renderInlineAsText = function (tokens, options, env) {\n  var result = '';\n\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    if (tokens[i].type === 'text') {\n      result += tokens[i].content;\n    } else if (tokens[i].type === 'image') {\n      result += this.renderInlineAsText(tokens[i].children, options, env);\n    }\n  }\n\n  return result;\n};\n\n\n/**\n * Renderer.render(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to renter\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Takes token stream and generates HTML. Probably, you will never need to call\n * this method directly.\n **/\nRenderer.prototype.render = function (tokens, options, env) {\n  var i, len, type,\n      result = '',\n      rules = this.rules;\n\n  for (i = 0, len = tokens.length; i < len; i++) {\n    type = tokens[i].type;\n\n    if (type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env);\n    } else if (typeof rules[type] !== 'undefined') {\n      result += rules[tokens[i].type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options, env);\n    }\n  }\n\n  return result;\n};\n\nmodule.exports = Renderer;\n","/**\n * class Ruler\n *\n * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and\n * [[MarkdownIt#inline]] to manage sequences of functions (rules):\n *\n * - keep rules in defined order\n * - assign the name to each rule\n * - enable/disable rules\n * - add/replace rules\n * - allow assign rules to additional named chains (in the same)\n * - cacheing lists of active rules\n *\n * You will not need use this class directly until write plugins. For simple\n * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and\n * [[MarkdownIt.use]].\n **/\n'use strict';\n\n\n/**\n * new Ruler()\n **/\nfunction Ruler() {\n  // List of added rules. Each element is:\n  //\n  // {\n  //   name: XXX,\n  //   enabled: Boolean,\n  //   fn: Function(),\n  //   alt: [ name2, name3 ]\n  // }\n  //\n  this.__rules__ = [];\n\n  // Cached rule chains.\n  //\n  // First level - chain name, '' for default.\n  // Second level - diginal anchor for fast filtering by charcodes.\n  //\n  this.__cache__ = null;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Helper methods, should not be used directly\n\n\n// Find rule index by name\n//\nRuler.prototype.__find__ = function (name) {\n  for (var i = 0; i < this.__rules__.length; i++) {\n    if (this.__rules__[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n\n// Build rules lookup cache\n//\nRuler.prototype.__compile__ = function () {\n  var self = this;\n  var chains = [ '' ];\n\n  // collect unique names\n  self.__rules__.forEach(function (rule) {\n    if (!rule.enabled) { return; }\n\n    rule.alt.forEach(function (altName) {\n      if (chains.indexOf(altName) < 0) {\n        chains.push(altName);\n      }\n    });\n  });\n\n  self.__cache__ = {};\n\n  chains.forEach(function (chain) {\n    self.__cache__[chain] = [];\n    self.__rules__.forEach(function (rule) {\n      if (!rule.enabled) { return; }\n\n      if (chain && rule.alt.indexOf(chain) < 0) { return; }\n\n      self.__cache__[chain].push(rule.fn);\n    });\n  });\n};\n\n\n/**\n * Ruler.at(name, fn [, options])\n * - name (String): rule name to replace.\n * - fn (Function): new rule function.\n * - options (Object): new rule options (not mandatory).\n *\n * Replace rule by name with new function & options. Throws error if name not\n * found.\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * Replace existing typographer replacement rule with new one:\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.core.ruler.at('replacements', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.at = function (name, fn, options) {\n  var index = this.__find__(name);\n  var opt = options || {};\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + name); }\n\n  this.__rules__[index].fn = fn;\n  this.__rules__[index].alt = opt.alt || [];\n  this.__cache__ = null;\n};\n\n\n/**\n * Ruler.before(beforeName, ruleName, fn [, options])\n * - beforeName (String): new rule will be added before this one.\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Add new rule to chain before one with given name. See also\n * [[Ruler.after]], [[Ruler.push]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.before = function (beforeName, ruleName, fn, options) {\n  var index = this.__find__(beforeName);\n  var opt = options || {};\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + beforeName); }\n\n  this.__rules__.splice(index, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n\n/**\n * Ruler.after(afterName, ruleName, fn [, options])\n * - afterName (String): new rule will be added after this one.\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Add new rule to chain after one with given name. See also\n * [[Ruler.before]], [[Ruler.push]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.inline.ruler.after('text', 'my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.after = function (afterName, ruleName, fn, options) {\n  var index = this.__find__(afterName);\n  var opt = options || {};\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + afterName); }\n\n  this.__rules__.splice(index + 1, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n/**\n * Ruler.push(ruleName, fn [, options])\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Push new rule to the end of chain. See also\n * [[Ruler.before]], [[Ruler.after]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.core.ruler.push('my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.push = function (ruleName, fn, options) {\n  var opt = options || {};\n\n  this.__rules__.push({\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n\n\n/**\n * Ruler.enable(list [, ignoreInvalid]) -> Array\n * - list (String|Array): list of rule names to enable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable rules with given names. If any rule name not found - throw Error.\n * Errors can be disabled by second param.\n *\n * Returns list of found rule names (if no exception happened).\n *\n * See also [[Ruler.disable]], [[Ruler.enableOnly]].\n **/\nRuler.prototype.enable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  var result = [];\n\n  // Search by name and enable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n\n    if (idx < 0) {\n      if (ignoreInvalid) { return; }\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = true;\n    result.push(name);\n  }, this);\n\n  this.__cache__ = null;\n  return result;\n};\n\n\n/**\n * Ruler.enableOnly(list [, ignoreInvalid])\n * - list (String|Array): list of rule names to enable (whitelist).\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable rules with given names, and disable everything else. If any rule name\n * not found - throw Error. Errors can be disabled by second param.\n *\n * See also [[Ruler.disable]], [[Ruler.enable]].\n **/\nRuler.prototype.enableOnly = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  this.__rules__.forEach(function (rule) { rule.enabled = false; });\n\n  this.enable(list, ignoreInvalid);\n};\n\n\n/**\n * Ruler.disable(list [, ignoreInvalid]) -> Array\n * - list (String|Array): list of rule names to disable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Disable rules with given names. If any rule name not found - throw Error.\n * Errors can be disabled by second param.\n *\n * Returns list of found rule names (if no exception happened).\n *\n * See also [[Ruler.enable]], [[Ruler.enableOnly]].\n **/\nRuler.prototype.disable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [ list ]; }\n\n  var result = [];\n\n  // Search by name and disable\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n\n    if (idx < 0) {\n      if (ignoreInvalid) { return; }\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n    this.__rules__[idx].enabled = false;\n    result.push(name);\n  }, this);\n\n  this.__cache__ = null;\n  return result;\n};\n\n\n/**\n * Ruler.getRules(chainName) -> Array\n *\n * Return array of active functions (rules) for given chain name. It analyzes\n * rules configuration, compiles caches if not exists and returns result.\n *\n * Default chain name is `''` (empty string). It can't be skipped. That's\n * done intentionally, to keep signature monomorphic for high speed.\n **/\nRuler.prototype.getRules = function (chainName) {\n  if (this.__cache__ === null) {\n    this.__compile__();\n  }\n\n  // Chain can be empty, if rules disabled. But we still have to return Array.\n  return this.__cache__[chainName] || [];\n};\n\nmodule.exports = Ruler;\n","// Block quotes\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\n\nmodule.exports = function blockquote(state, startLine, endLine, silent) {\n  var adjustTab,\n      ch,\n      i,\n      initial,\n      l,\n      lastLineEmpty,\n      lines,\n      nextLine,\n      offset,\n      oldBMarks,\n      oldBSCount,\n      oldIndent,\n      oldParentType,\n      oldSCount,\n      oldTShift,\n      spaceAfterMarker,\n      terminate,\n      terminatorRules,\n      token,\n      isOutdented,\n      oldLineMax = state.lineMax,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) { return true; }\n\n  // set offset past spaces and \">\"\n  initial = offset = state.sCount[startLine] + 1;\n\n  // skip one optional space after '>'\n  if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n    // ' >   test '\n    //     ^ -- position start of line here:\n    pos++;\n    initial++;\n    offset++;\n    adjustTab = false;\n    spaceAfterMarker = true;\n  } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n    spaceAfterMarker = true;\n\n    if ((state.bsCount[startLine] + offset) % 4 === 3) {\n      // '  >\\t  test '\n      //       ^ -- position start of line here (tab has width===1)\n      pos++;\n      initial++;\n      offset++;\n      adjustTab = false;\n    } else {\n      // ' >\\t  test '\n      //    ^ -- position start of line here + shift bsCount slightly\n      //         to make extra space appear\n      adjustTab = true;\n    }\n  } else {\n    spaceAfterMarker = false;\n  }\n\n  oldBMarks = [ state.bMarks[startLine] ];\n  state.bMarks[startLine] = pos;\n\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (isSpace(ch)) {\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;\n      } else {\n        offset++;\n      }\n    } else {\n      break;\n    }\n\n    pos++;\n  }\n\n  oldBSCount = [ state.bsCount[startLine] ];\n  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n  lastLineEmpty = pos >= max;\n\n  oldSCount = [ state.sCount[startLine] ];\n  state.sCount[startLine] = offset - initial;\n\n  oldTShift = [ state.tShift[startLine] ];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n\n  terminatorRules = state.md.block.ruler.getRules('blockquote');\n\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag:\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    // check if it's outdented, i.e. it's inside list item and indented\n    // less than said list item:\n    //\n    // ```\n    // 1. anything\n    //    > current blockquote\n    // 2. checking this line\n    // ```\n    isOutdented = state.sCount[nextLine] < state.blkIndent;\n\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */ && !isOutdented) {\n      // This line is inside the blockquote.\n\n      // set offset past spaces and \">\"\n      initial = offset = state.sCount[nextLine] + 1;\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n        // ' >   test '\n        //     ^ -- position start of line here:\n        pos++;\n        initial++;\n        offset++;\n        adjustTab = false;\n        spaceAfterMarker = true;\n      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n        spaceAfterMarker = true;\n\n        if ((state.bsCount[nextLine] + offset) % 4 === 3) {\n          // '  >\\t  test '\n          //       ^ -- position start of line here (tab has width===1)\n          pos++;\n          initial++;\n          offset++;\n          adjustTab = false;\n        } else {\n          // ' >\\t  test '\n          //    ^ -- position start of line here + shift bsCount slightly\n          //         to make extra space appear\n          adjustTab = true;\n        }\n      } else {\n        spaceAfterMarker = false;\n      }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n\n      while (pos < max) {\n        ch = state.src.charCodeAt(pos);\n\n        if (isSpace(ch)) {\n          if (ch === 0x09) {\n            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;\n          } else {\n            offset++;\n          }\n        } else {\n          break;\n        }\n\n        pos++;\n      }\n\n      lastLineEmpty = pos >= max;\n\n      oldBSCount.push(state.bsCount[nextLine]);\n      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n      oldSCount.push(state.sCount[nextLine]);\n      state.sCount[nextLine] = offset - initial;\n\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) { break; }\n\n    // Case 3: another tag found.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      // Quirk to enforce \"hard termination mode\" for paragraphs;\n      // normally if you call `tokenize(state, startLine, nextLine)`,\n      // paragraphs will look below nextLine for paragraph continuation,\n      // but if blockquote is terminated by another tag, they shouldn't\n      state.lineMax = nextLine;\n\n      if (state.blkIndent !== 0) {\n        // state.blkIndent was non-zero, we now set it to zero,\n        // so we need to re-calculate all offsets to appear as\n        // if indent wasn't changed\n        oldBMarks.push(state.bMarks[nextLine]);\n        oldBSCount.push(state.bsCount[nextLine]);\n        oldTShift.push(state.tShift[nextLine]);\n        oldSCount.push(state.sCount[nextLine]);\n        state.sCount[nextLine] -= state.blkIndent;\n      }\n\n      break;\n    }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldBSCount.push(state.bsCount[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n    oldSCount.push(state.sCount[nextLine]);\n\n    // A negative indentation means that this is a paragraph continuation\n    //\n    state.sCount[nextLine] = -1;\n  }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n\n  token        = state.push('blockquote_open', 'blockquote', 1);\n  token.markup = '>';\n  token.map    = lines = [ startLine, 0 ];\n\n  state.md.block.tokenize(state, startLine, nextLine);\n\n  token        = state.push('blockquote_close', 'blockquote', -1);\n  token.markup = '>';\n\n  state.lineMax = oldLineMax;\n  state.parentType = oldParentType;\n  lines[1] = state.line;\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n    state.sCount[i + startLine] = oldSCount[i];\n    state.bsCount[i + startLine] = oldBSCount[i];\n  }\n  state.blkIndent = oldIndent;\n\n  return true;\n};\n","// Code block (4 spaces padded)\n\n'use strict';\n\n\nmodule.exports = function code(state, startLine, endLine/*, silent*/) {\n  var nextLine, last, token;\n\n  if (state.sCount[startLine] - state.blkIndent < 4) { return false; }\n\n  last = nextLine = startLine + 1;\n\n  while (nextLine < endLine) {\n    if (state.isEmpty(nextLine)) {\n      nextLine++;\n      continue;\n    }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      nextLine++;\n      last = nextLine;\n      continue;\n    }\n    break;\n  }\n\n  state.line = last;\n\n  token         = state.push('code_block', 'code', 0);\n  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);\n  token.map     = [ startLine, state.line ];\n\n  return true;\n};\n","// fences (``` lang, ~~~ lang)\n\n'use strict';\n\n\nmodule.exports = function fence(state, startLine, endLine, silent) {\n  var marker, len, params, nextLine, mem, token, markup,\n      haveEndMarker = false,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  if (pos + 3 > max) { return false; }\n\n  marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {\n    return false;\n  }\n\n  // scan marker length\n  mem = pos;\n  pos = state.skipChars(pos, marker);\n\n  len = pos - mem;\n\n  if (len < 3) { return false; }\n\n  markup = state.src.slice(mem, pos);\n  params = state.src.slice(pos, max);\n\n  if (marker === 0x60 /* ` */) {\n    if (params.indexOf(String.fromCharCode(marker)) >= 0) {\n      return false;\n    }\n  }\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) { return true; }\n\n  // search end of block\n  nextLine = startLine;\n\n  for (;;) {\n    nextLine++;\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break;\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break;\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) { continue; }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue;\n    }\n\n    pos = state.skipChars(pos, marker);\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) { continue; }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos);\n\n    if (pos < max) { continue; }\n\n    haveEndMarker = true;\n    // found!\n    break;\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.sCount[startLine];\n\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\n\n  token         = state.push('fence', 'code', 0);\n  token.info    = params;\n  token.content = state.getLines(startLine + 1, nextLine, len, true);\n  token.markup  = markup;\n  token.map     = [ startLine, state.line ];\n\n  return true;\n};\n","// heading (#, ##, ...)\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\n\nmodule.exports = function heading(state, startLine, endLine, silent) {\n  var ch, level, tmp, token,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  ch  = state.src.charCodeAt(pos);\n\n  if (ch !== 0x23/* # */ || pos >= max) { return false; }\n\n  // count heading level\n  level = 1;\n  ch = state.src.charCodeAt(++pos);\n  while (ch === 0x23/* # */ && pos < max && level <= 6) {\n    level++;\n    ch = state.src.charCodeAt(++pos);\n  }\n\n  if (level > 6 || (pos < max && !isSpace(ch))) { return false; }\n\n  if (silent) { return true; }\n\n  // Let's cut tails like '    ###  ' from the end of string\n\n  max = state.skipSpacesBack(max, pos);\n  tmp = state.skipCharsBack(max, 0x23, pos); // #\n  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {\n    max = tmp;\n  }\n\n  state.line = startLine + 1;\n\n  token        = state.push('heading_open', 'h' + String(level), 1);\n  token.markup = '########'.slice(0, level);\n  token.map    = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = state.src.slice(pos, max).trim();\n  token.map      = [ startLine, state.line ];\n  token.children = [];\n\n  token        = state.push('heading_close', 'h' + String(level), -1);\n  token.markup = '########'.slice(0, level);\n\n  return true;\n};\n","// Horizontal rule\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\n\nmodule.exports = function hr(state, startLine, endLine, silent) {\n  var marker, cnt, ch, token,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  marker = state.src.charCodeAt(pos++);\n\n  // Check hr marker\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x5F/* _ */) {\n    return false;\n  }\n\n  // markers can be mixed with spaces, but there should be at least 3 of them\n\n  cnt = 1;\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos++);\n    if (ch !== marker && !isSpace(ch)) { return false; }\n    if (ch === marker) { cnt++; }\n  }\n\n  if (cnt < 3) { return false; }\n\n  if (silent) { return true; }\n\n  state.line = startLine + 1;\n\n  token        = state.push('hr', 'hr', 0);\n  token.map    = [ startLine, state.line ];\n  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));\n\n  return true;\n};\n","// HTML block\n\n'use strict';\n\n\nvar block_names = require('../common/html_blocks');\nvar HTML_OPEN_CLOSE_TAG_RE = require('../common/html_re').HTML_OPEN_CLOSE_TAG_RE;\n\n// An array of opening and corresponding closing sequences for html tags,\n// last argument defines whether it can terminate a paragraph or not\n//\nvar HTML_SEQUENCES = [\n  [ /^<(script|pre|style)(?=(\\s|>|$))/i, /<\\/(script|pre|style)>/i, true ],\n  [ /^<!--/,        /-->/,   true ],\n  [ /^<\\?/,         /\\?>/,   true ],\n  [ /^<![A-Z]/,     />/,     true ],\n  [ /^<!\\[CDATA\\[/, /\\]\\]>/, true ],\n  [ new RegExp('^</?(' + block_names.join('|') + ')(?=(\\\\s|/?>|$))', 'i'), /^$/, true ],\n  [ new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\\\s*$'),  /^$/, false ]\n];\n\n\nmodule.exports = function html_block(state, startLine, endLine, silent) {\n  var i, nextLine, token, lineText,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  if (!state.md.options.html) { return false; }\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n  lineText = state.src.slice(pos, max);\n\n  for (i = 0; i < HTML_SEQUENCES.length; i++) {\n    if (HTML_SEQUENCES[i][0].test(lineText)) { break; }\n  }\n\n  if (i === HTML_SEQUENCES.length) { return false; }\n\n  if (silent) {\n    // true if this sequence can be a terminator, false otherwise\n    return HTML_SEQUENCES[i][2];\n  }\n\n  nextLine = startLine + 1;\n\n  // If we are here - we detected HTML block.\n  // Let's roll down till block end.\n  if (!HTML_SEQUENCES[i][1].test(lineText)) {\n    for (; nextLine < endLine; nextLine++) {\n      if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n      lineText = state.src.slice(pos, max);\n\n      if (HTML_SEQUENCES[i][1].test(lineText)) {\n        if (lineText.length !== 0) { nextLine++; }\n        break;\n      }\n    }\n  }\n\n  state.line = nextLine;\n\n  token         = state.push('html_block', '', 0);\n  token.map     = [ startLine, nextLine ];\n  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);\n\n  return true;\n};\n","// lheading (---, ===)\n\n'use strict';\n\n\nmodule.exports = function lheading(state, startLine, endLine/*, silent*/) {\n  var content, terminate, i, l, token, pos, max, level, marker,\n      nextLine = startLine + 1, oldParentType,\n      terminatorRules = state.md.block.ruler.getRules('paragraph');\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  oldParentType = state.parentType;\n  state.parentType = 'paragraph'; // use paragraph to match terminatorRules\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    //\n    // Check for underline in setext header\n    //\n    if (state.sCount[nextLine] >= state.blkIndent) {\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (pos < max) {\n        marker = state.src.charCodeAt(pos);\n\n        if (marker === 0x2D/* - */ || marker === 0x3D/* = */) {\n          pos = state.skipChars(pos, marker);\n          pos = state.skipSpaces(pos);\n\n          if (pos >= max) {\n            level = (marker === 0x3D/* = */ ? 1 : 2);\n            break;\n          }\n        }\n      }\n    }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  if (!level) {\n    // Didn't find valid underline\n    return false;\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine + 1;\n\n  token          = state.push('heading_open', 'h' + String(level), 1);\n  token.markup   = String.fromCharCode(marker);\n  token.map      = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = content;\n  token.map      = [ startLine, state.line - 1 ];\n  token.children = [];\n\n  token          = state.push('heading_close', 'h' + String(level), -1);\n  token.markup   = String.fromCharCode(marker);\n\n  state.parentType = oldParentType;\n\n  return true;\n};\n","// Lists\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\n\n// Search `[-+*][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max, ch;\n\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n\n  marker = state.src.charCodeAt(pos++);\n  // Check bullet\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x2B/* + */) {\n    return -1;\n  }\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" -test \" - is not a list item\n      return -1;\n    }\n  }\n\n  return pos;\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n      start = state.bMarks[startLine] + state.tShift[startLine],\n      pos = start,\n      max = state.eMarks[startLine];\n\n  // List marker should have at least 2 chars (digit + dot)\n  if (pos + 1 >= max) { return -1; }\n\n  ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) { return -1; }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\n\n      // List marker should have no more than 9 digits\n      // (prevents integer overflow in browsers)\n      if (pos - start >= 10) { return -1; }\n\n      continue;\n    }\n\n    // found valid marker\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\n      break;\n    }\n\n    return -1;\n  }\n\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" 1.test \" - is not a list item\n      return -1;\n    }\n  }\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i, l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].hidden = true;\n      state.tokens[i].hidden = true;\n      i += 2;\n    }\n  }\n}\n\n\nmodule.exports = function list(state, startLine, endLine, silent) {\n  var ch,\n      contentStart,\n      i,\n      indent,\n      indentAfterMarker,\n      initial,\n      isOrdered,\n      itemLines,\n      l,\n      listLines,\n      listTokIdx,\n      markerCharCode,\n      markerValue,\n      max,\n      nextLine,\n      offset,\n      oldListIndent,\n      oldParentType,\n      oldSCount,\n      oldTShift,\n      oldTight,\n      pos,\n      posAfterMarker,\n      prevEmptyEnd,\n      start,\n      terminate,\n      terminatorRules,\n      token,\n      isTerminatingParagraph = false,\n      tight = true;\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  // Special case:\n  //  - item 1\n  //   - item 2\n  //    - item 3\n  //     - item 4\n  //      - this one is a paragraph continuation\n  if (state.listIndent >= 0 &&\n      state.sCount[startLine] - state.listIndent >= 4 &&\n      state.sCount[startLine] < state.blkIndent) {\n    return false;\n  }\n\n  // limit conditions when list can interrupt\n  // a paragraph (validation mode only)\n  if (silent && state.parentType === 'paragraph') {\n    // Next list item should still terminate previous list item;\n    //\n    // This code can fail if plugins use blkIndent as well as lists,\n    // but I hope the spec gets fixed long before that happens.\n    //\n    if (state.tShift[startLine] >= state.blkIndent) {\n      isTerminatingParagraph = true;\n    }\n  }\n\n  // Detect list type and position after marker\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\n\n    // If we're starting a new ordered list right after\n    // a paragraph, it should start with 1.\n    if (isTerminatingParagraph && markerValue !== 1) return false;\n\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n\n  } else {\n    return false;\n  }\n\n  // If we're starting a new unordered list right after\n  // a paragraph, first line should not be empty.\n  if (isTerminatingParagraph) {\n    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;\n  }\n\n  // We should terminate list on style change. Remember first one to compare.\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n\n  // For validation mode we can terminate immediately\n  if (silent) { return true; }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    token       = state.push('ordered_list_open', 'ol', 1);\n    if (markerValue !== 1) {\n      token.attrs = [ [ 'start', markerValue ] ];\n    }\n\n  } else {\n    token       = state.push('bullet_list_open', 'ul', 1);\n  }\n\n  token.map    = listLines = [ startLine, 0 ];\n  token.markup = String.fromCharCode(markerCharCode);\n\n  //\n  // Iterate list items\n  //\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.md.block.ruler.getRules('list');\n\n  oldParentType = state.parentType;\n  state.parentType = 'list';\n\n  while (nextLine < endLine) {\n    pos = posAfterMarker;\n    max = state.eMarks[nextLine];\n\n    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);\n\n    while (pos < max) {\n      ch = state.src.charCodeAt(pos);\n\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[nextLine]) % 4;\n      } else if (ch === 0x20) {\n        offset++;\n      } else {\n        break;\n      }\n\n      pos++;\n    }\n\n    contentStart = pos;\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = offset - initial;\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) { indentAfterMarker = 1; }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    indent = initial + indentAfterMarker;\n\n    // Run subparser & write tokens\n    token        = state.push('list_item_open', 'li', 1);\n    token.markup = String.fromCharCode(markerCharCode);\n    token.map    = itemLines = [ startLine, 0 ];\n\n    // change current state, then restore it after parser subcall\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldSCount = state.sCount[startLine];\n\n    //  - example list\n    // ^ listIndent position will be here\n    //   ^ blkIndent position will be here\n    //\n    oldListIndent = state.listIndent;\n    state.listIndent = state.blkIndent;\n    state.blkIndent = indent;\n\n    state.tight = true;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.sCount[startLine] = offset;\n\n    if (contentStart >= max && state.isEmpty(startLine + 1)) {\n      // workaround for this case\n      // (list item is empty, list terminates before \"foo\"):\n      // ~~~~~~~~\n      //   -\n      //\n      //     foo\n      // ~~~~~~~~\n      state.line = Math.min(state.line + 2, endLine);\n    } else {\n      state.md.block.tokenize(state, startLine, endLine, true);\n    }\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);\n\n    state.blkIndent = state.listIndent;\n    state.listIndent = oldListIndent;\n    state.tShift[startLine] = oldTShift;\n    state.sCount[startLine] = oldSCount;\n    state.tight = oldTight;\n\n    token        = state.push('list_item_close', 'li', -1);\n    token.markup = String.fromCharCode(markerCharCode);\n\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n\n    if (nextLine >= endLine) { break; }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n    // if it's indented more than 3 spaces, it should be a code block\n    if (state.sCount[startLine] - state.blkIndent >= 4) { break; }\n\n    // fail if terminating block found\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }\n  }\n\n  // Finalize list\n  if (isOrdered) {\n    token = state.push('ordered_list_close', 'ol', -1);\n  } else {\n    token = state.push('bullet_list_close', 'ul', -1);\n  }\n  token.markup = String.fromCharCode(markerCharCode);\n\n  listLines[1] = nextLine;\n  state.line = nextLine;\n\n  state.parentType = oldParentType;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n};\n","// Paragraph\n\n'use strict';\n\n\nmodule.exports = function paragraph(state, startLine/*, endLine*/) {\n  var content, terminate, i, l, token, oldParentType,\n      nextLine = startLine + 1,\n      terminatorRules = state.md.block.ruler.getRules('paragraph'),\n      endLine = state.lineMax;\n\n  oldParentType = state.parentType;\n  state.parentType = 'paragraph';\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine;\n\n  token          = state.push('paragraph_open', 'p', 1);\n  token.map      = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = content;\n  token.map      = [ startLine, state.line ];\n  token.children = [];\n\n  token          = state.push('paragraph_close', 'p', -1);\n\n  state.parentType = oldParentType;\n\n  return true;\n};\n","'use strict';\n\n\nvar normalizeReference   = require('../common/utils').normalizeReference;\nvar isSpace              = require('../common/utils').isSpace;\n\n\nmodule.exports = function reference(state, startLine, _endLine, silent) {\n  var ch,\n      destEndPos,\n      destEndLineNo,\n      endLine,\n      href,\n      i,\n      l,\n      label,\n      labelEnd,\n      oldParentType,\n      res,\n      start,\n      str,\n      terminate,\n      terminatorRules,\n      title,\n      lines = 0,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine],\n      nextLine = startLine + 1;\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false; }\n\n  // Simple check to quickly interrupt scan on [link](url) at the start of line.\n  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54\n  while (++pos < max) {\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&\n        state.src.charCodeAt(pos - 1) !== 0x5C/* \\ */) {\n      if (pos + 1 === max) { return false; }\n      if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false; }\n      break;\n    }\n  }\n\n  endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  terminatorRules = state.md.block.ruler.getRules('reference');\n\n  oldParentType = state.parentType;\n  state.parentType = 'reference';\n\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  max = str.length;\n\n  for (pos = 1; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x5B /* [ */) {\n      return false;\n    } else if (ch === 0x5D /* ] */) {\n      labelEnd = pos;\n      break;\n    } else if (ch === 0x0A /* \\n */) {\n      lines++;\n    } else if (ch === 0x5C /* \\ */) {\n      pos++;\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\n        lines++;\n      }\n    }\n  }\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false; }\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  res = state.md.helpers.parseLinkDestination(str, pos, max);\n  if (!res.ok) { return false; }\n\n  href = state.md.normalizeLink(res.str);\n  if (!state.md.validateLink(href)) { return false; }\n\n  pos = res.pos;\n  lines += res.lines;\n\n  // save cursor state, we could require to rollback later\n  destEndPos = pos;\n  destEndLineNo = lines;\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  start = pos;\n  for (; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  res = state.md.helpers.parseLinkTitle(str, pos, max);\n  if (pos < max && start !== pos && res.ok) {\n    title = res.str;\n    pos = res.pos;\n    lines += res.lines;\n  } else {\n    title = '';\n    pos = destEndPos;\n    lines = destEndLineNo;\n  }\n\n  // skip trailing spaces until the rest of the line\n  while (pos < max) {\n    ch = str.charCodeAt(pos);\n    if (!isSpace(ch)) { break; }\n    pos++;\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = '';\n      pos = destEndPos;\n      lines = destEndLineNo;\n      while (pos < max) {\n        ch = str.charCodeAt(pos);\n        if (!isSpace(ch)) { break; }\n        pos++;\n      }\n    }\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false;\n  }\n\n  label = normalizeReference(str.slice(1, labelEnd));\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false;\n  }\n\n  // Reference can not terminate anything. This check is for safety only.\n  /*istanbul ignore if*/\n  if (silent) { return true; }\n\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {};\n  }\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = { title: title, href: href };\n  }\n\n  state.parentType = oldParentType;\n\n  state.line = startLine + lines + 1;\n  return true;\n};\n","// Parser state class\n\n'use strict';\n\nvar Token = require('../token');\nvar isSpace = require('../common/utils').isSpace;\n\n\nfunction StateBlock(src, md, env, tokens) {\n  var ch, s, start, pos, len, indent, offset, indent_found;\n\n  this.src = src;\n\n  // link to parser instance\n  this.md     = md;\n\n  this.env = env;\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n\n  this.bMarks = [];  // line begin offsets for fast jumps\n  this.eMarks = [];  // line end offsets for fast jumps\n  this.tShift = [];  // offsets of the first non-space characters (tabs not expanded)\n  this.sCount = [];  // indents for each line (tabs expanded)\n\n  // An amount of virtual spaces (tabs expanded) between beginning\n  // of each line (bMarks) and real beginning of that line.\n  //\n  // It exists only as a hack because blockquotes override bMarks\n  // losing information in the process.\n  //\n  // It's used only when expanding tabs, you can think about it as\n  // an initial tab length, e.g. bsCount=21 applied to string `\\t123`\n  // means first tab should be expanded to 4-21%4 === 3 spaces.\n  //\n  this.bsCount = [];\n\n  // block parser variables\n  this.blkIndent  = 0; // required block content indent (for example, if we are\n                       // inside a list, it would be positioned after list marker)\n  this.line       = 0; // line index in src\n  this.lineMax    = 0; // lines count\n  this.tight      = false;  // loose/tight mode for lists\n  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)\n  this.listIndent = -1; // indent of the current list block (-1 if there isn't any)\n\n  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'\n  // used in lists to determine if they interrupt a paragraph\n  this.parentType = 'root';\n\n  this.level = 0;\n\n  // renderer\n  this.result = '';\n\n  // Create caches\n  // Generate markers.\n  s = this.src;\n  indent_found = false;\n\n  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (isSpace(ch)) {\n        indent++;\n\n        if (ch === 0x09) {\n          offset += 4 - offset % 4;\n        } else {\n          offset++;\n        }\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) { pos++; }\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n      this.sCount.push(offset);\n      this.bsCount.push(0);\n\n      indent_found = false;\n      indent = 0;\n      offset = 0;\n      start = pos + 1;\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n  this.sCount.push(0);\n  this.bsCount.push(0);\n\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\n\n// Push new token to \"stream\".\n//\nStateBlock.prototype.push = function (type, tag, nesting) {\n  var token = new Token(type, tag, nesting);\n  token.block = true;\n\n  if (nesting < 0) this.level--; // closing tag\n  token.level = this.level;\n  if (nesting > 0) this.level++; // opening tag\n\n  this.tokens.push(token);\n  return token;\n};\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n  return from;\n};\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  var ch;\n\n  for (var max = this.src.length; pos < max; pos++) {\n    ch = this.src.charCodeAt(pos);\n    if (!isSpace(ch)) { break; }\n  }\n  return pos;\n};\n\n// Skip spaces from given position in reverse.\nStateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (!isSpace(this.src.charCodeAt(--pos))) { return pos + 1; }\n  }\n  return pos;\n};\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) { break; }\n  }\n  return pos;\n};\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) { return pos; }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }\n  }\n  return pos;\n};\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i, lineIndent, ch, first, last, queue, lineStart,\n      line = begin;\n\n  if (begin >= end) {\n    return '';\n  }\n\n  queue = new Array(end - begin);\n\n  for (i = 0; line < end; line++, i++) {\n    lineIndent = 0;\n    lineStart = first = this.bMarks[line];\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    while (first < last && lineIndent < indent) {\n      ch = this.src.charCodeAt(first);\n\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;\n        } else {\n          lineIndent++;\n        }\n      } else if (first - lineStart < this.tShift[line]) {\n        // patched tShift masked characters to look like spaces (blockquotes, list markers)\n        lineIndent++;\n      } else {\n        break;\n      }\n\n      first++;\n    }\n\n    if (lineIndent > indent) {\n      // partially expanding tabs in code blocks, e.g '\\t\\tfoobar'\n      // with indent=2 becomes '  \\tfoobar'\n      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);\n    } else {\n      queue[i] = this.src.slice(first, last);\n    }\n  }\n\n  return queue.join('');\n};\n\n// re-export Token class to use in block rules\nStateBlock.prototype.Token = Token;\n\n\nmodule.exports = StateBlock;\n","// GFM table, https://github.github.com/gfm/#tables-extension-\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\n\nfunction getLine(state, line) {\n  var pos = state.bMarks[line] + state.blkIndent,\n      max = state.eMarks[line];\n\n  return state.src.substr(pos, max - pos);\n}\n\nfunction escapedSplit(str) {\n  var result = [],\n      pos = 0,\n      max = str.length,\n      ch,\n      isEscaped = false,\n      lastPos = 0,\n      current = '';\n\n  ch  = str.charCodeAt(pos);\n\n  while (pos < max) {\n    if (ch === 0x7c/* | */) {\n      if (!isEscaped) {\n        // pipe separating cells, '|'\n        result.push(current + str.substring(lastPos, pos));\n        current = '';\n        lastPos = pos + 1;\n      } else {\n        // escaped pipe, '\\|'\n        current += str.substring(lastPos, pos - 1);\n        lastPos = pos;\n      }\n    }\n\n    isEscaped = (ch === 0x5c/* \\ */);\n    pos++;\n\n    ch = str.charCodeAt(pos);\n  }\n\n  result.push(current + str.substring(lastPos));\n\n  return result;\n}\n\n\nmodule.exports = function table(state, startLine, endLine, silent) {\n  var ch, lineText, pos, i, l, nextLine, columns, columnCount, token,\n      aligns, t, tableLines, tbodyLines, oldParentType, terminate,\n      terminatorRules;\n\n  // should have at least two lines\n  if (startLine + 2 > endLine) { return false; }\n\n  nextLine = startLine + 1;\n\n  if (state.sCount[nextLine] < state.blkIndent) { return false; }\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[nextLine] - state.blkIndent >= 4) { return false; }\n\n  // first character of the second line should be '|', '-', ':',\n  // and no other characters are allowed but spaces;\n  // basically, this is the equivalent of /^[-:|][-:|\\s]*$/ regexp\n\n  pos = state.bMarks[nextLine] + state.tShift[nextLine];\n  if (pos >= state.eMarks[nextLine]) { return false; }\n\n  ch = state.src.charCodeAt(pos++);\n  if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */) { return false; }\n\n  while (pos < state.eMarks[nextLine]) {\n    ch = state.src.charCodeAt(pos);\n\n    if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */ && !isSpace(ch)) { return false; }\n\n    pos++;\n  }\n\n  lineText = getLine(state, startLine + 1);\n\n  columns = lineText.split('|');\n  aligns = [];\n  for (i = 0; i < columns.length; i++) {\n    t = columns[i].trim();\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === columns.length - 1) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n\n    if (!/^:?-+:?$/.test(t)) { return false; }\n    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {\n      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');\n    } else if (t.charCodeAt(0) === 0x3A/* : */) {\n      aligns.push('left');\n    } else {\n      aligns.push('');\n    }\n  }\n\n  lineText = getLine(state, startLine).trim();\n  if (lineText.indexOf('|') === -1) { return false; }\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n  columns = escapedSplit(lineText);\n  if (columns.length && columns[0] === '') columns.shift();\n  if (columns.length && columns[columns.length - 1] === '') columns.pop();\n\n  // header row will define an amount of columns in the entire table,\n  // and align row should be exactly the same (the rest of the rows can differ)\n  columnCount = columns.length;\n  if (columnCount !== aligns.length) { return false; }\n\n  if (silent) { return true; }\n\n  oldParentType = state.parentType;\n  state.parentType = 'table';\n\n  // use 'blockquote' lists for termination because it's\n  // the most similar to tables\n  terminatorRules = state.md.block.ruler.getRules('blockquote');\n\n  token     = state.push('table_open', 'table', 1);\n  token.map = tableLines = [ startLine, 0 ];\n\n  token     = state.push('thead_open', 'thead', 1);\n  token.map = [ startLine, startLine + 1 ];\n\n  token     = state.push('tr_open', 'tr', 1);\n  token.map = [ startLine, startLine + 1 ];\n\n  for (i = 0; i < columns.length; i++) {\n    token          = state.push('th_open', 'th', 1);\n    if (aligns[i]) {\n      token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];\n    }\n\n    token          = state.push('inline', '', 0);\n    token.content  = columns[i].trim();\n    token.children = [];\n\n    token          = state.push('th_close', 'th', -1);\n  }\n\n  token     = state.push('tr_close', 'tr', -1);\n  token     = state.push('thead_close', 'thead', -1);\n\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) { break; }\n    lineText = getLine(state, nextLine).trim();\n    if (!lineText) { break; }\n    if (state.sCount[nextLine] - state.blkIndent >= 4) { break; }\n    columns = escapedSplit(lineText);\n    if (columns.length && columns[0] === '') columns.shift();\n    if (columns.length && columns[columns.length - 1] === '') columns.pop();\n\n    if (nextLine === startLine + 2) {\n      token     = state.push('tbody_open', 'tbody', 1);\n      token.map = tbodyLines = [ startLine + 2, 0 ];\n    }\n\n    token     = state.push('tr_open', 'tr', 1);\n    token.map = [ nextLine, nextLine + 1 ];\n\n    for (i = 0; i < columnCount; i++) {\n      token          = state.push('td_open', 'td', 1);\n      if (aligns[i]) {\n        token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];\n      }\n\n      token          = state.push('inline', '', 0);\n      token.content  = columns[i] ? columns[i].trim() : '';\n      token.children = [];\n\n      token          = state.push('td_close', 'td', -1);\n    }\n    token = state.push('tr_close', 'tr', -1);\n  }\n\n  if (tbodyLines) {\n    token = state.push('tbody_close', 'tbody', -1);\n    tbodyLines[1] = nextLine;\n  }\n\n  token = state.push('table_close', 'table', -1);\n  tableLines[1] = nextLine;\n\n  state.parentType = oldParentType;\n  state.line = nextLine;\n  return true;\n};\n","'use strict';\n\n\nmodule.exports = function block(state) {\n  var token;\n\n  if (state.inlineMode) {\n    token          = new state.Token('inline', '', 0);\n    token.content  = state.src;\n    token.map      = [ 0, 1 ];\n    token.children = [];\n    state.tokens.push(token);\n  } else {\n    state.md.block.parse(state.src, state.md, state.env, state.tokens);\n  }\n};\n","'use strict';\n\nmodule.exports = function inline(state) {\n  var tokens = state.tokens, tok, i, l;\n\n  // Parse inlines\n  for (i = 0, l = tokens.length; i < l; i++) {\n    tok = tokens[i];\n    if (tok.type === 'inline') {\n      state.md.inline.parse(tok.content, state.md, state.env, tok.children);\n    }\n  }\n};\n","// Replace link-like texts with link nodes.\n//\n// Currently restricted by `md.validateLink()` to http/https/ftp\n//\n'use strict';\n\n\nvar arrayReplaceAt = require('../common/utils').arrayReplaceAt;\n\n\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n}\n\n\nmodule.exports = function linkify(state) {\n  var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos,\n      level, htmlLinkLevel, url, fullUrl, urlText,\n      blockTokens = state.tokens,\n      links;\n\n  if (!state.md.options.linkify) { return; }\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline' ||\n        !state.md.linkify.pretest(blockTokens[j].content)) {\n      continue;\n    }\n\n    tokens = blockTokens[j].children;\n\n    htmlLinkLevel = 0;\n\n    // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n    for (i = tokens.length - 1; i >= 0; i--) {\n      currentToken = tokens[i];\n\n      // Skip content of markdown links\n      if (currentToken.type === 'link_close') {\n        i--;\n        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {\n          i--;\n        }\n        continue;\n      }\n\n      // Skip content of html tag links\n      if (currentToken.type === 'html_inline') {\n        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--;\n        }\n        if (isLinkClose(currentToken.content)) {\n          htmlLinkLevel++;\n        }\n      }\n      if (htmlLinkLevel > 0) { continue; }\n\n      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {\n\n        text = currentToken.content;\n        links = state.md.linkify.match(text);\n\n        // Now split string to nodes\n        nodes = [];\n        level = currentToken.level;\n        lastPos = 0;\n\n        for (ln = 0; ln < links.length; ln++) {\n\n          url = links[ln].url;\n          fullUrl = state.md.normalizeLink(url);\n          if (!state.md.validateLink(fullUrl)) { continue; }\n\n          urlText = links[ln].text;\n\n          // Linkifier might send raw hostnames like \"example.com\", where url\n          // starts with domain name. So we prepend http:// in those cases,\n          // and remove it afterwards.\n          //\n          if (!links[ln].schema) {\n            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\\/\\//, '');\n          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {\n            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');\n          } else {\n            urlText = state.md.normalizeLinkText(urlText);\n          }\n\n          pos = links[ln].index;\n\n          if (pos > lastPos) {\n            token         = new state.Token('text', '', 0);\n            token.content = text.slice(lastPos, pos);\n            token.level   = level;\n            nodes.push(token);\n          }\n\n          token         = new state.Token('link_open', 'a', 1);\n          token.attrs   = [ [ 'href', fullUrl ] ];\n          token.level   = level++;\n          token.markup  = 'linkify';\n          token.info    = 'auto';\n          nodes.push(token);\n\n          token         = new state.Token('text', '', 0);\n          token.content = urlText;\n          token.level   = level;\n          nodes.push(token);\n\n          token         = new state.Token('link_close', 'a', -1);\n          token.level   = --level;\n          token.markup  = 'linkify';\n          token.info    = 'auto';\n          nodes.push(token);\n\n          lastPos = links[ln].lastIndex;\n        }\n        if (lastPos < text.length) {\n          token         = new state.Token('text', '', 0);\n          token.content = text.slice(lastPos);\n          token.level   = level;\n          nodes.push(token);\n        }\n\n        // replace current node\n        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);\n      }\n    }\n  }\n};\n","// Normalize input string\n\n'use strict';\n\n\n// https://spec.commonmark.org/0.29/#line-ending\nvar NEWLINES_RE  = /\\r\\n?|\\n/g;\nvar NULL_RE      = /\\0/g;\n\n\nmodule.exports = function normalize(state) {\n  var str;\n\n  // Normalize newlines\n  str = state.src.replace(NEWLINES_RE, '\\n');\n\n  // Replace NULL characters\n  str = str.replace(NULL_RE, '\\uFFFD');\n\n  state.src = str;\n};\n","// Simple typographic replacements\n//\n// (c) (C) → ©\n// (tm) (TM) → ™\n// (r) (R) → ®\n// +- → ±\n// (p) (P) -> §\n// ... → … (also ?.... → ?.., !.... → !..)\n// ???????? → ???, !!!!! → !!!, `,,` → `,`\n// -- → &ndash;, --- → &mdash;\n//\n'use strict';\n\n// TODO:\n// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾\n// - miltiplication 2 x 4 -> 2 × 4\n\nvar RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/;\n\n// Workaround for phantomjs - need regex without /g flag,\n// or root check will fail every second time\nvar SCOPED_ABBR_TEST_RE = /\\((c|tm|r|p)\\)/i;\n\nvar SCOPED_ABBR_RE = /\\((c|tm|r|p)\\)/ig;\nvar SCOPED_ABBR = {\n  c: '©',\n  r: '®',\n  p: '§',\n  tm: '™'\n};\n\nfunction replaceFn(match, name) {\n  return SCOPED_ABBR[name.toLowerCase()];\n}\n\nfunction replace_scoped(inlineTokens) {\n  var i, token, inside_autolink = 0;\n\n  for (i = inlineTokens.length - 1; i >= 0; i--) {\n    token = inlineTokens[i];\n\n    if (token.type === 'text' && !inside_autolink) {\n      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);\n    }\n\n    if (token.type === 'link_open' && token.info === 'auto') {\n      inside_autolink--;\n    }\n\n    if (token.type === 'link_close' && token.info === 'auto') {\n      inside_autolink++;\n    }\n  }\n}\n\nfunction replace_rare(inlineTokens) {\n  var i, token, inside_autolink = 0;\n\n  for (i = inlineTokens.length - 1; i >= 0; i--) {\n    token = inlineTokens[i];\n\n    if (token.type === 'text' && !inside_autolink) {\n      if (RARE_RE.test(token.content)) {\n        token.content = token.content\n          .replace(/\\+-/g, '±')\n          // .., ..., ....... -> …\n          // but ?..... & !..... -> ?.. & !..\n          .replace(/\\.{2,}/g, '…').replace(/([?!])…/g, '$1..')\n          .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')\n          // em-dash\n          .replace(/(^|[^-])---(?=[^-]|$)/mg, '$1\\u2014')\n          // en-dash\n          .replace(/(^|\\s)--(?=\\s|$)/mg, '$1\\u2013')\n          .replace(/(^|[^-\\s])--(?=[^-\\s]|$)/mg, '$1\\u2013');\n      }\n    }\n\n    if (token.type === 'link_open' && token.info === 'auto') {\n      inside_autolink--;\n    }\n\n    if (token.type === 'link_close' && token.info === 'auto') {\n      inside_autolink++;\n    }\n  }\n}\n\n\nmodule.exports = function replace(state) {\n  var blkIdx;\n\n  if (!state.md.options.typographer) { return; }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n    if (state.tokens[blkIdx].type !== 'inline') { continue; }\n\n    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {\n      replace_scoped(state.tokens[blkIdx].children);\n    }\n\n    if (RARE_RE.test(state.tokens[blkIdx].content)) {\n      replace_rare(state.tokens[blkIdx].children);\n    }\n\n  }\n};\n","// Convert straight quotation marks to typographic ones\n//\n'use strict';\n\n\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\nvar isPunctChar    = require('../common/utils').isPunctChar;\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\nvar QUOTE_TEST_RE = /['\"]/;\nvar QUOTE_RE = /['\"]/g;\nvar APOSTROPHE = '\\u2019'; /* ’ */\n\n\nfunction replaceAt(str, index, ch) {\n  return str.substr(0, index) + ch + str.substr(index + 1);\n}\n\nfunction process_inlines(tokens, state) {\n  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar,\n      isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace,\n      canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;\n\n  stack = [];\n\n  for (i = 0; i < tokens.length; i++) {\n    token = tokens[i];\n\n    thisLevel = tokens[i].level;\n\n    for (j = stack.length - 1; j >= 0; j--) {\n      if (stack[j].level <= thisLevel) { break; }\n    }\n    stack.length = j + 1;\n\n    if (token.type !== 'text') { continue; }\n\n    text = token.content;\n    pos = 0;\n    max = text.length;\n\n    /*eslint no-labels:0,block-scoped-var:0*/\n    OUTER:\n    while (pos < max) {\n      QUOTE_RE.lastIndex = pos;\n      t = QUOTE_RE.exec(text);\n      if (!t) { break; }\n\n      canOpen = canClose = true;\n      pos = t.index + 1;\n      isSingle = (t[0] === \"'\");\n\n      // Find previous character,\n      // default to space if it's the beginning of the line\n      //\n      lastChar = 0x20;\n\n      if (t.index - 1 >= 0) {\n        lastChar = text.charCodeAt(t.index - 1);\n      } else {\n        for (j = i - 1; j >= 0; j--) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20\n          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);\n          break;\n        }\n      }\n\n      // Find next character,\n      // default to space if it's the end of the line\n      //\n      nextChar = 0x20;\n\n      if (pos < max) {\n        nextChar = text.charCodeAt(pos);\n      } else {\n        for (j = i + 1; j < tokens.length; j++) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20\n          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          nextChar = tokens[j].content.charCodeAt(0);\n          break;\n        }\n      }\n\n      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n      isLastWhiteSpace = isWhiteSpace(lastChar);\n      isNextWhiteSpace = isWhiteSpace(nextChar);\n\n      if (isNextWhiteSpace) {\n        canOpen = false;\n      } else if (isNextPunctChar) {\n        if (!(isLastWhiteSpace || isLastPunctChar)) {\n          canOpen = false;\n        }\n      }\n\n      if (isLastWhiteSpace) {\n        canClose = false;\n      } else if (isLastPunctChar) {\n        if (!(isNextWhiteSpace || isNextPunctChar)) {\n          canClose = false;\n        }\n      }\n\n      if (nextChar === 0x22 /* \" */ && t[0] === '\"') {\n        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {\n          // special case: 1\"\" - count first quote as an inch\n          canClose = canOpen = false;\n        }\n      }\n\n      if (canOpen && canClose) {\n        // Replace quotes in the middle of punctuation sequence, but not\n        // in the middle of the words, i.e.:\n        //\n        // 1. foo \" bar \" baz - not replaced\n        // 2. foo-\"-bar-\"-baz - replaced\n        // 3. foo\"bar\"baz     - not replaced\n        //\n        canOpen = isLastPunctChar;\n        canClose = isNextPunctChar;\n      }\n\n      if (!canOpen && !canClose) {\n        // middle of word\n        if (isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\n        }\n        continue;\n      }\n\n      if (canClose) {\n        // this could be a closing quote, rewind the stack to get a match\n        for (j = stack.length - 1; j >= 0; j--) {\n          item = stack[j];\n          if (stack[j].level < thisLevel) { break; }\n          if (item.single === isSingle && stack[j].level === thisLevel) {\n            item = stack[j];\n\n            if (isSingle) {\n              openQuote = state.md.options.quotes[2];\n              closeQuote = state.md.options.quotes[3];\n            } else {\n              openQuote = state.md.options.quotes[0];\n              closeQuote = state.md.options.quotes[1];\n            }\n\n            // replace token.content *before* tokens[item.token].content,\n            // because, if they are pointing at the same token, replaceAt\n            // could mess up indices when quote length != 1\n            token.content = replaceAt(token.content, t.index, closeQuote);\n            tokens[item.token].content = replaceAt(\n              tokens[item.token].content, item.pos, openQuote);\n\n            pos += closeQuote.length - 1;\n            if (item.token === i) { pos += openQuote.length - 1; }\n\n            text = token.content;\n            max = text.length;\n\n            stack.length = j;\n            continue OUTER;\n          }\n        }\n      }\n\n      if (canOpen) {\n        stack.push({\n          token: i,\n          pos: t.index,\n          single: isSingle,\n          level: thisLevel\n        });\n      } else if (canClose && isSingle) {\n        token.content = replaceAt(token.content, t.index, APOSTROPHE);\n      }\n    }\n  }\n}\n\n\nmodule.exports = function smartquotes(state) {\n  /*eslint max-depth:0*/\n  var blkIdx;\n\n  if (!state.md.options.typographer) { return; }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n    if (state.tokens[blkIdx].type !== 'inline' ||\n        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n      continue;\n    }\n\n    process_inlines(state.tokens[blkIdx].children, state);\n  }\n};\n","// Core state object\n//\n'use strict';\n\nvar Token = require('../token');\n\n\nfunction StateCore(src, md, env) {\n  this.src = src;\n  this.env = env;\n  this.tokens = [];\n  this.inlineMode = false;\n  this.md = md; // link to parser instance\n}\n\n// re-export Token class to use in core rules\nStateCore.prototype.Token = Token;\n\n\nmodule.exports = StateCore;\n","// Process autolinks '<protocol:...>'\n\n'use strict';\n\n\n/*eslint max-len:0*/\nvar EMAIL_RE    = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\nvar AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\\-]{1,31}):([^<>\\x00-\\x20]*)>/;\n\n\nmodule.exports = function autolink(state, silent) {\n  var tail, linkMatch, emailMatch, url, fullUrl, token,\n      pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n  tail = state.src.slice(pos);\n\n  if (tail.indexOf('>') < 0) { return false; }\n\n  if (AUTOLINK_RE.test(tail)) {\n    linkMatch = tail.match(AUTOLINK_RE);\n\n    url = linkMatch[0].slice(1, -1);\n    fullUrl = state.md.normalizeLink(url);\n    if (!state.md.validateLink(fullUrl)) { return false; }\n\n    if (!silent) {\n      token         = state.push('link_open', 'a', 1);\n      token.attrs   = [ [ 'href', fullUrl ] ];\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n\n      token         = state.push('text', '', 0);\n      token.content = state.md.normalizeLinkText(url);\n\n      token         = state.push('link_close', 'a', -1);\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n    }\n\n    state.pos += linkMatch[0].length;\n    return true;\n  }\n\n  if (EMAIL_RE.test(tail)) {\n    emailMatch = tail.match(EMAIL_RE);\n\n    url = emailMatch[0].slice(1, -1);\n    fullUrl = state.md.normalizeLink('mailto:' + url);\n    if (!state.md.validateLink(fullUrl)) { return false; }\n\n    if (!silent) {\n      token         = state.push('link_open', 'a', 1);\n      token.attrs   = [ [ 'href', fullUrl ] ];\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n\n      token         = state.push('text', '', 0);\n      token.content = state.md.normalizeLinkText(url);\n\n      token         = state.push('link_close', 'a', -1);\n      token.markup  = 'autolink';\n      token.info    = 'auto';\n    }\n\n    state.pos += emailMatch[0].length;\n    return true;\n  }\n\n  return false;\n};\n","// Parse backticks\n\n'use strict';\n\nmodule.exports = function backtick(state, silent) {\n  var start, max, marker, matchStart, matchEnd, token,\n      pos = state.pos,\n      ch = state.src.charCodeAt(pos);\n\n  if (ch !== 0x60/* ` */) { return false; }\n\n  start = pos;\n  pos++;\n  max = state.posMax;\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }\n\n  marker = state.src.slice(start, pos);\n\n  matchStart = matchEnd = pos;\n\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n    matchEnd = matchStart + 1;\n\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }\n\n    if (matchEnd - matchStart === marker.length) {\n      if (!silent) {\n        token         = state.push('code_inline', 'code', 0);\n        token.markup  = marker;\n        token.content = state.src.slice(pos, matchStart)\n          .replace(/\\n/g, ' ')\n          .replace(/^ (.+) $/, '$1');\n      }\n      state.pos = matchEnd;\n      return true;\n    }\n  }\n\n  if (!silent) { state.pending += marker; }\n  state.pos += marker.length;\n  return true;\n};\n","// For each opening emphasis-like marker find a matching closing one\n//\n'use strict';\n\n\nfunction processDelimiters(state, delimiters) {\n  var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx,\n      isOddMatch, lastJump,\n      openersBottom = {},\n      max = delimiters.length;\n\n  for (closerIdx = 0; closerIdx < max; closerIdx++) {\n    closer = delimiters[closerIdx];\n\n    // Length is only used for emphasis-specific \"rule of 3\",\n    // if it's not defined (in strikethrough or 3rd party plugins),\n    // we can default it to 0 to disable those checks.\n    //\n    closer.length = closer.length || 0;\n\n    if (!closer.close) continue;\n\n    // Previously calculated lower bounds (previous fails)\n    // for each marker and each delimiter length modulo 3.\n    if (!openersBottom.hasOwnProperty(closer.marker)) {\n      openersBottom[closer.marker] = [ -1, -1, -1 ];\n    }\n\n    minOpenerIdx = openersBottom[closer.marker][closer.length % 3];\n    newMinOpenerIdx = -1;\n\n    openerIdx = closerIdx - closer.jump - 1;\n\n    for (; openerIdx > minOpenerIdx; openerIdx -= opener.jump + 1) {\n      opener = delimiters[openerIdx];\n\n      if (opener.marker !== closer.marker) continue;\n\n      if (newMinOpenerIdx === -1) newMinOpenerIdx = openerIdx;\n\n      if (opener.open && opener.end < 0) {\n\n        isOddMatch = false;\n\n        // from spec:\n        //\n        // If one of the delimiters can both open and close emphasis, then the\n        // sum of the lengths of the delimiter runs containing the opening and\n        // closing delimiters must not be a multiple of 3 unless both lengths\n        // are multiples of 3.\n        //\n        if (opener.close || closer.open) {\n          if ((opener.length + closer.length) % 3 === 0) {\n            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n              isOddMatch = true;\n            }\n          }\n        }\n\n        if (!isOddMatch) {\n          // If previous delimiter cannot be an opener, we can safely skip\n          // the entire sequence in future checks. This is required to make\n          // sure algorithm has linear complexity (see *_*_*_*_*_... case).\n          //\n          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ?\n            delimiters[openerIdx - 1].jump + 1 :\n            0;\n\n          closer.jump  = closerIdx - openerIdx + lastJump;\n          closer.open  = false;\n          opener.end   = closerIdx;\n          opener.jump  = lastJump;\n          opener.close = false;\n          newMinOpenerIdx = -1;\n          break;\n        }\n      }\n    }\n\n    if (newMinOpenerIdx !== -1) {\n      // If match for this delimiter run failed, we want to set lower bound for\n      // future lookups. This is required to make sure algorithm has linear\n      // complexity.\n      //\n      // See details here:\n      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442\n      //\n      openersBottom[closer.marker][(closer.length || 0) % 3] = newMinOpenerIdx;\n    }\n  }\n}\n\n\nmodule.exports = function link_pairs(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n\n  processDelimiters(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      processDelimiters(state, tokens_meta[curr].delimiters);\n    }\n  }\n};\n","// Process *this* and _that_\n//\n'use strict';\n\n\n// Insert each marker as a separate text token, and add it to delimiter list\n//\nmodule.exports.tokenize = function emphasis(state, silent) {\n  var i, scanned, token,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (silent) { return false; }\n\n  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) { return false; }\n\n  scanned = state.scanDelims(state.pos, marker === 0x2A);\n\n  for (i = 0; i < scanned.length; i++) {\n    token         = state.push('text', '', 0);\n    token.content = String.fromCharCode(marker);\n\n    state.delimiters.push({\n      // Char code of the starting marker (number).\n      //\n      marker: marker,\n\n      // Total length of these series of delimiters.\n      //\n      length: scanned.length,\n\n      // An amount of characters before this one that's equivalent to\n      // current one. In plain English: if this delimiter does not open\n      // an emphasis, neither do previous `jump` characters.\n      //\n      // Used to skip sequences like \"*****\" in one step, for 1st asterisk\n      // value will be 0, for 2nd it's 1 and so on.\n      //\n      jump:   i,\n\n      // A position of the token this delimiter corresponds to.\n      //\n      token:  state.tokens.length - 1,\n\n      // If this delimiter is matched as a valid opener, `end` will be\n      // equal to its position, otherwise it's `-1`.\n      //\n      end:    -1,\n\n      // Boolean flags that determine if this delimiter could open or close\n      // an emphasis.\n      //\n      open:   scanned.can_open,\n      close:  scanned.can_close\n    });\n  }\n\n  state.pos += scanned.length;\n\n  return true;\n};\n\n\nfunction postProcess(state, delimiters) {\n  var i,\n      startDelim,\n      endDelim,\n      token,\n      ch,\n      isStrong,\n      max = delimiters.length;\n\n  for (i = max - 1; i >= 0; i--) {\n    startDelim = delimiters[i];\n\n    if (startDelim.marker !== 0x5F/* _ */ && startDelim.marker !== 0x2A/* * */) {\n      continue;\n    }\n\n    // Process only opening markers\n    if (startDelim.end === -1) {\n      continue;\n    }\n\n    endDelim = delimiters[startDelim.end];\n\n    // If the previous delimiter has the same marker and is adjacent to this one,\n    // merge those into one strong delimiter.\n    //\n    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`\n    //\n    isStrong = i > 0 &&\n               delimiters[i - 1].end === startDelim.end + 1 &&\n               delimiters[i - 1].token === startDelim.token - 1 &&\n               delimiters[startDelim.end + 1].token === endDelim.token + 1 &&\n               delimiters[i - 1].marker === startDelim.marker;\n\n    ch = String.fromCharCode(startDelim.marker);\n\n    token         = state.tokens[startDelim.token];\n    token.type    = isStrong ? 'strong_open' : 'em_open';\n    token.tag     = isStrong ? 'strong' : 'em';\n    token.nesting = 1;\n    token.markup  = isStrong ? ch + ch : ch;\n    token.content = '';\n\n    token         = state.tokens[endDelim.token];\n    token.type    = isStrong ? 'strong_close' : 'em_close';\n    token.tag     = isStrong ? 'strong' : 'em';\n    token.nesting = -1;\n    token.markup  = isStrong ? ch + ch : ch;\n    token.content = '';\n\n    if (isStrong) {\n      state.tokens[delimiters[i - 1].token].content = '';\n      state.tokens[delimiters[startDelim.end + 1].token].content = '';\n      i--;\n    }\n  }\n}\n\n\n// Walk through delimiter list and replace text tokens with tags\n//\nmodule.exports.postProcess = function emphasis(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n\n  postProcess(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      postProcess(state, tokens_meta[curr].delimiters);\n    }\n  }\n};\n","// Process html entity - &#123;, &#xAF;, &quot;, ...\n\n'use strict';\n\nvar entities          = require('../common/entities');\nvar has               = require('../common/utils').has;\nvar isValidEntityCode = require('../common/utils').isValidEntityCode;\nvar fromCodePoint     = require('../common/utils').fromCodePoint;\n\n\nvar DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;\nvar NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;\n\n\nmodule.exports = function entity(state, silent) {\n  var ch, code, match, pos = state.pos, max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }\n\n  if (pos + 1 < max) {\n    ch = state.src.charCodeAt(pos + 1);\n\n    if (ch === 0x23 /* # */) {\n      match = state.src.slice(pos).match(DIGITAL_RE);\n      if (match) {\n        if (!silent) {\n          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);\n          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);\n        }\n        state.pos += match[0].length;\n        return true;\n      }\n    } else {\n      match = state.src.slice(pos).match(NAMED_RE);\n      if (match) {\n        if (has(entities, match[1])) {\n          if (!silent) { state.pending += entities[match[1]]; }\n          state.pos += match[0].length;\n          return true;\n        }\n      }\n    }\n  }\n\n  if (!silent) { state.pending += '&'; }\n  state.pos++;\n  return true;\n};\n","// Process escaped chars and hardbreaks\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\nvar ESCAPED = [];\n\nfor (var i = 0; i < 256; i++) { ESCAPED.push(0); }\n\n'\\\\!\"#$%&\\'()*+,./:;<=>?@[]^_`{|}~-'\n  .split('').forEach(function (ch) { ESCAPED[ch.charCodeAt(0)] = 1; });\n\n\nmodule.exports = function escape(state, silent) {\n  var ch, pos = state.pos, max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x5C/* \\ */) { return false; }\n\n  pos++;\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (ch < 256 && ESCAPED[ch] !== 0) {\n      if (!silent) { state.pending += state.src[pos]; }\n      state.pos += 2;\n      return true;\n    }\n\n    if (ch === 0x0A) {\n      if (!silent) {\n        state.push('hardbreak', 'br', 0);\n      }\n\n      pos++;\n      // skip leading whitespaces from next line\n      while (pos < max) {\n        ch = state.src.charCodeAt(pos);\n        if (!isSpace(ch)) { break; }\n        pos++;\n      }\n\n      state.pos = pos;\n      return true;\n    }\n  }\n\n  if (!silent) { state.pending += '\\\\'; }\n  state.pos++;\n  return true;\n};\n","// Process html tags\n\n'use strict';\n\n\nvar HTML_TAG_RE = require('../common/html_re').HTML_TAG_RE;\n\n\nfunction isLetter(ch) {\n  /*eslint no-bitwise:0*/\n  var lc = ch | 0x20; // to lower case\n  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);\n}\n\n\nmodule.exports = function html_inline(state, silent) {\n  var ch, match, max, token,\n      pos = state.pos;\n\n  if (!state.md.options.html) { return false; }\n\n  // Check start\n  max = state.posMax;\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||\n      pos + 2 >= max) {\n    return false;\n  }\n\n  // Quick fail on second char\n  ch = state.src.charCodeAt(pos + 1);\n  if (ch !== 0x21/* ! */ &&\n      ch !== 0x3F/* ? */ &&\n      ch !== 0x2F/* / */ &&\n      !isLetter(ch)) {\n    return false;\n  }\n\n  match = state.src.slice(pos).match(HTML_TAG_RE);\n  if (!match) { return false; }\n\n  if (!silent) {\n    token         = state.push('html_inline', '', 0);\n    token.content = state.src.slice(pos, pos + match[0].length);\n  }\n  state.pos += match[0].length;\n  return true;\n};\n","// Process ![image](<src> \"title\")\n\n'use strict';\n\nvar normalizeReference   = require('../common/utils').normalizeReference;\nvar isSpace              = require('../common/utils').isSpace;\n\n\nmodule.exports = function image(state, silent) {\n  var attrs,\n      code,\n      content,\n      label,\n      labelEnd,\n      labelStart,\n      pos,\n      ref,\n      res,\n      title,\n      token,\n      tokens,\n      start,\n      href = '',\n      oldPos = state.pos,\n      max = state.posMax;\n\n  if (state.src.charCodeAt(state.pos) !== 0x21/* ! */) { return false; }\n  if (state.src.charCodeAt(state.pos + 1) !== 0x5B/* [ */) { return false; }\n\n  labelStart = state.pos + 2;\n  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false; }\n\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n    if (pos >= max) { return false; }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n      if (state.md.validateLink(href)) {\n        pos = res.pos;\n      } else {\n        href = '';\n      }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (!isSpace(code) && code !== 0x0A) { break; }\n      }\n    } else {\n      title = '';\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      state.pos = oldPos;\n      return false;\n    }\n    pos++;\n  } else {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') { return false; }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1;\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = labelEnd + 1;\n      }\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) { label = state.src.slice(labelStart, labelEnd); }\n\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    content = state.src.slice(labelStart, labelEnd);\n\n    state.md.inline.parse(\n      content,\n      state.md,\n      state.env,\n      tokens = []\n    );\n\n    token          = state.push('image', 'img', 0);\n    token.attrs    = attrs = [ [ 'src', href ], [ 'alt', '' ] ];\n    token.children = tokens;\n    token.content  = content;\n\n    if (title) {\n      attrs.push([ 'title', title ]);\n    }\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n};\n","// Process [link](<to> \"stuff\")\n\n'use strict';\n\nvar normalizeReference   = require('../common/utils').normalizeReference;\nvar isSpace              = require('../common/utils').isSpace;\n\n\nmodule.exports = function link(state, silent) {\n  var attrs,\n      code,\n      label,\n      labelEnd,\n      labelStart,\n      pos,\n      res,\n      ref,\n      title,\n      token,\n      href = '',\n      oldPos = state.pos,\n      max = state.posMax,\n      start = state.pos,\n      parseReference = true;\n\n  if (state.src.charCodeAt(state.pos) !== 0x5B/* [ */) { return false; }\n\n  labelStart = state.pos + 1;\n  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false; }\n\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // might have found a valid shortcut link, disable reference parsing\n    parseReference = false;\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n    if (pos >= max) { return false; }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n      if (state.md.validateLink(href)) {\n        pos = res.pos;\n      } else {\n        href = '';\n      }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (!isSpace(code) && code !== 0x0A) { break; }\n      }\n    } else {\n      title = '';\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      // parsing a valid shortcut link failed, fallback to reference\n      parseReference = true;\n    }\n    pos++;\n  }\n\n  if (parseReference) {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') { return false; }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1;\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = labelEnd + 1;\n      }\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) { label = state.src.slice(labelStart, labelEnd); }\n\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n\n    token        = state.push('link_open', 'a', 1);\n    token.attrs  = attrs = [ [ 'href', href ] ];\n    if (title) {\n      attrs.push([ 'title', title ]);\n    }\n\n    state.md.inline.tokenize(state);\n\n    token        = state.push('link_close', 'a', -1);\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n};\n","// Proceess '\\n'\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\n\nmodule.exports = function newline(state, silent) {\n  var pmax, max, pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x0A/* \\n */) { return false; }\n\n  pmax = state.pending.length - 1;\n  max = state.posMax;\n\n  // '  \\n' -> hardbreak\n  // Lookup in pending chars is bad practice! Don't copy to other rules!\n  // Pending string is stored in concat mode, indexed lookups will cause\n  // convertion to flat mode.\n  if (!silent) {\n    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {\n      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {\n        state.pending = state.pending.replace(/ +$/, '');\n        state.push('hardbreak', 'br', 0);\n      } else {\n        state.pending = state.pending.slice(0, -1);\n        state.push('softbreak', 'br', 0);\n      }\n\n    } else {\n      state.push('softbreak', 'br', 0);\n    }\n  }\n\n  pos++;\n\n  // skip heading spaces for next line\n  while (pos < max && isSpace(state.src.charCodeAt(pos))) { pos++; }\n\n  state.pos = pos;\n  return true;\n};\n","// Inline parser state\n\n'use strict';\n\n\nvar Token          = require('../token');\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\nvar isPunctChar    = require('../common/utils').isPunctChar;\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\n\nfunction StateInline(src, md, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.md = md;\n  this.tokens = outTokens;\n  this.tokens_meta = Array(outTokens.length);\n\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n\n  // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n  this.cache = {};\n\n  // List of emphasis-like delimiters for current tag\n  this.delimiters = [];\n\n  // Stack of delimiter lists for upper level tags\n  this._prev_delimiters = [];\n}\n\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  var token = new Token('text', '', 0);\n  token.content = this.pending;\n  token.level = this.pendingLevel;\n  this.tokens.push(token);\n  this.pending = '';\n  return token;\n};\n\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  var token = new Token(type, tag, nesting);\n  var token_meta = null;\n\n  if (nesting < 0) {\n    // closing tag\n    this.level--;\n    this.delimiters = this._prev_delimiters.pop();\n  }\n\n  token.level = this.level;\n\n  if (nesting > 0) {\n    // opening tag\n    this.level++;\n    this._prev_delimiters.push(this.delimiters);\n    this.delimiters = [];\n    token_meta = { delimiters: this.delimiters };\n  }\n\n  this.pendingLevel = this.level;\n  this.tokens.push(token);\n  this.tokens_meta.push(token_meta);\n  return token;\n};\n\n\n// Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  var pos = start, lastChar, nextChar, count, can_open, can_close,\n      isLastWhiteSpace, isLastPunctChar,\n      isNextWhiteSpace, isNextPunctChar,\n      left_flanking = true,\n      right_flanking = true,\n      max = this.posMax,\n      marker = this.src.charCodeAt(start);\n\n  // treat beginning of the line as a whitespace\n  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;\n\n  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++; }\n\n  count = pos - start;\n\n  // treat end of the line as a whitespace\n  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;\n\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n  isLastWhiteSpace = isWhiteSpace(lastChar);\n  isNextWhiteSpace = isWhiteSpace(nextChar);\n\n  if (isNextWhiteSpace) {\n    left_flanking = false;\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      left_flanking = false;\n    }\n  }\n\n  if (isLastWhiteSpace) {\n    right_flanking = false;\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      right_flanking = false;\n    }\n  }\n\n  if (!canSplitWord) {\n    can_open  = left_flanking  && (!right_flanking || isLastPunctChar);\n    can_close = right_flanking && (!left_flanking  || isNextPunctChar);\n  } else {\n    can_open  = left_flanking;\n    can_close = right_flanking;\n  }\n\n  return {\n    can_open:  can_open,\n    can_close: can_close,\n    length:    count\n  };\n};\n\n\n// re-export Token class to use in block rules\nStateInline.prototype.Token = Token;\n\n\nmodule.exports = StateInline;\n","// ~~strike through~~\n//\n'use strict';\n\n\n// Insert each marker as a separate text token, and add it to delimiter list\n//\nmodule.exports.tokenize = function strikethrough(state, silent) {\n  var i, scanned, token, len, ch,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (silent) { return false; }\n\n  if (marker !== 0x7E/* ~ */) { return false; }\n\n  scanned = state.scanDelims(state.pos, true);\n  len = scanned.length;\n  ch = String.fromCharCode(marker);\n\n  if (len < 2) { return false; }\n\n  if (len % 2) {\n    token         = state.push('text', '', 0);\n    token.content = ch;\n    len--;\n  }\n\n  for (i = 0; i < len; i += 2) {\n    token         = state.push('text', '', 0);\n    token.content = ch + ch;\n\n    state.delimiters.push({\n      marker: marker,\n      length: 0, // disable \"rule of 3\" length checks meant for emphasis\n      jump:   i,\n      token:  state.tokens.length - 1,\n      end:    -1,\n      open:   scanned.can_open,\n      close:  scanned.can_close\n    });\n  }\n\n  state.pos += scanned.length;\n\n  return true;\n};\n\n\nfunction postProcess(state, delimiters) {\n  var i, j,\n      startDelim,\n      endDelim,\n      token,\n      loneMarkers = [],\n      max = delimiters.length;\n\n  for (i = 0; i < max; i++) {\n    startDelim = delimiters[i];\n\n    if (startDelim.marker !== 0x7E/* ~ */) {\n      continue;\n    }\n\n    if (startDelim.end === -1) {\n      continue;\n    }\n\n    endDelim = delimiters[startDelim.end];\n\n    token         = state.tokens[startDelim.token];\n    token.type    = 's_open';\n    token.tag     = 's';\n    token.nesting = 1;\n    token.markup  = '~~';\n    token.content = '';\n\n    token         = state.tokens[endDelim.token];\n    token.type    = 's_close';\n    token.tag     = 's';\n    token.nesting = -1;\n    token.markup  = '~~';\n    token.content = '';\n\n    if (state.tokens[endDelim.token - 1].type === 'text' &&\n        state.tokens[endDelim.token - 1].content === '~') {\n\n      loneMarkers.push(endDelim.token - 1);\n    }\n  }\n\n  // If a marker sequence has an odd number of characters, it's splitted\n  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n  // start of the sequence.\n  //\n  // So, we have to move all those markers after subsequent s_close tags.\n  //\n  while (loneMarkers.length) {\n    i = loneMarkers.pop();\n    j = i + 1;\n\n    while (j < state.tokens.length && state.tokens[j].type === 's_close') {\n      j++;\n    }\n\n    j--;\n\n    if (i !== j) {\n      token = state.tokens[j];\n      state.tokens[j] = state.tokens[i];\n      state.tokens[i] = token;\n    }\n  }\n}\n\n\n// Walk through delimiter list and replace text tokens with tags\n//\nmodule.exports.postProcess = function strikethrough(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n\n  postProcess(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      postProcess(state, tokens_meta[curr].delimiters);\n    }\n  }\n};\n","// Skip text characters for text token, place those to pending buffer\n// and increment current pos\n\n'use strict';\n\n\n// Rule to skip pure text\n// '{}$%@~+=:' reserved for extentions\n\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n\n// !!!! Don't confuse with \"Markdown ASCII Punctuation\" chars\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\nfunction isTerminatorChar(ch) {\n  switch (ch) {\n    case 0x0A/* \\n */:\n    case 0x21/* ! */:\n    case 0x23/* # */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x26/* & */:\n    case 0x2A/* * */:\n    case 0x2B/* + */:\n    case 0x2D/* - */:\n    case 0x3A/* : */:\n    case 0x3C/* < */:\n    case 0x3D/* = */:\n    case 0x3E/* > */:\n    case 0x40/* @ */:\n    case 0x5B/* [ */:\n    case 0x5C/* \\ */:\n    case 0x5D/* ] */:\n    case 0x5E/* ^ */:\n    case 0x5F/* _ */:\n    case 0x60/* ` */:\n    case 0x7B/* { */:\n    case 0x7D/* } */:\n    case 0x7E/* ~ */:\n      return true;\n    default:\n      return false;\n  }\n}\n\nmodule.exports = function text(state, silent) {\n  var pos = state.pos;\n\n  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n    pos++;\n  }\n\n  if (pos === state.pos) { return false; }\n\n  if (!silent) { state.pending += state.src.slice(state.pos, pos); }\n\n  state.pos = pos;\n\n  return true;\n};\n\n// Alternative implementation, for memory.\n//\n// It costs 10% of performance, but allows extend terminators list, if place it\n// to `ParcerInline` property. Probably, will switch to it sometime, such\n// flexibility required.\n\n/*\nvar TERMINATOR_RE = /[\\n!#$%&*+\\-:<=>@[\\\\\\]^_`{}~]/;\n\nmodule.exports = function text(state, silent) {\n  var pos = state.pos,\n      idx = state.src.slice(pos).search(TERMINATOR_RE);\n\n  // first char is terminator -> empty text\n  if (idx === 0) { return false; }\n\n  // no terminator -> text till end of string\n  if (idx < 0) {\n    if (!silent) { state.pending += state.src.slice(pos); }\n    state.pos = state.src.length;\n    return true;\n  }\n\n  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }\n\n  state.pos += idx;\n\n  return true;\n};*/\n","// Clean up tokens after emphasis and strikethrough postprocessing:\n// merge adjacent text nodes into one and re-calculate all token levels\n//\n// This is necessary because initially emphasis delimiter markers (*, _, ~)\n// are treated as their own separate text tokens. Then emphasis rule either\n// leaves them as text (needed to merge with adjacent text) or turns them\n// into opening/closing tags (which messes up levels inside).\n//\n'use strict';\n\n\nmodule.exports = function text_collapse(state) {\n  var curr, last,\n      level = 0,\n      tokens = state.tokens,\n      max = state.tokens.length;\n\n  for (curr = last = 0; curr < max; curr++) {\n    // re-calculate levels after emphasis/strikethrough turns some text nodes\n    // into opening/closing tags\n    if (tokens[curr].nesting < 0) level--; // closing tag\n    tokens[curr].level = level;\n    if (tokens[curr].nesting > 0) level++; // opening tag\n\n    if (tokens[curr].type === 'text' &&\n        curr + 1 < max &&\n        tokens[curr + 1].type === 'text') {\n\n      // collapse two adjacent text nodes\n      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;\n    } else {\n      if (curr !== last) { tokens[last] = tokens[curr]; }\n\n      last++;\n    }\n  }\n\n  if (curr !== last) {\n    tokens.length = last;\n  }\n};\n","// Token class\n\n'use strict';\n\n\n/**\n * class Token\n **/\n\n/**\n * new Token(type, tag, nesting)\n *\n * Create new token and fill passed properties.\n **/\nfunction Token(type, tag, nesting) {\n  /**\n   * Token#type -> String\n   *\n   * Type of the token (string, e.g. \"paragraph_open\")\n   **/\n  this.type     = type;\n\n  /**\n   * Token#tag -> String\n   *\n   * html tag name, e.g. \"p\"\n   **/\n  this.tag      = tag;\n\n  /**\n   * Token#attrs -> Array\n   *\n   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`\n   **/\n  this.attrs    = null;\n\n  /**\n   * Token#map -> Array\n   *\n   * Source map info. Format: `[ line_begin, line_end ]`\n   **/\n  this.map      = null;\n\n  /**\n   * Token#nesting -> Number\n   *\n   * Level change (number in {-1, 0, 1} set), where:\n   *\n   * -  `1` means the tag is opening\n   * -  `0` means the tag is self-closing\n   * - `-1` means the tag is closing\n   **/\n  this.nesting  = nesting;\n\n  /**\n   * Token#level -> Number\n   *\n   * nesting level, the same as `state.level`\n   **/\n  this.level    = 0;\n\n  /**\n   * Token#children -> Array\n   *\n   * An array of child nodes (inline and img tokens)\n   **/\n  this.children = null;\n\n  /**\n   * Token#content -> String\n   *\n   * In a case of self-closing tag (code, html, fence, etc.),\n   * it has contents of this tag.\n   **/\n  this.content  = '';\n\n  /**\n   * Token#markup -> String\n   *\n   * '*' or '_' for emphasis, fence string for fence, etc.\n   **/\n  this.markup   = '';\n\n  /**\n   * Token#info -> String\n   *\n   * fence infostring\n   **/\n  this.info     = '';\n\n  /**\n   * Token#meta -> Object\n   *\n   * A place for plugins to store an arbitrary data\n   **/\n  this.meta     = null;\n\n  /**\n   * Token#block -> Boolean\n   *\n   * True for block-level tokens, false for inline tokens.\n   * Used in renderer to calculate line breaks\n   **/\n  this.block    = false;\n\n  /**\n   * Token#hidden -> Boolean\n   *\n   * If it's true, ignore this element when rendering. Used for tight lists\n   * to hide paragraphs.\n   **/\n  this.hidden   = false;\n}\n\n\n/**\n * Token.attrIndex(name) -> Number\n *\n * Search attribute index by name.\n **/\nToken.prototype.attrIndex = function attrIndex(name) {\n  var attrs, i, len;\n\n  if (!this.attrs) { return -1; }\n\n  attrs = this.attrs;\n\n  for (i = 0, len = attrs.length; i < len; i++) {\n    if (attrs[i][0] === name) { return i; }\n  }\n  return -1;\n};\n\n\n/**\n * Token.attrPush(attrData)\n *\n * Add `[ name, value ]` attribute to list. Init attrs if necessary\n **/\nToken.prototype.attrPush = function attrPush(attrData) {\n  if (this.attrs) {\n    this.attrs.push(attrData);\n  } else {\n    this.attrs = [ attrData ];\n  }\n};\n\n\n/**\n * Token.attrSet(name, value)\n *\n * Set `name` attribute to `value`. Override old value if exists.\n **/\nToken.prototype.attrSet = function attrSet(name, value) {\n  var idx = this.attrIndex(name),\n      attrData = [ name, value ];\n\n  if (idx < 0) {\n    this.attrPush(attrData);\n  } else {\n    this.attrs[idx] = attrData;\n  }\n};\n\n\n/**\n * Token.attrGet(name)\n *\n * Get the value of attribute `name`, or null if it does not exist.\n **/\nToken.prototype.attrGet = function attrGet(name) {\n  var idx = this.attrIndex(name), value = null;\n  if (idx >= 0) {\n    value = this.attrs[idx][1];\n  }\n  return value;\n};\n\n\n/**\n * Token.attrJoin(name, value)\n *\n * Join value to existing attribute via space. Or create new attribute if not\n * exists. Useful to operate with token classes.\n **/\nToken.prototype.attrJoin = function attrJoin(name, value) {\n  var idx = this.attrIndex(name);\n\n  if (idx < 0) {\n    this.attrPush([ name, value ]);\n  } else {\n    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;\n  }\n};\n\n\nmodule.exports = Token;\n","\n'use strict';\n\n\n/* eslint-disable no-bitwise */\n\nvar decodeCache = {};\n\nfunction getDecodeCache(exclude) {\n  var i, ch, cache = decodeCache[exclude];\n  if (cache) { return cache; }\n\n  cache = decodeCache[exclude] = [];\n\n  for (i = 0; i < 128; i++) {\n    ch = String.fromCharCode(i);\n    cache.push(ch);\n  }\n\n  for (i = 0; i < exclude.length; i++) {\n    ch = exclude.charCodeAt(i);\n    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);\n  }\n\n  return cache;\n}\n\n\n// Decode percent-encoded string.\n//\nfunction decode(string, exclude) {\n  var cache;\n\n  if (typeof exclude !== 'string') {\n    exclude = decode.defaultChars;\n  }\n\n  cache = getDecodeCache(exclude);\n\n  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {\n    var i, l, b1, b2, b3, b4, chr,\n        result = '';\n\n    for (i = 0, l = seq.length; i < l; i += 3) {\n      b1 = parseInt(seq.slice(i + 1, i + 3), 16);\n\n      if (b1 < 0x80) {\n        result += cache[b1];\n        continue;\n      }\n\n      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {\n        // 110xxxxx 10xxxxxx\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n\n        if ((b2 & 0xC0) === 0x80) {\n          chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);\n\n          if (chr < 0x80) {\n            result += '\\ufffd\\ufffd';\n          } else {\n            result += String.fromCharCode(chr);\n          }\n\n          i += 3;\n          continue;\n        }\n      }\n\n      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {\n        // 1110xxxx 10xxxxxx 10xxxxxx\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n          chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);\n\n          if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {\n            result += '\\ufffd\\ufffd\\ufffd';\n          } else {\n            result += String.fromCharCode(chr);\n          }\n\n          i += 6;\n          continue;\n        }\n      }\n\n      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {\n        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n        b4 = parseInt(seq.slice(i + 10, i + 12), 16);\n\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {\n          chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);\n\n          if (chr < 0x10000 || chr > 0x10FFFF) {\n            result += '\\ufffd\\ufffd\\ufffd\\ufffd';\n          } else {\n            chr -= 0x10000;\n            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));\n          }\n\n          i += 9;\n          continue;\n        }\n      }\n\n      result += '\\ufffd';\n    }\n\n    return result;\n  });\n}\n\n\ndecode.defaultChars   = ';/?:@&=+$,#';\ndecode.componentChars = '';\n\n\nmodule.exports = decode;\n","\n'use strict';\n\n\nvar encodeCache = {};\n\n\n// Create a lookup array where anything but characters in `chars` string\n// and alphanumeric chars is percent-encoded.\n//\nfunction getEncodeCache(exclude) {\n  var i, ch, cache = encodeCache[exclude];\n  if (cache) { return cache; }\n\n  cache = encodeCache[exclude] = [];\n\n  for (i = 0; i < 128; i++) {\n    ch = String.fromCharCode(i);\n\n    if (/^[0-9a-z]$/i.test(ch)) {\n      // always allow unencoded alphanumeric characters\n      cache.push(ch);\n    } else {\n      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));\n    }\n  }\n\n  for (i = 0; i < exclude.length; i++) {\n    cache[exclude.charCodeAt(i)] = exclude[i];\n  }\n\n  return cache;\n}\n\n\n// Encode unsafe characters with percent-encoding, skipping already\n// encoded sequences.\n//\n//  - string       - string to encode\n//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\n//\nfunction encode(string, exclude, keepEscaped) {\n  var i, l, code, nextCode, cache,\n      result = '';\n\n  if (typeof exclude !== 'string') {\n    // encode(string, keepEscaped)\n    keepEscaped  = exclude;\n    exclude = encode.defaultChars;\n  }\n\n  if (typeof keepEscaped === 'undefined') {\n    keepEscaped = true;\n  }\n\n  cache = getEncodeCache(exclude);\n\n  for (i = 0, l = string.length; i < l; i++) {\n    code = string.charCodeAt(i);\n\n    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {\n      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n        result += string.slice(i, i + 3);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (code < 128) {\n      result += cache[code];\n      continue;\n    }\n\n    if (code >= 0xD800 && code <= 0xDFFF) {\n      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\n        nextCode = string.charCodeAt(i + 1);\n        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\n          result += encodeURIComponent(string[i] + string[i + 1]);\n          i++;\n          continue;\n        }\n      }\n      result += '%EF%BF%BD';\n      continue;\n    }\n\n    result += encodeURIComponent(string[i]);\n  }\n\n  return result;\n}\n\nencode.defaultChars   = \";/?:@&=+$,-_.!~*'()#\";\nencode.componentChars = \"-_.!~*'()\";\n\n\nmodule.exports = encode;\n","\n'use strict';\n\n\nmodule.exports = function format(url) {\n  var result = '';\n\n  result += url.protocol || '';\n  result += url.slashes ? '//' : '';\n  result += url.auth ? url.auth + '@' : '';\n\n  if (url.hostname && url.hostname.indexOf(':') !== -1) {\n    // ipv6 address\n    result += '[' + url.hostname + ']';\n  } else {\n    result += url.hostname || '';\n  }\n\n  result += url.port ? ':' + url.port : '';\n  result += url.pathname || '';\n  result += url.search || '';\n  result += url.hash || '';\n\n  return result;\n};\n","'use strict';\n\n\nmodule.exports.encode = require('./encode');\nmodule.exports.decode = require('./decode');\nmodule.exports.format = require('./format');\nmodule.exports.parse  = require('./parse');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n//\n// Changes from joyent/node:\n//\n// 1. No leading slash in paths,\n//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`\n//\n// 2. Backslashes are not replaced with slashes,\n//    so `http:\\\\example.org\\` is treated like a relative path\n//\n// 3. Trailing colon is treated like a part of the path,\n//    i.e. in `http://example.org:foo` pathname is `:foo`\n//\n// 4. Nothing is URL-encoded in the resulting object,\n//    (in joyent/node some chars in auth and paths are encoded)\n//\n// 5. `url.parse()` does not have `parseQueryString` argument\n//\n// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,\n//    which can be constructed using other parts of the url.\n//\n\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.pathname = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = [ '<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t' ],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = [ '{', '}', '|', '\\\\', '^', '`' ].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = [ '\\'' ].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = [ '%', '/', '?', ';', '#' ].concat(autoEscape),\n    hostEndingChars = [ '/', '?', '#' ],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    /* eslint-disable no-script-url */\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    };\n    /* eslint-enable no-script-url */\n\nfunction urlParse(url, slashesDenoteHost) {\n  if (url && url instanceof Url) { return url; }\n\n  var u = new Url();\n  u.parse(url, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, slashesDenoteHost) {\n  var i, l, lowerProto, hec, slashes,\n      rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    lowerProto = proto.toLowerCase();\n    this.protocol = proto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (i = 0; i < hostEndingChars.length; i++) {\n      hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = auth;\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (i = 0; i < nonHostChars.length; i++) {\n      hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1) {\n      hostEnd = rest.length;\n    }\n\n    if (rest[hostEnd - 1] === ':') { hostEnd--; }\n    var host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost(host);\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) { continue; }\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    }\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n    }\n  }\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    rest = rest.slice(0, qm);\n  }\n  if (rest) { this.pathname = rest; }\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '';\n  }\n\n  return this;\n};\n\nUrl.prototype.parseHost = function(host) {\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) { this.hostname = host; }\n};\n\nmodule.exports = urlParse;\n","/*global define:false */\n/**\n * Copyright 2012-2017 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.5\n * @url craig.is/killing/mice\n */\n(function(window, document, undefined) {\n\n    // Check if mousetrap is used inside browser, if not, return\n    if (!window) {\n        return;\n    }\n\n    /**\n     * mapping of special keycodes to their corresponding keys\n     *\n     * everything in this dictionary cannot use keypress events\n     * so it has to be here to map to the correct keycodes for\n     * keyup/keydown events\n     *\n     * @type {Object}\n     */\n    var _MAP = {\n        8: 'backspace',\n        9: 'tab',\n        13: 'enter',\n        16: 'shift',\n        17: 'ctrl',\n        18: 'alt',\n        20: 'capslock',\n        27: 'esc',\n        32: 'space',\n        33: 'pageup',\n        34: 'pagedown',\n        35: 'end',\n        36: 'home',\n        37: 'left',\n        38: 'up',\n        39: 'right',\n        40: 'down',\n        45: 'ins',\n        46: 'del',\n        91: 'meta',\n        93: 'meta',\n        224: 'meta'\n    };\n\n    /**\n     * mapping for special characters so they can support\n     *\n     * this dictionary is only used incase you want to bind a\n     * keyup or keydown event to one of these keys\n     *\n     * @type {Object}\n     */\n    var _KEYCODE_MAP = {\n        106: '*',\n        107: '+',\n        109: '-',\n        110: '.',\n        111 : '/',\n        186: ';',\n        187: '=',\n        188: ',',\n        189: '-',\n        190: '.',\n        191: '/',\n        192: '`',\n        219: '[',\n        220: '\\\\',\n        221: ']',\n        222: '\\''\n    };\n\n    /**\n     * this is a mapping of keys that require shift on a US keypad\n     * back to the non shift equivelents\n     *\n     * this is so you can use keyup events with these keys\n     *\n     * note that this will only work reliably on US keyboards\n     *\n     * @type {Object}\n     */\n    var _SHIFT_MAP = {\n        '~': '`',\n        '!': '1',\n        '@': '2',\n        '#': '3',\n        '$': '4',\n        '%': '5',\n        '^': '6',\n        '&': '7',\n        '*': '8',\n        '(': '9',\n        ')': '0',\n        '_': '-',\n        '+': '=',\n        ':': ';',\n        '\\\"': '\\'',\n        '<': ',',\n        '>': '.',\n        '?': '/',\n        '|': '\\\\'\n    };\n\n    /**\n     * this is a list of special strings you can use to map\n     * to modifier keys when you specify your keyboard shortcuts\n     *\n     * @type {Object}\n     */\n    var _SPECIAL_ALIASES = {\n        'option': 'alt',\n        'command': 'meta',\n        'return': 'enter',\n        'escape': 'esc',\n        'plus': '+',\n        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n    };\n\n    /**\n     * variable to store the flipped version of _MAP from above\n     * needed to check if we should use keypress or not when no action\n     * is specified\n     *\n     * @type {Object|undefined}\n     */\n    var _REVERSE_MAP;\n\n    /**\n     * loop through the f keys, f1 to f19 and add them to the map\n     * programatically\n     */\n    for (var i = 1; i < 20; ++i) {\n        _MAP[111 + i] = 'f' + i;\n    }\n\n    /**\n     * loop through to map numbers on the numeric keypad\n     */\n    for (i = 0; i <= 9; ++i) {\n\n        // This needs to use a string cause otherwise since 0 is falsey\n        // mousetrap will never fire for numpad 0 pressed as part of a keydown\n        // event.\n        //\n        // @see https://github.com/ccampbell/mousetrap/pull/258\n        _MAP[i + 96] = i.toString();\n    }\n\n    /**\n     * cross browser add event method\n     *\n     * @param {Element|HTMLDocument} object\n     * @param {string} type\n     * @param {Function} callback\n     * @returns void\n     */\n    function _addEvent(object, type, callback) {\n        if (object.addEventListener) {\n            object.addEventListener(type, callback, false);\n            return;\n        }\n\n        object.attachEvent('on' + type, callback);\n    }\n\n    /**\n     * takes the event and returns the key character\n     *\n     * @param {Event} e\n     * @return {string}\n     */\n    function _characterFromEvent(e) {\n\n        // for keypress events we should return the character as is\n        if (e.type == 'keypress') {\n            var character = String.fromCharCode(e.which);\n\n            // if the shift key is not pressed then it is safe to assume\n            // that we want the character to be lowercase.  this means if\n            // you accidentally have caps lock on then your key bindings\n            // will continue to work\n            //\n            // the only side effect that might not be desired is if you\n            // bind something like 'A' cause you want to trigger an\n            // event when capital A is pressed caps lock will no longer\n            // trigger the event.  shift+a will though.\n            if (!e.shiftKey) {\n                character = character.toLowerCase();\n            }\n\n            return character;\n        }\n\n        // for non keypress events the special maps are needed\n        if (_MAP[e.which]) {\n            return _MAP[e.which];\n        }\n\n        if (_KEYCODE_MAP[e.which]) {\n            return _KEYCODE_MAP[e.which];\n        }\n\n        // if it is not in the special map\n\n        // with keydown and keyup events the character seems to always\n        // come in as an uppercase character whether you are pressing shift\n        // or not.  we should make sure it is always lowercase for comparisons\n        return String.fromCharCode(e.which).toLowerCase();\n    }\n\n    /**\n     * checks if two arrays are equal\n     *\n     * @param {Array} modifiers1\n     * @param {Array} modifiers2\n     * @returns {boolean}\n     */\n    function _modifiersMatch(modifiers1, modifiers2) {\n        return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n    }\n\n    /**\n     * takes a key event and figures out what the modifiers are\n     *\n     * @param {Event} e\n     * @returns {Array}\n     */\n    function _eventModifiers(e) {\n        var modifiers = [];\n\n        if (e.shiftKey) {\n            modifiers.push('shift');\n        }\n\n        if (e.altKey) {\n            modifiers.push('alt');\n        }\n\n        if (e.ctrlKey) {\n            modifiers.push('ctrl');\n        }\n\n        if (e.metaKey) {\n            modifiers.push('meta');\n        }\n\n        return modifiers;\n    }\n\n    /**\n     * prevents default for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _preventDefault(e) {\n        if (e.preventDefault) {\n            e.preventDefault();\n            return;\n        }\n\n        e.returnValue = false;\n    }\n\n    /**\n     * stops propogation for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _stopPropagation(e) {\n        if (e.stopPropagation) {\n            e.stopPropagation();\n            return;\n        }\n\n        e.cancelBubble = true;\n    }\n\n    /**\n     * determines if the keycode specified is a modifier key or not\n     *\n     * @param {string} key\n     * @returns {boolean}\n     */\n    function _isModifier(key) {\n        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n    }\n\n    /**\n     * reverses the map lookup so that we can look for specific keys\n     * to see what can and can't use keypress\n     *\n     * @return {Object}\n     */\n    function _getReverseMap() {\n        if (!_REVERSE_MAP) {\n            _REVERSE_MAP = {};\n            for (var key in _MAP) {\n\n                // pull out the numeric keypad from here cause keypress should\n                // be able to detect the keys from the character\n                if (key > 95 && key < 112) {\n                    continue;\n                }\n\n                if (_MAP.hasOwnProperty(key)) {\n                    _REVERSE_MAP[_MAP[key]] = key;\n                }\n            }\n        }\n        return _REVERSE_MAP;\n    }\n\n    /**\n     * picks the best action based on the key combination\n     *\n     * @param {string} key - character for key\n     * @param {Array} modifiers\n     * @param {string=} action passed in\n     */\n    function _pickBestAction(key, modifiers, action) {\n\n        // if no action was picked in we should try to pick the one\n        // that we think would work best for this key\n        if (!action) {\n            action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n        }\n\n        // modifier keys don't work as expected with keypress,\n        // switch to keydown\n        if (action == 'keypress' && modifiers.length) {\n            action = 'keydown';\n        }\n\n        return action;\n    }\n\n    /**\n     * Converts from a string key combination to an array\n     *\n     * @param  {string} combination like \"command+shift+l\"\n     * @return {Array}\n     */\n    function _keysFromString(combination) {\n        if (combination === '+') {\n            return ['+'];\n        }\n\n        combination = combination.replace(/\\+{2}/g, '+plus');\n        return combination.split('+');\n    }\n\n    /**\n     * Gets info for a specific key combination\n     *\n     * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n     * @param  {string=} action\n     * @returns {Object}\n     */\n    function _getKeyInfo(combination, action) {\n        var keys;\n        var key;\n        var i;\n        var modifiers = [];\n\n        // take the keys from this pattern and figure out what the actual\n        // pattern is all about\n        keys = _keysFromString(combination);\n\n        for (i = 0; i < keys.length; ++i) {\n            key = keys[i];\n\n            // normalize key names\n            if (_SPECIAL_ALIASES[key]) {\n                key = _SPECIAL_ALIASES[key];\n            }\n\n            // if this is not a keypress event then we should\n            // be smart about using shift keys\n            // this will only work for US keyboards however\n            if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n                key = _SHIFT_MAP[key];\n                modifiers.push('shift');\n            }\n\n            // if this key is a modifier then add it to the list of modifiers\n            if (_isModifier(key)) {\n                modifiers.push(key);\n            }\n        }\n\n        // depending on what the key combination is\n        // we will try to pick the best event for it\n        action = _pickBestAction(key, modifiers, action);\n\n        return {\n            key: key,\n            modifiers: modifiers,\n            action: action\n        };\n    }\n\n    function _belongsTo(element, ancestor) {\n        if (element === null || element === document) {\n            return false;\n        }\n\n        if (element === ancestor) {\n            return true;\n        }\n\n        return _belongsTo(element.parentNode, ancestor);\n    }\n\n    function Mousetrap(targetElement) {\n        var self = this;\n\n        targetElement = targetElement || document;\n\n        if (!(self instanceof Mousetrap)) {\n            return new Mousetrap(targetElement);\n        }\n\n        /**\n         * element to attach key events to\n         *\n         * @type {Element}\n         */\n        self.target = targetElement;\n\n        /**\n         * a list of all the callbacks setup via Mousetrap.bind()\n         *\n         * @type {Object}\n         */\n        self._callbacks = {};\n\n        /**\n         * direct map of string combinations to callbacks used for trigger()\n         *\n         * @type {Object}\n         */\n        self._directMap = {};\n\n        /**\n         * keeps track of what level each sequence is at since multiple\n         * sequences can start out with the same sequence\n         *\n         * @type {Object}\n         */\n        var _sequenceLevels = {};\n\n        /**\n         * variable to store the setTimeout call\n         *\n         * @type {null|number}\n         */\n        var _resetTimer;\n\n        /**\n         * temporary state where we will ignore the next keyup\n         *\n         * @type {boolean|string}\n         */\n        var _ignoreNextKeyup = false;\n\n        /**\n         * temporary state where we will ignore the next keypress\n         *\n         * @type {boolean}\n         */\n        var _ignoreNextKeypress = false;\n\n        /**\n         * are we currently inside of a sequence?\n         * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n         *\n         * @type {boolean|string}\n         */\n        var _nextExpectedAction = false;\n\n        /**\n         * resets all sequence counters except for the ones passed in\n         *\n         * @param {Object} doNotReset\n         * @returns void\n         */\n        function _resetSequences(doNotReset) {\n            doNotReset = doNotReset || {};\n\n            var activeSequences = false,\n                key;\n\n            for (key in _sequenceLevels) {\n                if (doNotReset[key]) {\n                    activeSequences = true;\n                    continue;\n                }\n                _sequenceLevels[key] = 0;\n            }\n\n            if (!activeSequences) {\n                _nextExpectedAction = false;\n            }\n        }\n\n        /**\n         * finds all callbacks that match based on the keycode, modifiers,\n         * and action\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event|Object} e\n         * @param {string=} sequenceName - name of the sequence we are looking for\n         * @param {string=} combination\n         * @param {number=} level\n         * @returns {Array}\n         */\n        function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n            var i;\n            var callback;\n            var matches = [];\n            var action = e.type;\n\n            // if there are no events related to this keycode\n            if (!self._callbacks[character]) {\n                return [];\n            }\n\n            // if a modifier key is coming up on its own we should allow it\n            if (action == 'keyup' && _isModifier(character)) {\n                modifiers = [character];\n            }\n\n            // loop through all callbacks for the key that was pressed\n            // and see if any of them match\n            for (i = 0; i < self._callbacks[character].length; ++i) {\n                callback = self._callbacks[character][i];\n\n                // if a sequence name is not specified, but this is a sequence at\n                // the wrong level then move onto the next match\n                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n                    continue;\n                }\n\n                // if the action we are looking for doesn't match the action we got\n                // then we should keep going\n                if (action != callback.action) {\n                    continue;\n                }\n\n                // if this is a keypress event and the meta key and control key\n                // are not pressed that means that we need to only look at the\n                // character, otherwise check the modifiers as well\n                //\n                // chrome will not fire a keypress if meta or control is down\n                // safari will fire a keypress if meta or meta+shift is down\n                // firefox will fire a keypress if meta or control is down\n                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\n                    // when you bind a combination or sequence a second time it\n                    // should overwrite the first one.  if a sequenceName or\n                    // combination is specified in this call it does just that\n                    //\n                    // @todo make deleting its own method?\n                    var deleteCombo = !sequenceName && callback.combo == combination;\n                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n                    if (deleteCombo || deleteSequence) {\n                        self._callbacks[character].splice(i, 1);\n                    }\n\n                    matches.push(callback);\n                }\n            }\n\n            return matches;\n        }\n\n        /**\n         * actually calls the callback function\n         *\n         * if your callback function returns false this will use the jquery\n         * convention - prevent default and stop propogation on the event\n         *\n         * @param {Function} callback\n         * @param {Event} e\n         * @returns void\n         */\n        function _fireCallback(callback, e, combo, sequence) {\n\n            // if this event should not happen stop here\n            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n                return;\n            }\n\n            if (callback(e, combo) === false) {\n                _preventDefault(e);\n                _stopPropagation(e);\n            }\n        }\n\n        /**\n         * handles a character key event\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event} e\n         * @returns void\n         */\n        self._handleKey = function(character, modifiers, e) {\n            var callbacks = _getMatches(character, modifiers, e);\n            var i;\n            var doNotReset = {};\n            var maxLevel = 0;\n            var processedSequenceCallback = false;\n\n            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n            for (i = 0; i < callbacks.length; ++i) {\n                if (callbacks[i].seq) {\n                    maxLevel = Math.max(maxLevel, callbacks[i].level);\n                }\n            }\n\n            // loop through matching callbacks for this key event\n            for (i = 0; i < callbacks.length; ++i) {\n\n                // fire for all sequence callbacks\n                // this is because if for example you have multiple sequences\n                // bound such as \"g i\" and \"g t\" they both need to fire the\n                // callback for matching g cause otherwise you can only ever\n                // match the first one\n                if (callbacks[i].seq) {\n\n                    // only fire callbacks for the maxLevel to prevent\n                    // subsequences from also firing\n                    //\n                    // for example 'a option b' should not cause 'option b' to fire\n                    // even though 'option b' is part of the other sequence\n                    //\n                    // any sequences that do not match here will be discarded\n                    // below by the _resetSequences call\n                    if (callbacks[i].level != maxLevel) {\n                        continue;\n                    }\n\n                    processedSequenceCallback = true;\n\n                    // keep a list of which sequences were matches for later\n                    doNotReset[callbacks[i].seq] = 1;\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n                    continue;\n                }\n\n                // if there were no sequence matches but we are still here\n                // that means this is a regular match so we should fire that\n                if (!processedSequenceCallback) {\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n                }\n            }\n\n            // if the key you pressed matches the type of sequence without\n            // being a modifier (ie \"keyup\" or \"keypress\") then we should\n            // reset all sequences that were not matched by this event\n            //\n            // this is so, for example, if you have the sequence \"h a t\" and you\n            // type \"h e a r t\" it does not match.  in this case the \"e\" will\n            // cause the sequence to reset\n            //\n            // modifier keys are ignored because you can have a sequence\n            // that contains modifiers such as \"enter ctrl+space\" and in most\n            // cases the modifier key will be pressed before the next key\n            //\n            // also if you have a sequence such as \"ctrl+b a\" then pressing the\n            // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n            //\n            // the \"keydown\" is expected when there is a modifier, but the\n            // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n            // after and that causes the sequence to reset\n            //\n            // we ignore keypresses in a sequence that directly follow a keydown\n            // for the same character\n            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n                _resetSequences(doNotReset);\n            }\n\n            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n        };\n\n        /**\n         * handles a keydown event\n         *\n         * @param {Event} e\n         * @returns void\n         */\n        function _handleKeyEvent(e) {\n\n            // normalize e.which for key events\n            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n            if (typeof e.which !== 'number') {\n                e.which = e.keyCode;\n            }\n\n            var character = _characterFromEvent(e);\n\n            // no character found then stop\n            if (!character) {\n                return;\n            }\n\n            // need to use === for the character check because the character can be 0\n            if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n                _ignoreNextKeyup = false;\n                return;\n            }\n\n            self.handleKey(character, _eventModifiers(e), e);\n        }\n\n        /**\n         * called to set a 1 second timeout on the specified sequence\n         *\n         * this is so after each key press in the sequence you have 1 second\n         * to press the next key before you have to start over\n         *\n         * @returns void\n         */\n        function _resetSequenceTimer() {\n            clearTimeout(_resetTimer);\n            _resetTimer = setTimeout(_resetSequences, 1000);\n        }\n\n        /**\n         * binds a key sequence to an event\n         *\n         * @param {string} combo - combo specified in bind call\n         * @param {Array} keys\n         * @param {Function} callback\n         * @param {string=} action\n         * @returns void\n         */\n        function _bindSequence(combo, keys, callback, action) {\n\n            // start off by adding a sequence level record for this combination\n            // and setting the level to 0\n            _sequenceLevels[combo] = 0;\n\n            /**\n             * callback to increase the sequence level for this sequence and reset\n             * all other sequences that were active\n             *\n             * @param {string} nextAction\n             * @returns {Function}\n             */\n            function _increaseSequence(nextAction) {\n                return function() {\n                    _nextExpectedAction = nextAction;\n                    ++_sequenceLevels[combo];\n                    _resetSequenceTimer();\n                };\n            }\n\n            /**\n             * wraps the specified callback inside of another function in order\n             * to reset all sequence counters as soon as this sequence is done\n             *\n             * @param {Event} e\n             * @returns void\n             */\n            function _callbackAndReset(e) {\n                _fireCallback(callback, e, combo);\n\n                // we should ignore the next key up if the action is key down\n                // or keypress.  this is so if you finish a sequence and\n                // release the key the final key will not trigger a keyup\n                if (action !== 'keyup') {\n                    _ignoreNextKeyup = _characterFromEvent(e);\n                }\n\n                // weird race condition if a sequence ends with the key\n                // another sequence begins with\n                setTimeout(_resetSequences, 10);\n            }\n\n            // loop through keys one at a time and bind the appropriate callback\n            // function.  for any key leading up to the final one it should\n            // increase the sequence. after the final, it should reset all sequences\n            //\n            // if an action is specified in the original bind call then that will\n            // be used throughout.  otherwise we will pass the action that the\n            // next key in the sequence should match.  this allows a sequence\n            // to mix and match keypress and keydown events depending on which\n            // ones are better suited to the key provided\n            for (var i = 0; i < keys.length; ++i) {\n                var isFinal = i + 1 === keys.length;\n                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n                _bindSingle(keys[i], wrappedCallback, action, combo, i);\n            }\n        }\n\n        /**\n         * binds a single keyboard combination\n         *\n         * @param {string} combination\n         * @param {Function} callback\n         * @param {string=} action\n         * @param {string=} sequenceName - name of sequence if part of sequence\n         * @param {number=} level - what part of the sequence the command is\n         * @returns void\n         */\n        function _bindSingle(combination, callback, action, sequenceName, level) {\n\n            // store a direct mapped reference for use with Mousetrap.trigger\n            self._directMap[combination + ':' + action] = callback;\n\n            // make sure multiple spaces in a row become a single space\n            combination = combination.replace(/\\s+/g, ' ');\n\n            var sequence = combination.split(' ');\n            var info;\n\n            // if this pattern is a sequence of keys then run through this method\n            // to reprocess each pattern one key at a time\n            if (sequence.length > 1) {\n                _bindSequence(combination, sequence, callback, action);\n                return;\n            }\n\n            info = _getKeyInfo(combination, action);\n\n            // make sure to initialize array if this is the first time\n            // a callback is added for this key\n            self._callbacks[info.key] = self._callbacks[info.key] || [];\n\n            // remove an existing match if there is one\n            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);\n\n            // add this call back to the array\n            // if it is a sequence put it at the beginning\n            // if not put it at the end\n            //\n            // this is important because the way these are processed expects\n            // the sequence ones to come first\n            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n                callback: callback,\n                modifiers: info.modifiers,\n                action: info.action,\n                seq: sequenceName,\n                level: level,\n                combo: combination\n            });\n        }\n\n        /**\n         * binds multiple combinations to the same callback\n         *\n         * @param {Array} combinations\n         * @param {Function} callback\n         * @param {string|undefined} action\n         * @returns void\n         */\n        self._bindMultiple = function(combinations, callback, action) {\n            for (var i = 0; i < combinations.length; ++i) {\n                _bindSingle(combinations[i], callback, action);\n            }\n        };\n\n        // start!\n        _addEvent(targetElement, 'keypress', _handleKeyEvent);\n        _addEvent(targetElement, 'keydown', _handleKeyEvent);\n        _addEvent(targetElement, 'keyup', _handleKeyEvent);\n    }\n\n    /**\n     * binds an event to mousetrap\n     *\n     * can be a single key, a combination of keys separated with +,\n     * an array of keys, or a sequence of keys separated by spaces\n     *\n     * be sure to list the modifier keys first to make sure that the\n     * correct key ends up getting bound (the last key in the pattern)\n     *\n     * @param {string|Array} keys\n     * @param {Function} callback\n     * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n     * @returns void\n     */\n    Mousetrap.prototype.bind = function(keys, callback, action) {\n        var self = this;\n        keys = keys instanceof Array ? keys : [keys];\n        self._bindMultiple.call(self, keys, callback, action);\n        return self;\n    };\n\n    /**\n     * unbinds an event to mousetrap\n     *\n     * the unbinding sets the callback function of the specified key combo\n     * to an empty function and deletes the corresponding key in the\n     * _directMap dict.\n     *\n     * TODO: actually remove this from the _callbacks dictionary instead\n     * of binding an empty function\n     *\n     * the keycombo+action has to be exactly the same as\n     * it was defined in the bind method\n     *\n     * @param {string|Array} keys\n     * @param {string} action\n     * @returns void\n     */\n    Mousetrap.prototype.unbind = function(keys, action) {\n        var self = this;\n        return self.bind.call(self, keys, function() {}, action);\n    };\n\n    /**\n     * triggers an event that has already been bound\n     *\n     * @param {string} keys\n     * @param {string=} action\n     * @returns void\n     */\n    Mousetrap.prototype.trigger = function(keys, action) {\n        var self = this;\n        if (self._directMap[keys + ':' + action]) {\n            self._directMap[keys + ':' + action]({}, keys);\n        }\n        return self;\n    };\n\n    /**\n     * resets the library back to its initial state.  this is useful\n     * if you want to clear out the current keyboard shortcuts and bind\n     * new ones - for example if you switch to another page\n     *\n     * @returns void\n     */\n    Mousetrap.prototype.reset = function() {\n        var self = this;\n        self._callbacks = {};\n        self._directMap = {};\n        return self;\n    };\n\n    /**\n     * should we stop this event before firing off callbacks\n     *\n     * @param {Event} e\n     * @param {Element} element\n     * @return {boolean}\n     */\n    Mousetrap.prototype.stopCallback = function(e, element) {\n        var self = this;\n\n        // if the element has the class \"mousetrap\" then no need to stop\n        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n            return false;\n        }\n\n        if (_belongsTo(element, self.target)) {\n            return false;\n        }\n\n        // Events originating from a shadow DOM are re-targetted and `e.target` is the shadow host,\n        // not the initial event target in the shadow tree. Note that not all events cross the\n        // shadow boundary.\n        // For shadow trees with `mode: 'open'`, the initial event target is the first element in\n        // the event’s composed path. For shadow trees with `mode: 'closed'`, the initial event\n        // target cannot be obtained.\n        if ('composedPath' in e && typeof e.composedPath === 'function') {\n            // For open shadow trees, update `element` so that the following check works.\n            var initialEventTarget = e.composedPath()[0];\n            if (initialEventTarget !== e.target) {\n                element = initialEventTarget;\n            }\n        }\n\n        // stop for input, select, and textarea\n        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n    };\n\n    /**\n     * exposes _handleKey publicly so it can be overwritten by extensions\n     */\n    Mousetrap.prototype.handleKey = function() {\n        var self = this;\n        return self._handleKey.apply(self, arguments);\n    };\n\n    /**\n     * allow custom key mappings\n     */\n    Mousetrap.addKeycodes = function(object) {\n        for (var key in object) {\n            if (object.hasOwnProperty(key)) {\n                _MAP[key] = object[key];\n            }\n        }\n        _REVERSE_MAP = null;\n    };\n\n    /**\n     * Init the global mousetrap functions\n     *\n     * This method is needed to allow the global mousetrap functions to work\n     * now that mousetrap is a constructor function.\n     */\n    Mousetrap.init = function() {\n        var documentMousetrap = Mousetrap(document);\n        for (var method in documentMousetrap) {\n            if (method.charAt(0) !== '_') {\n                Mousetrap[method] = (function(method) {\n                    return function() {\n                        return documentMousetrap[method].apply(documentMousetrap, arguments);\n                    };\n                } (method));\n            }\n        }\n    };\n\n    Mousetrap.init();\n\n    // expose mousetrap to the global object\n    window.Mousetrap = Mousetrap;\n\n    // expose as a common js module\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = Mousetrap;\n    }\n\n    // expose mousetrap as an AMD module\n    if (typeof define === 'function' && define.amd) {\n        define(function() {\n            return Mousetrap;\n        });\n    }\n}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);\n","'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tconst parts = string.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tconst labels = string.split('.');\n\tconst encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = array => String.fromCodePoint(...array);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tlet oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tlet inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tlet basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue == n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.1.0',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\nexport { ucs2decode, ucs2encode, decode, encode, toASCII, toUnicode };\nexport default punycode;\n","/*jshint node:true*/\n'use strict';\n\n/**\n * Replaces characters in strings that are illegal/unsafe for filenames.\n * Unsafe characters are either removed or replaced by a substitute set\n * in the optional `options` object.\n *\n * Illegal Characters on Various Operating Systems\n * / ? < > \\ : * | \"\n * https://kb.acronis.com/content/39790\n *\n * Unicode Control codes\n * C0 0x00-0x1f & C1 (0x80-0x9f)\n * http://en.wikipedia.org/wiki/C0_and_C1_control_codes\n *\n * Reserved filenames on Unix-based systems (\".\", \"..\")\n * Reserved filenames in Windows (\"CON\", \"PRN\", \"AUX\", \"NUL\", \"COM1\",\n * \"COM2\", \"COM3\", \"COM4\", \"COM5\", \"COM6\", \"COM7\", \"COM8\", \"COM9\",\n * \"LPT1\", \"LPT2\", \"LPT3\", \"LPT4\", \"LPT5\", \"LPT6\", \"LPT7\", \"LPT8\", and\n * \"LPT9\") case-insesitively and with or without filename extensions.\n *\n * Capped at 255 characters in length.\n * http://unix.stackexchange.com/questions/32795/what-is-the-maximum-allowed-filename-and-folder-size-with-ecryptfs\n *\n * @param  {String} input   Original filename\n * @param  {Object} options {replacement: String | Function }\n * @return {String}         Sanitized filename\n */\n\nvar truncate = require(\"truncate-utf8-bytes\");\n\nvar illegalRe = /[\\/\\?<>\\\\:\\*\\|\"]/g;\nvar controlRe = /[\\x00-\\x1f\\x80-\\x9f]/g;\nvar reservedRe = /^\\.+$/;\nvar windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\\..*)?$/i;\nvar windowsTrailingRe = /[\\. ]+$/;\n\nfunction sanitize(input, replacement) {\n  if (typeof input !== 'string') {\n    throw new Error('Input must be string');\n  }\n  var sanitized = input\n    .replace(illegalRe, replacement)\n    .replace(controlRe, replacement)\n    .replace(reservedRe, replacement)\n    .replace(windowsReservedRe, replacement)\n    .replace(windowsTrailingRe, replacement);\n  return truncate(sanitized, 255);\n}\n\nmodule.exports = function (input, options) {\n  var replacement = (options && options.replacement) || '';\n  var output = sanitize(input, replacement);\n  if (replacement === '') {\n    return output;\n  }\n  return sanitize(output, '');\n};\n","var api = require(\"!../../style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = require(\"!!../../css-loader/dist/cjs.js!./font-awesome.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};","var api = require(\"!../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = require(\"!!../../../../node_modules/css-loader/dist/cjs.js!../../../../node_modules/less-loader/dist/cjs.js!./index.less\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};","\"use strict\";\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce = typeof __webpack_nonce__ !== 'undefined' ? __webpack_nonce__ : null;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && btoa) {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};","'use strict';\n\nvar truncate = require(\"./lib/truncate\");\nvar getLength = require(\"utf8-byte-length/browser\");\nmodule.exports = truncate.bind(null, getLength);\n","'use strict';\n\nfunction isHighSurrogate(codePoint) {\n  return codePoint >= 0xd800 && codePoint <= 0xdbff;\n}\n\nfunction isLowSurrogate(codePoint) {\n  return codePoint >= 0xdc00 && codePoint <= 0xdfff;\n}\n\n// Truncate string by size in bytes\nmodule.exports = function truncate(getLength, string, byteLength) {\n  if (typeof string !== \"string\") {\n    throw new Error(\"Input must be string\");\n  }\n\n  var charLength = string.length;\n  var curByteLength = 0;\n  var codePoint;\n  var segment;\n\n  for (var i = 0; i < charLength; i += 1) {\n    codePoint = string.charCodeAt(i);\n    segment = string[i];\n\n    if (isHighSurrogate(codePoint) && isLowSurrogate(string.charCodeAt(i + 1))) {\n      i += 1;\n      segment += string[i];\n    }\n\n    curByteLength += getLength(segment);\n\n    if (curByteLength === byteLength) {\n      return string.slice(0, i + 1);\n    }\n    else if (curByteLength > byteLength) {\n      return string.slice(0, i - segment.length + 1);\n    }\n  }\n\n  return string;\n};\n\n","module.exports=/[\\0-\\x1F\\x7F-\\x9F]/","module.exports=/[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u08E2\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804[\\uDCBD\\uDCCD]|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/","module.exports=/[!-#%-\\*,-\\/:;\\?@\\[-\\]_\\{\\}\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4E\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD803[\\uDF55-\\uDF59]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC8\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDC4B-\\uDC4F\\uDC5B\\uDC5D\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDE60-\\uDE6C\\uDF3C-\\uDF3E]|\\uD806[\\uDC3B\\uDE3F-\\uDE46\\uDE9A-\\uDE9C\\uDE9E-\\uDEA2]|\\uD807[\\uDC41-\\uDC45\\uDC70\\uDC71\\uDEF7\\uDEF8]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD81B[\\uDE97-\\uDE9A]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]|\\uD83A[\\uDD5E\\uDD5F]/","module.exports=/[ \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000]/","'use strict';\n\nexports.Any = require('./properties/Any/regex');\nexports.Cc  = require('./categories/Cc/regex');\nexports.Cf  = require('./categories/Cf/regex');\nexports.P   = require('./categories/P/regex');\nexports.Z   = require('./categories/Z/regex');\n","module.exports=/[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/","'use strict';\n\nfunction isHighSurrogate(codePoint) {\n  return codePoint >= 0xd800 && codePoint <= 0xdbff;\n}\n\nfunction isLowSurrogate(codePoint) {\n  return codePoint >= 0xdc00 && codePoint <= 0xdfff;\n}\n\n// Truncate string by size in bytes\nmodule.exports = function getByteLength(string) {\n  if (typeof string !== \"string\") {\n    throw new Error(\"Input must be string\");\n  }\n\n  var charLength = string.length;\n  var byteLength = 0;\n  var codePoint = null;\n  var prevCodePoint = null;\n  for (var i = 0; i < charLength; i++) {\n    codePoint = string.charCodeAt(i);\n    // handle 4-byte non-BMP chars\n    // low surrogate\n    if (isLowSurrogate(codePoint)) {\n      // when parsing previous hi-surrogate, 3 is added to byteLength\n      if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {\n        byteLength += 1;\n      }\n      else {\n        byteLength += 3;\n      }\n    }\n    else if (codePoint <= 0x7f ) {\n      byteLength += 1;\n    }\n    else if (codePoint >= 0x80 && codePoint <= 0x7ff) {\n      byteLength += 2;\n    }\n    else if (codePoint >= 0x800 && codePoint <= 0xffff) {\n      byteLength += 3;\n    }\n    prevCodePoint = codePoint;\n  }\n\n  return byteLength;\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => module['default'] :\n\t\t() => module;\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(\"./app/frontend/designer/js/index.js\");\n"],"sourceRoot":""}